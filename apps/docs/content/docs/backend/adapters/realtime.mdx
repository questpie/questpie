---
title: Realtime Adapter
description: Live updates and subscriptions over SSE
---

# Realtime Adapter

QUESTPIE realtime is based on an outbox table (`questpie_realtime_log`) plus Server-Sent Events (SSE).

- Collection endpoint: `GET /cms/realtime/:collection`
- Global endpoint: `GET /cms/realtime/globals/:global`
- Stream event types: `snapshot`, `ping`, `error`

`snapshot` always contains fresh query results (not a diff event payload).

## Configuration

### Automatic PostgreSQL setup

If your app uses a PostgreSQL `db.url`, QUESTPIE automatically wires the `pg-notify` adapter.

```typescript
import { q } from "questpie";

const cms = q({ name: "my-cms" }).build({
  app: { url: process.env.APP_URL! },
  db: { url: process.env.DATABASE_URL! },
});
```

### Custom adapter setup

```typescript
import { q, redisStreamsAdapter } from "questpie";

const cms = q({ name: "my-cms" }).build({
  app: { url: process.env.APP_URL! },
  db: { url: process.env.DATABASE_URL! },
  realtime: {
    adapter: redisStreamsAdapter({ client: redisClient }),
    pollIntervalMs: 2000,
    batchSize: 500,
    retentionDays: 7,
  },
});
```

Notes:

- External clients passed to adapters are not force-closed by QUESTPIE realtime shutdown.
- `retentionDays` enables time-based cleanup of old outbox rows.
- Realtime service also performs watermark cleanup using min consumed seq across active subscribers.

## SSE usage

```typescript
const source = new EventSource("/cms/realtime/posts?with[author]=true");

source.addEventListener("snapshot", (event) => {
  const payload = JSON.parse(event.data);
  // payload = { seq, data }
  // data matches collections.posts.find(...) result shape
  renderPosts(payload.data.docs);
});

source.addEventListener("error", (event) => {
  console.error("Realtime error", event);
});
```

Global example:

```typescript
const source = new EventSource("/cms/realtime/globals/settings");

source.addEventListener("snapshot", (event) => {
  const payload = JSON.parse(event.data);
  // payload.data matches globals.settings.get(...) result shape
  updateUI(payload.data);
});
```

## Server-side service API

For advanced usage you can subscribe inside server runtime:

```typescript
const unsubscribe = cms.realtime?.subscribe(
  (event) => {
    console.log(event.operation, event.resource, event.recordId);
  },
  {
    resourceType: "collection",
    resource: "posts",
    where: { status: "published" },
    with: { author: true },
  },
);

unsubscribe?.();
```

`event.operation` can be: `create`, `update`, `delete`, `bulk_update`, `bulk_delete`.

## Filtering semantics

- `create` events use payload-based filter matching.
- `update`/`delete`/bulk events trigger direct subscribers even when a `where` filter exists.

This avoids stale filtered snapshots when a record leaves a filter set or is deleted.

### Complex `where` behavior

For complex filters (`OR`, nested conditions, non-equality operators), realtime matching is conservative:

- create events may refresh subscribers even when payload-only checks are inconclusive
- update/delete/bulk events refresh filtered subscribers by design

This prioritizes correctness over minimal refreshes.

## Related

- [Realtime Guide](/docs/guides/realtime-subscriptions)
- [KV Store](/docs/backend/adapters/kv)
