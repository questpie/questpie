---
title: Queue Adapter
description: Background jobs across worker, serverless, and push runtimes
---

# Queue Adapter

QUESTPIE queue supports multiple runtime modes through one API:

- `cms.queue.listen()` for long-running workers (Node/Bun)
- `cms.queue.runOnce()` for serverless tick processing
- `cms.queue.createPushConsumer()` for push runtimes (Cloudflare Queues style)

## Configuration

### pg-boss (PostgreSQL)

```ts
import { pgBossAdapter, q } from "questpie";

export const cms = q({ name: "my-cms" })
  .jobs({
    // your jobs
  })
  .build({
    app: { url: process.env.APP_URL! },
    db: { url: process.env.DATABASE_URL! },
    queue: {
      adapter: pgBossAdapter({
        connectionString: process.env.DATABASE_URL!,
        schema: "pgboss",
      }),
    },
  });
```

### Cloudflare Queues (push model)

```ts
import { cloudflareQueuesAdapter, q } from "questpie";

const adapter = cloudflareQueuesAdapter({
  enqueue: async (message) => {
    // send to your Cloudflare Queue producer binding
    // return message id if available
    return null;
  },
});

export const cms = q({ name: "my-cms" })
  .jobs({
    // your jobs
  })
  .build({
    app: { url: "https://example.com" },
    db: { url: process.env.DATABASE_URL! },
    queue: { adapter },
  });
```

## Defining and Registering Jobs

```ts
import { q } from "questpie";
import { z } from "zod";

const sendEmail = q.job({
	name: "send-email",
	schema: z.object({
		to: z.string().email(),
		subject: z.string(),
		html: z.string(),
	}),
	handler: async ({ payload, app }) => {
		await app.email.send(payload);
	},
	options: {
		retryLimit: 3,
		retryDelay: 30,
		retryBackoff: true,
	},
});

export const cms = q({ name: "my-cms" })
	.jobs({ sendEmail })
	.build({
		app: { url: process.env.APP_URL! },
		db: { url: process.env.DATABASE_URL! },
		queue: { adapter: /* ... */ },
	});
```

## Publishing Jobs

```ts
await cms.queue.sendEmail.publish({
  to: "user@example.com",
  subject: "Welcome",
  html: "<p>Hello</p>",
});

await cms.queue.sendEmail.publish(
  { to: "user@example.com", subject: "Later", html: "<p>Deferred</p>" },
  { startAfter: 60 },
);
```

## Scheduling

Per-job scheduling:

```ts
await cms.queue.sendEmail.schedule(
  { to: "ops@example.com", subject: "Daily", html: "<p>Report</p>" },
  "0 8 * * *",
);
```

Auto-schedule cron jobs declared in job definitions:

```ts
await cms.queue.registerSchedules();
```

## Runtime Modes

### Long-running Worker

```ts
// worker.ts
import { cms } from "./cms";

await cms.queue.listen({
  teamSize: 10,
  batchSize: 5,
  gracefulShutdown: true,
  shutdownSignals: ["SIGINT", "SIGTERM"],
  shutdownTimeoutMs: 10000,
});
```

### Serverless Tick Mode

```ts
const result = await cms.queue.runOnce({
  batchSize: 20,
});

console.log("processed jobs", result.processed);
```

### Push Consumer Mode (Cloudflare style)

```ts
const handleQueueBatch = cms.queue.createPushConsumer();

export default {
  async queue(batch: any) {
    await handleQueueBatch(batch);
  },
};
```

## Idempotency Guidance

- Treat queue delivery as at-least-once.
- Make handlers idempotent (check/mark processed keys in DB).
- Use `singletonKey` for dedupe where adapter supports it.
- Prefer Postgres unique constraints / Redis SETNX / Durable Objects for critical idempotency.

## Related

- [Queue Jobs Guide](/docs/guides/queue-jobs)
- [Realtime Subscriptions](/docs/guides/realtime-subscriptions)
