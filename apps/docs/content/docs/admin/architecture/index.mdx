---
title: Architecture
description: Understanding QUESTPIE Admin's two-layer architecture
---

# Architecture Overview

QUESTPIE Admin uses a **two-layer architecture** where the server defines admin configuration and the client provides rendering components.

## Two-Layer Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                     SERVER (q builder)                           │
│                                                                  │
│  Defines WHAT to show:                                           │
│  ┌──────────────┐ ┌──────────────┐ ┌──────────────┐             │
│  │ Collections  │ │ Dashboard    │ │ Sidebar      │             │
│  │ .admin()     │ │ .dashboard() │ │ .sidebar()   │             │
│  │ .list()      │ │ d.stats()    │ │ s.section()  │             │
│  │ .form()      │ │ d.chart()    │ │ collections  │             │
│  │ .actions()   │ │ d.value()    │ │ globals      │             │
│  │ .preview()   │ │ d.timeline() │ │ links        │             │
│  └──────────────┘ └──────────────┘ └──────────────┘             │
│                                                                  │
│  Serialized config sent via getAdminConfig RPC                   │
│  fetchFn data sent via fetchWidgetData RPC                       │
├──────────────────────────────────────────────────────────────────┤
│                     CLIENT (qa builder)                          │
│                                                                  │
│  Defines HOW to render:                                          │
│  ┌──────────────┐ ┌──────────────┐ ┌──────────────┐             │
│  │ Field        │ │ View         │ │ Widget       │             │
│  │ Registry     │ │ Registry     │ │ Registry     │             │
│  │ - text       │ │ - table      │ │ - stats      │             │
│  │ - select     │ │ - form       │ │ - chart      │             │
│  │ - relation   │ │ - cards      │ │ - value      │             │
│  │ - richText   │ │ - wizard     │ │ - timeline   │             │
│  │ - ...        │ │              │ │ - custom     │             │
│  └──────────────┘ └──────────────┘ └──────────────┘             │
│                                                                  │
│  + Branding, locale, translations                                │
│  + Block Registry (client-side page builder blocks)              │
└──────────────────────────────────────────────────────────────────┘
```

### Why Two Layers?

1. **Security** — Server-side `fetchFn` and `access` rules keep sensitive logic off the client
2. **Serialization** — Server config is JSON-serializable, sent via RPC to the client
3. **Flexibility** — Different clients can render the same server config differently
4. **Separation** — Data structure concerns (server) vs presentation concerns (client)

## Data Flow

```
1. Configuration Phase (build time)
   Server: q().use(adminModule).collections({...}).dashboard({...}).sidebar({...}).build()
   Client: qa().use(adminModule).branding({...}).locale({...})

2. Runtime Phase (page load)
   Client calls getAdminConfig RPC → Server evaluates access rules → Returns config
   Client merges server config with local registries → Renders UI

3. Widget Data Phase (dashboard)
   Client sees hasFetchFn: true → Calls fetchWidgetData RPC → Server runs fetchFn → Returns data

4. Data Operations (user actions)
   User Action → React Hook → CMS Client → RPC → Server Handler → Database
```

## Registry Pattern

Everything in QUESTPIE Admin is registered in typed registries. The built-in `adminModule` provides default renderers:

```typescript
// Client-side: adminModule provides all built-in renderers
import { adminModule, qa } from "@questpie/admin/client";

const admin = qa()
  .use(adminModule)        // Built-in fields, views, widgets
  .use(myCustomModule);    // Custom extensions
```

Registries are merged with a "last wins" strategy:

| Property | Merge Strategy |
|----------|----------------|
| `fields` | Spread (later wins) |
| `views` | Spread (later wins) |
| `widgets` | Spread (later wins) |
| `blocks` | Spread (later wins) |
| `translations` | Deep merge |

## Icon System

Server-side icons use `c.icon("ph:icon-name")` which creates serializable `ComponentReference` objects:

```typescript
// Server creates a serializable reference
c.icon("ph:users")  →  { type: "icon", props: { name: "ph:users" } }

// Client resolves this to an @iconify/react <Icon> component
```

Icons use the [Phosphor](https://phosphoricons.com/) icon set via `@iconify/react`:

| Variant | Suffix | Example |
|---------|--------|---------|
| Regular | (none) | `ph:users` |
| Fill | `-fill` | `ph:users-fill` |
| Bold | `-bold` | `ph:users-bold` |
| Duotone | `-duotone` | `ph:users-duotone` |
| Light | `-light` | `ph:users-light` |
| Thin | `-thin` | `ph:users-thin` |

## State-Based Configuration

The client-side `qa()` builder uses state as configuration — no `.build()` method:

```typescript
const admin = qa<AppCMS>()
  .use(adminModule)
  .branding({ name: "My Admin" });

// State IS the config — used directly by React components
<AdminLayoutProvider admin={admin} ... />
```

## Type Inference

For global type inference, declare the type registry:

```typescript
declare module "@questpie/admin/client" {
  interface AdminTypeRegistry {
    cms: AppCMS;
    admin: typeof admin;
  }
}
```

This enables:
- Autocomplete for collection and global names
- Type-safe navigation helpers
- Inferred field types in hooks

## Related

- [Registry Pattern](/docs/admin/architecture/registry-pattern) — Deep dive into registries
- [Module Composition](/docs/admin/architecture/module-composition) — How modules merge
- [Type Inference](/docs/admin/architecture/type-inference) — TypeScript integration
