---
title: Type Safety
description: Complete guide to type-safe development with QUESTPIE CMS
---

# Type Safety Guide

QUESTPIE provides comprehensive TypeScript support with fully typed APIs, hooks, jobs, and functions. This guide covers best practices for maintaining type safety throughout your CMS application.

## Overview

QUESTPIE uses **explicit type helpers** instead of module augmentation to provide type safety. This approach:

- ✅ Avoids package conflicts in monorepos
- ✅ Works reliably across different TypeScript configurations
- ✅ Provides clear, predictable type inference
- ✅ Makes the type system explicit and discoverable

## Core Type Helpers

QUESTPIE provides three main helper functions for type-safe access to CMS context:

```ts
import { getApp, getDb, getSession } from "questpie";
```

### `getApp<T>(app)`

Get typed access to your CMS instance from hooks, jobs, and functions.

```ts
import { getApp } from "questpie";
import type { AppCMS } from "./cms";

const posts = q.collection("posts").hooks({
  afterChange: async ({ app }) => {
    const cms = getApp<AppCMS>(app);
    // ✅ Fully typed access
    await cms.queue.sendEmail.publish({ to: "user@example.com" });
    await cms.api.collections.posts.find();
  },
});
```

### `getDb<T>(db)`

Get typed database client (Drizzle) from context.

```ts
import { getApp, getDb } from "questpie";
import type { AppCMS } from "./cms";

const posts = q.collection("posts").hooks({
  afterChange: async ({ app, db }) => {
    const cms = getApp<AppCMS>(app);
    const typedDb = getDb<AppCMS>(db);

    // ✅ Fully typed Drizzle operations
    await typedDb.select().from(cms.config.collections.posts.table);
  },
});
```

### `getSession<T>(session)`

Get typed session from Better Auth.

```ts
import { getSession } from "questpie";
import type { AppCMS } from "./cms";

const posts = q.collection("posts").hooks({
  beforeChange: async ({ session }) => {
    const typedSession = getSession<AppCMS>(session);

    if (!typedSession) {
      throw new Error("Unauthorized");
    }

    // ✅ Typed session access
    const userId = typedSession.user.id;
    const role = typedSession.user.role;
  },
});
```

## Exporting CMS Types

In your `cms.ts` file, export your CMS type for use throughout your application:

```ts
// cms.ts
import { rpc } from "questpie";

export const appBuilder = q({ name: "my-app" })
  .collections({ posts, users })
  .jobs({ sendEmail })
;

export type AppShape = typeof appBuilder.$inferCms;

export const app = appBuilder.build({ ... });

export const appRpc = rpc().router({ getStats });

/**
 * Full CMS runtime type.
 * Use this type with getApp<AppCMS>() in hooks and jobs.
 */
export type AppCMS = typeof app;
export type AppRpc = typeof appRpc;
```

## Type Safety in Hooks

Collection and global hooks receive `app`, `db`, and `session` as `any` by default. Use the type helpers for full type safety:

### Collection Hooks

```ts
import { getApp, getDb, getSession } from "questpie";
import type { AppCMS } from "./cms";

export const posts = q.collection("posts")
  .fields({ title: text("title") })
  .hooks({
    afterChange: async ({ data, app, db, session }) => {
      const cms = getApp<AppCMS>(app);
      const typedDb = getDb<AppCMS>(db);
      const typedSession = getSession<AppCMS>(session);

      // ✅ All fully typed
      await cms.queue.notify.publish({ postId: data.id });
      await typedDb.insert(auditLog).values({ ... });

      if (typedSession?.user.role === "admin") {
        // Admin-specific logic
      }
    }
  });
```

### Global Hooks

```ts
import { getApp } from "questpie";
import type { AppCMS } from "./cms";

export const settings = q
  .global("settings")
  .fields({ siteName: text("site_name") })
  .hooks({
    afterUpdate: async ({ data, app }) => {
      const cms = getApp<AppCMS>(app);
      // ✅ Typed access
      await cms.kv.set("settings-cache", data);
    },
  });
```

## Type Safety in Jobs

Background jobs follow the same pattern:

```ts
import { getApp } from "questpie";
import type { AppCMS } from "./cms";

export const sendEmail = q.job({
  name: "send-email",
  schema: z.object({
    to: z.string(),
    subject: z.string(),
  }),
  handler: async ({ payload, app }) => {
    const cms = getApp<AppCMS>(app);

    // ✅ Fully typed
    await cms.email.send({
      to: payload.to,
      subject: payload.subject,
      html: "<p>Hello</p>",
    });
  },
});
```

## Type Safety in RPC Procedures

RPC procedures require special handling to avoid circular dependencies. QUESTPIE provides two patterns:

### Pattern 1: Explicit `outputSchema` (Recommended)

Use `outputSchema` to explicitly define return types:

```ts
import { q } from "questpie";
import { z } from "zod";

const statsSchema = z.object({
  total: z.number(),
  active: z.number(),
});

export const getStats = q.fn({
  schema: z.object({}),
  outputSchema: statsSchema, // ✅ Explicit return type
  handler: async ({ app }) => {
    // app can be any - doesn't matter
    return {
      total: 100,
      active: 50,
    };
  },
});

// Client-side usage - return type is automatically inferred!
const stats = await client.rpc.getStats({});
// stats: { total: number, active: number }
```

### Pattern 2: App Shape Type (For Complex Cases)

When you need typed CMS access inside RPC handlers, type against the builder shape and keep RPC separate from CMS runtime:

```ts
// cms.ts
import { rpc } from "questpie";

const appBuilder = q({ name: "app" })
  .collections({ posts, users })
  .jobs({ sendEmail });

export type AppShape = typeof appBuilder.$inferCms;

export const app = appBuilder.build({ ... });

export const appRpc = rpc().router({ getStats });

export type AppCMS = typeof app;
export type AppRpc = typeof appRpc;
```

```ts
// functions/index.ts
import { getApp } from "questpie";
import type { AppShape } from "../cms";

export const getStats = q.fn({
  schema: z.object({}),
  handler: async ({ app }) => {
    const cms = getApp<AppShape>(app);

    // ✅ Return type fully inferred from cms.api
    return await cms.api.collections.posts.find({
      where: { isPublished: true },
    });
  },
});
```

**Why AppShape?**

- Referencing final `AppCMS` from procedure files can create circular dependencies
- `AppShape` comes from the builder type layer and remains stable for handler typing
- CMS runtime and RPC contract stay separated (`app` + `appRpc`)
- Return types are still fully inferred from the CMS API

## Type Safety in Access Control

Access control rules also support the type helpers:

```ts
import { getSession } from "questpie";
import type { AppCMS } from "./cms";

export const posts = q.collection("posts").access({
  read: ({ session, data }) => {
    const typedSession = getSession<AppCMS>(session);

    // Public posts or owned by user
    return data.isPublic || data.authorId === typedSession?.user.id;
  },
  create: ({ session }) => {
    const typedSession = getSession<AppCMS>(session);
    // Only authenticated users can create
    return !!typedSession;
  },
});
```

## Advanced Type Utilities

QUESTPIE exports additional type utilities for advanced use cases:

### `InferSessionFromApp<T>`

Extract the session type from a CMS app type:

```ts
import type { InferSessionFromApp } from "questpie";
import type { AppCMS } from "./cms";

type MySession = InferSessionFromApp<AppCMS>;
// Same as: AppCMS["auth"]["$Infer"]["Session"]
```

### `InferDbFromApp<T>`

Extract the database type from a CMS app type:

```ts
import type { InferDbFromApp } from "questpie";
import type { AppCMS } from "./cms";

type MyDb = InferDbFromApp<AppCMS>;
// Same as: AppCMS["db"]
```

### `InferBaseCMS<T>`

Extract a CMS type without functions (useful for type definitions):

```ts
import type { InferBaseCMS } from "questpie";

const baseInstance = q().collections({...}).build();
type BaseCMS = InferBaseCMS<typeof baseInstance>;
```

## Migration from Module Augmentation

If you're upgrading from an older version that used module augmentation:

### Before (Old Pattern - Deprecated)

```ts
// cms.ts
export const cms = q({ name: "app" }).build({ ... });

declare module "questpie" {
  interface QuestpieContext {
    app: typeof cms
  }
}

// collection.ts
const posts = q.collection("posts").hooks({
  afterChange: async ({ app }) => {
    app.api.collections.posts.find(); // Typed via augmentation
  }
});
```

### After (New Pattern - Recommended)

```ts
// cms.ts
export const cms = q({ name: "app" }).build({ ... });
export type AppCMS = typeof cms;

// collection.ts
import { getApp } from "questpie";
import type { AppCMS } from "./cms";

const posts = q.collection("posts").hooks({
  afterChange: async ({ app }) => {
    const cms = getApp<AppCMS>(app);
    cms.api.collections.posts.find(); // ✅ Explicitly typed
  }
});
```

## Best Practices

1. **Always export your CMS type**: Make `AppCMS` and optionally `BaseCMS` available to your entire application

2. **Use type helpers consistently**: Don't mix `app as AppCMS` with `getApp<AppCMS>(app)` - stick to the helper functions

3. **Prefer `outputSchema` for functions**: When possible, use explicit output schemas rather than relying on return type inference

4. **Use `BaseCMS` when needed**: For functions that reference the CMS, use the BaseCMS pattern to avoid circular dependencies

5. **Keep CMS types in cms.ts**: Export all CMS-related types from your main cms.ts file for easy imports

## Common Patterns

### Checking Authentication

```ts
import { getSession } from "questpie";
import type { AppCMS } from "./cms";

const session = getSession<AppCMS>(context.session);

if (!session) {
  throw new Error("Unauthorized");
}

// ✅ TypeScript knows session is not null here
const userId = session.user.id;
```

### Database Transactions

```ts
import { getDb } from "questpie";
import type { AppCMS } from "./cms";

const typedDb = getDb<AppCMS>(db);

// ✅ Fully typed Drizzle operations
await typedDb.transaction(async (tx) => {
  await tx.insert(posts).values({ ... });
  await tx.insert(auditLog).values({ ... });
});
```

### Accessing Collection Tables

```ts
import { getApp } from "questpie";
import type { AppCMS } from "./cms";

const cms = getApp<AppCMS>(app);

// ✅ Type-safe table access
const postsTable = cms.config.collections.posts.table;
await db.select().from(postsTable);
```

## Troubleshooting

### "Type instantiation is excessively deep"

This usually happens when you have circular type dependencies. Use the `AppShape` pattern for RPC handlers:

```ts
// ✅ Use AppShape in RPC handlers
export const getStats = q.fn({
  handler: async ({ app }) => {
    const cms = getApp<AppShape>(app); // Not AppCMS!
    return cms.api.collections.posts.find();
  },
});
```

### "Property does not exist on type 'any'"

You forgot to use a type helper:

```ts
// ❌ Wrong
const result = await app.api.collections.posts.find();

// ✅ Correct
const cms = getApp<AppCMS>(app);
const result = await cms.api.collections.posts.find();
```

### Session type not specific enough

Make sure you're using `getSession<AppCMS>()` and not just accessing `session` directly:

```ts
// ❌ Wrong
if (session?.user.role === "admin") { ... }

// ✅ Correct
const typedSession = getSession<AppCMS>(session);
if (typedSession?.user.role === "admin") { ... }
```

## Summary

- Use `getApp<AppCMS>()`, `getDb<AppCMS>()`, and `getSession<AppCMS>()` for type-safe access
- Export `AppCMS`, `AppRpc`, and `AppShape` from your cms.ts
- Use `outputSchema` for RPC return types when possible
- Use `AppShape` pattern for RPC handlers that need CMS access
- Avoid module augmentation - use explicit type helpers instead
