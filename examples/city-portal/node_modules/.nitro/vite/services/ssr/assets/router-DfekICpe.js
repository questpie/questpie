import { createRootRoute, createFileRoute, lazyRouteComponent, createRouter as createRouter$2 } from "@tanstack/react-router";
import { jsxs, jsx, Fragment } from "react/jsx-runtime";
import { randomUUID, randomBytes as randomBytes$1, createHmac, timingSafeEqual as timingSafeEqual$1 } from "node:crypto";
import { AsyncLocalStorage } from "node:async_hooks";
import { getColumns, sql as sql$1, and, or, not, eq, inArray, count, sum, avg, min as min$1, max as max$1, ne, gt, lt, between, lte, gte, isNotNull as isNotNull$1, isNull as isNull$2, notIlike, notLike, ilike, like, notInArray, desc, asc } from "drizzle-orm";
import { pgTable, alias, timestamp, text, integer, jsonb, varchar, index as index$2, uniqueIndex, bigint, smallint, char, uuid as uuid$1, boolean, date, json, numeric, doublePrecision, real, pgEnum, time as time$1, bigserial, customType, unique } from "drizzle-orm/pg-core";
import * as z from "zod";
import { ZodError, z as z$1, ZodObject, ZodOptional } from "zod";
import require$$0$b, { tmpdir } from "node:os";
import require$$2$2, { join as join$1, resolve } from "node:path";
import { a as addRoute, c as createRouter, f as findRoute, b as findAllRoutes } from "../index.js";
import { SQL } from "bun";
import { drizzle } from "drizzle-orm/bun-sql";
import { drizzle as drizzle$1 } from "drizzle-orm/pglite";
import require$$7$1 from "buffer";
import { normalize as normalize$1 } from "path/posix";
import require$$0$6, { basename, join, dirname, relative } from "path";
import { format as format$1 } from "node:util";
import require$$0$5 from "crypto";
import require$$1$2, { existsSync, createReadStream, rmSync } from "fs";
import * as fsp from "fs/promises";
import fsp__default, { unlink } from "fs/promises";
import require$$0$8, { fileURLToPath } from "url";
import require$$1$1, { debuglog } from "util";
import require$$5$1, { AssertionError } from "assert";
import { toCamelCase } from "drizzle-orm/casing";
import { existsSync as existsSync$1, mkdirSync, writeFileSync, readFileSync } from "node:fs";
import EventEmitter from "node:events";
import require$$0$a from "node:diagnostics_channel";
import require$$0$7 from "events";
import require$$2$1 from "worker_threads";
import require$$0$9 from "module";
import * as html$1 from "prettier/plugins/html";
import { format as format$2 } from "prettier/standalone";
import React__default, { Suspense } from "react";
import { Writable } from "node:stream";
import require$$0$e from "http";
import require$$1$3 from "https";
import require$$3 from "zlib";
import require$$0$c from "stream";
import require$$0$d from "net";
import require$$4 from "dns";
import require$$6 from "os";
import require$$1$4 from "tls";
import require$$0$f from "child_process";
import assert, { notStrictEqual } from "node:assert";
import { setTimeout as setTimeout$1 } from "node:timers/promises";
import require$$1$5 from "string_decoder";
function _mergeNamespaces(n2, m) {
  for (var i = 0; i < m.length; i++) {
    const e2 = m[i];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k in e2) {
        if (k !== "default" && !(k in n2)) {
          const d = Object.getOwnPropertyDescriptor(e2, k);
          if (d) {
            Object.defineProperty(n2, k, d.get ? d : {
              enumerable: true,
              get: () => e2[k]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
const esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get Client() {
    return Client;
  },
  get Connection() {
    return Connection;
  },
  get DatabaseError() {
    return DatabaseError;
  },
  get Pool() {
    return Pool;
  },
  get Query() {
    return Query;
  },
  get Result() {
    return Result;
  },
  get TypeOverrides() {
    return TypeOverrides;
  },
  get default() {
    return pg;
  },
  get defaults() {
    return defaults;
  },
  get escapeIdentifier() {
    return escapeIdentifier;
  },
  get escapeLiteral() {
    return escapeLiteral;
  },
  get types() {
    return types$1;
  }
}, Symbol.toStringTag, { value: "Module" }));
const Route$7 = createRootRoute({
  head: () => ({
    meta: [
      {
        charSet: "utf-8"
      },
      {
        name: "viewport",
        content: "width=device-width, initial-scale=1"
      },
      {
        title: "City Portal - Local Council Websites"
      }
    ]
  }),
  notFoundComponent: () => /* @__PURE__ */ jsxs("main", { className: "container px-6 py-24 text-center", children: [
    /* @__PURE__ */ jsx("h1", { className: "text-3xl font-bold tracking-tight", children: "Page not found" }),
    /* @__PURE__ */ jsx("p", { className: "mt-3 text-muted-foreground", children: "The page you are looking for does not exist." }),
    /* @__PURE__ */ jsx(
      "a",
      {
        href: "/",
        className: "mt-6 inline-block text-sm font-medium text-primary hover:underline",
        children: "Back to homepage"
      }
    )
  ] }),
  shellComponent: RootDocument
});
function RootDocument({ children }) {
  return /* @__PURE__ */ jsx(Fragment, { children });
}
const $$splitComponentImporter$4 = () => import("./index-BmXFRawP.js");
const Route$6 = createFileRoute("/admin/")({
  component: lazyRouteComponent($$splitComponentImporter$4, "component")
});
const ERROR_CODE_TO_HTTP_STATUS = {
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  FORBIDDEN: 403,
  NOT_FOUND: 404,
  CONFLICT: 409,
  UNPROCESSABLE_CONTENT: 422,
  INTERNAL_SERVER_ERROR: 500,
  NOT_IMPLEMENTED: 501,
  HOOK_ERROR: 500,
  VALIDATION_ERROR: 400
};
function getHTTPStatusFromCode(code) {
  return ERROR_CODE_TO_HTTP_STATUS[code] || 500;
}
class ApiError extends Error {
  code;
  /** Translation key for i18n */
  messageKey;
  /** Parameters for translation interpolation */
  messageParams;
  fieldErrors;
  context;
  cause;
  constructor(options) {
    super(options.message);
    this.name = "ApiError";
    this.code = options.code;
    this.messageKey = options.messageKey;
    this.messageParams = options.messageParams;
    this.fieldErrors = options.fieldErrors;
    this.context = options.context;
    this.cause = options.cause;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, ApiError);
    }
  }
  /**
   * Get HTTP status code for this error
   */
  getHTTPStatus() {
    return getHTTPStatusFromCode(this.code);
  }
  /**
   * Get translated error message
   * @param t - Backend translate function
   * @param locale - Optional locale override
   */
  getTranslatedMessage(t2, locale) {
    if (this.messageKey) {
      return t2(this.messageKey, this.messageParams, locale);
    }
    return this.message;
  }
  /**
   * Convert to client-safe error shape
   * @param isDev - Include stack trace and detailed cause info
   * @param t - Optional backend translate function for i18n
   * @param locale - Optional locale for translation
   */
  toJSON(isDev2 = false, t2, locale) {
    const message2 = t2 && this.messageKey ? t2(this.messageKey, this.messageParams, locale) : this.message;
    return {
      code: this.code,
      message: message2,
      fieldErrors: this.fieldErrors,
      context: this.context,
      stack: isDev2 ? this.stack : void 0,
      cause: this.cause instanceof Error ? this.cause.message : void 0
    };
  }
  /**
   * Create validation error from Zod v4 error
   */
  static fromZodError(zodError, message2 = "Validation failed") {
    const fieldErrors = [];
    if (zodError.issues && Array.isArray(zodError.issues)) {
      for (const issue of zodError.issues) {
        fieldErrors.push({
          path: issue.path.join("."),
          message: issue.message,
          value: issue.input
        });
      }
    }
    return new ApiError({
      code: "VALIDATION_ERROR",
      message: message2,
      messageKey: "error.validation",
      fieldErrors,
      cause: zodError
    });
  }
  /**
   * Create NOT_FOUND error
   */
  static notFound(resource, id) {
    return new ApiError({
      code: "NOT_FOUND",
      message: id ? `${resource} not found: ${id}` : `${resource} not found`,
      messageKey: id ? "error.notFound.withId" : "error.notFound",
      messageParams: { resource, id }
    });
  }
  /**
   * Create FORBIDDEN error with access context
   */
  static forbidden(context) {
    const useDefaultTranslation = context.reason === "Access denied";
    return new ApiError({
      code: "FORBIDDEN",
      message: context.reason,
      messageKey: useDefaultTranslation ? "error.forbidden" : void 0,
      messageParams: useDefaultTranslation ? { reason: context.reason } : void 0,
      context: { access: context }
    });
  }
  /**
   * Create HOOK_ERROR with hook context
   */
  static hookError(hookContext, message2, cause) {
    return new ApiError({
      code: "HOOK_ERROR",
      message: message2,
      context: { hook: hookContext },
      cause
    });
  }
  /**
   * Create UNAUTHORIZED error
   */
  static unauthorized(message2 = "Authentication required") {
    return new ApiError({
      code: "UNAUTHORIZED",
      message: message2,
      messageKey: "error.unauthorized"
    });
  }
  /**
   * Create BAD_REQUEST error
   */
  static badRequest(message2 = "Bad request", fieldErrors) {
    const useDefaultTranslation = message2 === "Bad request";
    return new ApiError({
      code: "BAD_REQUEST",
      message: message2,
      messageKey: useDefaultTranslation ? "error.badRequest" : void 0,
      fieldErrors
    });
  }
  /**
   * Create INTERNAL_SERVER_ERROR
   */
  static internal(message2 = "Internal server error", cause) {
    return new ApiError({
      code: "INTERNAL_SERVER_ERROR",
      message: message2,
      messageKey: "error.internal",
      cause
    });
  }
  /**
   * Create NOT_IMPLEMENTED error
   */
  static notImplemented(feature) {
    return new ApiError({
      code: "NOT_IMPLEMENTED",
      message: `${feature} is not implemented or not enabled`,
      messageKey: "error.notImplemented",
      messageParams: { feature }
    });
  }
  /**
   * Create CONFLICT error
   */
  static conflict(message2) {
    return new ApiError({
      code: "CONFLICT",
      message: message2,
      messageKey: "error.conflict"
    });
  }
}
const PG_ERROR_CODES = {
  UNIQUE_VIOLATION: "23505",
  FOREIGN_KEY_VIOLATION: "23503",
  NOT_NULL_VIOLATION: "23502",
  CHECK_VIOLATION: "23514"
};
const unwrapError = (error2) => {
  if (!error2 || typeof error2 !== "object") return error2;
  const err2 = error2;
  if (err2.cause) return unwrapError(err2.cause);
  if (err2.original) return unwrapError(err2.original);
  if (err2.originalError) return unwrapError(err2.originalError);
  return error2;
};
const isDatabaseError = (error2) => {
  if (!error2 || typeof error2 !== "object") return false;
  const err2 = error2;
  const pgCode = err2.errno || err2.code;
  return typeof pgCode === "string" && /^\d{5}$/.test(pgCode);
};
const extractFieldFromConstraint = (constraint) => {
  const parts = constraint.split("_");
  if (parts.length < 2) return null;
  const suffixes = ["unique", "key", "fkey", "pkey", "check"];
  const fieldParts = [];
  for (const part of parts.slice(1)) {
    if (suffixes.includes(part)) break;
    fieldParts.push(part);
  }
  if (fieldParts.length === 0) return null;
  return fieldParts.map((part, i) => {
    if (i === 0) return part;
    return part.charAt(0).toUpperCase() + part.slice(1);
  }).join("");
};
const extractFieldFromDetail = (detail) => {
  const match2 = detail.match(/Key \(([^)]+)\)/);
  if (!match2) return null;
  const field = match2[1];
  const parts = field.split("_");
  return parts.map((part, i) => {
    if (i === 0) return part;
    return part.charAt(0).toUpperCase() + part.slice(1);
  }).join("");
};
const extractValueFromDetail = (detail) => {
  const match2 = detail.match(/Key \([^)]+\)=\(([^)]+)\)/);
  return match2 ? match2[1] : null;
};
const parseDatabaseError = (error2) => {
  const unwrapped = unwrapError(error2);
  if (!isDatabaseError(unwrapped)) return null;
  const dbError = unwrapped;
  const code = dbError.errno || dbError.code;
  const constraint = dbError.constraint_name || dbError.constraint;
  const detail = dbError.detail || "";
  const table = dbError.table || dbError.table_name;
  if (code === PG_ERROR_CODES.UNIQUE_VIOLATION) {
    const field = extractFieldFromConstraint(constraint) || extractFieldFromDetail(detail) || "value";
    const value = extractValueFromDetail(detail);
    const fieldErrors = [
      {
        path: field,
        message: `A record with this ${field} already exists`,
        value
      }
    ];
    const context = {
      operation: "insert",
      table: table || "unknown",
      constraint: constraint || "unique"
    };
    return new ApiError({
      code: "CONFLICT",
      message: `Duplicate ${field}: ${value || "value already exists"}`,
      messageKey: "error.database.uniqueViolation",
      messageParams: { field, value },
      fieldErrors,
      context: { db: context },
      cause: error2
    });
  }
  if (code === PG_ERROR_CODES.FOREIGN_KEY_VIOLATION) {
    const field = extractFieldFromConstraint(constraint) || extractFieldFromDetail(detail) || "reference";
    const fieldErrors = [
      {
        path: field,
        message: `Referenced record does not exist`
      }
    ];
    const context = {
      operation: "insert",
      table: table || "unknown",
      constraint: constraint || "foreign_key"
    };
    return new ApiError({
      code: "BAD_REQUEST",
      message: `Invalid ${field}: referenced record does not exist`,
      messageKey: "error.database.foreignKeyViolation",
      messageParams: { field },
      fieldErrors,
      context: { db: context },
      cause: error2
    });
  }
  if (code === PG_ERROR_CODES.NOT_NULL_VIOLATION) {
    const column = error2.column;
    const field = column || "field";
    const fieldErrors = [
      {
        path: field,
        message: `${field} is required`
      }
    ];
    const context = {
      operation: "insert",
      table: table || "unknown"
    };
    return new ApiError({
      code: "VALIDATION_ERROR",
      message: `${field} is required`,
      messageKey: "error.database.notNullViolation",
      messageParams: { field },
      fieldErrors,
      context: { db: context },
      cause: error2
    });
  }
  if (code === PG_ERROR_CODES.CHECK_VIOLATION) {
    const field = extractFieldFromConstraint(constraint) || "field";
    const fieldErrors = [
      {
        path: field,
        message: `Invalid value for ${field}`
      }
    ];
    const context = {
      operation: "insert",
      table: table || "unknown",
      constraint: constraint || "check"
    };
    return new ApiError({
      code: "VALIDATION_ERROR",
      message: `Invalid value for ${field}`,
      messageKey: "error.database.checkViolation",
      messageParams: { field },
      fieldErrors,
      context: { db: context },
      cause: error2
    });
  }
  return null;
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n2) {
  if (Object.prototype.hasOwnProperty.call(n2, "__esModule")) return n2;
  var f = n2.default;
  if (typeof f == "function") {
    var a = function a2() {
      var isInstance = false;
      try {
        isInstance = this instanceof a2;
      } catch {
      }
      if (isInstance) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n2, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n2[k];
      }
    });
  });
  return a;
}
var type;
var hasRequiredType;
function requireType() {
  if (hasRequiredType) return type;
  hasRequiredType = 1;
  type = TypeError;
  return type;
}
var util_inspect;
var hasRequiredUtil_inspect;
function requireUtil_inspect() {
  if (hasRequiredUtil_inspect) return util_inspect;
  hasRequiredUtil_inspect = 1;
  util_inspect = require$$1$1.inspect;
  return util_inspect;
}
var objectInspect;
var hasRequiredObjectInspect;
function requireObjectInspect() {
  if (hasRequiredObjectInspect) return objectInspect;
  hasRequiredObjectInspect = 1;
  var hasMap = typeof Map === "function" && Map.prototype;
  var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
  var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
  var mapForEach = hasMap && Map.prototype.forEach;
  var hasSet = typeof Set === "function" && Set.prototype;
  var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
  var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
  var setForEach = hasSet && Set.prototype.forEach;
  var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
  var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
  var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
  var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
  var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
  var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
  var booleanValueOf = Boolean.prototype.valueOf;
  var objectToString = Object.prototype.toString;
  var functionToString = Function.prototype.toString;
  var $match = String.prototype.match;
  var $slice = String.prototype.slice;
  var $replace = String.prototype.replace;
  var $toUpperCase = String.prototype.toUpperCase;
  var $toLowerCase = String.prototype.toLowerCase;
  var $test = RegExp.prototype.test;
  var $concat = Array.prototype.concat;
  var $join = Array.prototype.join;
  var $arrSlice = Array.prototype.slice;
  var $floor = Math.floor;
  var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
  var gOPS = Object.getOwnPropertySymbols;
  var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
  var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
  var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
  var isEnumerable = Object.prototype.propertyIsEnumerable;
  var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
    return O.__proto__;
  } : null);
  function addNumericSeparator(num, str) {
    if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
      return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === "number") {
      var int2 = num < 0 ? -$floor(-num) : $floor(num);
      if (int2 !== num) {
        var intStr = String(int2);
        var dec = $slice.call(str, intStr.length + 1);
        return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
      }
    }
    return $replace.call(str, sepRegex, "$&_");
  }
  var utilInspect = /* @__PURE__ */ requireUtil_inspect();
  var inspectCustom = utilInspect.custom;
  var inspectSymbol = isSymbol2(inspectCustom) ? inspectCustom : null;
  var quotes = {
    __proto__: null,
    "double": '"',
    single: "'"
  };
  var quoteREs = {
    __proto__: null,
    "double": /(["\\])/g,
    single: /(['\\])/g
  };
  objectInspect = function inspect_(obj, options, depth, seen) {
    var opts = options || {};
    if (has(opts, "quoteStyle") && !has(quotes, opts.quoteStyle)) {
      throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
      throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
    if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
      throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    }
    if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
      throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
      throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;
    if (typeof obj === "undefined") {
      return "undefined";
    }
    if (obj === null) {
      return "null";
    }
    if (typeof obj === "boolean") {
      return obj ? "true" : "false";
    }
    if (typeof obj === "string") {
      return inspectString(obj, opts);
    }
    if (typeof obj === "number") {
      if (obj === 0) {
        return Infinity / obj > 0 ? "0" : "-0";
      }
      var str = String(obj);
      return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === "bigint") {
      var bigIntStr = String(obj) + "n";
      return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }
    var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
    if (typeof depth === "undefined") {
      depth = 0;
    }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
      return isArray2(obj) ? "[Array]" : "[Object]";
    }
    var indent = getIndent(opts, depth);
    if (typeof seen === "undefined") {
      seen = [];
    } else if (indexOf(seen, obj) >= 0) {
      return "[Circular]";
    }
    function inspect(value, from, noIndent) {
      if (from) {
        seen = $arrSlice.call(seen);
        seen.push(from);
      }
      if (noIndent) {
        var newOpts = {
          depth: opts.depth
        };
        if (has(opts, "quoteStyle")) {
          newOpts.quoteStyle = opts.quoteStyle;
        }
        return inspect_(value, newOpts, depth + 1, seen);
      }
      return inspect_(value, opts, depth + 1, seen);
    }
    if (typeof obj === "function" && !isRegExp2(obj)) {
      var name2 = nameOf(obj);
      var keys = arrObjKeys(obj, inspect);
      return "[Function" + (name2 ? ": " + name2 : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
    }
    if (isSymbol2(obj)) {
      var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
      return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
      var s2 = "<" + $toLowerCase.call(String(obj.nodeName));
      var attrs = obj.attributes || [];
      for (var i = 0; i < attrs.length; i++) {
        s2 += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
      }
      s2 += ">";
      if (obj.childNodes && obj.childNodes.length) {
        s2 += "...";
      }
      s2 += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
      return s2;
    }
    if (isArray2(obj)) {
      if (obj.length === 0) {
        return "[]";
      }
      var xs = arrObjKeys(obj, inspect);
      if (indent && !singleLineValues(xs)) {
        return "[" + indentedJoin(xs, indent) + "]";
      }
      return "[ " + $join.call(xs, ", ") + " ]";
    }
    if (isError2(obj)) {
      var parts = arrObjKeys(obj, inspect);
      if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
        return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
      }
      if (parts.length === 0) {
        return "[" + String(obj) + "]";
      }
      return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
    }
    if (typeof obj === "object" && customInspect) {
      if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
        return utilInspect(obj, { depth: maxDepth - depth });
      } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
        return obj.inspect();
      }
    }
    if (isMap2(obj)) {
      var mapParts = [];
      if (mapForEach) {
        mapForEach.call(obj, function(value, key) {
          mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
        });
      }
      return collectionOf("Map", mapSize.call(obj), mapParts, indent);
    }
    if (isSet2(obj)) {
      var setParts = [];
      if (setForEach) {
        setForEach.call(obj, function(value) {
          setParts.push(inspect(value, obj));
        });
      }
      return collectionOf("Set", setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
      return weakCollectionOf("WeakMap");
    }
    if (isWeakSet(obj)) {
      return weakCollectionOf("WeakSet");
    }
    if (isWeakRef(obj)) {
      return weakCollectionOf("WeakRef");
    }
    if (isNumber2(obj)) {
      return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt2(obj)) {
      return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean2(obj)) {
      return markBoxed(booleanValueOf.call(obj));
    }
    if (isString2(obj)) {
      return markBoxed(inspect(String(obj)));
    }
    if (typeof window !== "undefined" && obj === window) {
      return "{ [object Window] }";
    }
    if (typeof globalThis !== "undefined" && obj === globalThis || typeof commonjsGlobal !== "undefined" && obj === commonjsGlobal) {
      return "{ [object globalThis] }";
    }
    if (!isDate2(obj) && !isRegExp2(obj)) {
      var ys = arrObjKeys(obj, inspect);
      var isPlainObject2 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
      var protoTag = obj instanceof Object ? "" : "null prototype";
      var stringTag = !isPlainObject2 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
      var constructorTag = isPlainObject2 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
      var tag2 = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
      if (ys.length === 0) {
        return tag2 + "{}";
      }
      if (indent) {
        return tag2 + "{" + indentedJoin(ys, indent) + "}";
      }
      return tag2 + "{ " + $join.call(ys, ", ") + " }";
    }
    return String(obj);
  };
  function wrapQuotes(s2, defaultStyle, opts) {
    var style = opts.quoteStyle || defaultStyle;
    var quoteChar = quotes[style];
    return quoteChar + s2 + quoteChar;
  }
  function quote(s2) {
    return $replace.call(String(s2), /"/g, "&quot;");
  }
  function canTrustToString(obj) {
    return !toStringTag || !(typeof obj === "object" && (toStringTag in obj || typeof obj[toStringTag] !== "undefined"));
  }
  function isArray2(obj) {
    return toStr(obj) === "[object Array]" && canTrustToString(obj);
  }
  function isDate2(obj) {
    return toStr(obj) === "[object Date]" && canTrustToString(obj);
  }
  function isRegExp2(obj) {
    return toStr(obj) === "[object RegExp]" && canTrustToString(obj);
  }
  function isError2(obj) {
    return toStr(obj) === "[object Error]" && canTrustToString(obj);
  }
  function isString2(obj) {
    return toStr(obj) === "[object String]" && canTrustToString(obj);
  }
  function isNumber2(obj) {
    return toStr(obj) === "[object Number]" && canTrustToString(obj);
  }
  function isBoolean2(obj) {
    return toStr(obj) === "[object Boolean]" && canTrustToString(obj);
  }
  function isSymbol2(obj) {
    if (hasShammedSymbols) {
      return obj && typeof obj === "object" && obj instanceof Symbol;
    }
    if (typeof obj === "symbol") {
      return true;
    }
    if (!obj || typeof obj !== "object" || !symToString) {
      return false;
    }
    try {
      symToString.call(obj);
      return true;
    } catch (e2) {
    }
    return false;
  }
  function isBigInt2(obj) {
    if (!obj || typeof obj !== "object" || !bigIntValueOf) {
      return false;
    }
    try {
      bigIntValueOf.call(obj);
      return true;
    } catch (e2) {
    }
    return false;
  }
  var hasOwn = Object.prototype.hasOwnProperty || function(key) {
    return key in this;
  };
  function has(obj, key) {
    return hasOwn.call(obj, key);
  }
  function toStr(obj) {
    return objectToString.call(obj);
  }
  function nameOf(f) {
    if (f.name) {
      return f.name;
    }
    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) {
      return m[1];
    }
    return null;
  }
  function indexOf(xs, x) {
    if (xs.indexOf) {
      return xs.indexOf(x);
    }
    for (var i = 0, l2 = xs.length; i < l2; i++) {
      if (xs[i] === x) {
        return i;
      }
    }
    return -1;
  }
  function isMap2(x) {
    if (!mapSize || !x || typeof x !== "object") {
      return false;
    }
    try {
      mapSize.call(x);
      try {
        setSize.call(x);
      } catch (s2) {
        return true;
      }
      return x instanceof Map;
    } catch (e2) {
    }
    return false;
  }
  function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== "object") {
      return false;
    }
    try {
      weakMapHas.call(x, weakMapHas);
      try {
        weakSetHas.call(x, weakSetHas);
      } catch (s2) {
        return true;
      }
      return x instanceof WeakMap;
    } catch (e2) {
    }
    return false;
  }
  function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== "object") {
      return false;
    }
    try {
      weakRefDeref.call(x);
      return true;
    } catch (e2) {
    }
    return false;
  }
  function isSet2(x) {
    if (!setSize || !x || typeof x !== "object") {
      return false;
    }
    try {
      setSize.call(x);
      try {
        mapSize.call(x);
      } catch (m) {
        return true;
      }
      return x instanceof Set;
    } catch (e2) {
    }
    return false;
  }
  function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== "object") {
      return false;
    }
    try {
      weakSetHas.call(x, weakSetHas);
      try {
        weakMapHas.call(x, weakMapHas);
      } catch (s2) {
        return true;
      }
      return x instanceof WeakSet;
    } catch (e2) {
    }
    return false;
  }
  function isElement(x) {
    if (!x || typeof x !== "object") {
      return false;
    }
    if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
      return true;
    }
    return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
  }
  function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
      var remaining = str.length - opts.maxStringLength;
      var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
      return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    var quoteRE = quoteREs[opts.quoteStyle || "single"];
    quoteRE.lastIndex = 0;
    var s2 = $replace.call($replace.call(str, quoteRE, "\\$1"), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s2, "single", opts);
  }
  function lowbyte(c2) {
    var n2 = c2.charCodeAt(0);
    var x = {
      8: "b",
      9: "t",
      10: "n",
      12: "f",
      13: "r"
    }[n2];
    if (x) {
      return "\\" + x;
    }
    return "\\x" + (n2 < 16 ? "0" : "") + $toUpperCase.call(n2.toString(16));
  }
  function markBoxed(str) {
    return "Object(" + str + ")";
  }
  function weakCollectionOf(type2) {
    return type2 + " { ? }";
  }
  function collectionOf(type2, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
    return type2 + " (" + size + ") {" + joinedEntries + "}";
  }
  function singleLineValues(xs) {
    for (var i = 0; i < xs.length; i++) {
      if (indexOf(xs[i], "\n") >= 0) {
        return false;
      }
    }
    return true;
  }
  function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === "	") {
      baseIndent = "	";
    } else if (typeof opts.indent === "number" && opts.indent > 0) {
      baseIndent = $join.call(Array(opts.indent + 1), " ");
    } else {
      return null;
    }
    return {
      base: baseIndent,
      prev: $join.call(Array(depth + 1), baseIndent)
    };
  }
  function indentedJoin(xs, indent) {
    if (xs.length === 0) {
      return "";
    }
    var lineJoiner = "\n" + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
  }
  function arrObjKeys(obj, inspect) {
    var isArr = isArray2(obj);
    var xs = [];
    if (isArr) {
      xs.length = obj.length;
      for (var i = 0; i < obj.length; i++) {
        xs[i] = has(obj, i) ? inspect(obj[i], obj) : "";
      }
    }
    var syms = typeof gOPS === "function" ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
      symMap = {};
      for (var k = 0; k < syms.length; k++) {
        symMap["$" + syms[k]] = syms[k];
      }
    }
    for (var key in obj) {
      if (!has(obj, key)) {
        continue;
      }
      if (isArr && String(Number(key)) === key && key < obj.length) {
        continue;
      }
      if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
        continue;
      } else if ($test.call(/[^\w$]/, key)) {
        xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
      } else {
        xs.push(key + ": " + inspect(obj[key], obj));
      }
    }
    if (typeof gOPS === "function") {
      for (var j = 0; j < syms.length; j++) {
        if (isEnumerable.call(obj, syms[j])) {
          xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
        }
      }
    }
    return xs;
  }
  return objectInspect;
}
var sideChannelList;
var hasRequiredSideChannelList;
function requireSideChannelList() {
  if (hasRequiredSideChannelList) return sideChannelList;
  hasRequiredSideChannelList = 1;
  var inspect = /* @__PURE__ */ requireObjectInspect();
  var $TypeError = /* @__PURE__ */ requireType();
  var listGetNode = function(list, key, isDelete) {
    var prev = list;
    var curr;
    for (; (curr = prev.next) != null; prev = curr) {
      if (curr.key === key) {
        prev.next = curr.next;
        if (!isDelete) {
          curr.next = /** @type {NonNullable<typeof list.next>} */
          list.next;
          list.next = curr;
        }
        return curr;
      }
    }
  };
  var listGet = function(objects, key) {
    if (!objects) {
      return void 0;
    }
    var node = listGetNode(objects, key);
    return node && node.value;
  };
  var listSet = function(objects, key, value) {
    var node = listGetNode(objects, key);
    if (node) {
      node.value = value;
    } else {
      objects.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */
      {
        // eslint-disable-line no-param-reassign, no-extra-parens
        key,
        next: objects.next,
        value
      };
    }
  };
  var listHas = function(objects, key) {
    if (!objects) {
      return false;
    }
    return !!listGetNode(objects, key);
  };
  var listDelete = function(objects, key) {
    if (objects) {
      return listGetNode(objects, key, true);
    }
  };
  sideChannelList = function getSideChannelList() {
    var $o;
    var channel = {
      assert: function(key) {
        if (!channel.has(key)) {
          throw new $TypeError("Side channel does not contain " + inspect(key));
        }
      },
      "delete": function(key) {
        var root = $o && $o.next;
        var deletedNode = listDelete($o, key);
        if (deletedNode && root && root === deletedNode) {
          $o = void 0;
        }
        return !!deletedNode;
      },
      get: function(key) {
        return listGet($o, key);
      },
      has: function(key) {
        return listHas($o, key);
      },
      set: function(key, value) {
        if (!$o) {
          $o = {
            next: void 0
          };
        }
        listSet(
          /** @type {NonNullable<typeof $o>} */
          $o,
          key,
          value
        );
      }
    };
    return channel;
  };
  return sideChannelList;
}
var esObjectAtoms;
var hasRequiredEsObjectAtoms;
function requireEsObjectAtoms() {
  if (hasRequiredEsObjectAtoms) return esObjectAtoms;
  hasRequiredEsObjectAtoms = 1;
  esObjectAtoms = Object;
  return esObjectAtoms;
}
var esErrors;
var hasRequiredEsErrors;
function requireEsErrors() {
  if (hasRequiredEsErrors) return esErrors;
  hasRequiredEsErrors = 1;
  esErrors = Error;
  return esErrors;
}
var _eval;
var hasRequired_eval;
function require_eval() {
  if (hasRequired_eval) return _eval;
  hasRequired_eval = 1;
  _eval = EvalError;
  return _eval;
}
var range;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange) return range;
  hasRequiredRange = 1;
  range = RangeError;
  return range;
}
var ref$1;
var hasRequiredRef;
function requireRef() {
  if (hasRequiredRef) return ref$1;
  hasRequiredRef = 1;
  ref$1 = ReferenceError;
  return ref$1;
}
var syntax;
var hasRequiredSyntax;
function requireSyntax() {
  if (hasRequiredSyntax) return syntax;
  hasRequiredSyntax = 1;
  syntax = SyntaxError;
  return syntax;
}
var uri;
var hasRequiredUri;
function requireUri() {
  if (hasRequiredUri) return uri;
  hasRequiredUri = 1;
  uri = URIError;
  return uri;
}
var abs;
var hasRequiredAbs;
function requireAbs() {
  if (hasRequiredAbs) return abs;
  hasRequiredAbs = 1;
  abs = Math.abs;
  return abs;
}
var floor;
var hasRequiredFloor;
function requireFloor() {
  if (hasRequiredFloor) return floor;
  hasRequiredFloor = 1;
  floor = Math.floor;
  return floor;
}
var max;
var hasRequiredMax;
function requireMax() {
  if (hasRequiredMax) return max;
  hasRequiredMax = 1;
  max = Math.max;
  return max;
}
var min;
var hasRequiredMin;
function requireMin() {
  if (hasRequiredMin) return min;
  hasRequiredMin = 1;
  min = Math.min;
  return min;
}
var pow;
var hasRequiredPow;
function requirePow() {
  if (hasRequiredPow) return pow;
  hasRequiredPow = 1;
  pow = Math.pow;
  return pow;
}
var round;
var hasRequiredRound;
function requireRound() {
  if (hasRequiredRound) return round;
  hasRequiredRound = 1;
  round = Math.round;
  return round;
}
var _isNaN;
var hasRequired_isNaN;
function require_isNaN() {
  if (hasRequired_isNaN) return _isNaN;
  hasRequired_isNaN = 1;
  _isNaN = Number.isNaN || function isNaN2(a) {
    return a !== a;
  };
  return _isNaN;
}
var sign$2;
var hasRequiredSign$1;
function requireSign$1() {
  if (hasRequiredSign$1) return sign$2;
  hasRequiredSign$1 = 1;
  var $isNaN = /* @__PURE__ */ require_isNaN();
  sign$2 = function sign2(number) {
    if ($isNaN(number) || number === 0) {
      return number;
    }
    return number < 0 ? -1 : 1;
  };
  return sign$2;
}
var gOPD;
var hasRequiredGOPD;
function requireGOPD() {
  if (hasRequiredGOPD) return gOPD;
  hasRequiredGOPD = 1;
  gOPD = Object.getOwnPropertyDescriptor;
  return gOPD;
}
var gopd;
var hasRequiredGopd;
function requireGopd() {
  if (hasRequiredGopd) return gopd;
  hasRequiredGopd = 1;
  var $gOPD = /* @__PURE__ */ requireGOPD();
  if ($gOPD) {
    try {
      $gOPD([], "length");
    } catch (e2) {
      $gOPD = null;
    }
  }
  gopd = $gOPD;
  return gopd;
}
var esDefineProperty;
var hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty) return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var $defineProperty = Object.defineProperty || false;
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e2) {
      $defineProperty = false;
    }
  }
  esDefineProperty = $defineProperty;
  return esDefineProperty;
}
var shams;
var hasRequiredShams;
function requireShams() {
  if (hasRequiredShams) return shams;
  hasRequiredShams = 1;
  shams = function hasSymbols2() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = /* @__PURE__ */ Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (var _ in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(obj, sym)
      );
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
  return shams;
}
var hasSymbols;
var hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols;
  hasRequiredHasSymbols = 1;
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = requireShams();
  hasSymbols = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof /* @__PURE__ */ Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
  return hasSymbols;
}
var Reflect_getPrototypeOf;
var hasRequiredReflect_getPrototypeOf;
function requireReflect_getPrototypeOf() {
  if (hasRequiredReflect_getPrototypeOf) return Reflect_getPrototypeOf;
  hasRequiredReflect_getPrototypeOf = 1;
  Reflect_getPrototypeOf = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  return Reflect_getPrototypeOf;
}
var Object_getPrototypeOf;
var hasRequiredObject_getPrototypeOf;
function requireObject_getPrototypeOf() {
  if (hasRequiredObject_getPrototypeOf) return Object_getPrototypeOf;
  hasRequiredObject_getPrototypeOf = 1;
  var $Object = /* @__PURE__ */ requireEsObjectAtoms();
  Object_getPrototypeOf = $Object.getPrototypeOf || null;
  return Object_getPrototypeOf;
}
var implementation;
var hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation) return implementation;
  hasRequiredImplementation = 1;
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr = Object.prototype.toString;
  var max2 = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty2(a, b) {
    var arr = [];
    for (var i = 0; i < a.length; i += 1) {
      arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
      arr[j + a.length] = b[j];
    }
    return arr;
  };
  var slicy = function slicy2(arrLike, offset2) {
    var arr = [];
    for (var i = offset2, j = 0; i < arrLike.length; i += 1, j += 1) {
      arr[j] = arrLike[i];
    }
    return arr;
  };
  var joiny = function(arr, joiner) {
    var str = "";
    for (var i = 0; i < arr.length; i += 1) {
      str += arr[i];
      if (i + 1 < arr.length) {
        str += joiner;
      }
    }
    return str;
  };
  implementation = function bind2(that) {
    var target = this;
    if (typeof target !== "function" || toStr.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result2 = target.apply(
          this,
          concatty(args, arguments)
        );
        if (Object(result2) === result2) {
          return result2;
        }
        return this;
      }
      return target.apply(
        that,
        concatty(args, arguments)
      );
    };
    var boundLength = max2(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
      boundArgs[i] = "$" + i;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty2() {
      };
      Empty.prototype = target.prototype;
      bound.prototype = new Empty();
      Empty.prototype = null;
    }
    return bound;
  };
  return implementation;
}
var functionBind;
var hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind) return functionBind;
  hasRequiredFunctionBind = 1;
  var implementation2 = requireImplementation();
  functionBind = Function.prototype.bind || implementation2;
  return functionBind;
}
var functionCall;
var hasRequiredFunctionCall;
function requireFunctionCall() {
  if (hasRequiredFunctionCall) return functionCall;
  hasRequiredFunctionCall = 1;
  functionCall = Function.prototype.call;
  return functionCall;
}
var functionApply;
var hasRequiredFunctionApply;
function requireFunctionApply() {
  if (hasRequiredFunctionApply) return functionApply;
  hasRequiredFunctionApply = 1;
  functionApply = Function.prototype.apply;
  return functionApply;
}
var reflectApply;
var hasRequiredReflectApply;
function requireReflectApply() {
  if (hasRequiredReflectApply) return reflectApply;
  hasRequiredReflectApply = 1;
  reflectApply = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  return reflectApply;
}
var actualApply;
var hasRequiredActualApply;
function requireActualApply() {
  if (hasRequiredActualApply) return actualApply;
  hasRequiredActualApply = 1;
  var bind2 = requireFunctionBind();
  var $apply = requireFunctionApply();
  var $call = requireFunctionCall();
  var $reflectApply = requireReflectApply();
  actualApply = $reflectApply || bind2.call($call, $apply);
  return actualApply;
}
var callBindApplyHelpers;
var hasRequiredCallBindApplyHelpers;
function requireCallBindApplyHelpers() {
  if (hasRequiredCallBindApplyHelpers) return callBindApplyHelpers;
  hasRequiredCallBindApplyHelpers = 1;
  var bind2 = requireFunctionBind();
  var $TypeError = /* @__PURE__ */ requireType();
  var $call = requireFunctionCall();
  var $actualApply = requireActualApply();
  callBindApplyHelpers = function callBindBasic(args) {
    if (args.length < 1 || typeof args[0] !== "function") {
      throw new $TypeError("a function is required");
    }
    return $actualApply(bind2, $call, args);
  };
  return callBindApplyHelpers;
}
var get$1;
var hasRequiredGet;
function requireGet() {
  if (hasRequiredGet) return get$1;
  hasRequiredGet = 1;
  var callBind = requireCallBindApplyHelpers();
  var gOPD2 = /* @__PURE__ */ requireGopd();
  var hasProtoAccessor;
  try {
    hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (e2) {
    if (!e2 || typeof e2 !== "object" || !("code" in e2) || e2.code !== "ERR_PROTO_ACCESS") {
      throw e2;
    }
  }
  var desc2 = !!hasProtoAccessor && gOPD2 && gOPD2(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  );
  var $Object = Object;
  var $getPrototypeOf = $Object.getPrototypeOf;
  get$1 = desc2 && typeof desc2.get === "function" ? callBind([desc2.get]) : typeof $getPrototypeOf === "function" ? (
    /** @type {import('./get')} */
    function getDunder(value) {
      return $getPrototypeOf(value == null ? value : $Object(value));
    }
  ) : false;
  return get$1;
}
var getProto;
var hasRequiredGetProto;
function requireGetProto() {
  if (hasRequiredGetProto) return getProto;
  hasRequiredGetProto = 1;
  var reflectGetProto = requireReflect_getPrototypeOf();
  var originalGetProto = requireObject_getPrototypeOf();
  var getDunderProto = /* @__PURE__ */ requireGet();
  getProto = reflectGetProto ? function getProto2(O) {
    return reflectGetProto(O);
  } : originalGetProto ? function getProto2(O) {
    if (!O || typeof O !== "object" && typeof O !== "function") {
      throw new TypeError("getProto: not an object");
    }
    return originalGetProto(O);
  } : getDunderProto ? function getProto2(O) {
    return getDunderProto(O);
  } : null;
  return getProto;
}
var hasown;
var hasRequiredHasown;
function requireHasown() {
  if (hasRequiredHasown) return hasown;
  hasRequiredHasown = 1;
  var call = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind2 = requireFunctionBind();
  hasown = bind2.call(call, $hasOwn);
  return hasown;
}
var getIntrinsic;
var hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic) return getIntrinsic;
  hasRequiredGetIntrinsic = 1;
  var undefined$1;
  var $Object = /* @__PURE__ */ requireEsObjectAtoms();
  var $Error = /* @__PURE__ */ requireEsErrors();
  var $EvalError = /* @__PURE__ */ require_eval();
  var $RangeError = /* @__PURE__ */ requireRange();
  var $ReferenceError = /* @__PURE__ */ requireRef();
  var $SyntaxError = /* @__PURE__ */ requireSyntax();
  var $TypeError = /* @__PURE__ */ requireType();
  var $URIError = /* @__PURE__ */ requireUri();
  var abs2 = /* @__PURE__ */ requireAbs();
  var floor2 = /* @__PURE__ */ requireFloor();
  var max2 = /* @__PURE__ */ requireMax();
  var min2 = /* @__PURE__ */ requireMin();
  var pow2 = /* @__PURE__ */ requirePow();
  var round2 = /* @__PURE__ */ requireRound();
  var sign2 = /* @__PURE__ */ requireSign$1();
  var $Function = Function;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e2) {
    }
  };
  var $gOPD = /* @__PURE__ */ requireGopd();
  var $defineProperty = /* @__PURE__ */ requireEsDefineProperty();
  var throwTypeError = function() {
    throw new $TypeError();
  };
  var ThrowTypeError = $gOPD ? (function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  })() : throwTypeError;
  var hasSymbols2 = requireHasSymbols()();
  var getProto2 = requireGetProto();
  var $ObjectGPO = requireObject_getPrototypeOf();
  var $ReflectGPO = requireReflect_getPrototypeOf();
  var $apply = requireFunctionApply();
  var $call = requireFunctionCall();
  var needsEval = {};
  var TypedArray = typeof Uint8Array === "undefined" || !getProto2 ? undefined$1 : getProto2(Uint8Array);
  var INTRINSICS = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2([][Symbol.iterator]()) : undefined$1,
    "%AsyncFromSyncIteratorPrototype%": undefined$1,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": $Error,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": $EvalError,
    "%Float16Array%": typeof Float16Array === "undefined" ? undefined$1 : Float16Array,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(getProto2([][Symbol.iterator]())) : undefined$1,
    "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
    "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": $Object,
    "%Object.getOwnPropertyDescriptor%": $gOPD,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
    "%RangeError%": $RangeError,
    "%ReferenceError%": $ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(""[Symbol.iterator]()) : undefined$1,
    "%Symbol%": hasSymbols2 ? Symbol : undefined$1,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
    "%URIError%": $URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet,
    "%Function.prototype.call%": $call,
    "%Function.prototype.apply%": $apply,
    "%Object.defineProperty%": $defineProperty,
    "%Object.getPrototypeOf%": $ObjectGPO,
    "%Math.abs%": abs2,
    "%Math.floor%": floor2,
    "%Math.max%": max2,
    "%Math.min%": min2,
    "%Math.pow%": pow2,
    "%Math.round%": round2,
    "%Math.sign%": sign2,
    "%Reflect.getPrototypeOf%": $ReflectGPO
  };
  if (getProto2) {
    try {
      null.error;
    } catch (e2) {
      var errorProto = getProto2(getProto2(e2));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
  }
  var doEval = function doEval2(name2) {
    var value;
    if (name2 === "%AsyncFunction%") {
      value = getEvalledConstructor("async function () {}");
    } else if (name2 === "%GeneratorFunction%") {
      value = getEvalledConstructor("function* () {}");
    } else if (name2 === "%AsyncGeneratorFunction%") {
      value = getEvalledConstructor("async function* () {}");
    } else if (name2 === "%AsyncGenerator%") {
      var fn2 = doEval2("%AsyncGeneratorFunction%");
      if (fn2) {
        value = fn2.prototype;
      }
    } else if (name2 === "%AsyncIteratorPrototype%") {
      var gen = doEval2("%AsyncGenerator%");
      if (gen && getProto2) {
        value = getProto2(gen.prototype);
      }
    }
    INTRINSICS[name2] = value;
    return value;
  };
  var LEGACY_ALIASES = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  };
  var bind2 = requireFunctionBind();
  var hasOwn = /* @__PURE__ */ requireHasown();
  var $concat = bind2.call($call, Array.prototype.concat);
  var $spliceApply = bind2.call($apply, Array.prototype.splice);
  var $replace = bind2.call($call, String.prototype.replace);
  var $strSlice = bind2.call($call, String.prototype.slice);
  var $exec = bind2.call($call, RegExp.prototype.exec);
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = function stringToPath2(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === "%" && last !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    } else if (last === "%" && first !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    }
    var result2 = [];
    $replace(string, rePropName, function(match2, number, quote, subString) {
      result2[result2.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match2;
    });
    return result2;
  };
  var getBaseIntrinsic = function getBaseIntrinsic2(name2, allowMissing) {
    var intrinsicName = name2;
    var alias2;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
      alias2 = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias2[0] + "%";
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
      var value = INTRINSICS[intrinsicName];
      if (value === needsEval) {
        value = doEval(intrinsicName);
      }
      if (typeof value === "undefined" && !allowMissing) {
        throw new $TypeError("intrinsic " + name2 + " exists, but is not available. Please file an issue!");
      }
      return {
        alias: alias2,
        name: intrinsicName,
        value
      };
    }
    throw new $SyntaxError("intrinsic " + name2 + " does not exist!");
  };
  getIntrinsic = function GetIntrinsic(name2, allowMissing) {
    if (typeof name2 !== "string" || name2.length === 0) {
      throw new $TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name2) === null) {
      throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    }
    var parts = stringToPath(name2);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias2 = intrinsic.alias;
    if (alias2) {
      intrinsicBaseName = alias2[0];
      $spliceApply(parts, $concat([0, 1], alias2));
    }
    for (var i = 1, isOwn = true; i < parts.length; i += 1) {
      var part = parts[i];
      var first = $strSlice(part, 0, 1);
      var last = $strSlice(part, -1);
      if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
        throw new $SyntaxError("property names with quotes must have matching quotes");
      }
      if (part === "constructor" || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += "." + part;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (hasOwn(INTRINSICS, intrinsicRealName)) {
        value = INTRINSICS[intrinsicRealName];
      } else if (value != null) {
        if (!(part in value)) {
          if (!allowMissing) {
            throw new $TypeError("base intrinsic for " + name2 + " exists, but the property is not available.");
          }
          return void undefined$1;
        }
        if ($gOPD && i + 1 >= parts.length) {
          var desc2 = $gOPD(value, part);
          isOwn = !!desc2;
          if (isOwn && "get" in desc2 && !("originalValue" in desc2.get)) {
            value = desc2.get;
          } else {
            value = value[part];
          }
        } else {
          isOwn = hasOwn(value, part);
          value = value[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value;
        }
      }
    }
    return value;
  };
  return getIntrinsic;
}
var callBound;
var hasRequiredCallBound;
function requireCallBound() {
  if (hasRequiredCallBound) return callBound;
  hasRequiredCallBound = 1;
  var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
  var callBindBasic = requireCallBindApplyHelpers();
  var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
  callBound = function callBoundIntrinsic(name2, allowMissing) {
    var intrinsic = (
      /** @type {(this: unknown, ...args: unknown[]) => unknown} */
      GetIntrinsic(name2, !!allowMissing)
    );
    if (typeof intrinsic === "function" && $indexOf(name2, ".prototype.") > -1) {
      return callBindBasic(
        /** @type {const} */
        [intrinsic]
      );
    }
    return intrinsic;
  };
  return callBound;
}
var sideChannelMap;
var hasRequiredSideChannelMap;
function requireSideChannelMap() {
  if (hasRequiredSideChannelMap) return sideChannelMap;
  hasRequiredSideChannelMap = 1;
  var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
  var callBound2 = /* @__PURE__ */ requireCallBound();
  var inspect = /* @__PURE__ */ requireObjectInspect();
  var $TypeError = /* @__PURE__ */ requireType();
  var $Map = GetIntrinsic("%Map%", true);
  var $mapGet = callBound2("Map.prototype.get", true);
  var $mapSet = callBound2("Map.prototype.set", true);
  var $mapHas = callBound2("Map.prototype.has", true);
  var $mapDelete = callBound2("Map.prototype.delete", true);
  var $mapSize = callBound2("Map.prototype.size", true);
  sideChannelMap = !!$Map && /** @type {Exclude<import('.'), false>} */
  function getSideChannelMap() {
    var $m;
    var channel = {
      assert: function(key) {
        if (!channel.has(key)) {
          throw new $TypeError("Side channel does not contain " + inspect(key));
        }
      },
      "delete": function(key) {
        if ($m) {
          var result2 = $mapDelete($m, key);
          if ($mapSize($m) === 0) {
            $m = void 0;
          }
          return result2;
        }
        return false;
      },
      get: function(key) {
        if ($m) {
          return $mapGet($m, key);
        }
      },
      has: function(key) {
        if ($m) {
          return $mapHas($m, key);
        }
        return false;
      },
      set: function(key, value) {
        if (!$m) {
          $m = new $Map();
        }
        $mapSet($m, key, value);
      }
    };
    return channel;
  };
  return sideChannelMap;
}
var sideChannelWeakmap;
var hasRequiredSideChannelWeakmap;
function requireSideChannelWeakmap() {
  if (hasRequiredSideChannelWeakmap) return sideChannelWeakmap;
  hasRequiredSideChannelWeakmap = 1;
  var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
  var callBound2 = /* @__PURE__ */ requireCallBound();
  var inspect = /* @__PURE__ */ requireObjectInspect();
  var getSideChannelMap = requireSideChannelMap();
  var $TypeError = /* @__PURE__ */ requireType();
  var $WeakMap = GetIntrinsic("%WeakMap%", true);
  var $weakMapGet = callBound2("WeakMap.prototype.get", true);
  var $weakMapSet = callBound2("WeakMap.prototype.set", true);
  var $weakMapHas = callBound2("WeakMap.prototype.has", true);
  var $weakMapDelete = callBound2("WeakMap.prototype.delete", true);
  sideChannelWeakmap = $WeakMap ? (
    /** @type {Exclude<import('.'), false>} */
    function getSideChannelWeakMap() {
      var $wm;
      var $m;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        },
        "delete": function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapDelete($wm, key);
            }
          } else if (getSideChannelMap) {
            if ($m) {
              return $m["delete"](key);
            }
          }
          return false;
        },
        get: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key);
            }
          }
          return $m && $m.get(key);
        },
        has: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key);
            }
          }
          return !!$m && $m.has(key);
        },
        set: function(key, value) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key, value);
          } else if (getSideChannelMap) {
            if (!$m) {
              $m = getSideChannelMap();
            }
            $m.set(key, value);
          }
        }
      };
      return channel;
    }
  ) : getSideChannelMap;
  return sideChannelWeakmap;
}
var sideChannel;
var hasRequiredSideChannel;
function requireSideChannel() {
  if (hasRequiredSideChannel) return sideChannel;
  hasRequiredSideChannel = 1;
  var $TypeError = /* @__PURE__ */ requireType();
  var inspect = /* @__PURE__ */ requireObjectInspect();
  var getSideChannelList = requireSideChannelList();
  var getSideChannelMap = requireSideChannelMap();
  var getSideChannelWeakMap = requireSideChannelWeakmap();
  var makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;
  sideChannel = function getSideChannel() {
    var $channelData;
    var channel = {
      assert: function(key) {
        if (!channel.has(key)) {
          throw new $TypeError("Side channel does not contain " + inspect(key));
        }
      },
      "delete": function(key) {
        return !!$channelData && $channelData["delete"](key);
      },
      get: function(key) {
        return $channelData && $channelData.get(key);
      },
      has: function(key) {
        return !!$channelData && $channelData.has(key);
      },
      set: function(key, value) {
        if (!$channelData) {
          $channelData = makeChannel();
        }
        $channelData.set(key, value);
      }
    };
    return channel;
  };
  return sideChannel;
}
var formats;
var hasRequiredFormats;
function requireFormats() {
  if (hasRequiredFormats) return formats;
  hasRequiredFormats = 1;
  var replace = String.prototype.replace;
  var percentTwenties = /%20/g;
  var Format = {
    RFC1738: "RFC1738",
    RFC3986: "RFC3986"
  };
  formats = {
    "default": Format.RFC3986,
    formatters: {
      RFC1738: function(value) {
        return replace.call(value, percentTwenties, "+");
      },
      RFC3986: function(value) {
        return String(value);
      }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
  };
  return formats;
}
var utils$2;
var hasRequiredUtils$2;
function requireUtils$2() {
  if (hasRequiredUtils$2) return utils$2;
  hasRequiredUtils$2 = 1;
  var formats2 = /* @__PURE__ */ requireFormats();
  var getSideChannel = requireSideChannel();
  var has = Object.prototype.hasOwnProperty;
  var isArray2 = Array.isArray;
  var overflowChannel = getSideChannel();
  var markOverflow = function markOverflow2(obj, maxIndex) {
    overflowChannel.set(obj, maxIndex);
    return obj;
  };
  var isOverflow = function isOverflow2(obj) {
    return overflowChannel.has(obj);
  };
  var getMaxIndex = function getMaxIndex2(obj) {
    return overflowChannel.get(obj);
  };
  var setMaxIndex = function setMaxIndex2(obj, maxIndex) {
    overflowChannel.set(obj, maxIndex);
  };
  var hexTable = (function() {
    var array = [];
    for (var i = 0; i < 256; ++i) {
      array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
    }
    return array;
  })();
  var compactQueue = function compactQueue2(queue) {
    while (queue.length > 1) {
      var item = queue.pop();
      var obj = item.obj[item.prop];
      if (isArray2(obj)) {
        var compacted = [];
        for (var j = 0; j < obj.length; ++j) {
          if (typeof obj[j] !== "undefined") {
            compacted.push(obj[j]);
          }
        }
        item.obj[item.prop] = compacted;
      }
    }
  };
  var arrayToObject = function arrayToObject2(source, options) {
    var obj = options && options.plainObjects ? { __proto__: null } : {};
    for (var i = 0; i < source.length; ++i) {
      if (typeof source[i] !== "undefined") {
        obj[i] = source[i];
      }
    }
    return obj;
  };
  var merge2 = function merge3(target, source, options) {
    if (!source) {
      return target;
    }
    if (typeof source !== "object" && typeof source !== "function") {
      if (isArray2(target)) {
        target.push(source);
      } else if (target && typeof target === "object") {
        if (isOverflow(target)) {
          var newIndex = getMaxIndex(target) + 1;
          target[newIndex] = source;
          setMaxIndex(target, newIndex);
        } else if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
          target[source] = true;
        }
      } else {
        return [target, source];
      }
      return target;
    }
    if (!target || typeof target !== "object") {
      if (isOverflow(source)) {
        var sourceKeys = Object.keys(source);
        var result2 = options && options.plainObjects ? { __proto__: null, 0: target } : { 0: target };
        for (var m = 0; m < sourceKeys.length; m++) {
          var oldKey = parseInt(sourceKeys[m], 10);
          result2[oldKey + 1] = source[sourceKeys[m]];
        }
        return markOverflow(result2, getMaxIndex(source) + 1);
      }
      return [target].concat(source);
    }
    var mergeTarget = target;
    if (isArray2(target) && !isArray2(source)) {
      mergeTarget = arrayToObject(target, options);
    }
    if (isArray2(target) && isArray2(source)) {
      source.forEach(function(item, i) {
        if (has.call(target, i)) {
          var targetItem = target[i];
          if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
            target[i] = merge3(targetItem, item, options);
          } else {
            target.push(item);
          }
        } else {
          target[i] = item;
        }
      });
      return target;
    }
    return Object.keys(source).reduce(function(acc, key) {
      var value = source[key];
      if (has.call(acc, key)) {
        acc[key] = merge3(acc[key], value, options);
      } else {
        acc[key] = value;
      }
      return acc;
    }, mergeTarget);
  };
  var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function(acc, key) {
      acc[key] = source[key];
      return acc;
    }, target);
  };
  var decode2 = function(str, defaultDecoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, " ");
    if (charset === "iso-8859-1") {
      return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    try {
      return decodeURIComponent(strWithoutPlus);
    } catch (e2) {
      return strWithoutPlus;
    }
  };
  var limit = 1024;
  var encode2 = function encode3(str, defaultEncoder, charset, kind, format2) {
    if (str.length === 0) {
      return str;
    }
    var string = str;
    if (typeof str === "symbol") {
      string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== "string") {
      string = String(str);
    }
    if (charset === "iso-8859-1") {
      return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
        return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
      });
    }
    var out = "";
    for (var j = 0; j < string.length; j += limit) {
      var segment = string.length >= limit ? string.slice(j, j + limit) : string;
      var arr = [];
      for (var i = 0; i < segment.length; ++i) {
        var c2 = segment.charCodeAt(i);
        if (c2 === 45 || c2 === 46 || c2 === 95 || c2 === 126 || c2 >= 48 && c2 <= 57 || c2 >= 65 && c2 <= 90 || c2 >= 97 && c2 <= 122 || format2 === formats2.RFC1738 && (c2 === 40 || c2 === 41)) {
          arr[arr.length] = segment.charAt(i);
          continue;
        }
        if (c2 < 128) {
          arr[arr.length] = hexTable[c2];
          continue;
        }
        if (c2 < 2048) {
          arr[arr.length] = hexTable[192 | c2 >> 6] + hexTable[128 | c2 & 63];
          continue;
        }
        if (c2 < 55296 || c2 >= 57344) {
          arr[arr.length] = hexTable[224 | c2 >> 12] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
          continue;
        }
        i += 1;
        c2 = 65536 + ((c2 & 1023) << 10 | segment.charCodeAt(i) & 1023);
        arr[arr.length] = hexTable[240 | c2 >> 18] + hexTable[128 | c2 >> 12 & 63] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
      }
      out += arr.join("");
    }
    return out;
  };
  var compact = function compact2(value) {
    var queue = [{ obj: { o: value }, prop: "o" }];
    var refs = [];
    for (var i = 0; i < queue.length; ++i) {
      var item = queue[i];
      var obj = item.obj[item.prop];
      var keys = Object.keys(obj);
      for (var j = 0; j < keys.length; ++j) {
        var key = keys[j];
        var val = obj[key];
        if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
          queue.push({ obj, prop: key });
          refs.push(val);
        }
      }
    }
    compactQueue(queue);
    return value;
  };
  var isRegExp2 = function isRegExp3(obj) {
    return Object.prototype.toString.call(obj) === "[object RegExp]";
  };
  var isBuffer2 = function isBuffer3(obj) {
    if (!obj || typeof obj !== "object") {
      return false;
    }
    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
  };
  var combine = function combine2(a, b, arrayLimit, plainObjects) {
    if (isOverflow(a)) {
      var newIndex = getMaxIndex(a) + 1;
      a[newIndex] = b;
      setMaxIndex(a, newIndex);
      return a;
    }
    var result2 = [].concat(a, b);
    if (result2.length > arrayLimit) {
      return markOverflow(arrayToObject(result2, { plainObjects }), result2.length - 1);
    }
    return result2;
  };
  var maybeMap = function maybeMap2(val, fn2) {
    if (isArray2(val)) {
      var mapped = [];
      for (var i = 0; i < val.length; i += 1) {
        mapped.push(fn2(val[i]));
      }
      return mapped;
    }
    return fn2(val);
  };
  utils$2 = {
    arrayToObject,
    assign,
    combine,
    compact,
    decode: decode2,
    encode: encode2,
    isBuffer: isBuffer2,
    isOverflow,
    isRegExp: isRegExp2,
    maybeMap,
    merge: merge2
  };
  return utils$2;
}
var stringify_1;
var hasRequiredStringify;
function requireStringify() {
  if (hasRequiredStringify) return stringify_1;
  hasRequiredStringify = 1;
  var getSideChannel = requireSideChannel();
  var utils2 = /* @__PURE__ */ requireUtils$2();
  var formats2 = /* @__PURE__ */ requireFormats();
  var has = Object.prototype.hasOwnProperty;
  var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
      return prefix + "[]";
    },
    comma: "comma",
    indices: function indices(prefix, key) {
      return prefix + "[" + key + "]";
    },
    repeat: function repeat(prefix) {
      return prefix;
    }
  };
  var isArray2 = Array.isArray;
  var push = Array.prototype.push;
  var pushToArray = function(arr, valueOrArray) {
    push.apply(arr, isArray2(valueOrArray) ? valueOrArray : [valueOrArray]);
  };
  var toISO = Date.prototype.toISOString;
  var defaultFormat = formats2["default"];
  var defaults2 = {
    addQueryPrefix: false,
    allowDots: false,
    allowEmptyArrays: false,
    arrayFormat: "indices",
    charset: "utf-8",
    charsetSentinel: false,
    commaRoundTrip: false,
    delimiter: "&",
    encode: true,
    encodeDotInKeys: false,
    encoder: utils2.encode,
    encodeValuesOnly: false,
    filter: void 0,
    format: defaultFormat,
    formatter: formats2.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date2) {
      return toISO.call(date2);
    },
    skipNulls: false,
    strictNullHandling: false
  };
  var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
    return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
  };
  var sentinel = {};
  var stringify2 = function stringify3(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder2, filter, sort, allowDots, serializeDate, format2, formatter, encodeValuesOnly, charset, sideChannel2) {
    var obj = object;
    var tmpSc = sideChannel2;
    var step = 0;
    var findFlag = false;
    while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
      var pos = tmpSc.get(object);
      step += 1;
      if (typeof pos !== "undefined") {
        if (pos === step) {
          throw new RangeError("Cyclic object value");
        } else {
          findFlag = true;
        }
      }
      if (typeof tmpSc.get(sentinel) === "undefined") {
        step = 0;
      }
    }
    if (typeof filter === "function") {
      obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
      obj = serializeDate(obj);
    } else if (generateArrayPrefix === "comma" && isArray2(obj)) {
      obj = utils2.maybeMap(obj, function(value2) {
        if (value2 instanceof Date) {
          return serializeDate(value2);
        }
        return value2;
      });
    }
    if (obj === null) {
      if (strictNullHandling) {
        return encoder2 && !encodeValuesOnly ? encoder2(prefix, defaults2.encoder, charset, "key", format2) : prefix;
      }
      obj = "";
    }
    if (isNonNullishPrimitive(obj) || utils2.isBuffer(obj)) {
      if (encoder2) {
        var keyValue = encodeValuesOnly ? prefix : encoder2(prefix, defaults2.encoder, charset, "key", format2);
        return [formatter(keyValue) + "=" + formatter(encoder2(obj, defaults2.encoder, charset, "value", format2))];
      }
      return [formatter(prefix) + "=" + formatter(String(obj))];
    }
    var values = [];
    if (typeof obj === "undefined") {
      return values;
    }
    var objKeys;
    if (generateArrayPrefix === "comma" && isArray2(obj)) {
      if (encodeValuesOnly && encoder2) {
        obj = utils2.maybeMap(obj, encoder2);
      }
      objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
    } else if (isArray2(filter)) {
      objKeys = filter;
    } else {
      var keys = Object.keys(obj);
      objKeys = sort ? keys.sort(sort) : keys;
    }
    var encodedPrefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
    var adjustedPrefix = commaRoundTrip && isArray2(obj) && obj.length === 1 ? encodedPrefix + "[]" : encodedPrefix;
    if (allowEmptyArrays && isArray2(obj) && obj.length === 0) {
      return adjustedPrefix + "[]";
    }
    for (var j = 0; j < objKeys.length; ++j) {
      var key = objKeys[j];
      var value = typeof key === "object" && key && typeof key.value !== "undefined" ? key.value : obj[key];
      if (skipNulls && value === null) {
        continue;
      }
      var encodedKey = allowDots && encodeDotInKeys ? String(key).replace(/\./g, "%2E") : String(key);
      var keyPrefix = isArray2(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + encodedKey : "[" + encodedKey + "]");
      sideChannel2.set(object, step);
      var valueSideChannel = getSideChannel();
      valueSideChannel.set(sentinel, sideChannel2);
      pushToArray(values, stringify3(
        value,
        keyPrefix,
        generateArrayPrefix,
        commaRoundTrip,
        allowEmptyArrays,
        strictNullHandling,
        skipNulls,
        encodeDotInKeys,
        generateArrayPrefix === "comma" && encodeValuesOnly && isArray2(obj) ? null : encoder2,
        filter,
        sort,
        allowDots,
        serializeDate,
        format2,
        formatter,
        encodeValuesOnly,
        charset,
        valueSideChannel
      ));
    }
    return values;
  };
  var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
    if (!opts) {
      return defaults2;
    }
    if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
      throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    }
    if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
      throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
    }
    if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
      throw new TypeError("Encoder has to be a function.");
    }
    var charset = opts.charset || defaults2.charset;
    if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    }
    var format2 = formats2["default"];
    if (typeof opts.format !== "undefined") {
      if (!has.call(formats2.formatters, opts.format)) {
        throw new TypeError("Unknown format option provided.");
      }
      format2 = opts.format;
    }
    var formatter = formats2.formatters[format2];
    var filter = defaults2.filter;
    if (typeof opts.filter === "function" || isArray2(opts.filter)) {
      filter = opts.filter;
    }
    var arrayFormat;
    if (opts.arrayFormat in arrayPrefixGenerators) {
      arrayFormat = opts.arrayFormat;
    } else if ("indices" in opts) {
      arrayFormat = opts.indices ? "indices" : "repeat";
    } else {
      arrayFormat = defaults2.arrayFormat;
    }
    if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
      throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
    }
    var allowDots = typeof opts.allowDots === "undefined" ? opts.encodeDotInKeys === true ? true : defaults2.allowDots : !!opts.allowDots;
    return {
      addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults2.addQueryPrefix,
      allowDots,
      allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults2.allowEmptyArrays,
      arrayFormat,
      charset,
      charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults2.charsetSentinel,
      commaRoundTrip: !!opts.commaRoundTrip,
      delimiter: typeof opts.delimiter === "undefined" ? defaults2.delimiter : opts.delimiter,
      encode: typeof opts.encode === "boolean" ? opts.encode : defaults2.encode,
      encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults2.encodeDotInKeys,
      encoder: typeof opts.encoder === "function" ? opts.encoder : defaults2.encoder,
      encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults2.encodeValuesOnly,
      filter,
      format: format2,
      formatter,
      serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults2.serializeDate,
      skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults2.skipNulls,
      sort: typeof opts.sort === "function" ? opts.sort : null,
      strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults2.strictNullHandling
    };
  };
  stringify_1 = function(object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);
    var objKeys;
    var filter;
    if (typeof options.filter === "function") {
      filter = options.filter;
      obj = filter("", obj);
    } else if (isArray2(options.filter)) {
      filter = options.filter;
      objKeys = filter;
    }
    var keys = [];
    if (typeof obj !== "object" || obj === null) {
      return "";
    }
    var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
    var commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
    if (!objKeys) {
      objKeys = Object.keys(obj);
    }
    if (options.sort) {
      objKeys.sort(options.sort);
    }
    var sideChannel2 = getSideChannel();
    for (var i = 0; i < objKeys.length; ++i) {
      var key = objKeys[i];
      var value = obj[key];
      if (options.skipNulls && value === null) {
        continue;
      }
      pushToArray(keys, stringify2(
        value,
        key,
        generateArrayPrefix,
        commaRoundTrip,
        options.allowEmptyArrays,
        options.strictNullHandling,
        options.skipNulls,
        options.encodeDotInKeys,
        options.encode ? options.encoder : null,
        options.filter,
        options.sort,
        options.allowDots,
        options.serializeDate,
        options.format,
        options.formatter,
        options.encodeValuesOnly,
        options.charset,
        sideChannel2
      ));
    }
    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? "?" : "";
    if (options.charsetSentinel) {
      if (options.charset === "iso-8859-1") {
        prefix += "utf8=%26%2310003%3B&";
      } else {
        prefix += "utf8=%E2%9C%93&";
      }
    }
    return joined.length > 0 ? prefix + joined : "";
  };
  return stringify_1;
}
var parse$5;
var hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse$5;
  hasRequiredParse = 1;
  var utils2 = /* @__PURE__ */ requireUtils$2();
  var has = Object.prototype.hasOwnProperty;
  var isArray2 = Array.isArray;
  var defaults2 = {
    allowDots: false,
    allowEmptyArrays: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: "utf-8",
    charsetSentinel: false,
    comma: false,
    decodeDotInKeys: false,
    decoder: utils2.decode,
    delimiter: "&",
    depth: 5,
    duplicates: "combine",
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1e3,
    parseArrays: true,
    plainObjects: false,
    strictDepth: false,
    strictNullHandling: false,
    throwOnLimitExceeded: false
  };
  var interpretNumericEntities = function(str) {
    return str.replace(/&#(\d+);/g, function($0, numberStr) {
      return String.fromCharCode(parseInt(numberStr, 10));
    });
  };
  var parseArrayValue = function(val, options, currentArrayLength) {
    if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
      return val.split(",");
    }
    if (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) {
      throw new RangeError("Array limit exceeded. Only " + options.arrayLimit + " element" + (options.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
    }
    return val;
  };
  var isoSentinel = "utf8=%26%2310003%3B";
  var charsetSentinel = "utf8=%E2%9C%93";
  var parseValues = function parseQueryStringValues(str, options) {
    var obj = { __proto__: null };
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
    cleanStr = cleanStr.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
    var parts = cleanStr.split(
      options.delimiter,
      options.throwOnLimitExceeded ? limit + 1 : limit
    );
    if (options.throwOnLimitExceeded && parts.length > limit) {
      throw new RangeError("Parameter limit exceeded. Only " + limit + " parameter" + (limit === 1 ? "" : "s") + " allowed.");
    }
    var skipIndex = -1;
    var i;
    var charset = options.charset;
    if (options.charsetSentinel) {
      for (i = 0; i < parts.length; ++i) {
        if (parts[i].indexOf("utf8=") === 0) {
          if (parts[i] === charsetSentinel) {
            charset = "utf-8";
          } else if (parts[i] === isoSentinel) {
            charset = "iso-8859-1";
          }
          skipIndex = i;
          i = parts.length;
        }
      }
    }
    for (i = 0; i < parts.length; ++i) {
      if (i === skipIndex) {
        continue;
      }
      var part = parts[i];
      var bracketEqualsPos = part.indexOf("]=");
      var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
      var key;
      var val;
      if (pos === -1) {
        key = options.decoder(part, defaults2.decoder, charset, "key");
        val = options.strictNullHandling ? null : "";
      } else {
        key = options.decoder(part.slice(0, pos), defaults2.decoder, charset, "key");
        if (key !== null) {
          val = utils2.maybeMap(
            parseArrayValue(
              part.slice(pos + 1),
              options,
              isArray2(obj[key]) ? obj[key].length : 0
            ),
            function(encodedVal) {
              return options.decoder(encodedVal, defaults2.decoder, charset, "value");
            }
          );
        }
      }
      if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
        val = interpretNumericEntities(String(val));
      }
      if (part.indexOf("[]=") > -1) {
        val = isArray2(val) ? [val] : val;
      }
      if (key !== null) {
        var existing = has.call(obj, key);
        if (existing && options.duplicates === "combine") {
          obj[key] = utils2.combine(
            obj[key],
            val,
            options.arrayLimit,
            options.plainObjects
          );
        } else if (!existing || options.duplicates === "last") {
          obj[key] = val;
        }
      }
    }
    return obj;
  };
  var parseObject = function(chain2, val, options, valuesParsed) {
    var currentArrayLength = 0;
    if (chain2.length > 0 && chain2[chain2.length - 1] === "[]") {
      var parentKey = chain2.slice(0, -1).join("");
      currentArrayLength = Array.isArray(val) && val[parentKey] ? val[parentKey].length : 0;
    }
    var leaf = valuesParsed ? val : parseArrayValue(val, options, currentArrayLength);
    for (var i = chain2.length - 1; i >= 0; --i) {
      var obj;
      var root = chain2[i];
      if (root === "[]" && options.parseArrays) {
        if (utils2.isOverflow(leaf)) {
          obj = leaf;
        } else {
          obj = options.allowEmptyArrays && (leaf === "" || options.strictNullHandling && leaf === null) ? [] : utils2.combine(
            [],
            leaf,
            options.arrayLimit,
            options.plainObjects
          );
        }
      } else {
        obj = options.plainObjects ? { __proto__: null } : {};
        var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
        var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, ".") : cleanRoot;
        var index2 = parseInt(decodedRoot, 10);
        if (!options.parseArrays && decodedRoot === "") {
          obj = { 0: leaf };
        } else if (!isNaN(index2) && root !== decodedRoot && String(index2) === decodedRoot && index2 >= 0 && (options.parseArrays && index2 <= options.arrayLimit)) {
          obj = [];
          obj[index2] = leaf;
        } else if (decodedRoot !== "__proto__") {
          obj[decodedRoot] = leaf;
        }
      }
      leaf = obj;
    }
    return leaf;
  };
  var splitKeyIntoSegments = function splitKeyIntoSegments2(givenKey, options) {
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
    if (options.depth <= 0) {
      if (!options.plainObjects && has.call(Object.prototype, key)) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      return [key];
    }
    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;
    var segment = brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;
    var keys = [];
    if (parent) {
      if (!options.plainObjects && has.call(Object.prototype, parent)) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys.push(parent);
    }
    var i = 0;
    while ((segment = child.exec(key)) !== null && i < options.depth) {
      i += 1;
      var segmentContent = segment[1].slice(1, -1);
      if (!options.plainObjects && has.call(Object.prototype, segmentContent)) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys.push(segment[1]);
    }
    if (segment) {
      if (options.strictDepth === true) {
        throw new RangeError("Input depth exceeded depth option of " + options.depth + " and strictDepth is true");
      }
      keys.push("[" + key.slice(segment.index) + "]");
    }
    return keys;
  };
  var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
      return;
    }
    var keys = splitKeyIntoSegments(givenKey, options);
    if (!keys) {
      return;
    }
    return parseObject(keys, val, options, valuesParsed);
  };
  var normalizeParseOptions = function normalizeParseOptions2(opts) {
    if (!opts) {
      return defaults2;
    }
    if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
      throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    }
    if (typeof opts.decodeDotInKeys !== "undefined" && typeof opts.decodeDotInKeys !== "boolean") {
      throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
    }
    if (opts.decoder !== null && typeof opts.decoder !== "undefined" && typeof opts.decoder !== "function") {
      throw new TypeError("Decoder has to be a function.");
    }
    if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    }
    if (typeof opts.throwOnLimitExceeded !== "undefined" && typeof opts.throwOnLimitExceeded !== "boolean") {
      throw new TypeError("`throwOnLimitExceeded` option must be a boolean");
    }
    var charset = typeof opts.charset === "undefined" ? defaults2.charset : opts.charset;
    var duplicates = typeof opts.duplicates === "undefined" ? defaults2.duplicates : opts.duplicates;
    if (duplicates !== "combine" && duplicates !== "first" && duplicates !== "last") {
      throw new TypeError("The duplicates option must be either combine, first, or last");
    }
    var allowDots = typeof opts.allowDots === "undefined" ? opts.decodeDotInKeys === true ? true : defaults2.allowDots : !!opts.allowDots;
    return {
      allowDots,
      allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults2.allowEmptyArrays,
      allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults2.allowPrototypes,
      allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults2.allowSparse,
      arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults2.arrayLimit,
      charset,
      charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults2.charsetSentinel,
      comma: typeof opts.comma === "boolean" ? opts.comma : defaults2.comma,
      decodeDotInKeys: typeof opts.decodeDotInKeys === "boolean" ? opts.decodeDotInKeys : defaults2.decodeDotInKeys,
      decoder: typeof opts.decoder === "function" ? opts.decoder : defaults2.decoder,
      delimiter: typeof opts.delimiter === "string" || utils2.isRegExp(opts.delimiter) ? opts.delimiter : defaults2.delimiter,
      // eslint-disable-next-line no-implicit-coercion, no-extra-parens
      depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults2.depth,
      duplicates,
      ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
      interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults2.interpretNumericEntities,
      parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults2.parameterLimit,
      parseArrays: opts.parseArrays !== false,
      plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults2.plainObjects,
      strictDepth: typeof opts.strictDepth === "boolean" ? !!opts.strictDepth : defaults2.strictDepth,
      strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults2.strictNullHandling,
      throwOnLimitExceeded: typeof opts.throwOnLimitExceeded === "boolean" ? opts.throwOnLimitExceeded : false
    };
  };
  parse$5 = function(str, opts) {
    var options = normalizeParseOptions(opts);
    if (str === "" || str === null || typeof str === "undefined") {
      return options.plainObjects ? { __proto__: null } : {};
    }
    var tempObj = typeof str === "string" ? parseValues(str, options) : str;
    var obj = options.plainObjects ? { __proto__: null } : {};
    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];
      var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
      obj = utils2.merge(obj, newObj, options);
    }
    if (options.allowSparse === true) {
      return obj;
    }
    return utils2.compact(obj);
  };
  return parse$5;
}
var lib$2;
var hasRequiredLib$2;
function requireLib$2() {
  if (hasRequiredLib$2) return lib$2;
  hasRequiredLib$2 = 1;
  var stringify2 = /* @__PURE__ */ requireStringify();
  var parse2 = /* @__PURE__ */ requireParse();
  var formats2 = /* @__PURE__ */ requireFormats();
  lib$2 = {
    formats: formats2,
    parse: parse2,
    stringify: stringify2
  };
  return lib$2;
}
var libExports$1 = /* @__PURE__ */ requireLib$2();
const qs = /* @__PURE__ */ getDefaultExportFromCjs(libExports$1);
class DoubleIndexedKV {
  constructor() {
    this.keyToValue = /* @__PURE__ */ new Map();
    this.valueToKey = /* @__PURE__ */ new Map();
  }
  set(key, value) {
    this.keyToValue.set(key, value);
    this.valueToKey.set(value, key);
  }
  getByKey(key) {
    return this.keyToValue.get(key);
  }
  getByValue(value) {
    return this.valueToKey.get(value);
  }
  clear() {
    this.keyToValue.clear();
    this.valueToKey.clear();
  }
}
class Registry {
  constructor(generateIdentifier) {
    this.generateIdentifier = generateIdentifier;
    this.kv = new DoubleIndexedKV();
  }
  register(value, identifier) {
    if (this.kv.getByValue(value)) {
      return;
    }
    if (!identifier) {
      identifier = this.generateIdentifier(value);
    }
    this.kv.set(identifier, value);
  }
  clear() {
    this.kv.clear();
  }
  getIdentifier(value) {
    return this.kv.getByValue(value);
  }
  getValue(identifier) {
    return this.kv.getByKey(identifier);
  }
}
class ClassRegistry extends Registry {
  constructor() {
    super((c2) => c2.name);
    this.classToAllowedProps = /* @__PURE__ */ new Map();
  }
  register(value, options) {
    if (typeof options === "object") {
      if (options.allowProps) {
        this.classToAllowedProps.set(value, options.allowProps);
      }
      super.register(value, options.identifier);
    } else {
      super.register(value, options);
    }
  }
  getAllowedProps(value) {
    return this.classToAllowedProps.get(value);
  }
}
function valuesOfObj(record) {
  if ("values" in Object) {
    return Object.values(record);
  }
  const values = [];
  for (const key in record) {
    if (record.hasOwnProperty(key)) {
      values.push(record[key]);
    }
  }
  return values;
}
function find(record, predicate) {
  const values = valuesOfObj(record);
  if ("find" in values) {
    return values.find(predicate);
  }
  const valuesNotNever = values;
  for (let i = 0; i < valuesNotNever.length; i++) {
    const value = valuesNotNever[i];
    if (predicate(value)) {
      return value;
    }
  }
  return void 0;
}
function forEach(record, run) {
  Object.entries(record).forEach(([key, value]) => run(value, key));
}
function includes(arr, value) {
  return arr.indexOf(value) !== -1;
}
function findArr(record, predicate) {
  for (let i = 0; i < record.length; i++) {
    const value = record[i];
    if (predicate(value)) {
      return value;
    }
  }
  return void 0;
}
class CustomTransformerRegistry {
  constructor() {
    this.transfomers = {};
  }
  register(transformer) {
    this.transfomers[transformer.name] = transformer;
  }
  findApplicable(v) {
    return find(this.transfomers, (transformer) => transformer.isApplicable(v));
  }
  findByName(name2) {
    return this.transfomers[name2];
  }
}
const getType$1 = (payload) => Object.prototype.toString.call(payload).slice(8, -1);
const isUndefined$2 = (payload) => typeof payload === "undefined";
const isNull$1 = (payload) => payload === null;
const isPlainObject$3 = (payload) => {
  if (typeof payload !== "object" || payload === null)
    return false;
  if (payload === Object.prototype)
    return false;
  if (Object.getPrototypeOf(payload) === null)
    return true;
  return Object.getPrototypeOf(payload) === Object.prototype;
};
const isEmptyObject = (payload) => isPlainObject$3(payload) && Object.keys(payload).length === 0;
const isArray$1 = (payload) => Array.isArray(payload);
const isString$2 = (payload) => typeof payload === "string";
const isNumber$4 = (payload) => typeof payload === "number" && !isNaN(payload);
const isBoolean$1 = (payload) => typeof payload === "boolean";
const isRegExp = (payload) => payload instanceof RegExp;
const isMap = (payload) => payload instanceof Map;
const isSet = (payload) => payload instanceof Set;
const isSymbol = (payload) => getType$1(payload) === "Symbol";
const isDate$2 = (payload) => payload instanceof Date && !isNaN(payload.valueOf());
const isError = (payload) => payload instanceof Error;
const isNaNValue = (payload) => typeof payload === "number" && isNaN(payload);
const isPrimitive = (payload) => isBoolean$1(payload) || isNull$1(payload) || isUndefined$2(payload) || isNumber$4(payload) || isString$2(payload) || isSymbol(payload);
const isBigint = (payload) => typeof payload === "bigint";
const isInfinite = (payload) => payload === Infinity || payload === -Infinity;
const isTypedArray = (payload) => ArrayBuffer.isView(payload) && !(payload instanceof DataView);
const isURL = (payload) => payload instanceof URL;
const escapeKey = (key) => key.replace(/\\/g, "\\\\").replace(/\./g, "\\.");
const stringifyPath = (path) => path.map(String).map(escapeKey).join(".");
const parsePath = (string, legacyPaths) => {
  const result2 = [];
  let segment = "";
  for (let i = 0; i < string.length; i++) {
    let char2 = string.charAt(i);
    if (!legacyPaths && char2 === "\\") {
      const escaped = string.charAt(i + 1);
      if (escaped === "\\") {
        segment += "\\";
        i++;
        continue;
      } else if (escaped !== ".") {
        throw Error("invalid path");
      }
    }
    const isEscapedDot = char2 === "\\" && string.charAt(i + 1) === ".";
    if (isEscapedDot) {
      segment += ".";
      i++;
      continue;
    }
    const isEndOfSegment = char2 === ".";
    if (isEndOfSegment) {
      result2.push(segment);
      segment = "";
      continue;
    }
    segment += char2;
  }
  const lastSegment = segment;
  result2.push(lastSegment);
  return result2;
};
function simpleTransformation(isApplicable, annotation, transform2, untransform) {
  return {
    isApplicable,
    annotation,
    transform: transform2,
    untransform
  };
}
const simpleRules = [
  simpleTransformation(isUndefined$2, "undefined", () => null, () => void 0),
  simpleTransformation(isBigint, "bigint", (v) => v.toString(), (v) => {
    if (typeof BigInt !== "undefined") {
      return BigInt(v);
    }
    console.error("Please add a BigInt polyfill.");
    return v;
  }),
  simpleTransformation(isDate$2, "Date", (v) => v.toISOString(), (v) => new Date(v)),
  simpleTransformation(isError, "Error", (v, superJson) => {
    const baseError = {
      name: v.name,
      message: v.message
    };
    if ("cause" in v) {
      baseError.cause = v.cause;
    }
    superJson.allowedErrorProps.forEach((prop) => {
      baseError[prop] = v[prop];
    });
    return baseError;
  }, (v, superJson) => {
    const e2 = new Error(v.message, { cause: v.cause });
    e2.name = v.name;
    e2.stack = v.stack;
    superJson.allowedErrorProps.forEach((prop) => {
      e2[prop] = v[prop];
    });
    return e2;
  }),
  simpleTransformation(isRegExp, "regexp", (v) => "" + v, (regex) => {
    const body = regex.slice(1, regex.lastIndexOf("/"));
    const flags = regex.slice(regex.lastIndexOf("/") + 1);
    return new RegExp(body, flags);
  }),
  simpleTransformation(
    isSet,
    "set",
    // (sets only exist in es6+)
    // eslint-disable-next-line es5/no-es6-methods
    (v) => [...v.values()],
    (v) => new Set(v)
  ),
  simpleTransformation(isMap, "map", (v) => [...v.entries()], (v) => new Map(v)),
  simpleTransformation((v) => isNaNValue(v) || isInfinite(v), "number", (v) => {
    if (isNaNValue(v)) {
      return "NaN";
    }
    if (v > 0) {
      return "Infinity";
    } else {
      return "-Infinity";
    }
  }, Number),
  simpleTransformation((v) => v === 0 && 1 / v === -Infinity, "number", () => {
    return "-0";
  }, Number),
  simpleTransformation(isURL, "URL", (v) => v.toString(), (v) => new URL(v))
];
function compositeTransformation(isApplicable, annotation, transform2, untransform) {
  return {
    isApplicable,
    annotation,
    transform: transform2,
    untransform
  };
}
const symbolRule = compositeTransformation((s2, superJson) => {
  if (isSymbol(s2)) {
    const isRegistered = !!superJson.symbolRegistry.getIdentifier(s2);
    return isRegistered;
  }
  return false;
}, (s2, superJson) => {
  const identifier = superJson.symbolRegistry.getIdentifier(s2);
  return ["symbol", identifier];
}, (v) => v.description, (_, a, superJson) => {
  const value = superJson.symbolRegistry.getValue(a[1]);
  if (!value) {
    throw new Error("Trying to deserialize unknown symbol");
  }
  return value;
});
const constructorToName = [
  Int8Array,
  Uint8Array,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
  Uint8ClampedArray
].reduce((obj, ctor) => {
  obj[ctor.name] = ctor;
  return obj;
}, {});
const typedArrayRule = compositeTransformation(isTypedArray, (v) => ["typed-array", v.constructor.name], (v) => [...v], (v, a) => {
  const ctor = constructorToName[a[1]];
  if (!ctor) {
    throw new Error("Trying to deserialize unknown typed array");
  }
  return new ctor(v);
});
function isInstanceOfRegisteredClass(potentialClass, superJson) {
  if (potentialClass?.constructor) {
    const isRegistered = !!superJson.classRegistry.getIdentifier(potentialClass.constructor);
    return isRegistered;
  }
  return false;
}
const classRule = compositeTransformation(isInstanceOfRegisteredClass, (clazz, superJson) => {
  const identifier = superJson.classRegistry.getIdentifier(clazz.constructor);
  return ["class", identifier];
}, (clazz, superJson) => {
  const allowedProps = superJson.classRegistry.getAllowedProps(clazz.constructor);
  if (!allowedProps) {
    return { ...clazz };
  }
  const result2 = {};
  allowedProps.forEach((prop) => {
    result2[prop] = clazz[prop];
  });
  return result2;
}, (v, a, superJson) => {
  const clazz = superJson.classRegistry.getValue(a[1]);
  if (!clazz) {
    throw new Error(`Trying to deserialize unknown class '${a[1]}' - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564`);
  }
  return Object.assign(Object.create(clazz.prototype), v);
});
const customRule = compositeTransformation((value, superJson) => {
  return !!superJson.customTransformerRegistry.findApplicable(value);
}, (value, superJson) => {
  const transformer = superJson.customTransformerRegistry.findApplicable(value);
  return ["custom", transformer.name];
}, (value, superJson) => {
  const transformer = superJson.customTransformerRegistry.findApplicable(value);
  return transformer.serialize(value);
}, (v, a, superJson) => {
  const transformer = superJson.customTransformerRegistry.findByName(a[1]);
  if (!transformer) {
    throw new Error("Trying to deserialize unknown custom value");
  }
  return transformer.deserialize(v);
});
const compositeRules = [classRule, symbolRule, customRule, typedArrayRule];
const transformValue = (value, superJson) => {
  const applicableCompositeRule = findArr(compositeRules, (rule) => rule.isApplicable(value, superJson));
  if (applicableCompositeRule) {
    return {
      value: applicableCompositeRule.transform(value, superJson),
      type: applicableCompositeRule.annotation(value, superJson)
    };
  }
  const applicableSimpleRule = findArr(simpleRules, (rule) => rule.isApplicable(value, superJson));
  if (applicableSimpleRule) {
    return {
      value: applicableSimpleRule.transform(value, superJson),
      type: applicableSimpleRule.annotation
    };
  }
  return void 0;
};
const simpleRulesByAnnotation = {};
simpleRules.forEach((rule) => {
  simpleRulesByAnnotation[rule.annotation] = rule;
});
const untransformValue = (json2, type2, superJson) => {
  if (isArray$1(type2)) {
    switch (type2[0]) {
      case "symbol":
        return symbolRule.untransform(json2, type2, superJson);
      case "class":
        return classRule.untransform(json2, type2, superJson);
      case "custom":
        return customRule.untransform(json2, type2, superJson);
      case "typed-array":
        return typedArrayRule.untransform(json2, type2, superJson);
      default:
        throw new Error("Unknown transformation: " + type2);
    }
  } else {
    const transformation = simpleRulesByAnnotation[type2];
    if (!transformation) {
      throw new Error("Unknown transformation: " + type2);
    }
    return transformation.untransform(json2, superJson);
  }
};
const getNthKey = (value, n2) => {
  if (n2 > value.size)
    throw new Error("index out of bounds");
  const keys = value.keys();
  while (n2 > 0) {
    keys.next();
    n2--;
  }
  return keys.next().value;
};
function validatePath(path) {
  if (includes(path, "__proto__")) {
    throw new Error("__proto__ is not allowed as a property");
  }
  if (includes(path, "prototype")) {
    throw new Error("prototype is not allowed as a property");
  }
  if (includes(path, "constructor")) {
    throw new Error("constructor is not allowed as a property");
  }
}
const getDeep = (object, path) => {
  validatePath(path);
  for (let i = 0; i < path.length; i++) {
    const key = path[i];
    if (isSet(object)) {
      object = getNthKey(object, +key);
    } else if (isMap(object)) {
      const row = +key;
      const type2 = +path[++i] === 0 ? "key" : "value";
      const keyOfRow = getNthKey(object, row);
      switch (type2) {
        case "key":
          object = keyOfRow;
          break;
        case "value":
          object = object.get(keyOfRow);
          break;
      }
    } else {
      object = object[key];
    }
  }
  return object;
};
const setDeep = (object, path, mapper) => {
  validatePath(path);
  if (path.length === 0) {
    return mapper(object);
  }
  let parent = object;
  for (let i = 0; i < path.length - 1; i++) {
    const key = path[i];
    if (isArray$1(parent)) {
      const index2 = +key;
      parent = parent[index2];
    } else if (isPlainObject$3(parent)) {
      parent = parent[key];
    } else if (isSet(parent)) {
      const row = +key;
      parent = getNthKey(parent, row);
    } else if (isMap(parent)) {
      const isEnd = i === path.length - 2;
      if (isEnd) {
        break;
      }
      const row = +key;
      const type2 = +path[++i] === 0 ? "key" : "value";
      const keyOfRow = getNthKey(parent, row);
      switch (type2) {
        case "key":
          parent = keyOfRow;
          break;
        case "value":
          parent = parent.get(keyOfRow);
          break;
      }
    }
  }
  const lastKey = path[path.length - 1];
  if (isArray$1(parent)) {
    parent[+lastKey] = mapper(parent[+lastKey]);
  } else if (isPlainObject$3(parent)) {
    parent[lastKey] = mapper(parent[lastKey]);
  }
  if (isSet(parent)) {
    const oldValue = getNthKey(parent, +lastKey);
    const newValue = mapper(oldValue);
    if (oldValue !== newValue) {
      parent.delete(oldValue);
      parent.add(newValue);
    }
  }
  if (isMap(parent)) {
    const row = +path[path.length - 2];
    const keyToRow = getNthKey(parent, row);
    const type2 = +lastKey === 0 ? "key" : "value";
    switch (type2) {
      case "key": {
        const newKey = mapper(keyToRow);
        parent.set(newKey, parent.get(keyToRow));
        if (newKey !== keyToRow) {
          parent.delete(keyToRow);
        }
        break;
      }
      case "value": {
        parent.set(keyToRow, mapper(parent.get(keyToRow)));
        break;
      }
    }
  }
  return object;
};
const enableLegacyPaths = (version2) => version2 < 1;
function traverse(tree, walker2, version2, origin = []) {
  if (!tree) {
    return;
  }
  const legacyPaths = enableLegacyPaths(version2);
  if (!isArray$1(tree)) {
    forEach(tree, (subtree, key) => traverse(subtree, walker2, version2, [
      ...origin,
      ...parsePath(key, legacyPaths)
    ]));
    return;
  }
  const [nodeValue, children] = tree;
  if (children) {
    forEach(children, (child, key) => {
      traverse(child, walker2, version2, [
        ...origin,
        ...parsePath(key, legacyPaths)
      ]);
    });
  }
  walker2(nodeValue, origin);
}
function applyValueAnnotations(plain, annotations, version2, superJson) {
  traverse(annotations, (type2, path) => {
    plain = setDeep(plain, path, (v) => untransformValue(v, type2, superJson));
  }, version2);
  return plain;
}
function applyReferentialEqualityAnnotations(plain, annotations, version2) {
  const legacyPaths = enableLegacyPaths(version2);
  function apply(identicalPaths, path) {
    const object = getDeep(plain, parsePath(path, legacyPaths));
    identicalPaths.map((path2) => parsePath(path2, legacyPaths)).forEach((identicalObjectPath) => {
      plain = setDeep(plain, identicalObjectPath, () => object);
    });
  }
  if (isArray$1(annotations)) {
    const [root, other] = annotations;
    root.forEach((identicalPath) => {
      plain = setDeep(plain, parsePath(identicalPath, legacyPaths), () => plain);
    });
    if (other) {
      forEach(other, apply);
    }
  } else {
    forEach(annotations, apply);
  }
  return plain;
}
const isDeep = (object, superJson) => isPlainObject$3(object) || isArray$1(object) || isMap(object) || isSet(object) || isError(object) || isInstanceOfRegisteredClass(object, superJson);
function addIdentity(object, path, identities) {
  const existingSet = identities.get(object);
  if (existingSet) {
    existingSet.push(path);
  } else {
    identities.set(object, [path]);
  }
}
function generateReferentialEqualityAnnotations(identitites, dedupe) {
  const result2 = {};
  let rootEqualityPaths = void 0;
  identitites.forEach((paths2) => {
    if (paths2.length <= 1) {
      return;
    }
    if (!dedupe) {
      paths2 = paths2.map((path) => path.map(String)).sort((a, b) => a.length - b.length);
    }
    const [representativePath, ...identicalPaths] = paths2;
    if (representativePath.length === 0) {
      rootEqualityPaths = identicalPaths.map(stringifyPath);
    } else {
      result2[stringifyPath(representativePath)] = identicalPaths.map(stringifyPath);
    }
  });
  if (rootEqualityPaths) {
    if (isEmptyObject(result2)) {
      return [rootEqualityPaths];
    } else {
      return [rootEqualityPaths, result2];
    }
  } else {
    return isEmptyObject(result2) ? void 0 : result2;
  }
}
const walker = (object, identities, superJson, dedupe, path = [], objectsInThisPath = [], seenObjects = /* @__PURE__ */ new Map()) => {
  const primitive = isPrimitive(object);
  if (!primitive) {
    addIdentity(object, path, identities);
    const seen = seenObjects.get(object);
    if (seen) {
      return dedupe ? {
        transformedValue: null
      } : seen;
    }
  }
  if (!isDeep(object, superJson)) {
    const transformed2 = transformValue(object, superJson);
    const result3 = transformed2 ? {
      transformedValue: transformed2.value,
      annotations: [transformed2.type]
    } : {
      transformedValue: object
    };
    if (!primitive) {
      seenObjects.set(object, result3);
    }
    return result3;
  }
  if (includes(objectsInThisPath, object)) {
    return {
      transformedValue: null
    };
  }
  const transformationResult = transformValue(object, superJson);
  const transformed = transformationResult?.value ?? object;
  const transformedValue = isArray$1(transformed) ? [] : {};
  const innerAnnotations = {};
  forEach(transformed, (value, index2) => {
    if (index2 === "__proto__" || index2 === "constructor" || index2 === "prototype") {
      throw new Error(`Detected property ${index2}. This is a prototype pollution risk, please remove it from your object.`);
    }
    const recursiveResult = walker(value, identities, superJson, dedupe, [...path, index2], [...objectsInThisPath, object], seenObjects);
    transformedValue[index2] = recursiveResult.transformedValue;
    if (isArray$1(recursiveResult.annotations)) {
      innerAnnotations[escapeKey(index2)] = recursiveResult.annotations;
    } else if (isPlainObject$3(recursiveResult.annotations)) {
      forEach(recursiveResult.annotations, (tree, key) => {
        innerAnnotations[escapeKey(index2) + "." + key] = tree;
      });
    }
  });
  const result2 = isEmptyObject(innerAnnotations) ? {
    transformedValue,
    annotations: !!transformationResult ? [transformationResult.type] : void 0
  } : {
    transformedValue,
    annotations: !!transformationResult ? [transformationResult.type, innerAnnotations] : innerAnnotations
  };
  if (!primitive) {
    seenObjects.set(object, result2);
  }
  return result2;
};
function getType(payload) {
  return Object.prototype.toString.call(payload).slice(8, -1);
}
function isArray(payload) {
  return getType(payload) === "Array";
}
function isPlainObject$2(payload) {
  if (getType(payload) !== "Object")
    return false;
  const prototype = Object.getPrototypeOf(payload);
  return !!prototype && prototype.constructor === Object && prototype === Object.prototype;
}
function assignProp(carry, key, newVal, originalObject, includeNonenumerable) {
  const propType = {}.propertyIsEnumerable.call(originalObject, key) ? "enumerable" : "nonenumerable";
  if (propType === "enumerable")
    carry[key] = newVal;
  if (includeNonenumerable && propType === "nonenumerable") {
    Object.defineProperty(carry, key, {
      value: newVal,
      enumerable: false,
      writable: true,
      configurable: true
    });
  }
}
function copy(target, options = {}) {
  if (isArray(target)) {
    return target.map((item) => copy(item, options));
  }
  if (!isPlainObject$2(target)) {
    return target;
  }
  const props = Object.getOwnPropertyNames(target);
  const symbols2 = Object.getOwnPropertySymbols(target);
  return [...props, ...symbols2].reduce((carry, key) => {
    if (key === "__proto__")
      return carry;
    if (isArray(options.props) && !options.props.includes(key)) {
      return carry;
    }
    const val = target[key];
    const newVal = copy(val, options);
    assignProp(carry, key, newVal, target, options.nonenumerable);
    return carry;
  }, {});
}
class SuperJSON {
  /**
   * @param dedupeReferentialEqualities  If true, SuperJSON will make sure only one instance of referentially equal objects are serialized and the rest are replaced with `null`.
   */
  constructor({ dedupe = false } = {}) {
    this.classRegistry = new ClassRegistry();
    this.symbolRegistry = new Registry((s2) => s2.description ?? "");
    this.customTransformerRegistry = new CustomTransformerRegistry();
    this.allowedErrorProps = [];
    this.dedupe = dedupe;
  }
  serialize(object) {
    const identities = /* @__PURE__ */ new Map();
    const output = walker(object, identities, this, this.dedupe);
    const res2 = {
      json: output.transformedValue
    };
    if (output.annotations) {
      res2.meta = {
        ...res2.meta,
        values: output.annotations
      };
    }
    const equalityAnnotations = generateReferentialEqualityAnnotations(identities, this.dedupe);
    if (equalityAnnotations) {
      res2.meta = {
        ...res2.meta,
        referentialEqualities: equalityAnnotations
      };
    }
    if (res2.meta)
      res2.meta.v = 1;
    return res2;
  }
  deserialize(payload, options) {
    const { json: json2, meta: meta2 } = payload;
    let result2 = options?.inPlace ? json2 : copy(json2);
    if (meta2?.values) {
      result2 = applyValueAnnotations(result2, meta2.values, meta2.v ?? 0, this);
    }
    if (meta2?.referentialEqualities) {
      result2 = applyReferentialEqualityAnnotations(result2, meta2.referentialEqualities, meta2.v ?? 0);
    }
    return result2;
  }
  stringify(object) {
    return JSON.stringify(this.serialize(object));
  }
  parse(string) {
    return this.deserialize(JSON.parse(string), { inPlace: true });
  }
  registerClass(v, options) {
    this.classRegistry.register(v, options);
  }
  registerSymbol(v, identifier) {
    this.symbolRegistry.register(v, identifier);
  }
  registerCustom(transformer, name2) {
    this.customTransformerRegistry.register({
      name: name2,
      ...transformer
    });
  }
  allowErrorProps(...props) {
    this.allowedErrorProps.push(...props);
  }
}
SuperJSON.defaultInstance = new SuperJSON();
SuperJSON.serialize = SuperJSON.defaultInstance.serialize.bind(SuperJSON.defaultInstance);
SuperJSON.deserialize = SuperJSON.defaultInstance.deserialize.bind(SuperJSON.defaultInstance);
SuperJSON.stringify = SuperJSON.defaultInstance.stringify.bind(SuperJSON.defaultInstance);
SuperJSON.parse = SuperJSON.defaultInstance.parse.bind(SuperJSON.defaultInstance);
SuperJSON.registerClass = SuperJSON.defaultInstance.registerClass.bind(SuperJSON.defaultInstance);
SuperJSON.registerSymbol = SuperJSON.defaultInstance.registerSymbol.bind(SuperJSON.defaultInstance);
SuperJSON.registerCustom = SuperJSON.defaultInstance.registerCustom.bind(SuperJSON.defaultInstance);
SuperJSON.allowErrorProps = SuperJSON.defaultInstance.allowErrorProps.bind(SuperJSON.defaultInstance);
SuperJSON.serialize;
SuperJSON.deserialize;
SuperJSON.stringify;
SuperJSON.parse;
SuperJSON.registerClass;
SuperJSON.registerCustom;
SuperJSON.registerSymbol;
SuperJSON.allowErrorProps;
const jsonHeaders = {
  "Content-Type": "application/json"
};
const superjsonHeaders = {
  "Content-Type": "application/superjson+json"
};
const sseHeaders = {
  "Content-Type": "text/event-stream",
  "Cache-Control": "no-cache",
  Connection: "keep-alive",
  "X-Accel-Buffering": "no"
};
const supportsSuperJSON = (request) => {
  const xSuperJSON = request.headers.get("X-SuperJSON");
  const accept = request.headers.get("Accept");
  const contentType = request.headers.get("Content-Type");
  return xSuperJSON === "1" || accept?.includes("application/superjson+json") || contentType?.includes("application/superjson+json") || false;
};
const smartResponse = (data, request, status = 200) => {
  const useSuperJSON = supportsSuperJSON(request);
  const body = useSuperJSON ? SuperJSON.stringify(data) : JSON.stringify(data);
  const headers = useSuperJSON ? superjsonHeaders : jsonHeaders;
  return new Response(body, { status, headers });
};
const isDevelopment$1 = () => {
  try {
    return process?.env?.NODE_ENV === "development";
  } catch {
    return false;
  }
};
const handleError = (error2, options = {}) => {
  const { request, isDev: isDev2 = isDevelopment$1(), cms: cms2, locale } = options;
  const translator = cms2?.t;
  if (error2 instanceof ApiError) {
    const errorData2 = { error: error2.toJSON(isDev2, translator, locale) };
    if (request && supportsSuperJSON(request)) {
      return new Response(SuperJSON.stringify(errorData2), {
        status: error2.getHTTPStatus(),
        headers: superjsonHeaders
      });
    }
    return new Response(JSON.stringify(errorData2), {
      status: error2.getHTTPStatus(),
      headers: jsonHeaders
    });
  }
  if (error2 instanceof ZodError) {
    const cmsError = ApiError.fromZodError(error2);
    const errorData2 = { error: cmsError.toJSON(isDev2, translator, locale) };
    if (request && supportsSuperJSON(request)) {
      return new Response(SuperJSON.stringify(errorData2), {
        status: cmsError.getHTTPStatus(),
        headers: superjsonHeaders
      });
    }
    return new Response(JSON.stringify(errorData2), {
      status: cmsError.getHTTPStatus(),
      headers: jsonHeaders
    });
  }
  const dbError = parseDatabaseError(error2);
  if (dbError) {
    const errorData2 = { error: dbError.toJSON(isDev2, translator, locale) };
    if (request && supportsSuperJSON(request)) {
      return new Response(SuperJSON.stringify(errorData2), {
        status: dbError.getHTTPStatus(),
        headers: superjsonHeaders
      });
    }
    return new Response(JSON.stringify(errorData2), {
      status: dbError.getHTTPStatus(),
      headers: jsonHeaders
    });
  }
  const message2 = error2 instanceof Error ? error2.message : "Unknown error";
  const wrappedError = ApiError.internal(message2, error2);
  const errorData = { error: wrappedError.toJSON(isDev2, translator, locale) };
  if (request && supportsSuperJSON(request)) {
    return new Response(SuperJSON.stringify(errorData), {
      status: wrappedError.getHTTPStatus(),
      headers: superjsonHeaders
    });
  }
  return new Response(JSON.stringify(errorData), {
    status: wrappedError.getHTTPStatus(),
    headers: jsonHeaders
  });
};
const parseBoolean = (value) => value === true || value === "true" || value === 1 || value === "1";
const normalizeBasePath$1 = (basePath) => {
  const prefixed = basePath.startsWith("/") ? basePath : `/${basePath}`;
  if (prefixed.length > 1 && prefixed.endsWith("/")) {
    return prefixed.slice(0, -1);
  }
  return prefixed;
};
const getQueryParams = (url) => qs.parse(url.search.slice(1), { allowDots: true, comma: true });
const isFileLike = (value) => !!value && typeof value.name === "string" && typeof value.arrayBuffer === "function";
const resolveUploadFile = async (request, file) => {
  if (file && isFileLike(file)) {
    return file;
  }
  const formData = await request.formData();
  const formFile = formData.get("file");
  return isFileLike(formFile) ? formFile : null;
};
const parseRpcBody = async (request) => {
  const text2 = await request.text();
  if (!text2) return void 0;
  const useSuperJSON = supportsSuperJSON(request);
  try {
    return useSuperJSON ? SuperJSON.parse(text2) : JSON.parse(text2);
  } catch {
    return null;
  }
};
const resolveSession = async (cms2, request, config2) => {
  if (config2.getSession) {
    return config2.getSession(request, cms2);
  }
  if (!cms2.auth) {
    return null;
  }
  try {
    const result2 = await cms2.auth.api.getSession({
      headers: request.headers
    });
    return result2 ?? null;
  } catch {
    return null;
  }
};
const resolveLocale = async (cms2, request, config2, queryLocale) => {
  if (queryLocale) {
    return queryLocale;
  }
  if (config2.getLocale) {
    return config2.getLocale(request, cms2);
  }
  const header = request.headers.get("accept-language");
  return header?.split(",")[0]?.trim() || void 0;
};
const createAdapterContext = async (cms2, request, config2 = {}) => {
  const parsedQuery = getQueryParams(new URL(request.url));
  const queryLocale = typeof parsedQuery.locale === "string" ? parsedQuery.locale : void 0;
  const localeFallback = parsedQuery.localeFallback !== void 0 ? parseBoolean(parsedQuery.localeFallback) : void 0;
  const [sessionData, locale] = await Promise.all([
    resolveSession(cms2, request, config2),
    resolveLocale(cms2, request, config2, queryLocale)
  ]);
  const baseContext = {
    session: sessionData,
    locale,
    localeFallback,
    accessMode: config2.accessMode ?? "user"
  };
  const adapterExtension = config2.extendContext ? await config2.extendContext({ request, cms: cms2, context: baseContext }) : void 0;
  let cmsExtension;
  const contextResolver = cms2.config.contextResolver;
  if (contextResolver) {
    cmsExtension = await contextResolver({
      request,
      session: sessionData,
      db: cms2.db
    });
  }
  const cmsContext = await cms2.createContext({
    ...baseContext,
    ...adapterExtension ?? {},
    ...cmsExtension ?? {}
  });
  return {
    session: sessionData,
    locale: cmsContext.locale,
    localeFallback: cmsContext.localeFallback,
    cmsContext
  };
};
const resolveContext = async (cms2, request, config2, context) => {
  if (context?.cmsContext) {
    return context;
  }
  return createAdapterContext(cms2, request, config2);
};
const createAuthRoute = (cms2) => {
  return async (request) => {
    if (!cms2.auth) {
      return handleError(ApiError.notImplemented("Authentication"), {
        request,
        cms: cms2
      });
    }
    return cms2.auth.handler(request);
  };
};
async function executeJsonFunction(cms2, definition, input, context) {
  const parsed = definition.schema.parse(input);
  const resolvedContext = context ?? await cms2.createContext({ accessMode: "system" });
  const result2 = await definition.handler({
    input: parsed,
    app: cms2,
    session: resolvedContext.session,
    locale: resolvedContext.locale,
    db: resolvedContext.db ?? cms2.db
  });
  if (definition.outputSchema) {
    return definition.outputSchema.parse(
      result2
    );
  }
  return result2;
}
const isFunctionDefinition = (value) => {
  return typeof value === "object" && value !== null && "handler" in value && typeof value.handler === "function";
};
const extractAccessRule = (access) => {
  if (access === void 0) {
    return void 0;
  }
  if (typeof access === "object" && access !== null) {
    return access.execute;
  }
  return access;
};
const evaluateFunctionAccess = async (definition, ctx) => {
  const rule = extractAccessRule(definition.access);
  if (rule === void 0) {
    return true;
  }
  if (typeof rule === "boolean") {
    return rule;
  }
  try {
    return await rule(ctx);
  } catch {
    return false;
  }
};
const resolveRpcProcedure = (router2, path) => {
  let current = router2;
  for (const segment of path) {
    if (!current || typeof current !== "object") {
      return void 0;
    }
    current = current[segment];
  }
  return isFunctionDefinition(current) ? current : void 0;
};
const executeFunction = async (cms2, config2, definition, request, context) => {
  const errorResponse = (error2, request2, locale) => {
    return handleError(error2, { request: request2, cms: cms2, locale });
  };
  if (request.method !== "POST") {
    return errorResponse(ApiError.badRequest("Method not allowed"), request);
  }
  const resolved = await resolveContext(cms2, request, config2, context);
  const hasAccess = await evaluateFunctionAccess(definition, {
    app: cms2,
    session: resolved.cmsContext.session,
    db: resolved.cmsContext.db ?? cms2.db,
    locale: resolved.cmsContext.locale,
    request
  });
  if (!hasAccess) {
    return errorResponse(
      ApiError.forbidden({
        operation: "read",
        resource: "rpc",
        reason: "Access denied"
      }),
      request,
      resolved.cmsContext.locale
    );
  }
  if (definition.mode === "raw") {
    try {
      return await definition.handler({
        request,
        app: cms2,
        session: resolved.cmsContext.session,
        locale: resolved.cmsContext.locale,
        db: resolved.cmsContext.db ?? cms2.db
      });
    } catch (error2) {
      return errorResponse(error2, request, resolved.cmsContext.locale);
    }
  }
  const body = await parseRpcBody(request);
  if (body === null) {
    return errorResponse(
      ApiError.badRequest("Invalid JSON body"),
      request,
      resolved.cmsContext.locale
    );
  }
  try {
    const result2 = await executeJsonFunction(
      cms2,
      definition,
      body,
      resolved.cmsContext
    );
    return smartResponse(result2, request);
  } catch (error2) {
    return errorResponse(error2, request, resolved.cmsContext.locale);
  }
};
const createRpcRoutes = (cms2, config2 = {}) => {
  const errorResponse = (error2, request) => {
    return handleError(error2, { request, cms: cms2 });
  };
  return {
    root: async (request, params, context) => {
      if (!config2.rpc) {
        return errorResponse(ApiError.notFound("RPC router"), request);
      }
      const definition = resolveRpcProcedure(config2.rpc, params.path);
      if (!definition) {
        return errorResponse(
          ApiError.notFound("RPC procedure", params.path.join(".")),
          request
        );
      }
      return executeFunction(cms2, config2, definition, request, context);
    },
    collection: async (request, params, context) => {
      let collectionInstance;
      try {
        collectionInstance = cms2.getCollectionConfig(params.collection);
      } catch {
        return errorResponse(
          ApiError.notFound("Collection", params.collection),
          request
        );
      }
      const functions = collectionInstance.state?.functions || {};
      const definition = functions[params.name];
      if (!definition) {
        return errorResponse(
          ApiError.notFound(
            `Function on collection "${params.collection}"`,
            params.name
          ),
          request
        );
      }
      return executeFunction(cms2, config2, definition, request, context);
    },
    global: async (request, params, context) => {
      let globalInstance;
      try {
        globalInstance = cms2.getGlobalConfig(params.global);
      } catch {
        return errorResponse(
          ApiError.notFound("Global", params.global),
          request
        );
      }
      const functions = globalInstance.state?.functions || {};
      const definition = functions[params.name];
      if (!definition) {
        return errorResponse(
          ApiError.notFound(
            `Function on global "${params.global}"`,
            params.name
          ),
          request
        );
      }
      return executeFunction(cms2, config2, definition, request, context);
    }
  };
};
function buildFieldBasedSchema(fieldDefinitions, mode = "insert") {
  const shape = {};
  for (const [fieldName, fieldDef] of Object.entries(fieldDefinitions)) {
    if (fieldDef.state.input === false) {
      continue;
    }
    let fieldSchema = fieldDef.toZodSchema();
    if (mode === "update") {
      fieldSchema = fieldSchema.optional();
    }
    if (mode === "insert" && fieldDef.state.input === "optional") {
      fieldSchema = fieldSchema.optional();
    }
    shape[fieldName] = fieldSchema;
  }
  return z$1.object(shape);
}
function extractBelongsToMappings(_fieldDefinitions) {
  return {};
}
function buildCollectionSchemas(fieldDefinitions) {
  const insertSchema = buildFieldBasedSchema(fieldDefinitions, "insert");
  const updateSchema = buildFieldBasedSchema(fieldDefinitions, "update");
  const belongsToMappings = extractBelongsToMappings();
  return {
    // Use passthrough to allow extra keys (nested mutations, FK columns)
    insertSchema: insertSchema.passthrough(),
    updateSchema: updateSchema.passthrough(),
    belongsToMappings
  };
}
function trackDependencies(fn2) {
  const deps = /* @__PURE__ */ new Set();
  const createProxy = (prefix) => new Proxy({}, {
    get(_, prop) {
      if (typeof prop === "symbol" || prop === "then" || prop === "toJSON") {
        return void 0;
      }
      const path = prefix ? `${prefix}.${prop}` : prop;
      deps.add(path);
      return createProxy(path);
    }
  });
  const ctx = {
    data: createProxy(""),
    sibling: createProxy("$sibling"),
    prev: {
      data: createProxy("$prev"),
      sibling: createProxy("$prev.$sibling")
    },
    ctx: {}
    // Dummy, won't be used during tracking
  };
  let result2;
  try {
    result2 = fn2(ctx);
  } catch {
  }
  return { result: result2, deps: [...deps] };
}
function trackDepsFunction(depsFn) {
  const { deps } = trackDependencies((ctx) => {
    depsFn(ctx);
    return void 0;
  });
  return deps;
}
function extractDependencies(config2) {
  if (typeof config2 === "function") {
    return trackDependencies(config2).deps;
  }
  const { handler: handler2, deps } = config2;
  if (Array.isArray(deps)) {
    return deps;
  }
  if (typeof deps === "function") {
    return trackDepsFunction(deps);
  }
  return trackDependencies(handler2).deps;
}
function getDebounce(config2) {
  return typeof config2 === "function" ? void 0 : config2.debounce;
}
function isReactiveConfig(value) {
  if (typeof value === "function") {
    return true;
  }
  if (typeof value === "object" && value !== null && "handler" in value) {
    return typeof value.handler === "function";
  }
  return false;
}
async function introspectCollection(collection, context, cms2) {
  const { state } = collection;
  const fieldDefinitions = state.fieldDefinitions || {};
  const formReactiveByField = extractFormReactiveConfigs(
    state.adminForm
  );
  const access = await evaluateCollectionAccess(state, context, cms2);
  const fields2 = {};
  for (const [name2, fieldDef] of Object.entries(fieldDefinitions)) {
    const metadata = fieldDef.getMetadata();
    const fieldAccess = await evaluateFieldAccess$1(fieldDef, context, cms2);
    let validation2;
    try {
      const zodSchema = fieldDef.toZodSchema();
      validation2 = z$1.toJSONSchema(zodSchema);
    } catch {
    }
    const reactive = extractFieldReactiveConfig(
      fieldDef,
      formReactiveByField[name2]
    );
    fields2[name2] = {
      name: name2,
      metadata,
      location: fieldDef.state.location,
      access: fieldAccess,
      validation: validation2,
      ...reactive && { reactive }
    };
  }
  const relations = {};
  for (const [name2, relationConfig] of Object.entries(state.relations)) {
    relations[name2] = {
      name: name2,
      type: mapRelationType(relationConfig.type),
      targetCollection: relationConfig.collection,
      foreignKey: relationConfig.references?.[0],
      through: relationConfig.through,
      sourceField: relationConfig.sourceField,
      targetField: relationConfig.targetField,
      onDelete: relationConfig.onDelete,
      onUpdate: relationConfig.onUpdate
    };
  }
  for (const [name2, fieldDef] of Object.entries(fieldDefinitions)) {
    const metadata = fieldDef.getMetadata();
    if (metadata.type === "relation" && !relations[name2]) {
      const relMeta = metadata;
      relations[name2] = {
        name: name2,
        type: mapInferredRelationType(relMeta.relationType),
        targetCollection: relMeta.targetCollection,
        foreignKey: relMeta.foreignKey,
        through: relMeta.through,
        sourceField: relMeta.sourceField,
        targetField: relMeta.targetField,
        onDelete: relMeta.onDelete,
        onUpdate: relMeta.onUpdate
      };
    }
  }
  let validation;
  if (fieldDefinitions && Object.keys(fieldDefinitions).length > 0) {
    try {
      const { insertSchema, updateSchema } = buildCollectionSchemas(
        fieldDefinitions
      );
      validation = {
        insert: insertSchema ? z$1.toJSONSchema(insertSchema) : void 0,
        update: updateSchema ? z$1.toJSONSchema(updateSchema) : void 0
      };
    } catch {
    }
  }
  const adminConfig = extractAdminConfig$1(state);
  return {
    name: state.name,
    // Use admin config label/description/icon if available
    label: adminConfig?.config?.label,
    description: adminConfig?.config?.description,
    // Keep full ComponentReference for icon (client resolves via component registry)
    icon: adminConfig?.config?.icon,
    fields: fields2,
    access,
    options: {
      timestamps: state.options?.timestamps !== false,
      softDelete: state.options?.softDelete ?? false,
      versioning: !!state.options?.versioning,
      singleton: void 0
      // TODO(globals): Derive singleton flag from collection config
    },
    title: state.title ? {
      field: state.title
    } : void 0,
    relations,
    validation,
    admin: adminConfig
  };
}
function extractAdminConfig$1(state) {
  const stateAny = state;
  const hasAdminConfig = stateAny.admin || stateAny.adminList || stateAny.adminForm || stateAny.adminPreview;
  if (!hasAdminConfig) {
    return void 0;
  }
  const result2 = {};
  if (stateAny.admin) {
    result2.config = {
      label: stateAny.admin.label,
      description: stateAny.admin.description,
      icon: stateAny.admin.icon,
      hidden: stateAny.admin.hidden,
      group: stateAny.admin.group,
      order: stateAny.admin.order
    };
  }
  if (stateAny.adminList) {
    result2.list = {
      view: stateAny.adminList.view,
      columns: stateAny.adminList.columns,
      defaultSort: stateAny.adminList.defaultSort,
      searchable: stateAny.adminList.searchable,
      filterable: stateAny.adminList.filterable,
      actions: stateAny.adminList.actions
    };
  }
  if (stateAny.adminForm) {
    result2.form = {
      view: stateAny.adminForm.view,
      fields: stateAny.adminForm.fields,
      sections: stateAny.adminForm.sections,
      tabs: stateAny.adminForm.tabs
    };
  }
  if (stateAny.adminPreview) {
    result2.preview = {
      enabled: stateAny.adminPreview.enabled,
      position: stateAny.adminPreview.position,
      defaultWidth: stateAny.adminPreview.defaultWidth,
      // Don't include the url function - just indicate it exists
      hasUrlBuilder: typeof stateAny.adminPreview.url === "function"
    };
  }
  if (stateAny.adminActions) {
    const actionsConfig = stateAny.adminActions;
    const customActions = (actionsConfig.custom || []).map(
      (action) => {
        const { handler: handler2, ...rest } = action;
        return rest;
      }
    );
    result2.actions = {
      builtin: actionsConfig.builtin || [
        "create",
        "save",
        "delete",
        "deleteMany"
      ],
      custom: customActions
    };
  }
  return result2;
}
function mapRelationType(type2) {
  switch (type2) {
    case "one":
      return "belongsTo";
    case "many":
      return "hasMany";
    case "manyToMany":
      return "manyToMany";
  }
}
function mapInferredRelationType(type2) {
  switch (type2) {
    case "belongsTo":
      return "belongsTo";
    case "hasMany":
      return "hasMany";
    case "manyToMany":
      return "manyToMany";
    case "multiple":
      return "hasMany";
    // Multiple is similar to hasMany
    case "morphTo":
      return "morphTo";
    case "morphMany":
      return "morphMany";
  }
}
async function evaluateCollectionAccess(state, context, cms2) {
  const { access } = state;
  if (!access || Object.keys(access).length === 0) {
    return {
      visible: true,
      level: "full",
      operations: {
        create: { allowed: true },
        read: { allowed: true },
        update: { allowed: true },
        delete: { allowed: true }
      }
    };
  }
  const accessContext = {
    app: cms2,
    session: context.session,
    db: context.db,
    locale: context.locale
  };
  const operations = {
    create: await evaluateAccessRule$1(access.create, accessContext),
    read: await evaluateAccessRule$1(access.read, accessContext),
    update: await evaluateAccessRule$1(access.update, accessContext),
    delete: await evaluateAccessRule$1(access.delete, accessContext)
  };
  const hasAnyAccess = Object.values(operations).some(
    (r2) => r2.allowed !== false
  );
  const hasFilteredAccess = Object.values(operations).some(
    (r2) => r2.allowed === "filtered"
  );
  const hasFullAccess = Object.values(operations).every(
    (r2) => r2.allowed === true
  );
  return {
    visible: hasAnyAccess,
    level: hasFullAccess ? "full" : hasFilteredAccess ? "filtered" : "none",
    operations
  };
}
async function evaluateAccessRule$1(rule, context) {
  if (rule === void 0 || rule === true) {
    return { allowed: true };
  }
  if (rule === false) {
    return { allowed: false };
  }
  if (typeof rule === "function") {
    try {
      const result2 = await rule(context);
      if (typeof result2 === "boolean") {
        return result2 ? { allowed: true } : { allowed: false };
      }
      if (result2 && typeof result2 === "object") {
        return { allowed: "filtered", where: result2 };
      }
      return { allowed: false };
    } catch (error2) {
      return {
        allowed: false,
        reason: error2 instanceof Error ? error2.message : "Access denied"
      };
    }
  }
  return { allowed: true };
}
async function evaluateFieldAccess$1(fieldDef, context, cms2) {
  const fieldAccess = fieldDef.state.config?.access;
  if (!fieldAccess) {
    return void 0;
  }
  const accessContext = {
    app: cms2,
    session: context.session,
    db: context.db,
    locale: context.locale
  };
  return {
    read: await evaluateFieldAccessRule(fieldAccess.read, accessContext),
    create: await evaluateFieldAccessRule(fieldAccess.create, accessContext),
    update: await evaluateFieldAccessRule(fieldAccess.update, accessContext)
  };
}
async function evaluateFieldAccessRule(rule, context) {
  if (rule === void 0 || rule === true) {
    return { allowed: true };
  }
  if (rule === false) {
    return { allowed: false };
  }
  if (typeof rule === "function") {
    try {
      const result2 = await rule(context);
      return result2 ? { allowed: true } : { allowed: false };
    } catch (error2) {
      return {
        allowed: false,
        reason: error2 instanceof Error ? error2.message : "Access denied"
      };
    }
  }
  return { allowed: true };
}
function extractFieldReactiveConfig(fieldDef, formReactive) {
  const optionsReactive = extractFieldOptionsReactiveConfig(fieldDef);
  if (!formReactive && !optionsReactive) {
    return void 0;
  }
  return {
    ...formReactive ?? {},
    ...optionsReactive ?? {}
  };
}
function extractFormReactiveConfigs(formConfig) {
  const result2 = {};
  if (!formConfig || typeof formConfig !== "object") {
    return result2;
  }
  const form = formConfig;
  collectReactiveFromLayoutItems(form.fields, result2);
  collectReactiveFromSections(form.sections, result2);
  collectReactiveFromTabs(form.tabs, result2);
  if (form.sidebar && typeof form.sidebar === "object") {
    const sidebar2 = form.sidebar;
    collectReactiveFromLayoutItems(sidebar2.fields, result2);
  }
  return result2;
}
function collectReactiveFromLayoutItems(items, result2) {
  if (!Array.isArray(items)) {
    return;
  }
  for (const item of items) {
    if (!item || typeof item !== "object") {
      continue;
    }
    const entry = item;
    if (typeof entry.field === "string") {
      const reactive = serializeFormFieldReactiveConfig(entry);
      if (reactive) {
        const existing = result2[entry.field] ?? {};
        result2[entry.field] = { ...existing, ...reactive };
      }
      continue;
    }
    if (entry.type === "section") {
      collectReactiveFromLayoutItems(entry.fields, result2);
      continue;
    }
    if (entry.type === "tabs") {
      collectReactiveFromTabs(entry.tabs, result2);
    }
  }
}
function collectReactiveFromSections(sections2, result2) {
  if (!Array.isArray(sections2)) {
    return;
  }
  for (const section of sections2) {
    if (!section || typeof section !== "object") {
      continue;
    }
    const sectionConfig = section;
    collectReactiveFromLayoutItems(sectionConfig.fields, result2);
  }
}
function collectReactiveFromTabs(tabs, result2) {
  if (!Array.isArray(tabs)) {
    return;
  }
  for (const tab of tabs) {
    if (!tab || typeof tab !== "object") {
      continue;
    }
    const tabConfig = tab;
    collectReactiveFromLayoutItems(tabConfig.fields, result2);
    collectReactiveFromSections(tabConfig.sections, result2);
  }
}
function serializeFormFieldReactiveConfig(fieldEntry) {
  const reactiveKeys = [
    "hidden",
    "readOnly",
    "disabled",
    "compute"
  ];
  const result2 = {};
  let hasReactive = false;
  for (const key of reactiveKeys) {
    const value = fieldEntry[key];
    if (typeof value === "boolean" || value === void 0) {
      continue;
    }
    if (isReactiveConfig(value)) {
      hasReactive = true;
      result2[key] = {
        watch: extractDependencies(value),
        debounce: getDebounce(value)
      };
      continue;
    }
    if (value && typeof value === "object" && "deps" in value && Array.isArray(value.deps)) {
      hasReactive = true;
      const serializedValue = value;
      result2[key] = {
        watch: serializedValue.deps,
        debounce: typeof serializedValue.debounce === "number" ? serializedValue.debounce : void 0
      };
    }
  }
  return hasReactive ? result2 : void 0;
}
function extractFieldOptionsReactiveConfig(fieldDef) {
  const config2 = fieldDef.state.config;
  const options = config2?.options;
  if (options && typeof options === "object" && "handler" in options) {
    const optionsConfig = options;
    let watch = [];
    if (Array.isArray(optionsConfig.deps)) {
      watch = optionsConfig.deps;
    } else if (typeof optionsConfig.deps === "function") {
      const deps = /* @__PURE__ */ new Set();
      const createProxy = (prefix) => new Proxy({}, {
        get(_, prop) {
          if (typeof prop === "symbol" || prop === "then") {
            return void 0;
          }
          const path = prefix ? `${prefix}.${prop}` : prop;
          deps.add(path);
          return createProxy(path);
        }
      });
      try {
        optionsConfig.deps({
          data: createProxy(""),
          sibling: createProxy("$sibling")
        });
      } catch {
      }
      watch = [...deps];
    }
    return {
      options: {
        watch,
        searchable: true,
        paginated: true
      }
    };
  }
  return void 0;
}
function parseIntParam(value) {
  if (value === void 0 || value === null || value === "") return void 0;
  const num = Number(value);
  if (Number.isNaN(num) || !Number.isFinite(num) || num < 0) return void 0;
  return Math.floor(num);
}
const parseFindOptions = (url) => {
  const parsedQuery = getQueryParams(url);
  const options = {};
  const limit = parseIntParam(parsedQuery.limit);
  if (limit !== void 0) options.limit = limit;
  const offset2 = parseIntParam(parsedQuery.offset);
  if (offset2 !== void 0) options.offset = offset2;
  const page = parseIntParam(parsedQuery.page);
  if (page !== void 0) options.page = page;
  if (parsedQuery.where) options.where = parsedQuery.where;
  if (parsedQuery.orderBy) options.orderBy = parsedQuery.orderBy;
  if (parsedQuery.with) options.with = parsedQuery.with;
  if (parsedQuery.includeDeleted !== void 0) {
    options.includeDeleted = parseBoolean(parsedQuery.includeDeleted);
  }
  if (parsedQuery.search) options.search = parsedQuery.search;
  if (parsedQuery.locale) options.locale = parsedQuery.locale;
  if (parsedQuery.localeFallback !== void 0) {
    options.localeFallback = parseBoolean(parsedQuery.localeFallback);
  }
  return options;
};
const parseFindOneOptions = (url, id) => {
  const parsedQuery = getQueryParams(url);
  const options = { where: { id } };
  if (parsedQuery.with) options.with = parsedQuery.with;
  if (parsedQuery.includeDeleted !== void 0) {
    options.includeDeleted = parseBoolean(parsedQuery.includeDeleted);
  }
  if (parsedQuery.locale) options.locale = parsedQuery.locale;
  if (parsedQuery.localeFallback !== void 0) {
    options.localeFallback = parseBoolean(parsedQuery.localeFallback);
  }
  return options;
};
const parseGlobalGetOptions = (url) => {
  const parsedQuery = getQueryParams(url);
  const options = {};
  if (parsedQuery.with) options.with = parsedQuery.with;
  if (parsedQuery.columns) options.columns = parsedQuery.columns;
  if (parsedQuery.locale) options.locale = parsedQuery.locale;
  if (parsedQuery.localeFallback !== void 0) {
    options.localeFallback = parseBoolean(parsedQuery.localeFallback);
  }
  return options;
};
const parseGlobalUpdateOptions = (url) => {
  const parsedQuery = getQueryParams(url);
  const options = {};
  if (parsedQuery.with) options.with = parsedQuery.with;
  if (parsedQuery.locale) options.locale = parsedQuery.locale;
  if (parsedQuery.localeFallback !== void 0) {
    options.localeFallback = parseBoolean(parsedQuery.localeFallback);
  }
  return options;
};
const createCollectionRoutes = (cms2, config2 = {}) => {
  const errorResponse = (error2, request, locale) => {
    return handleError(error2, { request, cms: cms2, locale });
  };
  return {
    find: async (request, params, context) => {
      const resolved = await resolveContext(cms2, request, config2, context);
      const crud = cms2.api.collections[params.collection];
      if (!crud) {
        return errorResponse(
          ApiError.notFound("Collection", params.collection),
          request,
          resolved.cmsContext.locale
        );
      }
      try {
        const options = parseFindOptions(new URL(request.url));
        const result2 = await crud.find(options, resolved.cmsContext);
        return smartResponse(result2, request);
      } catch (error2) {
        return errorResponse(error2, request, resolved.cmsContext.locale);
      }
    },
    count: async (request, params, context) => {
      const resolved = await resolveContext(cms2, request, config2, context);
      const crud = cms2.api.collections[params.collection];
      if (!crud) {
        return errorResponse(
          ApiError.notFound("Collection", params.collection),
          request,
          resolved.cmsContext.locale
        );
      }
      try {
        const options = parseFindOptions(new URL(request.url));
        const result2 = await crud.count(
          { where: options.where, includeDeleted: options.includeDeleted },
          resolved.cmsContext
        );
        return smartResponse({ count: result2 }, request);
      } catch (error2) {
        return errorResponse(error2, request, resolved.cmsContext.locale);
      }
    },
    create: async (request, params, context, input) => {
      const resolved = await resolveContext(cms2, request, config2, context);
      const crud = cms2.api.collections[params.collection];
      if (!crud) {
        return errorResponse(
          ApiError.notFound("Collection", params.collection),
          request,
          resolved.cmsContext.locale
        );
      }
      const body = input !== void 0 ? input : await parseRpcBody(request);
      if (body === null) {
        return errorResponse(
          ApiError.badRequest("Invalid JSON body"),
          request,
          resolved.cmsContext.locale
        );
      }
      try {
        const result2 = await crud.create(body, resolved.cmsContext);
        return smartResponse(result2, request);
      } catch (error2) {
        return errorResponse(error2, request, resolved.cmsContext.locale);
      }
    },
    findOne: async (request, params, context) => {
      const resolved = await resolveContext(cms2, request, config2, context);
      const crud = cms2.api.collections[params.collection];
      if (!crud) {
        return errorResponse(
          ApiError.notFound("Collection", params.collection),
          request,
          resolved.cmsContext.locale
        );
      }
      try {
        const options = parseFindOneOptions(new URL(request.url), params.id);
        const result2 = await crud.findOne(options, resolved.cmsContext);
        if (!result2) {
          return errorResponse(
            ApiError.notFound("Record", params.id),
            request,
            resolved.cmsContext.locale
          );
        }
        return smartResponse(result2, request);
      } catch (error2) {
        return errorResponse(error2, request, resolved.cmsContext.locale);
      }
    },
    update: async (request, params, context, input) => {
      const resolved = await resolveContext(cms2, request, config2, context);
      const crud = cms2.api.collections[params.collection];
      if (!crud) {
        return errorResponse(
          ApiError.notFound("Collection", params.collection),
          request,
          resolved.cmsContext.locale
        );
      }
      const body = input !== void 0 ? input : await parseRpcBody(request);
      if (body === null) {
        return errorResponse(
          ApiError.badRequest("Invalid JSON body"),
          request,
          resolved.cmsContext.locale
        );
      }
      try {
        const result2 = await crud.updateById(
          { id: params.id, data: body },
          resolved.cmsContext
        );
        return smartResponse(result2, request);
      } catch (error2) {
        return errorResponse(error2, request, resolved.cmsContext.locale);
      }
    },
    remove: async (request, params, context) => {
      const resolved = await resolveContext(cms2, request, config2, context);
      const crud = cms2.api.collections[params.collection];
      if (!crud) {
        return errorResponse(
          ApiError.notFound("Collection", params.collection),
          request,
          resolved.cmsContext.locale
        );
      }
      try {
        await crud.deleteById({ id: params.id }, resolved.cmsContext);
        return smartResponse({ success: true }, request);
      } catch (error2) {
        return errorResponse(error2, request, resolved.cmsContext.locale);
      }
    },
    restore: async (request, params, context) => {
      const resolved = await resolveContext(cms2, request, config2, context);
      const crud = cms2.api.collections[params.collection];
      if (!crud) {
        return errorResponse(
          ApiError.notFound("Collection", params.collection),
          request,
          resolved.cmsContext.locale
        );
      }
      try {
        const result2 = await crud.restoreById(
          { id: params.id },
          resolved.cmsContext
        );
        return smartResponse(result2, request);
      } catch (error2) {
        return errorResponse(error2, request, resolved.cmsContext.locale);
      }
    },
    updateMany: async (request, params, context, input) => {
      const resolved = await resolveContext(cms2, request, config2, context);
      const crud = cms2.api.collections[params.collection];
      if (!crud) {
        return errorResponse(
          ApiError.notFound("Collection", params.collection),
          request,
          resolved.cmsContext.locale
        );
      }
      const body = input !== void 0 ? input : await parseRpcBody(request);
      if (body === null || typeof body !== "object") {
        return errorResponse(
          ApiError.badRequest("Invalid JSON body"),
          request,
          resolved.cmsContext.locale
        );
      }
      try {
        const { where, data } = body;
        const result2 = await crud.update({ where, data }, resolved.cmsContext);
        return smartResponse(result2, request);
      } catch (error2) {
        return errorResponse(error2, request, resolved.cmsContext.locale);
      }
    },
    deleteMany: async (request, params, context, input) => {
      const resolved = await resolveContext(cms2, request, config2, context);
      const crud = cms2.api.collections[params.collection];
      if (!crud) {
        return errorResponse(
          ApiError.notFound("Collection", params.collection),
          request,
          resolved.cmsContext.locale
        );
      }
      const body = input !== void 0 ? input : await parseRpcBody(request);
      if (body === null || typeof body !== "object") {
        return errorResponse(
          ApiError.badRequest("Invalid JSON body"),
          request,
          resolved.cmsContext.locale
        );
      }
      try {
        const { where } = body;
        const result2 = await crud.delete({ where }, resolved.cmsContext);
        return smartResponse(result2, request);
      } catch (error2) {
        return errorResponse(error2, request, resolved.cmsContext.locale);
      }
    },
    meta: async (request, params, context) => {
      const resolved = await resolveContext(cms2, request, config2, context);
      const collection = cms2.getCollections()[params.collection];
      if (!collection) {
        return errorResponse(
          ApiError.notFound("Collection", params.collection),
          request,
          resolved.cmsContext.locale
        );
      }
      try {
        const meta2 = collection.getMeta();
        return smartResponse(meta2, request);
      } catch (error2) {
        return errorResponse(error2, request, resolved.cmsContext.locale);
      }
    },
    schema: async (request, params, context) => {
      const resolved = await resolveContext(cms2, request, config2, context);
      const collection = cms2.getCollections()[params.collection];
      if (!collection) {
        return errorResponse(
          ApiError.notFound("Collection", params.collection),
          request,
          resolved.cmsContext.locale
        );
      }
      try {
        const schema2 = await introspectCollection(
          collection,
          {
            session: resolved.cmsContext.session,
            db: cms2.db,
            locale: resolved.cmsContext.locale
          },
          cms2
        );
        return smartResponse(schema2, request);
      } catch (error2) {
        return errorResponse(error2, request, resolved.cmsContext.locale);
      }
    }
  };
};
async function introspectGlobal(global2, context, cms2) {
  const { state } = global2;
  const fieldDefinitions = state.fieldDefinitions || {};
  const access = await evaluateGlobalAccess(state, context, cms2);
  const fields2 = {};
  for (const [name2, fieldDef] of Object.entries(fieldDefinitions)) {
    const metadata = fieldDef.getMetadata();
    const fieldAccess = await evaluateGlobalFieldAccess(fieldDef, context);
    let validation;
    try {
      const zodSchema = fieldDef.toZodSchema();
      validation = z$1.toJSONSchema(zodSchema);
    } catch {
    }
    fields2[name2] = {
      name: name2,
      metadata,
      location: fieldDef.state.location,
      access: fieldAccess,
      validation
    };
  }
  const adminConfig = extractAdminConfig(state);
  return {
    name: state.name,
    // Use admin config label/description/icon if available
    label: adminConfig?.config?.label,
    description: adminConfig?.config?.description,
    icon: adminConfig?.config?.icon,
    fields: fields2,
    access,
    options: {
      timestamps: state.options?.timestamps !== false,
      versioning: !!state.options?.versioning
    },
    validation: buildGlobalValidation(fieldDefinitions),
    admin: adminConfig
  };
}
function buildGlobalValidation(fieldDefinitions) {
  if (!fieldDefinitions || Object.keys(fieldDefinitions).length === 0) {
    return void 0;
  }
  try {
    const updateSchema = buildFieldBasedSchema(fieldDefinitions, "update");
    return {
      update: updateSchema ? z$1.toJSONSchema(updateSchema.passthrough()) : void 0
    };
  } catch {
    return void 0;
  }
}
function extractAdminConfig(state) {
  const stateAny = state;
  const hasAdminConfig = stateAny.admin || stateAny.adminForm;
  if (!hasAdminConfig) {
    return void 0;
  }
  const result2 = {};
  if (stateAny.admin) {
    result2.config = {
      label: stateAny.admin.label,
      description: stateAny.admin.description,
      icon: stateAny.admin.icon,
      hidden: stateAny.admin.hidden,
      group: stateAny.admin.group,
      order: stateAny.admin.order
    };
  }
  if (stateAny.adminForm) {
    result2.form = {
      view: stateAny.adminForm.view,
      fields: stateAny.adminForm.fields,
      sections: stateAny.adminForm.sections,
      tabs: stateAny.adminForm.tabs
    };
  }
  return result2;
}
async function evaluateGlobalAccess(state, context, cms2) {
  const { access } = state;
  if (!access || Object.keys(access).length === 0) {
    return {
      visible: true,
      level: "full",
      operations: {
        read: { allowed: true },
        update: { allowed: true }
      }
    };
  }
  const accessContext = {
    app: cms2,
    session: context.session,
    db: context.db,
    locale: context.locale
  };
  const operations = {
    read: await evaluateAccessRule(access.read, accessContext),
    update: await evaluateAccessRule(access.update, accessContext)
  };
  const hasAnyAccess = Object.values(operations).some(
    (r2) => r2.allowed !== false
  );
  const hasFullAccess = Object.values(operations).every(
    (r2) => r2.allowed === true
  );
  return {
    visible: hasAnyAccess,
    level: hasFullAccess ? "full" : "none",
    operations
  };
}
async function evaluateAccessRule(rule, context) {
  if (rule === void 0 || rule === true) {
    return { allowed: true };
  }
  if (rule === false) {
    return { allowed: false };
  }
  if (typeof rule === "function") {
    try {
      const result2 = await rule(context);
      return result2 ? { allowed: true } : { allowed: false };
    } catch (error2) {
      return {
        allowed: false,
        reason: error2 instanceof Error ? error2.message : "Access denied"
      };
    }
  }
  return { allowed: true };
}
async function evaluateGlobalFieldAccess(fieldDef, context, cms2) {
  const fieldAccess = fieldDef.state.config?.access;
  if (!fieldAccess) {
    return void 0;
  }
  const req2 = context.req ?? context.request ?? (typeof Request !== "undefined" ? new Request("http://questpie.local") : {});
  const read = fieldAccess.read;
  const update = fieldAccess.update;
  const evaluateFieldRule = async (rule, operation) => {
    if (rule === void 0 || rule === true) {
      return { allowed: true };
    }
    if (rule === false) {
      return { allowed: false };
    }
    try {
      const allowed2 = await rule({
        req: req2,
        user: context.session?.user,
        doc: void 0,
        operation
      });
      return allowed2 ? { allowed: true } : { allowed: false };
    } catch (error2) {
      return {
        allowed: false,
        reason: error2 instanceof Error ? error2.message : "Access denied"
      };
    }
  };
  return {
    read: await evaluateFieldRule(read, "read"),
    write: await evaluateFieldRule(update, "update")
  };
}
const createGlobalRoutes = (cms2, config2 = {}) => {
  const errorResponse = (error2, request, locale) => {
    return handleError(error2, { request, cms: cms2, locale });
  };
  return {
    get: async (request, params, context) => {
      const resolved = await resolveContext(cms2, request, config2, context);
      try {
        const options = parseGlobalGetOptions(new URL(request.url));
        const globalInstance = cms2.getGlobalConfig(params.global);
        const crud = globalInstance.generateCRUD(resolved.cmsContext.db, cms2);
        const result2 = await crud.get(options, resolved.cmsContext);
        return smartResponse(result2, request);
      } catch (error2) {
        return errorResponse(error2, request, resolved.cmsContext.locale);
      }
    },
    schema: async (request, params, context) => {
      const resolved = await resolveContext(cms2, request, config2, context);
      const globalInstance = cms2.getGlobalConfig(params.global);
      if (!globalInstance) {
        return errorResponse(
          ApiError.notFound("Global", params.global),
          request,
          resolved.cmsContext.locale
        );
      }
      try {
        const schema2 = await introspectGlobal(
          globalInstance,
          {
            session: resolved.cmsContext.session,
            db: cms2.db,
            locale: resolved.cmsContext.locale
          },
          cms2
        );
        return smartResponse(schema2, request);
      } catch (error2) {
        return errorResponse(error2, request, resolved.cmsContext.locale);
      }
    },
    update: async (request, params, context, input) => {
      const resolved = await resolveContext(cms2, request, config2, context);
      const body = input !== void 0 ? input : await parseRpcBody(request);
      if (body === null) {
        return errorResponse(
          ApiError.badRequest("Invalid JSON body"),
          request,
          resolved.cmsContext.locale
        );
      }
      try {
        const options = parseGlobalUpdateOptions(new URL(request.url));
        const globalInstance = cms2.getGlobalConfig(params.global);
        const crud = globalInstance.generateCRUD(resolved.cmsContext.db, cms2);
        const result2 = await crud.update(body, resolved.cmsContext, options);
        return smartResponse(result2, request);
      } catch (error2) {
        return errorResponse(error2, request, resolved.cmsContext.locale);
      }
    }
  };
};
async function generateSignature(payload, secret) {
  const encoder2 = new TextEncoder();
  const keyData = encoder2.encode(secret);
  const data = encoder2.encode(payload);
  const cryptoKey = await crypto.subtle.importKey(
    "raw",
    keyData,
    { name: "HMAC", hash: "SHA-256" },
    false,
    ["sign"]
  );
  const signature = await crypto.subtle.sign("HMAC", cryptoKey, data);
  return btoa(String.fromCharCode(...new Uint8Array(signature))).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
async function verifySignature$2(payload, signature, secret) {
  const expectedSignature = await generateSignature(payload, secret);
  return expectedSignature === signature;
}
async function generateSignedUrlToken(key, secret, expirationSeconds) {
  const expires = Math.floor(Date.now() / 1e3) + expirationSeconds;
  const payload = { key, expires };
  const payloadStr = JSON.stringify(payload);
  const signature = await generateSignature(payloadStr, secret);
  const token2 = btoa(JSON.stringify({ ...payload, sig: signature })).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
  return token2;
}
async function verifySignedUrlToken(token2, secret) {
  try {
    const padded = token2.replace(/-/g, "+").replace(/_/g, "/");
    const decoded = JSON.parse(atob(padded));
    const { key, expires, sig } = decoded;
    if (!key || !expires || !sig) {
      return null;
    }
    const now2 = Math.floor(Date.now() / 1e3);
    if (expires < now2) {
      return null;
    }
    const payload = { key, expires };
    const payloadStr = JSON.stringify(payload);
    const isValid = await verifySignature$2(payloadStr, sig, secret);
    if (!isValid) {
      return null;
    }
    return payload;
  } catch {
    return null;
  }
}
function buildStorageFileUrl(baseUrl, basePath, key, token2) {
  const url = new URL(
    `${basePath}/storage/files/${encodeURIComponent(key)}`,
    baseUrl
  );
  if (token2) {
    url.searchParams.set("token", token2);
  }
  return url.toString();
}
const createStorageRoutes = (cms2, config2 = {}) => {
  const errorResponse = (error2, request, locale) => {
    return handleError(error2, { request, cms: cms2, locale });
  };
  return {
    collectionUpload: async (request, params, context, file) => {
      if (request.method !== "POST") {
        return errorResponse(
          ApiError.badRequest("Method not allowed"),
          request
        );
      }
      const { collection } = params;
      let collectionConfig;
      try {
        collectionConfig = cms2.getCollectionConfig(collection);
      } catch {
        return errorResponse(
          ApiError.notFound("Collection", collection),
          request
        );
      }
      if (!collectionConfig.state?.upload) {
        return errorResponse(
          ApiError.badRequest(
            `Collection "${collection}" does not support file uploads. Use .upload() to enable.`
          ),
          request
        );
      }
      const resolved = await resolveContext(cms2, request, config2, context);
      const uploadFile = await resolveUploadFile(request, file);
      if (!uploadFile) {
        return errorResponse(
          ApiError.badRequest("No file uploaded. Send 'file' in form-data."),
          request,
          resolved.cmsContext.locale
        );
      }
      try {
        const crud = cms2.api.collections[collection];
        if (!crud?.upload) {
          return errorResponse(
            ApiError.badRequest(
              `Collection "${collection}" upload method not available`
            ),
            request,
            resolved.cmsContext.locale
          );
        }
        const result2 = await crud.upload(uploadFile, resolved.cmsContext);
        return smartResponse(result2, request);
      } catch (error2) {
        return errorResponse(error2, request, resolved.cmsContext.locale);
      }
    },
    collectionServe: async (request, params, _context) => {
      if (request.method !== "GET") {
        return errorResponse(
          ApiError.badRequest("Method not allowed"),
          request
        );
      }
      const { collection, key } = params;
      let collectionConfig;
      try {
        collectionConfig = cms2.getCollectionConfig(collection);
      } catch {
        return errorResponse(
          ApiError.notFound("Collection", collection),
          request
        );
      }
      if (!collectionConfig.state?.upload) {
        return errorResponse(
          ApiError.badRequest(
            `Collection "${collection}" does not support file serving. Use .upload() to enable.`
          ),
          request
        );
      }
      const url = new URL(request.url);
      const token2 = url.searchParams.get("token");
      const exists = await cms2.storage.use().exists(key);
      if (!exists) {
        return errorResponse(ApiError.notFound("File", key), request);
      }
      const crud = cms2.api.collections[collection];
      const record = await crud.findOne({
        where: { key }
      });
      const visibility = record?.visibility || cms2.config.storage?.defaultVisibility || "public";
      if (visibility === "private") {
        if (!token2) {
          return errorResponse(
            ApiError.unauthorized("Token required for private files"),
            request
          );
        }
        const secret = cms2.config.secret;
        if (!secret) {
          return errorResponse(
            ApiError.internal(
              "Storage secret not configured. Set 'secret' in your CMS config to serve private files."
            ),
            request
          );
        }
        const payload = await verifySignedUrlToken(token2, secret);
        if (!payload) {
          return errorResponse(
            ApiError.unauthorized("Invalid or expired token"),
            request
          );
        }
        if (payload.key !== key) {
          return errorResponse(
            ApiError.unauthorized("Token does not match requested file"),
            request
          );
        }
      }
      try {
        const fileBuffer = await cms2.storage.use().getBytes(key);
        const metadata = await cms2.storage.use().getMetaData(key);
        const contentType = metadata.contentType || record?.mimeType || "application/octet-stream";
        const rawFilename = record?.filename;
        const sanitizedFilename = rawFilename ? rawFilename.replace(/[\r\n"\\]/g, "_") : null;
        return new Response(fileBuffer.buffer, {
          status: 200,
          headers: {
            "Content-Type": contentType,
            "Content-Length": String(fileBuffer.byteLength),
            "Cache-Control": visibility === "public" ? "public, max-age=31536000, immutable" : "private, no-cache",
            ...sanitizedFilename && {
              "Content-Disposition": `inline; filename="${sanitizedFilename}"`
            }
          }
        });
      } catch (error2) {
        return errorResponse(error2, request);
      }
    }
  };
};
const createRealtimeRoutes = (cms2, config2 = {}) => {
  const errorResponse = (error2, request, locale) => {
    return handleError(error2, { request, cms: cms2, locale });
  };
  return {
    subscribe: async (request, params, context) => {
      if (request.method !== "GET") {
        return errorResponse(
          ApiError.badRequest("Method not allowed"),
          request
        );
      }
      if (!cms2.realtime) {
        return errorResponse(ApiError.notImplemented("Realtime"), request);
      }
      const resolved = await resolveContext(cms2, request, config2, context);
      const crud = cms2.api.collections[params.collection];
      if (!crud) {
        return errorResponse(
          ApiError.notFound("Collection", params.collection),
          request,
          resolved.cmsContext.locale
        );
      }
      const options = parseFindOptions(new URL(request.url));
      const encoder2 = new TextEncoder();
      let closeStream = null;
      const stream2 = new ReadableStream({
        start: (controller) => {
          let closed = false;
          let refreshInFlight = false;
          let refreshQueued = false;
          let lastSeq = 0;
          const send = (event, data) => {
            if (closed) return;
            controller.enqueue(
              encoder2.encode(
                `event: ${event}
data: ${JSON.stringify(data)}

`
              )
            );
          };
          const sendError = (error2) => {
            const message2 = error2 instanceof Error ? error2.message : "Unknown error";
            send("error", { message: message2 });
          };
          const refresh = async (seq) => {
            if (closed) return;
            if (typeof seq === "number") {
              lastSeq = Math.max(lastSeq, seq);
            }
            if (refreshInFlight) {
              refreshQueued = true;
              return;
            }
            refreshInFlight = true;
            try {
              do {
                refreshQueued = false;
                const data = await crud.find(options, resolved.cmsContext);
                send("snapshot", { seq: lastSeq, data });
              } while (refreshQueued && !closed);
            } catch (error2) {
              sendError(error2);
            } finally {
              refreshInFlight = false;
            }
          };
          const unsubscribe2 = cms2.realtime.subscribe(
            (event) => {
              void refresh(event.seq);
            },
            {
              resourceType: "collection",
              resource: params.collection,
              where: options.where,
              with: options.with
            }
          );
          const pingTimer = setInterval(() => {
            send("ping", { ts: Date.now() });
          }, 25e3);
          const close = () => {
            if (closed) return;
            closed = true;
            clearInterval(pingTimer);
            unsubscribe2();
            controller.close();
          };
          closeStream = close;
          if (request.signal) {
            request.signal.addEventListener("abort", close);
          }
          void (async () => {
            try {
              lastSeq = await cms2.realtime?.getLatestSeq();
              await refresh(lastSeq);
            } catch (error2) {
              sendError(error2);
            }
          })();
        },
        cancel: () => {
          closeStream?.();
        }
      });
      return new Response(stream2, {
        headers: sseHeaders
      });
    },
    subscribeGlobal: async (request, params, context) => {
      if (request.method !== "GET") {
        return errorResponse(
          ApiError.badRequest("Method not allowed"),
          request
        );
      }
      if (!cms2.realtime) {
        return errorResponse(ApiError.notImplemented("Realtime"), request);
      }
      const resolved = await resolveContext(cms2, request, config2, context);
      let globalInstance;
      try {
        globalInstance = cms2.getGlobalConfig(params.global);
      } catch {
        return errorResponse(
          ApiError.notFound("Global", params.global),
          request,
          resolved.cmsContext.locale
        );
      }
      const crud = globalInstance.generateCRUD(resolved.cmsContext.db, cms2);
      const options = parseGlobalGetOptions(new URL(request.url));
      const encoder2 = new TextEncoder();
      let closeStream = null;
      const stream2 = new ReadableStream({
        start: (controller) => {
          let closed = false;
          let refreshInFlight = false;
          let refreshQueued = false;
          let lastSeq = 0;
          const send = (event, data) => {
            if (closed) return;
            controller.enqueue(
              encoder2.encode(
                `event: ${event}
data: ${JSON.stringify(data)}

`
              )
            );
          };
          const sendError = (error2) => {
            const message2 = error2 instanceof Error ? error2.message : "Unknown error";
            send("error", { message: message2 });
          };
          const refresh = async (seq) => {
            if (closed) return;
            if (typeof seq === "number") {
              lastSeq = Math.max(lastSeq, seq);
            }
            if (refreshInFlight) {
              refreshQueued = true;
              return;
            }
            refreshInFlight = true;
            try {
              do {
                refreshQueued = false;
                const data = await crud.get(options, resolved.cmsContext);
                send("snapshot", { seq: lastSeq, data });
              } while (refreshQueued && !closed);
            } catch (error2) {
              sendError(error2);
            } finally {
              refreshInFlight = false;
            }
          };
          const unsubscribe2 = cms2.realtime.subscribe(
            (event) => {
              void refresh(event.seq);
            },
            {
              resourceType: "global",
              resource: params.global,
              where: options.where,
              with: options.with
            }
          );
          const pingTimer = setInterval(() => {
            send("ping", { ts: Date.now() });
          }, 25e3);
          const close = () => {
            if (closed) return;
            closed = true;
            clearInterval(pingTimer);
            unsubscribe2();
            controller.close();
          };
          closeStream = close;
          if (request.signal) {
            request.signal.addEventListener("abort", close);
          }
          void (async () => {
            try {
              lastSeq = await cms2.realtime?.getLatestSeq();
              await refresh(lastSeq);
            } catch (error2) {
              sendError(error2);
            }
          })();
        },
        cancel: () => {
          closeStream?.();
        }
      });
      return new Response(stream2, {
        headers: sseHeaders
      });
    }
  };
};
const DEFAULT_LOCALE = "en";
const DEFAULT_LOCALE_CONFIG = {
  default: DEFAULT_LOCALE,
  supported: [DEFAULT_LOCALE]
};
function normalizeContext(context = {}) {
  return {
    ...context,
    accessMode: context.accessMode ?? "system",
    locale: context.locale ?? context.defaultLocale ?? DEFAULT_LOCALE,
    defaultLocale: context.defaultLocale ?? DEFAULT_LOCALE
  };
}
function getDb(defaultDb, context) {
  return context?.db ?? defaultDb;
}
async function executeAccessRule(rule, context) {
  if (rule === void 0) return true;
  if (typeof rule === "boolean") {
    return rule;
  }
  if (typeof rule === "function") {
    const result2 = await rule({
      app: context.cms,
      session: context.session,
      data: context.row,
      input: context.input,
      db: context.db,
      locale: context.locale
    });
    return result2;
  }
  return true;
}
async function matchesAccessConditions(conditions, row) {
  for (const [key, value] of Object.entries(conditions)) {
    if (key === "AND") {
      for (const cond of value) {
        if (!await matchesAccessConditions(cond, row)) {
          return false;
        }
      }
    } else if (key === "OR") {
      let anyMatch = false;
      for (const cond of value) {
        if (await matchesAccessConditions(cond, row)) {
          anyMatch = true;
          break;
        }
      }
      if (!anyMatch) return false;
    } else if (key === "NOT") {
      if (await matchesAccessConditions(value, row)) {
        return false;
      }
    } else {
      if (row[key] !== value) {
        return false;
      }
    }
  }
  return true;
}
function createFieldAccessContext(params) {
  const request = params.context.req ?? params.context.request ?? (typeof Request !== "undefined" ? new Request("http://questpie.local") : {});
  return {
    req: request,
    user: params.context.session?.user,
    doc: params.doc,
    operation: params.operation
  };
}
async function evaluateFieldAccess(rule, context) {
  if (rule === void 0 || rule === true) return true;
  if (rule === false) return false;
  if (typeof rule === "function") {
    return await rule(context) === true;
  }
  return true;
}
async function getRestrictedReadFields(result2, context, options) {
  if (!result2) return [];
  const normalized = normalizeContext(context);
  if (normalized.accessMode === "system") return [];
  const fieldAccess = options.fieldAccess;
  if (!fieldAccess) return [];
  const fieldsToRemove = [];
  for (const fieldName of Object.keys(result2)) {
    if (fieldName === "id" || fieldName === "_title" || fieldName === "createdAt" || fieldName === "updatedAt" || fieldName === "deletedAt") {
      continue;
    }
    const access = fieldAccess[fieldName];
    if (!access || access.read === void 0) {
      continue;
    }
    const canRead = await evaluateFieldAccess(
      access.read,
      createFieldAccessContext({
        context: normalized,
        operation: "read",
        doc: result2
      })
    );
    if (!canRead) {
      fieldsToRemove.push(fieldName);
    }
  }
  return fieldsToRemove;
}
async function checkFieldWriteAccess(fieldName, fieldAccess, context, options, operation, existingRow) {
  const normalized = normalizeContext(context);
  if (normalized.accessMode === "system") return true;
  if (!fieldAccess) return true;
  const access = fieldAccess[fieldName];
  if (!access) {
    return true;
  }
  const rule = operation === "create" ? access.create : access.update;
  return evaluateFieldAccess(
    rule,
    createFieldAccessContext({
      context: normalized,
      operation,
      doc: existingRow
    })
  );
}
async function validateFieldsWriteAccess(data, fieldAccess, context, options, collectionName, operation, existingRow) {
  const { ApiError: ApiError2 } = await import("./index-CBgCaryp.js");
  const normalized = normalizeContext(context);
  if (normalized.accessMode === "system") return;
  if (!fieldAccess) return;
  for (const fieldName of Object.keys(data)) {
    if (fieldName === "id" || fieldName === "createdAt" || fieldName === "updatedAt" || fieldName === "deletedAt") {
      continue;
    }
    const canWrite = await checkFieldWriteAccess(
      fieldName,
      fieldAccess,
      context,
      options,
      operation,
      existingRow
    );
    if (!canWrite) {
      throw ApiError2.forbidden({
        operation: "update",
        resource: collectionName,
        reason: `Cannot write field '${fieldName}': access denied`,
        fieldPath: fieldName
      });
    }
  }
}
function mergeWhereWithAccess(userWhere, accessWhere) {
  if (accessWhere === false) {
    throw new Error(
      "mergeWhereWithAccess called with accessWhere === false. This should be handled at the CRUD level by throwing a forbidden error."
    );
  }
  if (accessWhere === true || !accessWhere) {
    return userWhere;
  }
  if (!userWhere) {
    return accessWhere;
  }
  return {
    AND: [userWhere, accessWhere]
  };
}
const createSearchRoutes = (cms2, config2 = {}) => {
  const errorResponse = (error2, request, locale) => {
    return handleError(error2, { request, cms: cms2, locale });
  };
  const canReindexCollection = async (params) => {
    const customAccess = config2.search?.reindexAccess;
    if (typeof customAccess === "boolean") {
      return customAccess;
    }
    if (typeof customAccess === "function") {
      try {
        return await customAccess({
          request: params.request,
          cms: cms2,
          session: params.session,
          db: params.db,
          locale: params.locale,
          collection: params.collectionName
        });
      } catch {
        return false;
      }
    }
    const updateAccessRule = params.collection?.state?.access?.update;
    const updateAccessResult = await executeAccessRule(updateAccessRule, {
      cms: cms2,
      db: params.db,
      session: params.session,
      locale: params.locale
    });
    return updateAccessResult !== false;
  };
  return {
    /**
     * Search across collections
     * POST /cms/search
     *
     * Features:
     * - Respects collection-level access controls via SQL JOINs
     * - Populates full records via CRUD (hooks run)
     * - Returns search metadata merged with records
     *
     * Request body:
     * {
     *   query: string;
     *   collections?: string[];
     *   locale?: string;
     *   limit?: number;
     *   offset?: number;
     *   filters?: Record<string, string | string[]>;
     *   highlights?: boolean;
     *   facets?: FacetDefinition[];
     * }
     *
     * Response:
     * {
     *   docs: [{ ...fullRecord, _search: { score, highlights, indexedTitle } }],
     *   total: number,
     *   facets?: FacetResult[]
     * }
     */
    search: async (request, _params, context) => {
      const resolved = await resolveContext(cms2, request, config2, context);
      if (!cms2.search) {
        return errorResponse(
          ApiError.notFound("Search", "Search service not configured"),
          request,
          resolved.cmsContext.locale
        );
      }
      const body = await parseRpcBody(request);
      if (body === null) {
        return errorResponse(
          ApiError.badRequest("Invalid JSON body"),
          request,
          resolved.cmsContext.locale
        );
      }
      try {
        const allCollections = cms2.getCollections();
        const requestedCollections = body.collections ?? Object.keys(allCollections);
        const accessFilters = [];
        const accessibleCollections = [];
        for (const collectionName of requestedCollections) {
          const collection = allCollections[collectionName];
          if (!collection) continue;
          const accessRule = collection.state?.access?.read;
          const accessWhere = await executeAccessRule(accessRule, {
            cms: cms2,
            db: resolved.cmsContext.db ?? cms2.db,
            session: resolved.cmsContext.session,
            locale: resolved.cmsContext.locale
          });
          if (accessWhere === false) continue;
          accessFilters.push({
            collection: collectionName,
            table: collection.table,
            accessWhere,
            softDelete: collection.state?.options?.softDelete ?? false
          });
          accessibleCollections.push(collectionName);
        }
        if (accessibleCollections.length === 0) {
          return smartResponse(
            {
              docs: [],
              total: 0,
              facets: []
            },
            request
          );
        }
        const searchResults = await cms2.search.search({
          query: body.query || "",
          collections: accessibleCollections,
          locale: body.locale ?? resolved.cmsContext.locale,
          limit: body.limit ?? 10,
          offset: body.offset ?? 0,
          filters: body.filters,
          highlights: body.highlights ?? true,
          facets: body.facets,
          mode: body.mode,
          accessFilters
        });
        if (searchResults.results.length === 0) {
          return smartResponse(
            {
              docs: [],
              total: searchResults.total,
              facets: searchResults.facets
            },
            request
          );
        }
        const searchMetaMap = /* @__PURE__ */ new Map();
        for (const result2 of searchResults.results) {
          const key = `${result2.collection}:${result2.recordId}`;
          searchMetaMap.set(key, {
            score: result2.score,
            highlights: result2.highlights,
            indexedTitle: result2.title,
            indexedContent: result2.content
          });
        }
        const idsByCollection = /* @__PURE__ */ new Map();
        for (const result2 of searchResults.results) {
          const ids = idsByCollection.get(result2.collection) ?? [];
          ids.push(result2.recordId);
          idsByCollection.set(result2.collection, ids);
        }
        const populatedDocs = [];
        const crudContext = {
          session: resolved.cmsContext.session,
          locale: resolved.cmsContext.locale,
          db: resolved.cmsContext.db ?? cms2.db
        };
        for (const [collectionName, ids] of idsByCollection) {
          const collection = allCollections[collectionName];
          if (!collection) continue;
          const crud = collection.generateCRUD?.(
            resolved.cmsContext.db ?? cms2.db,
            cms2
          );
          if (!crud) continue;
          try {
            const crudResult = await crud.find(
              {
                where: { id: { in: ids } },
                limit: ids.length
              },
              crudContext
            );
            for (const doc of crudResult.docs) {
              const key = `${collectionName}:${doc.id}`;
              const searchMeta = searchMetaMap.get(key);
              if (searchMeta) {
                populatedDocs.push({
                  ...doc,
                  _collection: collectionName,
                  _search: searchMeta
                });
              }
            }
          } catch (err2) {
            console.error(
              `[Search] Failed to populate ${collectionName}:`,
              err2
            );
          }
        }
        populatedDocs.sort(
          (a, b) => (b._search?.score ?? 0) - (a._search?.score ?? 0)
        );
        return smartResponse(
          {
            docs: populatedDocs,
            total: searchResults.total,
            facets: searchResults.facets
          },
          request
        );
      } catch (error2) {
        return errorResponse(error2, request, resolved.cmsContext.locale);
      }
    },
    /**
     * Reindex a collection
     * POST /cms/search/reindex/:collection
     *
     * PROTECTED: Requires authentication and reindex access policy.
     * This is a potentially expensive operation that rebuilds the search index.
     */
    reindex: async (request, params, context) => {
      const resolved = await resolveContext(cms2, request, config2, context);
      if (!resolved.cmsContext.session) {
        return errorResponse(
          ApiError.unauthorized("Authentication required"),
          request,
          resolved.cmsContext.locale
        );
      }
      if (!cms2.search) {
        return errorResponse(
          ApiError.notFound("Search", "Search service not configured"),
          request,
          resolved.cmsContext.locale
        );
      }
      const collection = cms2.getCollections()[params.collection];
      if (!collection) {
        return errorResponse(
          ApiError.notFound("Collection", params.collection),
          request,
          resolved.cmsContext.locale
        );
      }
      const db = resolved.cmsContext.db ?? cms2.db;
      const hasReindexAccess = await canReindexCollection({
        request,
        collectionName: params.collection,
        collection,
        session: resolved.cmsContext.session,
        db,
        locale: resolved.cmsContext.locale
      });
      if (!hasReindexAccess) {
        return errorResponse(
          ApiError.forbidden({
            operation: "update",
            resource: `search/reindex/${params.collection}`,
            reason: "Reindex access denied by policy"
          }),
          request,
          resolved.cmsContext.locale
        );
      }
      try {
        await cms2.search.reindex(params.collection);
        return smartResponse(
          { success: true, collection: params.collection },
          request
        );
      } catch (error2) {
        return errorResponse(error2, request, resolved.cmsContext.locale);
      }
    }
  };
};
function resolveStorageAliasCollection(cms2, config2) {
  const configuredCollection = config2.storage?.collection;
  if (typeof configuredCollection === "string" && configuredCollection.trim().length > 0) {
    return { collection: configuredCollection.trim() };
  }
  const uploadCollections = Object.entries(cms2.getCollections()).filter(([, collection]) => Boolean(collection?.state?.upload)).map(([name2]) => name2);
  if (uploadCollections.length === 1) {
    return { collection: uploadCollections[0] };
  }
  if (uploadCollections.length === 0) {
    return {
      error: "No upload-enabled collection is registered for /storage/files alias route."
    };
  }
  return {
    error: `Multiple upload-enabled collections found (${uploadCollections.join(", ")}). Set adapter config \`storage.collection\` to choose one for /storage/files.`
  };
}
const createAdapterRoutes = (cms2, config2 = {}) => {
  const authRoute = createAuthRoute(cms2);
  const rpcRoutes = createRpcRoutes(cms2, config2);
  const collectionRoutes = createCollectionRoutes(cms2, config2);
  const globalRoutes = createGlobalRoutes(cms2, config2);
  const storageRoutes = createStorageRoutes(cms2, config2);
  const realtimeRoutes = createRealtimeRoutes(cms2, config2);
  const searchRoutes = createSearchRoutes(cms2, config2);
  return {
    auth: authRoute,
    collectionUpload: storageRoutes.collectionUpload,
    collectionServe: storageRoutes.collectionServe,
    rpc: rpcRoutes,
    realtime: realtimeRoutes,
    collections: collectionRoutes,
    globals: globalRoutes,
    search: searchRoutes
  };
};
const createFetchHandler = (cms2, config2 = {}) => {
  const routes = createAdapterRoutes(cms2, config2);
  const basePath = normalizeBasePath$1(config2.basePath ?? "/cms");
  const storageAliasCollection = resolveStorageAliasCollection(cms2, config2);
  const errorResponse = (error2, request) => {
    return handleError(error2, { request, cms: cms2 });
  };
  return async (request, context) => {
    const url = new URL(request.url);
    const pathname = url.pathname;
    const matchesBase = basePath === "/" ? true : pathname === basePath || pathname.startsWith(`${basePath}/`);
    if (!matchesBase) {
      return null;
    }
    const relativePath = basePath === "/" ? pathname : pathname.slice(basePath.length);
    let segments = relativePath.split("/").filter(Boolean);
    if (segments.length === 0) {
      return errorResponse(ApiError.notFound("Route"), request);
    }
    if (segments[0] === "cms") {
      segments = segments.slice(1);
    }
    if (segments.length === 0) {
      return errorResponse(ApiError.notFound("Route"), request);
    }
    if (segments[0] === "auth") {
      return routes.auth(request);
    }
    if (segments[0] === "search") {
      if (request.method === "POST") {
        if (segments[1] === "reindex" && segments[2]) {
          return routes.search.reindex(
            request,
            { collection: segments[2] },
            context
          );
        }
        return routes.search.search(request, {}, context);
      }
      return errorResponse(ApiError.badRequest("Method not allowed"), request);
    }
    if (segments[0] === "rpc") {
      const rpcPath = segments.slice(1);
      if (rpcPath.length === 0) {
        return errorResponse(
          ApiError.badRequest("RPC path not specified"),
          request
        );
      }
      return routes.rpc.root(request, { path: rpcPath }, context);
    }
    if (segments[0] === "collections" && segments[2] === "rpc") {
      const collectionName = segments[1];
      const functionName = segments[3];
      if (!collectionName) {
        return errorResponse(
          ApiError.badRequest("Collection not specified"),
          request
        );
      }
      if (!functionName) {
        return errorResponse(
          ApiError.badRequest("Function not specified"),
          request
        );
      }
      return routes.rpc.collection(
        request,
        { collection: collectionName, name: functionName },
        context
      );
    }
    if (segments[0] === "globals" && segments[2] === "rpc") {
      const globalName = segments[1];
      const functionName = segments[3];
      if (!globalName) {
        return errorResponse(
          ApiError.badRequest("Global not specified"),
          request
        );
      }
      if (!functionName) {
        return errorResponse(
          ApiError.badRequest("Function not specified"),
          request
        );
      }
      return routes.rpc.global(
        request,
        { global: globalName, name: functionName },
        context
      );
    }
    if (segments[0] === "realtime") {
      const maybeGlobals = segments[1];
      if (!maybeGlobals) {
        return errorResponse(
          ApiError.badRequest("Collection not specified"),
          request
        );
      }
      if (maybeGlobals === "globals") {
        const globalName = segments[2];
        if (!globalName) {
          return errorResponse(
            ApiError.badRequest("Global not specified"),
            request
          );
        }
        if (request.method === "GET") {
          return routes.realtime.subscribeGlobal(
            request,
            { global: globalName },
            context
          );
        }
        return errorResponse(
          ApiError.badRequest("Method not allowed"),
          request
        );
      }
      if (request.method === "GET") {
        return routes.realtime.subscribe(
          request,
          { collection: maybeGlobals },
          context
        );
      }
      return errorResponse(ApiError.badRequest("Method not allowed"), request);
    }
    if (segments[0] === "storage" && segments[1] === "files") {
      const key = decodeURIComponent(segments.slice(2).join("/"));
      if (!key) {
        return errorResponse(
          ApiError.badRequest("File key not specified"),
          request
        );
      }
      if (request.method === "GET") {
        if (!storageAliasCollection.collection) {
          return errorResponse(
            ApiError.badRequest(
              storageAliasCollection.error || "Storage collection alias is not configured"
            ),
            request
          );
        }
        return routes.collectionServe(
          request,
          { collection: storageAliasCollection.collection, key },
          context
        );
      }
      return errorResponse(ApiError.badRequest("Method not allowed"), request);
    }
    if (segments[0] === "globals") {
      const globalName = segments[1];
      const globalAction = segments[2];
      if (!globalName) {
        return errorResponse(
          ApiError.badRequest("Global not specified"),
          request
        );
      }
      if (globalAction === "schema") {
        if (request.method === "GET") {
          return routes.globals.schema(
            request,
            { global: globalName },
            context
          );
        }
        return errorResponse(
          ApiError.badRequest("Method not allowed"),
          request
        );
      }
      if (request.method === "GET") {
        return routes.globals.get(request, { global: globalName }, context);
      }
      if (request.method === "PATCH") {
        return routes.globals.update(request, { global: globalName }, context);
      }
      return errorResponse(ApiError.badRequest("Method not allowed"), request);
    }
    const collection = segments[0];
    const id = segments[1];
    const action = segments[2];
    if (id === "upload") {
      if (request.method === "POST") {
        return routes.collectionUpload(request, { collection }, context);
      }
      return errorResponse(ApiError.badRequest("Method not allowed"), request);
    }
    if (id === "files" && segments[2]) {
      const key = decodeURIComponent(segments.slice(2).join("/"));
      if (request.method === "GET") {
        return routes.collectionServe(request, { collection, key }, context);
      }
      return errorResponse(ApiError.badRequest("Method not allowed"), request);
    }
    if (id === "meta") {
      if (request.method === "GET") {
        return routes.collections.meta(request, { collection }, context);
      }
      return errorResponse(ApiError.badRequest("Method not allowed"), request);
    }
    if (id === "schema") {
      if (request.method === "GET") {
        return routes.collections.schema(request, { collection }, context);
      }
      return errorResponse(ApiError.badRequest("Method not allowed"), request);
    }
    if (id === "count") {
      if (request.method === "GET") {
        return routes.collections.count(request, { collection }, context);
      }
      return errorResponse(ApiError.badRequest("Method not allowed"), request);
    }
    if (id === "delete-many") {
      if (request.method === "POST") {
        return routes.collections.deleteMany(request, { collection }, context);
      }
      return errorResponse(ApiError.badRequest("Method not allowed"), request);
    }
    if (!id) {
      if (request.method === "GET") {
        return routes.collections.find(request, { collection }, context);
      }
      if (request.method === "POST") {
        return routes.collections.create(request, { collection }, context);
      }
      if (request.method === "PATCH") {
        return routes.collections.updateMany(request, { collection }, context);
      }
      return errorResponse(ApiError.badRequest("Method not allowed"), request);
    }
    if (action === "restore") {
      if (request.method === "POST") {
        return routes.collections.restore(request, { collection, id }, context);
      }
      return errorResponse(ApiError.badRequest("Method not allowed"), request);
    }
    if (request.method === "GET") {
      return routes.collections.findOne(request, { collection, id }, context);
    }
    if (request.method === "PATCH") {
      return routes.collections.update(request, { collection, id }, context);
    }
    if (request.method === "DELETE") {
      return routes.collections.remove(request, { collection, id }, context);
    }
    return errorResponse(ApiError.badRequest("Method not allowed"), request);
  };
};
function isNotNull(column) {
  return column.config?.notNull === true;
}
function hasDefault(column) {
  return column.config?.hasDefault === true;
}
function getColumnConfig$2(column) {
  return column.config || {};
}
function enumToZod(column) {
  const config2 = getColumnConfig$2(column);
  const enumFn = config2.enum;
  const enumValues = enumFn?.enumValues;
  if (!enumValues || !Array.isArray(enumValues) || enumValues.length === 0) {
    throw new Error("pgEnum column must have enum values defined");
  }
  return z$1.enum(enumValues);
}
function varcharToZod(column) {
  const config2 = getColumnConfig$2(column);
  if (config2.enumValues && Array.isArray(config2.enumValues) && config2.enumValues.length > 0) {
    return z$1.enum(config2.enumValues);
  }
  let schema2 = z$1.string();
  if (config2.length && typeof config2.length === "number") {
    schema2 = schema2.max(config2.length);
  }
  return schema2;
}
function textToZod(_column) {
  return z$1.string();
}
function integerToZod(_column) {
  return z$1.number().int();
}
function bigintToZod(column) {
  const config2 = getColumnConfig$2(column);
  const columnType = config2.columnType;
  const dataType = config2.dataType;
  if (columnType === "PgBigInt53" || columnType === "PgBigSerial53" || dataType?.includes("int53")) {
    return z$1.number().int();
  }
  return z$1.bigint();
}
function numericToZod(_column) {
  return z$1.string();
}
function floatToZod(_column) {
  return z$1.number();
}
function booleanToZod(_column) {
  return z$1.boolean();
}
function dateToZod(column) {
  const config2 = getColumnConfig$2(column);
  const dataType = config2.dataType;
  if (dataType?.includes("date") && dataType?.includes("object")) {
    return z$1.coerce.date();
  }
  return z$1.string();
}
function timestampToZod(column) {
  const config2 = getColumnConfig$2(column);
  const dataType = config2.dataType;
  if (dataType?.includes("date") && dataType?.includes("object")) {
    return z$1.coerce.date();
  }
  return z$1.string();
}
function timeToZod(_column) {
  return z$1.string();
}
function intervalToZod(_column) {
  return z$1.string();
}
function uuidToZod(_column) {
  return z$1.string().refine((val) => {
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    return uuidRegex.test(val);
  }, "Invalid UUID format");
}
function jsonToZod(_column) {
  return z$1.any();
}
function drizzleColumnToZod(column) {
  let baseSchema;
  const config2 = getColumnConfig$2(column);
  const columnType = config2.columnType || column.constructor.name;
  switch (columnType) {
    case "PgEnum":
    case "PgEnumColumn":
      baseSchema = enumToZod(column);
      break;
    case "PgVarchar":
    case "PgChar":
      baseSchema = varcharToZod(column);
      break;
    case "PgText":
      baseSchema = textToZod();
      break;
    case "PgInteger":
    case "PgSmallInt":
    case "PgSerial":
    case "PgSmallSerial":
      baseSchema = integerToZod();
      break;
    case "PgBigInt53":
    case "PgBigInt64":
    case "PgBigSerial53":
    case "PgBigSerial64":
      baseSchema = bigintToZod(column);
      break;
    case "PgNumeric":
      baseSchema = numericToZod();
      break;
    case "PgReal":
    case "PgDoublePrecision":
      baseSchema = floatToZod();
      break;
    case "PgBoolean":
      baseSchema = booleanToZod();
      break;
    case "PgDate":
      baseSchema = dateToZod(column);
      break;
    case "PgTimestamp":
      baseSchema = timestampToZod(column);
      break;
    case "PgTime":
      baseSchema = timeToZod();
      break;
    case "PgInterval":
      baseSchema = intervalToZod();
      break;
    case "PgUUID":
      baseSchema = uuidToZod();
      break;
    case "PgJson":
    case "PgJsonb":
      baseSchema = jsonToZod();
      break;
    default:
      baseSchema = z$1.any();
  }
  const columnHasDefault = hasDefault(column);
  const columnIsNotNull = isNotNull(column);
  if (columnHasDefault) {
    if (columnIsNotNull) {
      return baseSchema.optional();
    }
    return baseSchema.nullish();
  }
  if (columnIsNotNull) {
    return baseSchema;
  }
  return baseSchema.nullish();
}
function createInsertSchema(table, options) {
  const exclude = new Set(Object.keys(options?.exclude || {}));
  const optional = new Set(Object.keys(options?.optional || {}));
  const refine = options?.refine || {};
  const shape = {};
  for (const [key, column] of Object.entries(getColumns(table))) {
    if (exclude.has(key)) {
      continue;
    }
    let schema2 = drizzleColumnToZod(column);
    if (key in refine) {
      schema2 = refine[key](schema2);
    }
    if (optional.has(key) && !(schema2 instanceof z$1.ZodOptional)) {
      schema2 = schema2.optional();
    }
    shape[key] = schema2;
  }
  return z$1.object(shape);
}
function createUpdateSchema(table, options) {
  const exclude = new Set(Object.keys(options?.exclude || {}));
  const refine = options?.refine || {};
  const shape = {};
  for (const [key, column] of Object.entries(getColumns(table))) {
    if (exclude.has(key)) {
      continue;
    }
    let schema2 = drizzleColumnToZod(column);
    if (key in refine) {
      schema2 = refine[key](schema2);
    }
    if (!(schema2 instanceof z$1.ZodOptional)) {
      schema2 = schema2.optional();
    }
    shape[key] = schema2;
  }
  return z$1.object(shape);
}
function mergeFieldsForValidation$1(tableName, mainFields, localizedFields) {
  const mergedFields = {
    ...mainFields,
    ...localizedFields
  };
  return pgTable(`${tableName}_validation`, mergedFields);
}
function extractRelationFieldMappings(_fieldDefinitions) {
  return {};
}
function createRelationFieldPreprocessor(relationMappings) {
  return (input) => {
    if (typeof input !== "object" || input === null) {
      return input;
    }
    const result2 = { ...input };
    for (const [fieldName, fkColumnName] of Object.entries(relationMappings)) {
      if (fieldName in result2) {
        const value = result2[fieldName];
        if (typeof value === "string" || value === null) {
          result2[fkColumnName] = value;
          delete result2[fieldName];
        }
      }
    }
    return result2;
  };
}
function createCollectionValidationSchemas(tableName, mainFields, localizedFields, options) {
  const validationTable = mergeFieldsForValidation$1(
    tableName,
    mainFields,
    localizedFields
  );
  const baseInsertSchema = createInsertSchema(validationTable, {
    exclude: options?.exclude || {},
    refine: options?.refine
  });
  const baseUpdateSchema = createUpdateSchema(validationTable, {
    exclude: options?.exclude || {},
    refine: options?.refine
  });
  if (options?.fieldDefinitions) {
    const relationMappings = extractRelationFieldMappings(
      options.fieldDefinitions
    );
    if (Object.keys(relationMappings).length > 0) {
      const preprocessor = createRelationFieldPreprocessor(relationMappings);
      return {
        insertSchema: z$1.preprocess(
          preprocessor,
          baseInsertSchema.passthrough()
        ),
        updateSchema: z$1.preprocess(
          preprocessor,
          baseUpdateSchema.passthrough()
        )
      };
    }
  }
  return {
    insertSchema: baseInsertSchema,
    updateSchema: baseUpdateSchema
  };
}
function extractFieldNamesByLocation(fieldDefinitions, location) {
  const names = [];
  for (const [name2, fieldDef] of Object.entries(fieldDefinitions)) {
    if (fieldDef.state.location === location) {
      names.push(name2);
    }
  }
  return names;
}
function extractLocalizedFieldNames(fieldDefinitions) {
  return extractFieldNamesByLocation(fieldDefinitions, "i18n");
}
function extractNestedLocalizationSchema(fieldDef) {
  const config2 = fieldDef.state.config;
  const fieldType = fieldDef.state.type;
  if (fieldType === "object" && config2.fields) {
    const nestedFields = resolveFieldsConfig(config2.fields);
    if (!nestedFields) return null;
    const schema2 = {};
    let hasLocalized = false;
    for (const [fieldName, nestedFieldDef] of Object.entries(nestedFields)) {
      const nestedConfig = nestedFieldDef.state.config;
      if (nestedConfig.localized === true) {
        schema2[fieldName] = true;
        hasLocalized = true;
        continue;
      }
      const nestedSchema = extractNestedLocalizationSchema(nestedFieldDef);
      if (nestedSchema !== null) {
        schema2[fieldName] = nestedSchema;
        hasLocalized = true;
      }
    }
    return hasLocalized ? schema2 : null;
  }
  if (fieldType === "array" && config2.of) {
    const itemFieldDef = resolveItemConfig(config2.of);
    if (!itemFieldDef) return null;
    const itemConfig = itemFieldDef.state.config;
    if (itemConfig.localized === true) {
      return { _item: true };
    }
    const itemSchema = extractNestedLocalizationSchema(itemFieldDef);
    if (itemSchema !== null) {
      return { _item: itemSchema };
    }
    return null;
  }
  if (fieldType === "blocks") {
    const blockDefinitions = config2._blockDefinitions;
    if (!blockDefinitions) return null;
    const blocksSchema = {};
    let hasBlocksLocalized = false;
    for (const [blockType, blockDef] of Object.entries(blockDefinitions)) {
      const blockFields = resolveFieldsConfig(blockDef.state?.fields);
      if (!blockFields) continue;
      const blockSchema = {};
      let hasFieldLocalized = false;
      for (const [fieldName, blockFieldDef] of Object.entries(blockFields)) {
        const blockFieldConfig = blockFieldDef.state.config;
        if (blockFieldConfig.localized === true) {
          blockSchema[fieldName] = true;
          hasFieldLocalized = true;
          continue;
        }
        const nestedSchema = extractNestedLocalizationSchema(blockFieldDef);
        if (nestedSchema !== null) {
          blockSchema[fieldName] = nestedSchema;
          hasFieldLocalized = true;
        }
      }
      if (hasFieldLocalized) {
        blocksSchema[blockType] = blockSchema;
        hasBlocksLocalized = true;
      }
    }
    if (hasBlocksLocalized) {
      return { _blocks: blocksSchema };
    }
    return null;
  }
  return null;
}
function extractNestedLocalizationSchemas(fieldDefinitions) {
  const schemas = {};
  for (const [fieldName, fieldDef] of Object.entries(fieldDefinitions)) {
    if (fieldDef.state.location === "i18n") continue;
    const fieldType = fieldDef.state.type;
    if (fieldType !== "object" && fieldType !== "array" && fieldType !== "blocks") {
      continue;
    }
    const schema2 = extractNestedLocalizationSchema(fieldDef);
    if (schema2 !== null) {
      schemas[fieldName] = schema2;
    }
  }
  return schemas;
}
function resolveFieldsConfig(fields2) {
  if (!fields2) return null;
  if (typeof fields2 === "function") {
    return fields2();
  }
  return fields2;
}
function resolveItemConfig(of) {
  if (!of) return null;
  if (typeof of === "function") {
    return of();
  }
  return of;
}
function resolveFieldKey(state, column, table) {
  if (typeof column === "string") return column;
  const columnName = column?.name ?? column?.config?.name;
  if (!columnName) return void 0;
  for (const [key, value] of Object.entries(state.fields)) {
    const fieldName = value?.name ?? value?.config?.name;
    if (fieldName === columnName) return key;
  }
  if (table) {
    for (const [key, value] of Object.entries(table)) {
      const fieldName = value?.name ?? value?.config?.name;
      if (fieldName === columnName) return key;
    }
  }
  return void 0;
}
async function executeHooks(hooks, ctx) {
  if (!hooks) return;
  const hookArray = Array.isArray(hooks) ? hooks : [hooks];
  for (const hook of hookArray) {
    await hook(ctx);
  }
}
function createHookContext(params) {
  const normalized = normalizeContext(params.context);
  return {
    data: params.data,
    original: params.original,
    app: params.cms,
    // CMS instance
    session: normalized.session,
    locale: normalized.locale,
    accessMode: normalized.accessMode,
    operation: params.operation,
    db: params.db
  };
}
function isNullish(value) {
  return value === null || value === void 0;
}
function dedupeBy(array, getKey) {
  const seen = /* @__PURE__ */ new Set();
  const result2 = [];
  for (const item of array) {
    const key = getKey(item);
    if (!seen.has(key)) {
      seen.add(key);
      result2.push(item);
    }
  }
  return result2;
}
function isPlainObject$1(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  if (Array.isArray(value)) {
    return false;
  }
  const proto2 = Object.getPrototypeOf(value);
  return proto2 === Object.prototype || proto2 === null;
}
function deepMerge(target, ...sources) {
  if (sources.length === 0) {
    return structuredClone(target);
  }
  const result2 = structuredClone(target);
  for (const source of sources) {
    if (isNullish(source)) {
      continue;
    }
    for (const key in source) {
      if (!Object.prototype.hasOwnProperty.call(source, key)) {
        continue;
      }
      const sourceValue = source[key];
      const targetValue = result2[key];
      if (isNullish(sourceValue)) {
        continue;
      }
      if (isPlainObject$1(targetValue) && isPlainObject$1(sourceValue)) {
        result2[key] = deepMerge(
          targetValue,
          sourceValue
        );
      } else {
        result2[key] = structuredClone(sourceValue);
      }
    }
  }
  return result2;
}
const I18N_MARKER = "$i18n";
const ORDER_KEY = "_order";
const TREE_KEY = "_tree";
const VALUES_KEY = "_values";
function isI18nMarker(value) {
  return isPlainObject$1(value) && value[I18N_MARKER] === true;
}
function isIdBasedMap(value) {
  return isPlainObject$1(value) && Array.isArray(value[ORDER_KEY]);
}
function isBlocksStructure(value) {
  return isPlainObject$1(value) && Array.isArray(value[TREE_KEY]) && isPlainObject$1(value[VALUES_KEY]);
}
function deepMergeI18n(structure, i18nChain) {
  if (isI18nMarker(structure)) {
    for (const layer of i18nChain) {
      if (layer != null) {
        return layer;
      }
    }
    return null;
  }
  if (isBlocksStructure(structure)) {
    const blocksStruct = structure;
    const result2 = {
      [TREE_KEY]: blocksStruct[TREE_KEY]
      // Tree is not localized
    };
    const valuesStruct = blocksStruct[VALUES_KEY];
    const mergedValues = {};
    for (const blockId of Object.keys(valuesStruct)) {
      mergedValues[blockId] = deepMergeI18n(
        valuesStruct[blockId],
        i18nChain.map((layer) => {
          const layerValues = layer?.[VALUES_KEY];
          return layerValues?.[blockId];
        })
      );
    }
    result2[VALUES_KEY] = mergedValues;
    return result2;
  }
  if (isIdBasedMap(structure)) {
    const map2 = structure;
    const result2 = {
      [ORDER_KEY]: map2[ORDER_KEY]
      // Preserve order
    };
    for (const key of Object.keys(map2)) {
      if (key === ORDER_KEY) continue;
      result2[key] = deepMergeI18n(
        map2[key],
        i18nChain.map((layer) => layer?.[key])
      );
    }
    return result2;
  }
  if (Array.isArray(structure)) {
    return structure.map(
      (item, index2) => deepMergeI18n(
        item,
        i18nChain.map((layer) => layer?.[index2])
      )
    );
  }
  if (isPlainObject$1(structure)) {
    const result2 = {};
    for (const key of Object.keys(structure)) {
      result2[key] = deepMergeI18n(
        structure[key],
        i18nChain.map((layer) => layer?.[key])
      );
    }
    return result2;
  }
  return structure;
}
function findBlockTypeInTree(tree, blockId) {
  for (const node of tree) {
    if (node.id === blockId) {
      return node.type;
    }
    if (Array.isArray(node.children) && node.children.length > 0) {
      const found = findBlockTypeInTree(
        node.children,
        blockId
      );
      if (found) return found;
    }
  }
  return null;
}
function splitByNestedSchema(data, schema2) {
  if (schema2 === true) {
    if (isPlainObject$1(data)) {
      const entries = Object.entries(data);
      if (entries.length === 1 && entries[0]?.[0] === I18N_MARKER) {
        return {
          structure: { [I18N_MARKER]: true },
          i18nValues: entries[0][1]
        };
      }
    }
    return {
      structure: { [I18N_MARKER]: true },
      i18nValues: data
    };
  }
  if (data == null) {
    return { structure: data, i18nValues: null };
  }
  if ("_blocks" in schema2 && schema2._blocks !== void 0) {
    return splitBlocksData(data, schema2);
  }
  if ("_item" in schema2 && schema2._item !== void 0) {
    if (!Array.isArray(data)) {
      return { structure: data, i18nValues: null };
    }
    const itemSchema = schema2._item;
    const structureArr = [];
    const i18nArr = [];
    let hasI18n2 = false;
    for (const item of data) {
      const { structure, i18nValues } = splitByNestedSchema(item, itemSchema);
      structureArr.push(structure);
      i18nArr.push(i18nValues);
      if (i18nValues != null) hasI18n2 = true;
    }
    return {
      structure: structureArr,
      i18nValues: hasI18n2 ? i18nArr : null
    };
  }
  if (!isPlainObject$1(data)) {
    return { structure: data, i18nValues: null };
  }
  const obj = data;
  const objSchema = schema2;
  const structureObj = {};
  const i18nObj = {};
  let hasI18n = false;
  for (const [key, value] of Object.entries(obj)) {
    const fieldSchema = objSchema[key];
    if (fieldSchema === void 0) {
      structureObj[key] = value;
    } else {
      const { structure, i18nValues } = splitByNestedSchema(value, fieldSchema);
      structureObj[key] = structure;
      if (i18nValues != null) {
        i18nObj[key] = i18nValues;
        hasI18n = true;
      }
    }
  }
  return {
    structure: structureObj,
    i18nValues: hasI18n ? i18nObj : null
  };
}
function splitBlocksData(data, schema2) {
  if (!isBlocksStructure(data)) {
    return { structure: data, i18nValues: null };
  }
  const blocksData = data;
  const blockSchemas = schema2._blocks;
  const structureValues = {};
  const i18nValuesMap = {};
  let hasI18n = false;
  for (const [blockId, blockValues] of Object.entries(blocksData._values)) {
    const blockType = findBlockTypeInTree(blocksData._tree, blockId);
    if (!blockType) {
      structureValues[blockId] = blockValues;
      continue;
    }
    const blockSchema = blockSchemas[blockType];
    if (!blockSchema) {
      structureValues[blockId] = blockValues;
      continue;
    }
    const { structure, i18nValues } = splitByNestedSchema(
      blockValues,
      blockSchema
    );
    structureValues[blockId] = structure;
    if (i18nValues != null) {
      i18nValuesMap[blockId] = i18nValues;
      hasI18n = true;
    }
  }
  return {
    structure: {
      [TREE_KEY]: blocksData._tree,
      [VALUES_KEY]: structureValues
    },
    i18nValues: hasI18n ? { [VALUES_KEY]: i18nValuesMap } : null
  };
}
const LOCALIZED_COLUMN = "_localized";
function splitLegacyI18nWrappers(value) {
  if (value == null) {
    return { structure: value, i18nValues: null };
  }
  if (isPlainObject$1(value)) {
    const obj = value;
    const entries = Object.entries(obj);
    if (entries.length === 1 && entries[0]?.[0] === "$i18n") {
      return {
        structure: { $i18n: true },
        i18nValues: entries[0][1]
      };
    }
    const structureObj = {};
    const i18nObj = {};
    let hasI18n = false;
    for (const [key, child] of entries) {
      const split = splitLegacyI18nWrappers(child);
      structureObj[key] = split.structure;
      if (split.i18nValues != null) {
        i18nObj[key] = split.i18nValues;
        hasI18n = true;
      }
    }
    return {
      structure: structureObj,
      i18nValues: hasI18n ? i18nObj : null
    };
  }
  if (Array.isArray(value)) {
    const structureArr = [];
    const i18nArr = [];
    let hasI18n = false;
    for (const item of value) {
      const split = splitLegacyI18nWrappers(item);
      structureArr.push(split.structure);
      i18nArr.push(split.i18nValues);
      if (split.i18nValues != null) {
        hasI18n = true;
      }
    }
    return {
      structure: structureArr,
      i18nValues: hasI18n ? i18nArr : null
    };
  }
  return { structure: value, i18nValues: null };
}
function splitLocalizedFields(input, localizedFields, nestedSchemas = {}) {
  const localized = {};
  const nonLocalized = {};
  const nestedLocalized = {};
  let hasNestedLocalized = false;
  const localizedSet = new Set(localizedFields);
  for (const [key, value] of Object.entries(input)) {
    const isTopLevelLocalized = localizedSet.has(key);
    const nestedSchema = nestedSchemas[key];
    if (nestedSchema !== void 0 && value != null) {
      const { structure, i18nValues } = splitByNestedSchema(
        value,
        nestedSchema
      );
      nonLocalized[key] = structure;
      if (i18nValues != null) {
        nestedLocalized[key] = i18nValues;
        hasNestedLocalized = true;
      }
      continue;
    }
    if (isTopLevelLocalized) {
      localized[key] = value;
      continue;
    }
    const split = splitLegacyI18nWrappers(value);
    nonLocalized[key] = split.structure;
    if (split.i18nValues != null) {
      nestedLocalized[key] = split.i18nValues;
      hasNestedLocalized = true;
    }
  }
  return {
    localized,
    nonLocalized,
    nestedLocalized: hasNestedLocalized ? nestedLocalized : null
  };
}
function mergeNestedLocalizedFromColumn(row, localizedCurrent, localizedFallback) {
  const result2 = { ...row };
  for (const [fieldName, value] of Object.entries(row)) {
    if (!hasI18nMarkers(value)) continue;
    const fieldI18nChain = [
      localizedCurrent?.[fieldName],
      localizedFallback?.[fieldName]
    ];
    result2[fieldName] = deepMergeI18n(value, fieldI18nChain);
  }
  return result2;
}
function hasI18nMarkers(value) {
  if (value == null || typeof value !== "object") {
    return false;
  }
  if (typeof value === "object" && value.$i18n === true) {
    return true;
  }
  if (Array.isArray(value)) {
    return value.some(hasI18nMarkers);
  }
  for (const prop of Object.values(value)) {
    if (hasI18nMarkers(prop)) {
      return true;
    }
  }
  return false;
}
function parseLocalizedField$1(localizedField) {
  if (localizedField.endsWith(":nested")) {
    return {
      name: localizedField.slice(0, -7),
      mode: "nested"
    };
  }
  return {
    name: localizedField,
    mode: "whole"
  };
}
const I18N_CURRENT_PREFIX = "_i18n_";
const I18N_FALLBACK_PREFIX = "_i18n_fallback_";
function mergeI18nRow(row, options) {
  const result2 = { ...row };
  for (const localizedField of options.localizedFields) {
    const parsed = parseLocalizedField$1(localizedField);
    if (parsed.mode === "nested") {
      continue;
    }
    const fieldName = parsed.name;
    const currentKey = `${I18N_CURRENT_PREFIX}${fieldName}`;
    const fallbackKey = `${I18N_FALLBACK_PREFIX}${fieldName}`;
    if (!(currentKey in result2)) {
      continue;
    }
    const currentValue = result2[currentKey];
    const fallbackValue = result2[fallbackKey];
    result2[fieldName] = currentValue ?? (options.hasFallback ? fallbackValue : null) ?? null;
    delete result2[currentKey];
    if (options.hasFallback) {
      delete result2[fallbackKey];
    }
  }
  const localizedCurrentKey = `${I18N_CURRENT_PREFIX}${LOCALIZED_COLUMN}`;
  const localizedFallbackKey = `${I18N_FALLBACK_PREFIX}${LOCALIZED_COLUMN}`;
  const localizedCurrent = result2[localizedCurrentKey];
  const localizedFallback = options.hasFallback ? result2[localizedFallbackKey] : null;
  delete result2[localizedCurrentKey];
  if (options.hasFallback) {
    delete result2[localizedFallbackKey];
  }
  const hasNestedMarkers = Object.values(result2).some(hasI18nMarkers);
  if (hasNestedMarkers || localizedCurrent != null || localizedFallback != null) {
    const merged = mergeNestedLocalizedFromColumn(
      result2,
      localizedCurrent,
      localizedFallback
    );
    return merged;
  }
  return result2;
}
function mergeI18nRows(rows, options) {
  return rows.map((row) => mergeI18nRow(row, options));
}
async function appendRealtimeChange(params, context, db, cms2, resourceName, resourceType = "collection") {
  if (!cms2?.realtime) return null;
  const normalized = normalizeContext(context);
  return cms2.realtime.appendChange(
    {
      resourceType,
      resource: resourceName,
      operation: params.operation,
      recordId: params.recordId ?? null,
      locale: normalized.locale ?? null,
      payload: params.payload ?? {}
    },
    { db }
  );
}
async function notifyRealtimeChange(change, cms2) {
  if (!change || !cms2?.realtime) return;
  await cms2.realtime.notify(change);
}
const transactionStorage = new AsyncLocalStorage();
function onAfterCommit(callback) {
  const ctx = transactionStorage.getStore();
  if (ctx) {
    ctx.afterCommit.push(callback);
  } else {
    callback().catch((error2) => {
      console.error(
        "[onAfterCommit] Callback failed outside transaction:",
        error2
      );
    });
  }
}
async function withTransaction(db, fn2) {
  const existingCtx = transactionStorage.getStore();
  if (existingCtx) {
    return fn2(existingCtx.tx);
  }
  const ctx = {
    tx: null,
    afterCommit: []
  };
  const result2 = await transactionStorage.run(ctx, async () => {
    return db.transaction(async (tx) => {
      ctx.tx = tx;
      return fn2(tx);
    });
  });
  for (const callback of ctx.afterCommit) {
    try {
      await callback();
    } catch (error2) {
      console.error("[withTransaction] afterCommit callback failed:", error2);
    }
  }
  return result2;
}
const EXCLUDED_CONTENT_FIELDS = /* @__PURE__ */ new Set([
  "id",
  "_title",
  "createdAt",
  "updatedAt",
  "deletedAt",
  "_locale",
  "_parentId"
]);
function generateAutoContent(record) {
  const parts = [];
  for (const [key, value] of Object.entries(record)) {
    if (EXCLUDED_CONTENT_FIELDS.has(key)) continue;
    if (value == null) continue;
    if (typeof value === "object") continue;
    parts.push(`${key}: ${String(value)}`);
  }
  return parts.join(", ");
}
function isSearchDisabled(state) {
  if (state.searchable === false) return true;
  if (state.searchable?.disabled) return true;
  if (state.searchable?.manual) return true;
  return false;
}
const pendingIndexItems = /* @__PURE__ */ new Map();
let flushTimeout = null;
const DEBOUNCE_DELAY_MS = 100;
function isAsyncIndexingAvailable(cms2) {
  if (!cms2.queue) return false;
  return typeof cms2.queue["index-records"]?.publish === "function";
}
async function flushPendingItems(cms2) {
  if (pendingIndexItems.size === 0) return;
  const items = Array.from(pendingIndexItems.values());
  pendingIndexItems.clear();
  try {
    await cms2.queue["index-records"].publish({ items });
  } catch (error2) {
    console.error("[Search] Failed to dispatch index-records job:", error2);
  }
}
function scheduleAsyncIndex(cms2, collection, recordId) {
  const key = `${collection}:${recordId}`;
  pendingIndexItems.set(key, { collection, recordId });
  if (flushTimeout) {
    clearTimeout(flushTimeout);
  }
  flushTimeout = setTimeout(() => {
    flushTimeout = null;
    flushPendingItems(cms2).catch((err2) => {
      console.error("[Search] Error in debounced flush:", err2);
    });
  }, DEBOUNCE_DELAY_MS);
}
async function indexRecordSync(record, locale, state, cms2, defaultLocale2) {
  const title = record._title || record.id;
  let content2;
  if (state.searchable && typeof state.searchable === "object" && state.searchable.content) {
    content2 = state.searchable.content(record) || void 0;
  } else {
    content2 = generateAutoContent(record) || void 0;
  }
  let metadata;
  if (state.searchable && typeof state.searchable === "object" && state.searchable.metadata) {
    metadata = state.searchable.metadata(record);
  }
  let embedding;
  if (state.searchable && typeof state.searchable === "object" && state.searchable.embeddings) {
    const searchableContext = {
      cms: cms2,
      locale,
      defaultLocale: defaultLocale2
    };
    embedding = await state.searchable.embeddings(record, searchableContext);
  }
  await cms2.search.index({
    collection: state.name,
    recordId: record.id,
    locale,
    title,
    content: content2,
    metadata,
    embedding
  });
}
async function indexAllLocalesSync(record, state, cms2, defaultLocale2) {
  const locales = await cms2.getLocales();
  for (const localeObj of locales) {
    const locale = localeObj.code;
    try {
      const crud = cms2.api.collections[state.name];
      if (!crud) continue;
      const localizedRecord = await crud.findOne({
        where: { id: record.id },
        locale,
        localeFallback: false,
        populate: false
      });
      if (!localizedRecord) continue;
      await indexRecordSync(localizedRecord, locale, state, cms2, defaultLocale2);
    } catch (error2) {
      console.warn(
        `[Search] Failed to index ${state.name}:${record.id} for locale ${locale}:`,
        error2
      );
    }
  }
}
async function indexToSearch(record, context, options) {
  const { cms: cms2, state } = options;
  if (!cms2?.search) return;
  if (isSearchDisabled(state)) return;
  const normalized = normalizeContext(context);
  if (isAsyncIndexingAvailable(cms2)) {
    scheduleAsyncIndex(cms2, state.name, record.id);
  } else {
    await indexAllLocalesSync(record, state, cms2, normalized.defaultLocale);
  }
}
async function removeFromSearch(recordId, _context, options) {
  const { cms: cms2, state } = options;
  if (!cms2?.search) return;
  if (isSearchDisabled(state)) return;
  await cms2.search.remove({
    collection: state.name,
    recordId
    // Note: Not passing locale removes ALL locales for this record
  });
}
function buildOrderByClauses(orderBy, options) {
  const {
    table,
    state,
    i18nCurrentTable,
    i18nFallbackTable,
    useI18n = false
  } = options;
  if (typeof orderBy === "function") {
    return orderBy(table, {
      asc: (col) => sql$1`${col} ASC`,
      desc: (col) => sql$1`${col} DESC`
    });
  }
  const clauses = [];
  for (const [field, direction] of Object.entries(orderBy)) {
    let column = table[field];
    if (useI18n && i18nCurrentTable && state.localized.includes(field)) {
      const i18nCurrentTbl = i18nCurrentTable;
      if (i18nFallbackTable) {
        const i18nFallbackTbl = i18nFallbackTable;
        column = sql$1`COALESCE(${i18nCurrentTbl[field]}, ${i18nFallbackTbl[field]})`;
      } else {
        column = i18nCurrentTbl[field];
      }
    }
    if (column) {
      clauses.push(
        direction === "desc" ? sql$1`${column} DESC` : sql$1`${column} ASC`
      );
    }
  }
  return clauses;
}
function buildLocalizedFieldRef(field, options) {
  const { table, state, i18nCurrentTable, i18nFallbackTable, useI18n } = options;
  const virtualExpression = state.virtuals?.[field];
  if (virtualExpression) {
    return virtualExpression;
  }
  const fieldDef = state.fieldDefinitions?.[field];
  if (fieldDef?.state?.location === "virtual") {
    return void 0;
  }
  if (!useI18n || !i18nCurrentTable || !state.localized.includes(field)) {
    const column = table[field];
    if (column) return column;
    return sql$1.identifier(field);
  }
  const i18nCurrentTbl = i18nCurrentTable;
  if (!i18nFallbackTable) {
    return i18nCurrentTbl[field] ?? sql$1.identifier(field);
  }
  const i18nFallbackTbl = i18nFallbackTable;
  return sql$1`COALESCE(${i18nCurrentTbl[field]}, ${i18nFallbackTbl[field]})`;
}
function isNonQueryableVirtualField(field, state) {
  const fieldDef = state.fieldDefinitions?.[field];
  if (!fieldDef || fieldDef.state.location !== "virtual") {
    return false;
  }
  return !(state.virtuals && field in state.virtuals);
}
function buildWhereClause(where, options) {
  const {
    table,
    state,
    i18nCurrentTable,
    i18nFallbackTable,
    context,
    cms: cms2,
    useI18n = false
  } = options;
  const conditions = [];
  for (const [key, value] of Object.entries(where)) {
    if (key === "AND" && Array.isArray(value)) {
      const subClauses = value.map(
        (w) => buildWhereClause(w, {
          table,
          state,
          i18nCurrentTable,
          i18nFallbackTable,
          context,
          cms: cms2,
          useI18n,
          db: options.db
        })
      ).filter(Boolean);
      if (subClauses.length > 0) {
        conditions.push(and(...subClauses));
      }
    } else if (key === "OR" && Array.isArray(value)) {
      const subClauses = value.map(
        (w) => buildWhereClause(w, {
          table,
          state,
          i18nCurrentTable,
          i18nFallbackTable,
          context,
          cms: cms2,
          useI18n,
          db: options.db
        })
      ).filter(Boolean);
      if (subClauses.length > 0) {
        conditions.push(or(...subClauses));
      }
    } else if (key === "NOT" && typeof value === "object") {
      const subClause = buildWhereClause(value, {
        table,
        state,
        i18nCurrentTable,
        i18nFallbackTable,
        context,
        cms: cms2,
        useI18n,
        db: options.db
      });
      if (subClause) {
        conditions.push(not(subClause));
      }
    } else if (key === "RAW" && typeof value === "function") {
      conditions.push(value(table));
    } else if (typeof value === "object" && value !== null && !Array.isArray(value)) {
      const fieldOperators = [
        "eq",
        "ne",
        "not",
        "gt",
        "gte",
        "lt",
        "lte",
        "in",
        "notIn",
        "like",
        "ilike",
        "notLike",
        "notIlike",
        "contains",
        "startsWith",
        "endsWith",
        "isNull",
        "isNotNull",
        "arrayOverlaps",
        "arrayContained",
        "arrayContains"
      ];
      const relationQuantifiers = ["some", "none", "every", "is", "isNot"];
      const valueKeys = Object.keys(value);
      const hasFieldOperators = valueKeys.some(
        (k) => fieldOperators.includes(k)
      );
      const hasRelationQuantifiers = valueKeys.some(
        (k) => relationQuantifiers.includes(k)
      );
      if (hasFieldOperators && !hasRelationQuantifiers) {
        const column = buildLocalizedFieldRef(key, {
          table,
          state,
          i18nCurrentTable,
          i18nFallbackTable,
          useI18n
        });
        if (!column) {
          if (isNonQueryableVirtualField(key, state)) {
            throw new Error(
              `Field '${key}' uses 'virtual: true' and is not queryable. Use 'virtual: sql\`...\`' to filter by this field.`
            );
          }
          continue;
        }
        for (const [op, val] of Object.entries(value)) {
          const condition = buildOperatorCondition(column, op, val);
          if (condition) conditions.push(condition);
        }
      } else if (state.relations?.[key]) {
        const relation = state.relations[key];
        const relationClause = buildRelationWhereClause(relation, value, {
          parentTable: table,
          context,
          cms: cms2,
          db: options.db
        });
        if (relationClause) {
          conditions.push(relationClause);
        }
      } else {
        const column = buildLocalizedFieldRef(key, {
          table,
          state,
          i18nCurrentTable,
          i18nFallbackTable,
          useI18n
        });
        if (!column) {
          if (isNonQueryableVirtualField(key, state)) {
            throw new Error(
              `Field '${key}' uses 'virtual: true' and is not queryable. Use 'virtual: sql\`...\`' to filter by this field.`
            );
          }
          continue;
        }
        for (const [op, val] of Object.entries(value)) {
          const condition = buildOperatorCondition(column, op, val);
          if (condition) conditions.push(condition);
        }
      }
    } else {
      const column = buildLocalizedFieldRef(key, {
        table,
        state,
        i18nCurrentTable,
        i18nFallbackTable,
        useI18n
      });
      if (!column) {
        if (isNonQueryableVirtualField(key, state)) {
          throw new Error(
            `Field '${key}' uses 'virtual: true' and is not queryable. Use 'virtual: sql\`...\`' to filter by this field.`
          );
        }
        continue;
      }
      if (value === null) {
        conditions.push(sql$1`${column} IS NULL`);
      } else {
        conditions.push(eq(column, value));
      }
    }
  }
  return conditions.length > 0 ? and(...conditions) : void 0;
}
function buildOperatorCondition(column, op, value) {
  switch (op) {
    case "eq":
      return eq(column, value);
    case "ne":
      return sql$1`${column} != ${value}`;
    case "not":
      if (value === null) {
        return sql$1`${column} IS NOT NULL`;
      }
      return sql$1`${column} != ${value}`;
    case "gt":
      return sql$1`${column} > ${value}`;
    case "gte":
      return sql$1`${column} >= ${value}`;
    case "lt":
      return sql$1`${column} < ${value}`;
    case "lte":
      return sql$1`${column} <= ${value}`;
    case "in":
      return Array.isArray(value) ? inArray(column, value) : void 0;
    case "notIn":
      return Array.isArray(value) ? not(inArray(column, value)) : void 0;
    case "like":
      return sql$1`${column} LIKE ${value}`;
    case "ilike":
      return sql$1`${column} ILIKE ${value}`;
    case "notLike":
      return sql$1`${column} NOT LIKE ${value}`;
    case "notIlike":
      return sql$1`${column} NOT ILIKE ${value}`;
    case "contains":
      return sql$1`${column} ILIKE ${`%${value}%`}`;
    case "startsWith":
      return sql$1`${column} ILIKE ${`${value}%`}`;
    case "endsWith":
      return sql$1`${column} ILIKE ${`%${value}`}`;
    case "isNull":
      return value ? sql$1`${column} IS NULL` : sql$1`${column} IS NOT NULL`;
    case "isNotNull":
      return value ? sql$1`${column} IS NOT NULL` : sql$1`${column} IS NULL`;
    case "arrayOverlaps":
      return sql$1`${column} && ${value}`;
    case "arrayContained":
      return sql$1`${column} <@ ${value}`;
    case "arrayContains":
      return sql$1`${column} @> ${value}`;
    default:
      return void 0;
  }
}
function buildRelationWhereClause(relation, relationValue, options) {
  const { cms: cms2 } = options;
  if (!cms2) return void 0;
  const normalizedValue = relationValue === true ? {} : relationValue;
  if (!normalizedValue || typeof normalizedValue !== "object" || Array.isArray(normalizedValue)) {
    return void 0;
  }
  const relationFilter = normalizedValue;
  const hasQuantifiers = ["some", "none", "every", "is", "isNot"].some(
    (key) => key in relationFilter
  );
  const clauses = [];
  if (relation.type === "one") {
    const isWhere = relationFilter.is ?? relationFilter.some ?? (hasQuantifiers ? void 0 : relationFilter);
    const isNotWhere = relationFilter.isNot;
    if (isWhere !== void 0) {
      const existsClause = buildRelationExistsClause(
        relation,
        isWhere,
        options
      );
      if (existsClause) clauses.push(existsClause);
    }
    if (isNotWhere !== void 0) {
      const existsClause = buildRelationExistsClause(
        relation,
        isNotWhere,
        options
      );
      if (existsClause) clauses.push(not(existsClause));
    }
  } else if (relation.type === "many" || relation.type === "manyToMany") {
    const someWhere = relationFilter.some ?? (hasQuantifiers ? void 0 : relationFilter);
    const noneWhere = relationFilter.none;
    const everyWhere = relationFilter.every;
    if (someWhere !== void 0) {
      const existsClause = buildRelationExistsClause(
        relation,
        someWhere,
        options
      );
      if (existsClause) clauses.push(existsClause);
    }
    if (noneWhere !== void 0) {
      const existsClause = buildRelationExistsClause(
        relation,
        noneWhere,
        options
      );
      if (existsClause) clauses.push(not(existsClause));
    }
    if (everyWhere !== void 0) {
      const negatedWhere = { NOT: everyWhere };
      const existsClause = buildRelationExistsClause(
        relation,
        negatedWhere,
        options
      );
      if (existsClause) clauses.push(not(existsClause));
    }
  }
  return clauses.length > 0 ? and(...clauses) : void 0;
}
function buildRelationExistsClause(relation, relationWhere, options) {
  switch (relation.type) {
    case "one":
      return buildBelongsToExistsClause(relation, relationWhere, options);
    case "many":
      return buildHasManyExistsClause(relation, relationWhere, options);
    case "manyToMany":
      return buildManyToManyExistsClause(relation, relationWhere, options);
    default:
      return void 0;
  }
}
function buildBelongsToExistsClause(relation, relationWhere, options) {
  const { cms: cms2, parentTable, context } = options;
  const hasFieldConfig = relation.fields && relation.fields.length > 0 || relation.field;
  if (!cms2 || !hasFieldConfig || !relation.references) {
    return void 0;
  }
  const relatedCrud = cms2.api.collections[relation.collection];
  const relatedTable = relatedCrud["~internalRelatedTable"];
  const relatedState = relatedCrud["~internalState"];
  let joinConditions = [];
  if (relation.field && typeof relation.field === "string") {
    const sourceFieldName = relation.field;
    const sourceColumn = parentTable[sourceFieldName];
    const targetFieldName = Array.isArray(relation.references) ? relation.references[0] : relation.references;
    const targetColumn = targetFieldName ? relatedTable[targetFieldName] : void 0;
    if (sourceColumn && targetColumn) {
      joinConditions.push(eq(targetColumn, sourceColumn));
    }
  } else if (relation.fields && relation.fields.length > 0) {
    joinConditions = relation.fields.map((sourceField, index2) => {
      const refs = relation.references;
      const targetFieldName = refs?.[index2];
      const targetColumn = targetFieldName ? relatedTable[targetFieldName] : void 0;
      const sourceFieldName = sourceField?.name ?? sourceField?.config?.name;
      const sourceColumn = sourceFieldName ? parentTable[sourceFieldName] : void 0;
      return targetColumn && sourceColumn ? eq(targetColumn, sourceColumn) : void 0;
    }).filter(Boolean);
  }
  if (joinConditions.length === 0) return void 0;
  const whereConditions = [...joinConditions];
  if (relationWhere) {
    const nestedClause = buildWhereClause(relationWhere, {
      table: relatedTable,
      state: relatedState,
      i18nCurrentTable: relatedCrud["~internalI18nTable"],
      i18nFallbackTable: null,
      context,
      cms: cms2,
      useI18n: false,
      db: options.db
    });
    if (nestedClause) whereConditions.push(nestedClause);
  }
  if (relatedState.options?.softDelete) {
    whereConditions.push(sql$1`${relatedTable.deletedAt} IS NULL`);
  }
  const db = getDb(options.db, context);
  const subquery = db.select({ one: sql$1`1` }).from(relatedTable).where(and(...whereConditions));
  return sql$1`exists (${subquery})`;
}
function buildHasManyExistsClause(relation, relationWhere, options) {
  const { cms: cms2, parentTable, context } = options;
  if (!cms2 || relation.fields) return void 0;
  const relatedCrud = cms2.api.collections[relation.collection];
  const relatedTable = relatedCrud["~internalRelatedTable"];
  const relatedState = relatedCrud["~internalState"];
  const reverseRelationName = relation.relationName;
  const reverseRelation = reverseRelationName ? relatedState.relations?.[reverseRelationName] : void 0;
  if (!reverseRelation?.fields || !reverseRelation.references?.length) {
    return void 0;
  }
  const joinConditions = reverseRelation.fields.map((foreignField, index2) => {
    const parentFieldName = reverseRelation.references?.[index2];
    const parentColumn = parentFieldName ? parentTable[parentFieldName] : void 0;
    const foreignFieldName = foreignField?.name ?? foreignField?.config?.name;
    const foreignColumn = foreignFieldName ? relatedTable[foreignFieldName] : void 0;
    return parentColumn && foreignColumn ? eq(foreignColumn, parentColumn) : void 0;
  }).filter(Boolean);
  if (joinConditions.length === 0) return void 0;
  const whereConditions = [...joinConditions];
  if (relationWhere) {
    const nestedClause = buildWhereClause(relationWhere, {
      table: relatedTable,
      state: relatedState,
      i18nCurrentTable: relatedCrud["~internalI18nTable"],
      i18nFallbackTable: null,
      context,
      cms: cms2,
      useI18n: false,
      db: options.db
    });
    if (nestedClause) whereConditions.push(nestedClause);
  }
  if (relatedState.options?.softDelete) {
    whereConditions.push(sql$1`${relatedTable.deletedAt} IS NULL`);
  }
  const db = getDb(options.db, context);
  const subquery = db.select({ one: sql$1`1` }).from(relatedTable).where(and(...whereConditions));
  return sql$1`exists (${subquery})`;
}
function buildManyToManyExistsClause(relation, relationWhere, options) {
  const { cms: cms2, parentTable, context } = options;
  if (!cms2 || !relation.through) return void 0;
  const relatedCrud = cms2.api.collections[relation.collection];
  const junctionCrud = cms2.api.collections[relation.through];
  const relatedTable = relatedCrud["~internalRelatedTable"];
  const junctionTable = junctionCrud["~internalRelatedTable"];
  const relatedState = relatedCrud["~internalState"];
  const junctionState = junctionCrud["~internalState"];
  const sourceKey = relation.sourceKey || "id";
  const targetKey = relation.targetKey || "id";
  const sourceField = relation.sourceField;
  const targetField = relation.targetField;
  const parentColumn = parentTable[sourceKey];
  const relatedColumn = relatedTable[targetKey];
  const junctionSourceColumn = sourceField ? junctionTable[sourceField] : void 0;
  const junctionTargetColumn = targetField ? junctionTable[targetField] : void 0;
  if (!parentColumn || !relatedColumn || !junctionSourceColumn || !junctionTargetColumn) {
    return void 0;
  }
  const whereConditions = [eq(junctionSourceColumn, parentColumn)];
  if (relationWhere) {
    const nestedClause = buildWhereClause(relationWhere, {
      table: relatedTable,
      state: relatedState,
      i18nCurrentTable: relatedCrud["~internalI18nTable"],
      i18nFallbackTable: null,
      context,
      cms: cms2,
      useI18n: false,
      db: options.db
    });
    if (nestedClause) whereConditions.push(nestedClause);
  }
  if (junctionState.options?.softDelete) {
    whereConditions.push(sql$1`${junctionTable.deletedAt} IS NULL`);
  }
  if (relatedState.options?.softDelete) {
    whereConditions.push(sql$1`${relatedTable.deletedAt} IS NULL`);
  }
  const db = getDb(options.db, context);
  const subquery = db.select({ one: sql$1`1` }).from(junctionTable).innerJoin(relatedTable, eq(junctionTargetColumn, relatedColumn)).where(and(...whereConditions));
  return sql$1`exists (${subquery})`;
}
function buildSelectObject(columns, extras, context, options) {
  const {
    table,
    state,
    i18nCurrentTable,
    i18nFallbackTable,
    getVirtualsWithAliases
  } = options;
  const select = {
    id: table.id
  };
  const locale = context?.locale;
  const hasFallback = i18nFallbackTable !== null && context?.localeFallback !== false;
  const includedFields = getIncludedFields(columns, state);
  for (const [name2, _column] of Object.entries(state.fields)) {
    if (!includedFields.has(name2)) continue;
    const isLocalizedField = state.localized.includes(name2);
    if (isLocalizedField && i18nCurrentTable && locale) {
      const i18nCurrentTbl = i18nCurrentTable;
      const columnExistsInI18n = i18nCurrentTbl && i18nCurrentTbl[name2];
      if (columnExistsInI18n) {
        select[`${I18N_CURRENT_PREFIX}${name2}`] = i18nCurrentTbl[name2];
        if (hasFallback) {
          const i18nFallbackTbl = i18nFallbackTable;
          select[`${I18N_FALLBACK_PREFIX}${name2}`] = i18nFallbackTbl[name2];
        }
      } else {
        select[name2] = table[name2];
      }
    } else {
      select[name2] = table[name2];
    }
  }
  if (i18nCurrentTable && locale) {
    const i18nCurrentTbl = i18nCurrentTable;
    if (i18nCurrentTbl._localized) {
      select[`${I18N_CURRENT_PREFIX}_localized`] = i18nCurrentTbl._localized;
      if (hasFallback) {
        const i18nFallbackTbl = i18nFallbackTable;
        select[`${I18N_FALLBACK_PREFIX}_localized`] = i18nFallbackTbl._localized;
      }
    }
  }
  const virtuals = getVirtualsWithAliases ? getVirtualsWithAliases(context, i18nCurrentTable, i18nFallbackTable) : state.virtuals;
  for (const [name2, sqlExpr] of Object.entries(virtuals ?? {})) {
    if (!includedFields.has(name2)) continue;
    select[name2] = sqlExpr;
  }
  if (includedFields.has("_title")) {
    let titleExpr = null;
    if (state.title) {
      if (state.localized.includes(state.title) && i18nCurrentTable && locale) {
        titleExpr = buildLocalizedFieldRef(state.title, {
          table,
          state,
          i18nCurrentTable,
          i18nFallbackTable,
          useI18n: true
        });
      } else if (state.title in state.fields) {
        titleExpr = table[state.title];
      } else if (virtuals && state.title in virtuals) {
        titleExpr = virtuals[state.title];
      }
    }
    select._title = titleExpr || table.id;
  }
  if (state.options.timestamps !== false) {
    if (includedFields.has("createdAt")) {
      select.createdAt = table.createdAt;
    }
    if (includedFields.has("updatedAt")) {
      select.updatedAt = table.updatedAt;
    }
  }
  if (state.options.softDelete && includedFields.has("deletedAt")) {
    select.deletedAt = table.deletedAt;
  }
  if (extras) {
    const extrasObj = typeof extras === "function" ? extras(table, { sql: sql$1 }) : extras;
    Object.assign(select, extrasObj);
  }
  return select;
}
function buildVersionsSelectObject(context, options) {
  const {
    versionsTable,
    i18nVersionsCurrentTable,
    i18nVersionsFallbackTable,
    state,
    getVirtualsForVersionsWithAliases
  } = options;
  if (!versionsTable) return {};
  const versionsTbl = versionsTable;
  const select = {
    versionId: versionsTbl.versionId,
    id: versionsTbl.id,
    versionNumber: versionsTbl.versionNumber,
    versionOperation: versionsTbl.versionOperation,
    versionUserId: versionsTbl.versionUserId,
    versionCreatedAt: versionsTbl.versionCreatedAt
  };
  const locale = context.locale;
  const hasFallback = i18nVersionsFallbackTable !== null && context.localeFallback !== false;
  for (const [name2, _column] of Object.entries(state.fields)) {
    if (state.localized.includes(name2)) {
      if (i18nVersionsCurrentTable && locale) {
        const i18nVersionsCurrentTbl = i18nVersionsCurrentTable;
        const columnExistsInI18n = i18nVersionsCurrentTbl && i18nVersionsCurrentTbl[name2];
        if (columnExistsInI18n) {
          select[`${I18N_CURRENT_PREFIX}${name2}`] = i18nVersionsCurrentTbl[name2];
          if (hasFallback) {
            const i18nVersionsFallbackTbl = i18nVersionsFallbackTable;
            select[`${I18N_FALLBACK_PREFIX}${name2}`] = i18nVersionsFallbackTbl[name2];
          }
        }
      }
      continue;
    }
    select[name2] = versionsTbl[name2];
  }
  if (i18nVersionsCurrentTable && locale) {
    const i18nVersionsCurrentTbl = i18nVersionsCurrentTable;
    if (i18nVersionsCurrentTbl._localized) {
      select[`${I18N_CURRENT_PREFIX}_localized`] = i18nVersionsCurrentTbl._localized;
      if (hasFallback) {
        const i18nVersionsFallbackTbl = i18nVersionsFallbackTable;
        select[`${I18N_FALLBACK_PREFIX}_localized`] = i18nVersionsFallbackTbl._localized;
      }
    }
  }
  const versionVirtuals = getVirtualsForVersionsWithAliases ? getVirtualsForVersionsWithAliases(
    context,
    i18nVersionsCurrentTable,
    i18nVersionsFallbackTable
  ) : {};
  if (versionVirtuals) {
    for (const [name2, sqlExpr] of Object.entries(versionVirtuals)) {
      select[name2] = sqlExpr;
    }
  }
  let titleExpr = null;
  if (state.title) {
    if (versionVirtuals && state.title in versionVirtuals) {
      titleExpr = versionVirtuals[state.title];
    } else if (state.localized.includes(state.title) && i18nVersionsCurrentTable) {
      const currentTbl = i18nVersionsCurrentTable;
      if (i18nVersionsFallbackTable) {
        const fallbackTbl = i18nVersionsFallbackTable;
        titleExpr = sql$1`COALESCE(${currentTbl[state.title]}, ${fallbackTbl[state.title]})`;
      } else {
        titleExpr = currentTbl[state.title];
      }
    } else if (state.title in state.fields) {
      titleExpr = versionsTbl[state.title];
    }
  }
  select._title = titleExpr || versionsTbl.id;
  return select;
}
function getIncludedFields(columns, state) {
  const allFields = [
    ...Object.keys(state.fields),
    ...Object.keys(state.virtuals ?? {}),
    "_title",
    "createdAt",
    "updatedAt",
    "deletedAt"
  ];
  if (!columns) {
    return new Set(allFields);
  }
  const included = /* @__PURE__ */ new Set();
  const hasTrueValues = Object.values(columns).some((v) => v === true);
  if (hasTrueValues) {
    for (const [key, value] of Object.entries(columns)) {
      if (value === true) {
        included.add(key);
      }
    }
  } else {
    for (const key of allFields) {
      if (columns[key] !== false) {
        included.add(key);
      }
    }
  }
  included.add("id");
  return included;
}
async function handleCascadeDelete(options) {
  const { record, relations, cms: cms2, context, resolveFieldKey: resolveFieldKey2 } = options;
  for (const [relationName, relation] of Object.entries(relations)) {
    if (relation.onDelete === "restrict") {
      if (relation.type === "many" && !relation.fields) {
        await checkRestrictViolation(
          record,
          relation,
          relationName,
          cms2,
          context,
          resolveFieldKey2
        );
      }
    }
  }
  for (const [_relationName, relation] of Object.entries(relations)) {
    if (!relation.onDelete || relation.onDelete === "no action" || relation.onDelete === "restrict") {
      continue;
    }
    if (relation.type === "many" && !relation.fields) {
      await cascadeDeleteHasMany(
        record,
        relation,
        cms2,
        context,
        resolveFieldKey2
      );
    } else if (relation.type === "manyToMany" && relation.through && relation.onDelete === "cascade") {
      await cascadeDeleteManyToMany(record, relation, cms2, context);
    }
  }
}
async function checkRestrictViolation(record, relation, relationName, cms2, context, resolveFieldKey2) {
  const reverseRelationName = relation.relationName;
  if (!reverseRelationName) return;
  const relatedCrud = cms2.api.collections[relation.collection];
  if (!relatedCrud) return;
  const reverseRelation = relatedCrud["~internalState"].relations?.[reverseRelationName];
  if (!reverseRelation?.fields || reverseRelation.fields.length === 0) return;
  const foreignKeyField = resolveFieldKey2(
    relatedCrud["~internalState"],
    reverseRelation.fields[0],
    relatedCrud["~internalRelatedTable"]
  ) ?? reverseRelation.fields[0].name;
  const primaryKeyField = reverseRelation.references?.[0] || "id";
  const { totalDocs } = await relatedCrud.find(
    {
      where: { [foreignKeyField]: { eq: record[primaryKeyField] } },
      limit: 1
    },
    context
  );
  if (totalDocs > 0) {
    throw new Error(
      `Cannot delete: related records exist in "${relation.collection}" (relation: ${relationName}, onDelete: restrict)`
    );
  }
}
async function cascadeDeleteHasMany(record, relation, cms2, context, resolveFieldKey2) {
  const reverseRelationName = relation.relationName;
  if (!reverseRelationName) return;
  const relatedCrud = cms2.api.collections[relation.collection];
  const reverseRelation = relatedCrud["~internalState"].relations?.[reverseRelationName];
  if (!reverseRelation?.fields || reverseRelation.fields.length === 0) return;
  const foreignKeyField = resolveFieldKey2(
    relatedCrud["~internalState"],
    reverseRelation.fields[0],
    relatedCrud["~internalRelatedTable"]
  ) ?? reverseRelation.fields[0].name;
  const primaryKeyField = reverseRelation.references?.[0] || "id";
  if (relation.onDelete === "cascade") {
    const { docs: relatedRecords } = await relatedCrud.find(
      {
        where: { [foreignKeyField]: { eq: record[primaryKeyField] } }
      },
      context
    );
    if (relatedRecords.length > 0) {
      for (const relatedRecord of relatedRecords) {
        await relatedCrud.deleteById({ id: relatedRecord.id }, context);
      }
    }
  } else if (relation.onDelete === "set null") {
    await relatedCrud.update(
      {
        where: { [foreignKeyField]: { eq: record[primaryKeyField] } },
        data: { [foreignKeyField]: null }
      },
      context
    );
  }
}
async function cascadeDeleteManyToMany(record, relation, cms2, context) {
  const sourceField = relation.sourceField;
  const sourceKey = relation.sourceKey || "id";
  if (!sourceField || !relation.through) return;
  const junctionCrud = cms2.api.collections[relation.through];
  const { docs: junctionRecords } = await junctionCrud.find(
    {
      where: { [sourceField]: { eq: record[sourceKey] } }
    },
    context
  );
  if (junctionRecords.length > 0) {
    for (const junctionRecord of junctionRecords) {
      await junctionCrud.deleteById({ id: junctionRecord.id }, context);
    }
  }
}
function separateNestedRelations(input, relationNames) {
  const regularFields = {};
  const nestedRelations = {};
  for (const [key, value] of Object.entries(input)) {
    if (relationNames.has(key) && typeof value === "object" && value !== null) {
      nestedRelations[key] = value;
    } else {
      regularFields[key] = value;
    }
  }
  return { regularFields, nestedRelations };
}
function extractBelongsToConnectValues(regularFields, nestedRelations, relations, resolveFieldKey2, state, table) {
  const updatedFields = { ...regularFields };
  const remainingRelations = { ...nestedRelations };
  for (const [relationName, operations] of Object.entries(nestedRelations)) {
    const relation = relations[relationName];
    if (!relation || relation.type !== "one" || !relation.fields?.length) {
      continue;
    }
    if (!operations?.connect) {
      continue;
    }
    const fieldKeys = relation.fields.map((field) => resolveFieldKey2(state, field, table) ?? field?.name).filter(Boolean);
    if (fieldKeys.length !== 1) {
      continue;
    }
    const foreignKeyField = fieldKeys[0];
    if (Array.isArray(operations.connect)) {
      if (operations.connect.length === 1) {
        updatedFields[foreignKeyField] = operations.connect[0].id;
      }
    } else {
      updatedFields[foreignKeyField] = operations.connect.id;
    }
    const { connect, ...restOperations } = operations;
    if (Object.keys(restOperations).length === 0) {
      delete remainingRelations[relationName];
    } else {
      remainingRelations[relationName] = restOperations;
    }
  }
  return {
    regularFields: updatedFields,
    nestedRelations: remainingRelations
  };
}
async function applyBelongsToRelations(regularFields, nestedRelations, relations, cms2, context, tx, resolveFieldKey2, state, table) {
  const updatedFields = { ...regularFields };
  const remainingRelations = { ...nestedRelations };
  for (const [relationName, operations] of Object.entries(nestedRelations)) {
    const relation = relations[relationName];
    if (!relation || relation.type !== "one" || !relation.fields?.length) {
      continue;
    }
    const actionKeys = ["connect", "create", "connectOrCreate"].filter(
      (key) => operations?.[key] !== void 0
    );
    if (actionKeys.length === 0) {
      delete remainingRelations[relationName];
      continue;
    }
    if (actionKeys.length > 1) {
      throw ApiError.badRequest(
        `Nested relation "${relationName}" supports only one operation at a time.`
      );
    }
    const fieldKeys = relation.fields.map((field) => resolveFieldKey2(state, field, table) ?? field?.name).filter(Boolean);
    if (fieldKeys.length !== 1) {
      throw ApiError.badRequest(
        `Nested relation "${relationName}" requires exactly one foreign key field.`
      );
    }
    const foreignKeyField = fieldKeys[0];
    const referenceKey = relation.references?.[0] || "id";
    const relatedCrud = cms2.api.collections[relation.collection];
    if (operations.connect) {
      if (Array.isArray(operations.connect)) {
        if (operations.connect.length !== 1) {
          throw ApiError.badRequest(
            `Nested relation "${relationName}" supports a single connect target.`
          );
        }
        updatedFields[foreignKeyField] = operations.connect[0].id;
      } else {
        updatedFields[foreignKeyField] = operations.connect.id;
      }
    } else if (operations.create) {
      if (Array.isArray(operations.create)) {
        throw ApiError.badRequest(
          `Nested relation "${relationName}" supports a single create payload.`
        );
      }
      const created = await relatedCrud.create(operations.create, {
        ...context,
        db: tx
      });
      updatedFields[foreignKeyField] = created?.[referenceKey] ?? created?.id;
    } else if (operations.connectOrCreate) {
      if (Array.isArray(operations.connectOrCreate)) {
        throw ApiError.badRequest(
          `Nested relation "${relationName}" supports a single connectOrCreate payload.`
        );
      }
      const existing = await relatedCrud.findOne(
        { where: operations.connectOrCreate.where },
        { ...context, db: tx }
      );
      const target = existing ? existing : await relatedCrud.create(operations.connectOrCreate.create, {
        ...context,
        db: tx
      });
      updatedFields[foreignKeyField] = target?.[referenceKey] ?? target?.id;
    }
    delete remainingRelations[relationName];
  }
  return {
    regularFields: updatedFields,
    nestedRelations: remainingRelations
  };
}
async function processHasManyNestedOperations(parentRecord, operations, relation, relatedCrud, reverseRelation, context, tx, resolveFieldKey2) {
  const foreignKeyField = resolveFieldKey2(
    relatedCrud["~internalState"],
    reverseRelation.fields[0],
    relatedCrud["~internalRelatedTable"]
  ) ?? reverseRelation.fields[0].name;
  const primaryKeyField = reverseRelation.references?.[0] || "id";
  if (operations.create) {
    const createInputs = Array.isArray(operations.create) ? operations.create : [operations.create];
    for (const createInput of createInputs) {
      await relatedCrud.create(
        {
          ...createInput,
          [foreignKeyField]: parentRecord[primaryKeyField]
        },
        { ...context, db: tx }
      );
    }
  }
  if (operations.connect) {
    const connectInputs = Array.isArray(operations.connect) ? operations.connect : [operations.connect];
    for (const connectInput of connectInputs) {
      await relatedCrud.updateById(
        {
          id: connectInput.id,
          data: { [foreignKeyField]: parentRecord[primaryKeyField] }
        },
        { ...context, db: tx }
      );
    }
  }
  if (operations.connectOrCreate) {
    const connectOrCreateInputs = Array.isArray(operations.connectOrCreate) ? operations.connectOrCreate : [operations.connectOrCreate];
    for (const connectOrCreateInput of connectOrCreateInputs) {
      const existing = await relatedCrud.findOne(
        { where: connectOrCreateInput.where },
        { ...context, db: tx }
      );
      if (existing) {
        await relatedCrud.updateById(
          {
            id: existing.id,
            data: { [foreignKeyField]: parentRecord[primaryKeyField] }
          },
          { ...context, db: tx }
        );
      } else {
        await relatedCrud.create(
          {
            ...connectOrCreateInput.create,
            [foreignKeyField]: parentRecord[primaryKeyField]
          },
          { ...context, db: tx }
        );
      }
    }
  }
}
async function processManyToManyNestedOperations(parentRecord, operations, relation, junctionCrud, relatedCrud, context, tx) {
  const sourceField = relation.sourceField;
  const targetField = relation.targetField;
  const sourceKey = relation.sourceKey || "id";
  if (Array.isArray(operations)) {
    await handleManyToManySet(
      parentRecord,
      operations.map((item) => typeof item === "string" ? item : item?.id).filter(Boolean),
      sourceField,
      targetField,
      sourceKey,
      junctionCrud,
      context,
      tx
    );
    return;
  }
  if (operations.set) {
    const setInputs = Array.isArray(operations.set) ? operations.set : [operations.set];
    const newIds = setInputs.map((item) => typeof item === "string" ? item : item?.id).filter(Boolean);
    await handleManyToManySet(
      parentRecord,
      newIds,
      sourceField,
      targetField,
      sourceKey,
      junctionCrud,
      context,
      tx
    );
  }
  if (operations.create) {
    const createInputs = Array.isArray(operations.create) ? operations.create : [operations.create];
    for (const createInput of createInputs) {
      const relatedRecord = await relatedCrud.create(createInput, {
        ...context,
        db: tx
      });
      await junctionCrud.create(
        {
          [sourceField]: parentRecord[sourceKey],
          [targetField]: relatedRecord.id
        },
        { ...context, db: tx }
      );
    }
  }
  if (operations.connect) {
    const connectInputs = Array.isArray(operations.connect) ? operations.connect : [operations.connect];
    for (const connectInput of connectInputs) {
      await junctionCrud.create(
        {
          [sourceField]: parentRecord[sourceKey],
          [targetField]: connectInput.id
        },
        { ...context, db: tx }
      );
    }
  }
  if (operations.connectOrCreate) {
    const connectOrCreateInputs = Array.isArray(operations.connectOrCreate) ? operations.connectOrCreate : [operations.connectOrCreate];
    for (const connectOrCreateInput of connectOrCreateInputs) {
      const existing = await relatedCrud.findOne(
        { where: connectOrCreateInput.where },
        { ...context, db: tx }
      );
      const targetId = existing ? existing.id : (await relatedCrud.create(connectOrCreateInput.create, {
        ...context,
        db: tx
      })).id;
      await junctionCrud.create(
        {
          [sourceField]: parentRecord[sourceKey],
          [targetField]: targetId
        },
        { ...context, db: tx }
      );
    }
  }
}
async function handleManyToManySet(parentRecord, newIds, sourceField, targetField, sourceKey, junctionCrud, context, tx) {
  const currentJunctions = await junctionCrud.find(
    { where: { [sourceField]: parentRecord[sourceKey] } },
    { ...context, db: tx }
  );
  const currentIds = currentJunctions.docs.map(
    (j) => j[targetField]
  );
  const toConnect = newIds.filter((id) => !currentIds.includes(id));
  const toDisconnect = currentIds.filter((id) => !newIds.includes(id));
  for (const targetId of toConnect) {
    await junctionCrud.create(
      {
        [sourceField]: parentRecord[sourceKey],
        [targetField]: targetId
      },
      { ...context, db: tx }
    );
  }
  for (const targetId of toDisconnect) {
    await junctionCrud.delete(
      {
        where: {
          AND: [
            { [sourceField]: parentRecord[sourceKey] },
            { [targetField]: targetId }
          ]
        }
      },
      { ...context, db: tx }
    );
  }
}
async function processNestedRelations(options) {
  const {
    parentRecord,
    nestedRelations,
    relations,
    cms: cms2,
    context,
    tx,
    resolveFieldKey: resolveFieldKey2
  } = options;
  for (const [relationName, operations] of Object.entries(nestedRelations)) {
    const relation = relations[relationName];
    if (!relation) continue;
    if (relation.type === "one" && relation.fields && relation.fields.length > 0) {
      continue;
    }
    if (relation.type === "many" && !relation.fields) {
      const reverseRelationName = relation.relationName;
      if (!reverseRelationName) continue;
      const relatedCrud = cms2.api.collections[relation.collection];
      const reverseRelation = relatedCrud["~internalState"].relations?.[reverseRelationName];
      if (!reverseRelation?.fields || reverseRelation.fields.length === 0)
        continue;
      await processHasManyNestedOperations(
        parentRecord,
        operations,
        relation,
        relatedCrud,
        reverseRelation,
        context,
        tx,
        resolveFieldKey2
      );
    } else if (relation.type === "manyToMany" && relation.through) {
      const sourceField = relation.sourceField;
      const targetField = relation.targetField;
      if (!sourceField || !targetField) continue;
      const junctionCrud = cms2.api.collections[relation.through];
      const relatedCrud = cms2.api.collections[relation.collection];
      await processManyToManyNestedOperations(
        parentRecord,
        operations,
        relation,
        junctionCrud,
        relatedCrud,
        context,
        tx
      );
    }
  }
}
async function resolveBelongsToRelation(options) {
  const {
    rows,
    relationName,
    relation,
    relatedCrud,
    nestedOptions,
    context,
    resolveFieldKey: resolveFieldKey2,
    sourceState,
    sourceTable
  } = options;
  if (rows.length === 0) return;
  let sourceFieldName;
  let targetFieldName;
  if (typeof relation.field === "string") {
    sourceFieldName = relation.field;
    targetFieldName = Array.isArray(relation.references) ? relation.references[0] : relation.references;
  } else {
    const sourceField = relation.fields?.[0];
    sourceFieldName = sourceField ? resolveFieldKey2(sourceState, sourceField, sourceTable) ?? sourceField.name : void 0;
    targetFieldName = Array.isArray(relation.references) ? relation.references[0] : relation.references?.[0];
  }
  if (!sourceFieldName || !targetFieldName) return;
  const sourceIds = new Set(
    rows.map((row) => row[sourceFieldName]).filter((id) => id !== null && id !== void 0)
  );
  if (sourceIds.size === 0) return;
  const { docs: relatedRows } = await relatedCrud.find(
    {
      ...nestedOptions,
      where: {
        ...nestedOptions.where || {},
        [targetFieldName]: { in: Array.from(sourceIds) }
      }
    },
    context
  );
  const relatedMap = /* @__PURE__ */ new Map();
  for (const row of relatedRows) {
    relatedMap.set(row[targetFieldName], row);
  }
  for (const row of rows) {
    const sourceId = row[sourceFieldName];
    if (sourceId !== null && sourceId !== void 0) {
      row[relationName] = relatedMap.get(sourceId) || null;
    } else {
      row[relationName] = null;
    }
  }
}
async function resolveHasManyRelation(options) {
  const {
    rows,
    relationName,
    relation,
    relatedCrud,
    nestedOptions,
    context,
    resolveFieldKey: resolveFieldKey2
  } = options;
  if (rows.length === 0) return;
  const reverseRelationName = relation.relationName;
  if (!reverseRelationName) return;
  const reverseRelation = relatedCrud["~internalState"].relations?.[reverseRelationName];
  if (!reverseRelation?.fields || reverseRelation.fields.length === 0) return;
  const foreignKeyField = resolveFieldKey2(
    relatedCrud["~internalState"],
    reverseRelation.fields[0],
    relatedCrud["~internalRelatedTable"]
  ) ?? reverseRelation.fields[0].name;
  const primaryKeyField = reverseRelation.references?.[0] || "id";
  const parentIds = new Set(
    rows.map((row) => row[primaryKeyField]).filter((id) => id !== null && id !== void 0)
  );
  if (parentIds.size === 0) return;
  const relatedWhere = {
    [foreignKeyField]: { in: Array.from(parentIds) }
  };
  if (nestedOptions.where) {
    relatedWhere.AND = [nestedOptions.where];
  }
  const queryOptions = { ...nestedOptions };
  if (queryOptions.columns) {
    queryOptions.columns = {
      ...queryOptions.columns,
      [foreignKeyField]: true
    };
  }
  const { docs: relatedRows } = await relatedCrud.find(
    {
      ...queryOptions,
      where: relatedWhere
    },
    context
  );
  const relatedMap = /* @__PURE__ */ new Map();
  for (const relatedRow of relatedRows) {
    const parentId = relatedRow[foreignKeyField];
    if (!relatedMap.has(parentId)) {
      relatedMap.set(parentId, []);
    }
    relatedMap.get(parentId)?.push(relatedRow);
  }
  for (const row of rows) {
    const parentId = row[primaryKeyField];
    row[relationName] = relatedMap.get(parentId) || [];
  }
}
async function resolveHasManyWithAggregation(options) {
  const {
    rows,
    relationName,
    relation,
    relatedCrud,
    nestedOptions,
    context,
    db,
    resolveFieldKey: resolveFieldKey2,
    buildWhereClause: buildWhereClause2,
    cms: cms2
  } = options;
  if (rows.length === 0) return;
  const reverseRelationName = relation.relationName;
  if (!reverseRelationName) return;
  const reverseRelation = relatedCrud["~internalState"].relations?.[reverseRelationName];
  if (!reverseRelation?.fields || reverseRelation.fields.length === 0) return;
  const foreignKeyField = resolveFieldKey2(
    relatedCrud["~internalState"],
    reverseRelation.fields[0],
    relatedCrud["~internalRelatedTable"]
  ) ?? reverseRelation.fields[0].name;
  const primaryKeyField = reverseRelation.references?.[0] || "id";
  const parentIds = new Set(
    rows.map((row) => row[primaryKeyField]).filter((id) => id !== null && id !== void 0)
  );
  if (parentIds.size === 0) return;
  const relatedTable = relatedCrud["~internalRelatedTable"];
  const foreignKeyCol = relatedTable[foreignKeyField];
  const selectClause = {
    [foreignKeyField]: foreignKeyCol
  };
  if (nestedOptions._count) {
    selectClause._count = count().as("_count");
  }
  if (nestedOptions._aggregate) {
    const agg = nestedOptions._aggregate;
    if (agg._count) {
      selectClause._count = count().as("_count");
    }
    if (agg._sum) {
      for (const [field, enabled] of Object.entries(agg._sum)) {
        if (enabled && relatedTable[field]) {
          selectClause[`_sum_${field}`] = sum(relatedTable[field]).as(
            `_sum_${field}`
          );
        }
      }
    }
    if (agg._avg) {
      for (const [field, enabled] of Object.entries(agg._avg)) {
        if (enabled && relatedTable[field]) {
          selectClause[`_avg_${field}`] = avg(relatedTable[field]).as(
            `_avg_${field}`
          );
        }
      }
    }
    if (agg._min) {
      for (const [field, enabled] of Object.entries(agg._min)) {
        if (enabled && relatedTable[field]) {
          selectClause[`_min_${field}`] = min$1(relatedTable[field]).as(
            `_min_${field}`
          );
        }
      }
    }
    if (agg._max) {
      for (const [field, enabled] of Object.entries(agg._max)) {
        if (enabled && relatedTable[field]) {
          selectClause[`_max_${field}`] = max$1(relatedTable[field]).as(
            `_max_${field}`
          );
        }
      }
    }
  }
  const whereConditions = [
    inArray(foreignKeyCol, Array.from(parentIds))
  ];
  if (nestedOptions.where) {
    const additionalWhere = buildWhereClause2(nestedOptions.where, {
      table: relatedTable,
      state: relatedCrud["~internalState"],
      i18nCurrentTable: relatedCrud["~internalI18nTable"],
      i18nFallbackTable: null,
      context,
      cms: cms2,
      useI18n: false,
      db
    });
    if (additionalWhere) {
      whereConditions.push(additionalWhere);
    }
  }
  const aggregateResults = await db.select(selectClause).from(relatedTable).where(and(...whereConditions)).groupBy(foreignKeyCol);
  const aggregateMap = /* @__PURE__ */ new Map();
  for (const result2 of aggregateResults) {
    const parentId = result2[foreignKeyField];
    const aggData = {};
    if (result2._count !== void 0) {
      aggData._count = Number(result2._count);
    }
    for (const key of Object.keys(result2)) {
      if (key.startsWith("_sum_")) {
        if (!aggData._sum) aggData._sum = {};
        aggData._sum[key.replace("_sum_", "")] = Number(result2[key]) || 0;
      } else if (key.startsWith("_avg_")) {
        if (!aggData._avg) aggData._avg = {};
        aggData._avg[key.replace("_avg_", "")] = Number(result2[key]) || 0;
      } else if (key.startsWith("_min_")) {
        if (!aggData._min) aggData._min = {};
        aggData._min[key.replace("_min_", "")] = result2[key];
      } else if (key.startsWith("_max_")) {
        if (!aggData._max) aggData._max = {};
        aggData._max[key.replace("_max_", "")] = result2[key];
      }
    }
    aggregateMap.set(parentId, aggData);
  }
  for (const row of rows) {
    const parentId = row[primaryKeyField];
    row[relationName] = aggregateMap.get(parentId) || { _count: 0 };
  }
}
async function resolveManyToManyRelation(options) {
  const {
    rows,
    relationName,
    relation,
    junctionCrud,
    relatedCrud,
    nestedOptions,
    context
  } = options;
  if (rows.length === 0) return;
  const sourceKey = relation.sourceKey || "id";
  const targetKey = relation.targetKey || "id";
  const sourceField = relation.sourceField;
  const targetField = relation.targetField;
  if (!sourceField || !targetField) return;
  const sourceIds = new Set(
    rows.map((row) => row[sourceKey]).filter((id) => id !== null && id !== void 0)
  );
  if (sourceIds.size === 0) return;
  const { docs: junctionRows } = await junctionCrud.find(
    {
      where: { [sourceField]: { in: Array.from(sourceIds) } }
    },
    context
  );
  if (!junctionRows.length) {
    for (const row of rows) {
      row[relationName] = [];
    }
    return;
  }
  const targetIds = [
    ...new Set(
      junctionRows.map((row) => row[targetField]).filter((id) => id !== null && id !== void 0)
    )
  ];
  if (!targetIds.length) {
    for (const row of rows) {
      row[relationName] = [];
    }
    return;
  }
  const relatedWhere = {
    [targetKey]: { in: targetIds }
  };
  if (nestedOptions.where) {
    relatedWhere.AND = [nestedOptions.where];
  }
  const { docs: relatedRows } = await relatedCrud.find(
    {
      ...nestedOptions,
      where: relatedWhere
    },
    context
  );
  const junctionMap = /* @__PURE__ */ new Map();
  for (const j of junctionRows) {
    const junctionRow = j;
    const sid = junctionRow[sourceField];
    if (!junctionMap.has(sid)) {
      junctionMap.set(sid, []);
    }
    junctionMap.get(sid)?.push(junctionRow[targetField]);
  }
  const relatedMap = /* @__PURE__ */ new Map();
  for (const row of relatedRows) {
    relatedMap.set(row[targetKey], row);
  }
  for (const row of rows) {
    const sourceId = row[sourceKey];
    const relatedIds = junctionMap.get(sourceId) || [];
    row[relationName] = relatedIds.map((tid) => relatedMap.get(tid)).filter((rel) => rel !== void 0);
  }
}
async function createVersionRecord(options) {
  const {
    tx,
    row,
    operation,
    versionsTable,
    i18nVersionsTable,
    i18nTable,
    options: collectionOptions,
    context
  } = options;
  const maxVersionQuery = await tx.select({
    max: sql$1`MAX(${versionsTable.versionNumber})`
  }).from(versionsTable).where(eq(versionsTable.id, row.id));
  const currentVersion = maxVersionQuery[0]?.max || 0;
  const newVersion = Number(currentVersion) + 1;
  await tx.insert(versionsTable).values({
    ...row,
    versionNumber: newVersion,
    versionOperation: operation,
    versionUserId: context.session?.user?.id ? String(context.session.user.id) : null,
    versionCreatedAt: /* @__PURE__ */ new Date()
  });
  if (i18nVersionsTable && i18nTable) {
    const i18nRows = await tx.select().from(i18nTable).where(eq(i18nTable.parentId, row.id));
    if (i18nRows.length > 0) {
      const insertRows = i18nRows.map((i18nRow) => {
        const { id: _id, parentId: _parentId, ...rest } = i18nRow;
        return {
          parentId: row.id,
          versionNumber: newVersion,
          ...rest
        };
      });
      await tx.insert(i18nVersionsTable).values(insertRows);
    }
  }
  const versioningConfig = collectionOptions.versioning;
  if (typeof versioningConfig === "object" && versioningConfig.maxVersions) {
    await cleanupOldVersions(
      tx,
      row.id,
      versioningConfig.maxVersions,
      versionsTable,
      i18nVersionsTable
    );
  }
}
async function cleanupOldVersions(tx, recordId, maxVersions, versionsTable, i18nVersionsTable) {
  const versionsToDelete = await tx.select({ versionNumber: versionsTable.versionNumber }).from(versionsTable).where(eq(versionsTable.id, recordId)).orderBy(sql$1`${versionsTable.versionNumber} DESC`).offset(maxVersions);
  if (versionsToDelete.length > 0) {
    const versionNumbers = versionsToDelete.map((v) => v.versionNumber);
    await tx.delete(versionsTable).where(
      and(
        eq(versionsTable.id, recordId),
        inArray(versionsTable.versionNumber, versionNumbers)
      )
    );
    if (i18nVersionsTable) {
      await tx.delete(i18nVersionsTable).where(
        and(
          eq(i18nVersionsTable.parentId, recordId),
          inArray(i18nVersionsTable.versionNumber, versionNumbers)
        )
      );
    }
  }
}
const cmsContextStorage = new AsyncLocalStorage();
function runWithContext(ctx, fn2) {
  return cmsContextStorage.run(ctx, fn2);
}
function getRequest(context) {
  const maybeReq = context.req ?? context.request;
  if (maybeReq instanceof Request) {
    return maybeReq;
  }
  if (typeof Request !== "undefined") {
    return new Request("http://questpie.local");
  }
  return {};
}
function createFieldHookContext(params) {
  return {
    field: params.fieldName,
    collection: params.collectionName,
    operation: params.operation,
    req: getRequest(params.context),
    user: params.context.session?.user,
    doc: params.document,
    originalValue: params.originalValue,
    db: params.db,
    config: params.config
  };
}
async function applyFieldInputHooks(params) {
  if (!params.fieldDefinitions) return params.data;
  const nextData = { ...params.data };
  for (const [fieldName, fieldDef] of Object.entries(params.fieldDefinitions)) {
    if (!(fieldName in nextData)) continue;
    const hooks = fieldDef.state.config?.hooks;
    if (!hooks) continue;
    const fieldConfig = fieldDef.state.config ?? {};
    let value = nextData[fieldName];
    const document = {
      ...params.originalDocument ?? {},
      ...nextData
    };
    const hookContext = createFieldHookContext({
      fieldName,
      collectionName: params.collectionName,
      operation: params.operation,
      context: params.context,
      db: params.db,
      config: fieldConfig,
      document,
      originalValue: params.originalDocument?.[fieldName]
    });
    if (hooks.validate) {
      await hooks.validate(value, hookContext);
    }
    if (params.operation === "create" && hooks.beforeCreate) {
      value = await hooks.beforeCreate(value, hookContext);
    }
    if (params.operation === "update" && hooks.beforeUpdate) {
      value = await hooks.beforeUpdate(value, hookContext);
    }
    if (hooks.beforeChange) {
      value = await hooks.beforeChange(value, hookContext);
    }
    nextData[fieldName] = value;
  }
  return nextData;
}
async function applyFieldOutputHooks(params) {
  if (!params.fieldDefinitions) return;
  for (const [fieldName, fieldDef] of Object.entries(params.fieldDefinitions)) {
    if (!(fieldName in params.data)) continue;
    const hooks = fieldDef.state.config?.hooks;
    if (!hooks?.afterRead) continue;
    const fieldConfig = fieldDef.state.config ?? {};
    const hookContext = createFieldHookContext({
      fieldName,
      collectionName: params.collectionName,
      operation: params.operation,
      context: params.context,
      db: params.db,
      config: fieldConfig,
      document: params.data,
      originalValue: params.originalDocument?.[fieldName]
    });
    params.data[fieldName] = await hooks.afterRead(
      params.data[fieldName],
      hookContext
    );
  }
}
class CRUDGenerator {
  constructor(state, table, i18nTable, versionsTable, i18nVersionsTable, db, _getVirtuals, getVirtualsWithAliases, getTitleExpression, getVirtualsForVersions, getVirtualsForVersionsWithAliases, getTitleExpressionForVersions, _getRawTitleExpression, cms2) {
    this.state = state;
    this.table = table;
    this.i18nTable = i18nTable;
    this.versionsTable = versionsTable;
    this.i18nVersionsTable = i18nVersionsTable;
    this.db = db;
    this.getVirtualsWithAliases = getVirtualsWithAliases;
    this.getTitleExpression = getTitleExpression;
    this.getVirtualsForVersions = getVirtualsForVersions;
    this.getVirtualsForVersionsWithAliases = getVirtualsForVersionsWithAliases;
    this.getTitleExpressionForVersions = getTitleExpressionForVersions;
    this.cms = cms2;
  }
  // Public accessors for internal use by relation resolution
  get relatedTable() {
    return this.table;
  }
  /**
   * Get localized field names.
   * Uses field definitions (new API) or state.localized array (legacy API).
   */
  getLocalizedFieldNames() {
    if (this.state.fieldDefinitions) {
      return extractLocalizedFieldNames(this.state.fieldDefinitions);
    }
    return this.state.localized ?? [];
  }
  /**
   * Check if collection has any localized fields.
   */
  hasLocalizedFieldsInternal() {
    return this.getLocalizedFieldNames().length > 0;
  }
  /**
   * Generate CRUD operations
   */
  generate() {
    const find2 = this.wrapWithCMSContext(this.createFind());
    const findOne = this.wrapWithCMSContext(this.createFindOne());
    const updateMany = this.wrapWithCMSContext(this.createUpdateMany());
    const deleteMany = this.wrapWithCMSContext(this.createDeleteMany());
    const restoreById = this.wrapWithCMSContext(this.createRestore());
    const crud = {
      find: find2,
      findOne,
      count: this.wrapWithCMSContext(this.createCount()),
      create: this.wrapWithCMSContext(this.createCreate()),
      updateById: this.wrapWithCMSContext(this.createUpdate()),
      update: updateMany,
      deleteById: this.wrapWithCMSContext(this.createDelete()),
      delete: deleteMany,
      restoreById,
      findVersions: this.wrapWithCMSContext(this.createFindVersions()),
      revertToVersion: this.wrapWithCMSContext(this.createRevertToVersion())
    };
    if (this.state.upload) {
      crud.upload = this.wrapWithCMSContext(this.createUpload());
      crud.uploadMany = this.wrapWithCMSContext(this.createUploadMany());
    }
    crud["~internalState"] = this.state;
    crud["~internalRelatedTable"] = this.table;
    crud["~internalI18nTable"] = this.i18nTable;
    return crud;
  }
  getDb(context) {
    return getDb(this.db, context);
  }
  /**
   * Normalize context with defaults
   * Delegates to shared normalizeContext utility
   */
  normalizeContext(context = {}) {
    return normalizeContext(context);
  }
  wrapWithCMSContext(fn2) {
    return fn2;
  }
  getFieldAccessRules() {
    const collectionAccess = this.state.access;
    return collectionAccess?.fields;
  }
  async runFieldInputHooks(data, operation, context, db, originalDocument) {
    return applyFieldInputHooks({
      data,
      fieldDefinitions: this.state.fieldDefinitions,
      collectionName: this.state.name,
      operation,
      context,
      db,
      originalDocument
    });
  }
  async runFieldOutputHooks(data, operation, context, db, originalDocument) {
    await applyFieldOutputHooks({
      data,
      fieldDefinitions: this.state.fieldDefinitions,
      collectionName: this.state.name,
      operation,
      context,
      db,
      originalDocument
    });
  }
  /**
   * Internal find execution - shared logic for find and findOne
   * Reduces code duplication between the two methods
   *
   * @param options - Query options (FindManyOptions or FindOneOptions)
   * @param context - CRUD context
   * @param mode - 'many' for paginated results, 'one' for single result
   */
  async _executeFind(options, context, mode) {
    const normalized = this.normalizeContext(context);
    const db = this.getDb(normalized);
    await this.executeHooks(
      this.state.hooks?.beforeOperation,
      this.createHookContext({
        data: options,
        operation: "read",
        context: normalized,
        db
      })
    );
    const accessWhere = await this.enforceAccessControl(
      "read",
      normalized,
      null,
      options
    );
    if (accessWhere === false) {
      throw ApiError.forbidden({
        operation: "read",
        resource: this.state.name,
        reason: "User does not have permission to read records"
      });
    }
    if (this.state.hooks?.beforeRead) {
      await this.executeHooks(
        this.state.hooks.beforeRead,
        this.createHookContext({
          data: options,
          operation: "read",
          context: normalized,
          db
        })
      );
    }
    const mergedWhere = this.mergeWhere(options.where, accessWhere);
    const includeDeleted = options.includeDeleted === true;
    let totalDocs = 0;
    if (mode === "many") {
      const countFn = this.createCount();
      totalDocs = await countFn(
        { where: mergedWhere, includeDeleted },
        { ...normalized, accessMode: "system" }
      );
    }
    const useI18n = !!this.i18nTable;
    const needsFallback = useI18n && normalized.localeFallback !== false && normalized.locale !== normalized.defaultLocale;
    const i18nCurrentTable = useI18n ? alias(this.i18nTable, "i18n_current") : null;
    const i18nFallbackTable = needsFallback ? alias(this.i18nTable, "i18n_fallback") : null;
    const selectObj = this.buildSelectObject(
      options.columns || options.select,
      options.extras,
      normalized,
      i18nCurrentTable,
      i18nFallbackTable
    );
    let query2 = db.select(selectObj).from(this.table);
    if (useI18n && i18nCurrentTable) {
      query2 = query2.leftJoin(
        i18nCurrentTable,
        and(
          eq(i18nCurrentTable.parentId, this.table.id),
          eq(i18nCurrentTable.locale, normalized.locale)
        )
      );
      if (needsFallback && i18nFallbackTable) {
        query2 = query2.leftJoin(
          i18nFallbackTable,
          and(
            eq(i18nFallbackTable.parentId, this.table.id),
            eq(i18nFallbackTable.locale, normalized.defaultLocale)
          )
        );
      }
    }
    const whereClauses = [];
    if (mergedWhere) {
      const whereClause = this.buildWhereClause(
        mergedWhere,
        useI18n,
        void 0,
        normalized,
        void 0,
        i18nCurrentTable,
        i18nFallbackTable
      );
      if (whereClause) {
        whereClauses.push(whereClause);
      }
    }
    if (this.state.options.softDelete && !includeDeleted) {
      const softDeleteFilter = sql$1`${this.table.deletedAt} IS NULL`;
      whereClauses.push(softDeleteFilter);
    }
    if (mode === "many" && options.search) {
      const searchTerm = options.search;
      let titleExpr = null;
      if (this.state.title) {
        const localizedFieldNames = this.getLocalizedFieldNames();
        if (localizedFieldNames.includes(this.state.title) && i18nCurrentTable) {
          titleExpr = buildLocalizedFieldRef(this.state.title, {
            table: this.table,
            state: this.state,
            i18nCurrentTable,
            i18nFallbackTable,
            useI18n
          });
        } else if (this.state.title in this.state.fields) {
          titleExpr = this.table[this.state.title];
        } else if (this.getVirtualsWithAliases) {
          const virtuals = this.getVirtualsWithAliases(
            normalized,
            i18nCurrentTable,
            i18nFallbackTable
          );
          if (virtuals && this.state.title in virtuals) {
            titleExpr = virtuals[this.state.title];
          }
        }
      }
      titleExpr = titleExpr || this.table.id;
      const searchFilter = sql$1`${titleExpr}::text ILIKE ${`%${searchTerm}%`}`;
      whereClauses.push(searchFilter);
    }
    if (whereClauses.length > 0) {
      query2 = query2.where(and(...whereClauses));
    }
    if (options.orderBy) {
      const orderClauses = this.buildOrderByClauses(
        options.orderBy,
        useI18n,
        i18nCurrentTable,
        i18nFallbackTable
      );
      for (const clause of orderClauses) {
        query2 = query2.orderBy(clause);
      }
    }
    if (mode === "one") {
      query2 = query2.limit(1);
    } else {
      const manyOptions2 = options;
      if (manyOptions2.limit !== void 0) {
        query2 = query2.limit(manyOptions2.limit);
      }
      if (manyOptions2.offset !== void 0) {
        query2 = query2.offset(manyOptions2.offset);
      }
    }
    let rows = await query2;
    const hasLocalized = this.hasLocalizedFieldsInternal();
    if (useI18n && rows.length > 0 && hasLocalized) {
      rows = mergeI18nRows(rows, {
        localizedFields: this.getLocalizedFieldNames(),
        hasFallback: needsFallback
      });
    }
    if (rows.length > 0 && options.with && this.cms) {
      await this.resolveRelations(rows, options.with, normalized);
    }
    for (const row of rows) {
      await this.filterFieldsForRead(row, normalized);
      await this.runFieldOutputHooks(row, "read", normalized, db);
    }
    if (this.state.hooks?.afterRead) {
      for (const row of rows) {
        await this.executeHooks(
          this.state.hooks.afterRead,
          this.createHookContext({
            data: row,
            operation: "read",
            context: normalized,
            db
          })
        );
      }
    }
    if (mode === "one") {
      return rows[0] || null;
    }
    const manyOptions = options;
    const limit = manyOptions.limit ?? totalDocs;
    const totalPages = limit > 0 ? Math.ceil(totalDocs / limit) : 1;
    const offset2 = manyOptions.offset ?? 0;
    const page = limit > 0 ? Math.floor(offset2 / limit) + 1 : 1;
    const pagingCounter = (page - 1) * limit + 1;
    const hasPrevPage = page > 1;
    const hasNextPage = page < totalPages;
    const prevPage = hasPrevPage ? page - 1 : null;
    const nextPage = hasNextPage ? page + 1 : null;
    return {
      docs: rows,
      totalDocs,
      limit,
      totalPages,
      page,
      pagingCounter,
      hasPrevPage,
      hasNextPage,
      prevPage,
      nextPage
    };
  }
  /**
   * Create find operation - returns paginated results
   */
  createFind() {
    return async (options = {}, context = {}) => {
      return this._executeFind(options, context, "many");
    };
  }
  /**
   * Create findOne operation - returns single record or null
   */
  createFindOne() {
    return async (options = {}, context = {}) => {
      return this._executeFind(options, context, "one");
    };
  }
  /**
   * Resolve relations recursively using extracted utilities
   */
  async resolveRelations(rows, withConfig, context) {
    if (!rows.length || !withConfig || !this.cms) return;
    const db = this.getDb(context);
    const typedRows = rows;
    const relationOptionKeys = /* @__PURE__ */ new Set([
      "columns",
      "where",
      "orderBy",
      "limit",
      "offset",
      "with",
      "_aggregate",
      "_count"
    ]);
    for (const [relationName, relationOptions] of Object.entries(withConfig)) {
      if (!relationOptions) continue;
      const relation = this.state.relations?.[relationName];
      if (!relation) continue;
      const relatedCrud = this.cms.api.collections[relation.collection];
      let nestedOptions = {};
      if (relationOptions === true) {
        nestedOptions = {};
      } else if (typeof relationOptions === "object" && relationOptions !== null && !Array.isArray(relationOptions)) {
        const hasQueryKey = Object.keys(relationOptions).some(
          (key) => relationOptionKeys.has(key)
        );
        nestedOptions = hasQueryKey ? relationOptions : { with: relationOptions };
      }
      const hasFieldConfig = relation.fields && relation.fields.length > 0 || typeof relation.field === "string";
      if (hasFieldConfig) {
        await resolveBelongsToRelation({
          rows: typedRows,
          relationName,
          relation,
          relatedCrud,
          nestedOptions,
          context,
          resolveFieldKey: this.resolveFieldKey,
          sourceState: this.state,
          sourceTable: this.table
        });
      } else if (relation.type === "many" && !relation.fields) {
        if (nestedOptions._count || nestedOptions._aggregate) {
          await resolveHasManyWithAggregation({
            rows: typedRows,
            relationName,
            relation,
            relatedCrud,
            nestedOptions,
            context,
            db,
            resolveFieldKey: this.resolveFieldKey,
            buildWhereClause,
            cms: this.cms
          });
        } else {
          await resolveHasManyRelation({
            rows: typedRows,
            relationName,
            relation,
            relatedCrud,
            nestedOptions,
            context,
            resolveFieldKey: this.resolveFieldKey,
            cms: this.cms
          });
        }
      } else if (relation.type === "manyToMany" && relation.through) {
        const junctionCrud = this.cms.api.collections[relation.through];
        await resolveManyToManyRelation({
          rows: typedRows,
          relationName,
          relation,
          junctionCrud,
          relatedCrud,
          nestedOptions,
          context
        });
      }
    }
  }
  /**
   * Create count operation
   */
  createCount() {
    return async (options = {}, context = {}) => {
      const db = this.getDb(context);
      const normalized = this.normalizeContext(context);
      const accessWhere = await this.enforceAccessControl(
        "read",
        normalized,
        null,
        options
      );
      if (accessWhere === false) {
        throw ApiError.forbidden({
          operation: "read",
          resource: this.state.name,
          reason: "User does not have permission to read records"
        });
      }
      const mergedWhere = this.mergeWhere(options.where, accessWhere);
      let whereClause;
      if (mergedWhere) {
        whereClause = this.buildWhereClause(
          mergedWhere,
          false,
          void 0,
          context
        );
      }
      if (this.state.options.softDelete && !options.includeDeleted) {
        const softDeleteClause = sql$1`${this.table.deletedAt} IS NULL`;
        whereClause = whereClause ? and(whereClause, softDeleteClause) : softDeleteClause;
      }
      let query2 = db.select({ count: count() }).from(this.table);
      if (whereClause) {
        query2 = query2.where(whereClause);
      }
      const result2 = await query2;
      return result2[0]?.count ?? 0;
    };
  }
  /**
   * Handle cascade delete operations for relations
   * Delegates to extracted handleCascadeDelete utility
   */
  async handleCascadeDeleteInternal(_id, record, context) {
    if (!this.cms || !this.state.relations) return;
    await handleCascadeDelete({
      record,
      relations: this.state.relations,
      cms: this.cms,
      context,
      resolveFieldKey: this.resolveFieldKey
    });
  }
  /**
   * Separate nested relation operations from regular fields
   * Delegates to extracted separateNestedRelations utility
   */
  separateNestedRelationsInternal(input) {
    const relationNames = new Set(Object.keys(this.state.relations || {}));
    return separateNestedRelations(input, relationNames);
  }
  /**
   * Apply belongsTo relation operations
   * Delegates to extracted applyBelongsToRelations utility
   */
  async applyBelongsToRelationsInternal(regularFields, nestedRelations, context, tx) {
    if (!this.cms || !this.state.relations) {
      return { regularFields, nestedRelations };
    }
    return applyBelongsToRelations(
      regularFields,
      nestedRelations,
      this.state.relations,
      this.cms,
      context,
      tx,
      this.resolveFieldKey,
      this.state,
      this.table
    );
  }
  /**
   * Pre-process connect operations before validation
   * Delegates to extracted extractBelongsToConnectValues utility
   */
  preApplyConnectOperations(regularFields, nestedRelations) {
    if (!this.state.relations) {
      return { regularFields, nestedRelations };
    }
    return extractBelongsToConnectValues(
      regularFields,
      nestedRelations,
      this.state.relations,
      this.resolveFieldKey,
      this.state,
      this.table
    );
  }
  /**
   * Process nested relation operations (create, connect, connectOrCreate)
   * Delegates to extracted processNestedRelations utility
   */
  async processNestedRelationsInternal(parentRecord, nestedRelations, context, tx) {
    if (!this.cms || !this.state.relations) return;
    await processNestedRelations({
      parentRecord,
      nestedRelations,
      relations: this.state.relations,
      cms: this.cms,
      context,
      tx,
      resolveFieldKey: this.resolveFieldKey
    });
  }
  /**
   * Create create operation
   */
  createCreate() {
    return async (input, context = {}) => {
      const normalized = this.normalizeContext(context);
      const db = this.getDb(normalized);
      return runWithContext(
        {
          app: this.cms,
          session: normalized.session,
          db,
          locale: normalized.locale,
          accessMode: normalized.accessMode
        },
        async () => {
          await this.executeHooks(
            this.state.hooks?.beforeOperation,
            this.createHookContext({
              data: input,
              operation: "create",
              context: normalized,
              db
            })
          );
          const canCreate = await this.enforceAccessControl(
            "create",
            normalized,
            null,
            input
          );
          if (canCreate === false) {
            throw ApiError.forbidden({
              operation: "create",
              resource: this.state.name,
              reason: "User does not have permission to create records"
            });
          }
          await this.executeHooks(
            this.state.hooks?.beforeValidate,
            this.createHookContext({
              data: input,
              operation: "create",
              context: normalized,
              db
            })
          );
          let { regularFields, nestedRelations } = this.separateNestedRelationsInternal(input);
          ({ regularFields, nestedRelations } = this.preApplyConnectOperations(
            regularFields,
            nestedRelations
          ));
          await this.validateFieldWriteAccess(
            regularFields,
            normalized,
            "create"
          );
          if (this.state.validation?.insertSchema) {
            try {
              regularFields = this.state.validation.insertSchema.parse(regularFields);
            } catch (error2) {
              throw ApiError.fromZodError(error2);
            }
          }
          regularFields = await this.runFieldInputHooks(
            regularFields,
            "create",
            normalized,
            db
          );
          await this.executeHooks(
            this.state.hooks?.beforeChange,
            this.createHookContext({
              data: regularFields,
              operation: "create",
              context,
              db
            })
          );
          let changeEvent = null;
          let record;
          try {
            record = await withTransaction(db, async (tx) => {
              ({ regularFields, nestedRelations } = await this.applyBelongsToRelationsInternal(
                regularFields,
                nestedRelations,
                context,
                tx
              ));
              const { localized, nonLocalized, nestedLocalized } = this.splitLocalizedFields(regularFields);
              const [insertedRecord] = await tx.insert(this.table).values(nonLocalized).returning();
              const hasLocalizedData = Object.keys(localized).length > 0 || nestedLocalized != null;
              if (this.i18nTable && context.locale && hasLocalizedData) {
                await tx.insert(this.i18nTable).values({
                  parentId: insertedRecord.id,
                  locale: context.locale,
                  ...localized,
                  ...nestedLocalized != null ? { _localized: nestedLocalized } : {}
                });
              }
              await this.processNestedRelationsInternal(
                insertedRecord,
                nestedRelations,
                context,
                tx
              );
              await this.createVersion(tx, insertedRecord, "create", context);
              const useI18n = !!this.i18nTable;
              const needsFallback = useI18n && normalized.localeFallback !== false && normalized.locale !== normalized.defaultLocale;
              const i18nCurrentTable = useI18n ? alias(this.i18nTable, "i18n_current") : null;
              const i18nFallbackTable = needsFallback ? alias(this.i18nTable, "i18n_fallback") : null;
              const selectObj = this.buildSelectObject(
                void 0,
                void 0,
                context,
                i18nCurrentTable,
                i18nFallbackTable
              );
              let query2 = tx.select(selectObj).from(this.table);
              if (useI18n && i18nCurrentTable) {
                query2 = query2.leftJoin(
                  i18nCurrentTable,
                  and(
                    eq(
                      i18nCurrentTable.parentId,
                      this.table.id
                    ),
                    eq(i18nCurrentTable.locale, context.locale)
                  )
                );
                if (needsFallback && i18nFallbackTable) {
                  query2 = query2.leftJoin(
                    i18nFallbackTable,
                    and(
                      eq(
                        i18nFallbackTable.parentId,
                        this.table.id
                      ),
                      eq(
                        i18nFallbackTable.locale,
                        context.defaultLocale
                      )
                    )
                  );
                }
              }
              let [createdRecord] = await query2.where(
                eq(this.table.id, insertedRecord.id)
              );
              const hasLocalizedCreate = this.hasLocalizedFieldsInternal();
              if (useI18n && createdRecord && hasLocalizedCreate) {
                [createdRecord] = mergeI18nRows([createdRecord], {
                  localizedFields: this.getLocalizedFieldNames(),
                  hasFallback: needsFallback
                });
              }
              await this.executeHooks(
                this.state.hooks?.afterChange,
                this.createHookContext({
                  data: createdRecord,
                  operation: "create",
                  context,
                  db: tx
                })
              );
              changeEvent = await this.appendRealtimeChange(
                {
                  operation: "create",
                  recordId: createdRecord.id,
                  payload: createdRecord
                },
                context,
                tx
              );
              onAfterCommit(() => {
                this.indexToSearch(createdRecord, context).catch((err2) => {
                  console.error("[Search] Index failed:", err2);
                });
                return Promise.resolve();
              });
              return createdRecord;
            });
          } catch (error2) {
            const dbError = parseDatabaseError(error2);
            if (dbError) {
              throw dbError;
            }
            throw error2;
          }
          await this.runFieldOutputHooks(record, "create", normalized, db);
          await this.executeHooks(
            this.state.hooks?.afterRead,
            this.createHookContext({
              data: record,
              operation: "create",
              context,
              db
            })
          );
          await this.notifyRealtimeChange(changeEvent);
          return record;
        }
      );
    };
  }
  /**
   * Shared core update handler for updateById and updateMany
   * Ensures consistency in access control, hooks, validation, and re-fetching.
   */
  async _executeUpdate(params, context = {}) {
    const normalized = this.normalizeContext(context);
    const db = this.getDb(normalized);
    const isBatch = "where" in params;
    const data = params.data;
    await this.executeHooks(
      this.state.hooks?.beforeOperation,
      this.createHookContext({
        data,
        operation: "update",
        context: normalized,
        db
      })
    );
    const findOptions = isBatch ? { where: params.where } : { where: { id: params.id } };
    const recordsResult = await this._executeFind(
      { ...findOptions, includeDeleted: true },
      { ...normalized, accessMode: "system" },
      "many"
    );
    const records = recordsResult.docs;
    if (records.length === 0) {
      if (isBatch) return [];
      throw ApiError.notFound("Record", params.id);
    }
    for (const existing of records) {
      const canUpdate = await this.enforceAccessControl(
        "update",
        normalized,
        existing,
        data
      );
      if (canUpdate === false) {
        throw ApiError.forbidden({
          operation: "update",
          resource: this.state.name,
          reason: `User does not have permission to update record ${existing.id}`
        });
      }
      if (typeof canUpdate === "object") {
        const matchesConditions = await this.checkAccessConditions(
          canUpdate,
          existing
        );
        if (!matchesConditions) {
          throw ApiError.forbidden({
            operation: "update",
            resource: this.state.name,
            reason: `Record ${existing.id} does not match access control conditions`
          });
        }
      }
      await this.executeHooks(
        this.state.hooks?.beforeValidate,
        this.createHookContext({
          data,
          original: existing,
          operation: "update",
          context: normalized,
          db
        })
      );
    }
    let { regularFields, nestedRelations } = this.separateNestedRelationsInternal(data);
    if (this.state.validation?.updateSchema) {
      try {
        regularFields = this.state.validation.updateSchema.parse(regularFields);
      } catch (error2) {
        if (error2?.name === "ZodError") {
          throw ApiError.fromZodError(error2);
        }
        throw ApiError.badRequest(`Validation error: ${error2.message}`);
      }
    }
    for (const existing of records) {
      await this.validateFieldWriteAccess(
        regularFields,
        normalized,
        "update",
        existing
      );
      regularFields = await this.runFieldInputHooks(
        regularFields,
        "update",
        normalized,
        db,
        existing
      );
      await this.executeHooks(
        this.state.hooks?.beforeChange,
        this.createHookContext({
          data: regularFields,
          original: existing,
          operation: "update",
          context: normalized,
          db
        })
      );
    }
    let changeEvent = null;
    let updatedRecords;
    try {
      updatedRecords = await withTransaction(db, async (tx) => {
        const txContext = { ...normalized, db: tx };
        ({ regularFields, nestedRelations } = await this.applyBelongsToRelationsInternal(
          regularFields,
          nestedRelations,
          txContext,
          tx
        ));
        const { localized, nonLocalized, nestedLocalized } = this.splitLocalizedFields(regularFields);
        const recordIds = records.map((r2) => r2.id);
        if (Object.keys(nonLocalized).length > 0 || this.state.options.timestamps !== false) {
          await tx.update(this.table).set({
            ...nonLocalized,
            ...this.state.options.timestamps !== false ? { updatedAt: /* @__PURE__ */ new Date() } : {}
          }).where(inArray(this.table.id, recordIds));
        }
        const hasLocalizedData = Object.keys(localized).length > 0 || nestedLocalized != null;
        if (this.i18nTable && normalized.locale && hasLocalizedData) {
          const i18nValues = {
            ...localized,
            ...nestedLocalized != null ? { _localized: nestedLocalized } : {}
          };
          for (const recordId of recordIds) {
            await tx.insert(this.i18nTable).values({
              parentId: recordId,
              locale: normalized.locale,
              ...i18nValues
            }).onConflictDoUpdate({
              target: [
                this.i18nTable.parentId,
                this.i18nTable.locale
              ],
              set: i18nValues
            });
          }
        }
        for (const existing of records) {
          await this.processNestedRelationsInternal(
            existing,
            nestedRelations,
            txContext,
            tx
          );
        }
        const reFetchResult = await this._executeFind(
          { where: { id: { in: recordIds } }, includeDeleted: true },
          { ...txContext, accessMode: "system" },
          "many"
        );
        const refetchedRecords = reFetchResult.docs;
        for (const updated of refetchedRecords) {
          const original = records.find((r2) => r2.id === updated.id);
          await this.createVersion(tx, updated, "update", txContext);
          await this.executeHooks(
            this.state.hooks?.afterChange,
            this.createHookContext({
              data: updated,
              original,
              operation: "update",
              context: txContext,
              db: tx
            })
          );
        }
        changeEvent = await this.appendRealtimeChange(
          {
            operation: isBatch ? "bulk_update" : "update",
            recordId: isBatch ? void 0 : refetchedRecords[0].id,
            payload: isBatch ? { count: refetchedRecords.length } : refetchedRecords[0]
          },
          txContext,
          tx
        );
        for (const updated of refetchedRecords) {
          onAfterCommit(() => {
            this.indexToSearch(updated, normalized).catch((err2) => {
              console.error("[Search] Index failed:", err2);
            });
            return Promise.resolve();
          });
        }
        return refetchedRecords;
      });
    } catch (error2) {
      const dbError = parseDatabaseError(error2);
      if (dbError) throw dbError;
      throw error2;
    }
    for (const updated of updatedRecords) {
      const original = records.find((r2) => r2.id === updated.id);
      await this.runFieldOutputHooks(
        updated,
        "update",
        normalized,
        db,
        original
      );
      await this.executeHooks(
        this.state.hooks?.afterRead,
        this.createHookContext({
          data: updated,
          original,
          operation: "update",
          context: normalized,
          db
        })
      );
    }
    await this.notifyRealtimeChange(changeEvent);
    return isBatch ? updatedRecords : updatedRecords[0];
  }
  /**
   * Create update operation
   */
  createUpdate() {
    return async (params, context = {}) => {
      return this._executeUpdate(params, context);
    };
  }
  /**
   * Create delete operation (supports soft delete)
   */
  createDelete() {
    return async (params, context = {}) => {
      const db = this.getDb(context);
      const { id } = params;
      await this.executeHooks(
        this.state.hooks?.beforeOperation,
        this.createHookContext({
          data: params,
          operation: "delete",
          context,
          db
        })
      );
      const existingRows = await db.select().from(this.table).where(eq(this.table.id, id)).limit(1);
      const existing = existingRows[0];
      if (!existing) {
        throw ApiError.notFound("Record", id);
      }
      const canDelete = await this.enforceAccessControl(
        "delete",
        context,
        existing,
        params
      );
      if (canDelete === false) {
        throw ApiError.forbidden({
          operation: "delete",
          resource: this.state.name,
          reason: "User does not have permission to delete this record"
        });
      }
      if (typeof canDelete === "object") {
        const matchesConditions = await this.checkAccessConditions(
          canDelete,
          existing
        );
        if (!matchesConditions) {
          throw ApiError.forbidden({
            operation: "delete",
            resource: this.state.name,
            reason: "Record does not match access control conditions"
          });
        }
      }
      await this.executeHooks(
        this.state.hooks?.beforeDelete,
        this.createHookContext({
          data: existing,
          original: existing,
          operation: "delete",
          context,
          db
        })
      );
      await this.handleCascadeDeleteInternal(id, existing, context);
      let changeEvent = null;
      await withTransaction(db, async (tx) => {
        await this.createVersion(tx, existing, "delete", context);
        if (this.state.options.softDelete) {
          await tx.update(this.table).set({ deletedAt: /* @__PURE__ */ new Date() }).where(eq(this.table.id, id));
        } else {
          await tx.delete(this.table).where(eq(this.table.id, id));
        }
        changeEvent = await this.appendRealtimeChange(
          {
            operation: "delete",
            recordId: id
          },
          context,
          tx
        );
        onAfterCommit(async () => {
          await this.removeFromSearch(id, context);
        });
      });
      await this.executeHooks(
        this.state.hooks?.afterDelete,
        this.createHookContext({
          data: existing,
          original: existing,
          operation: "delete",
          context,
          db
        })
      );
      await this.notifyRealtimeChange(changeEvent);
      const result2 = { success: true, data: existing };
      await this.executeHooks(
        this.state.hooks?.afterRead,
        this.createHookContext({
          data: existing,
          original: existing,
          operation: "delete",
          context,
          db
        })
      );
      return result2;
    };
  }
  /**
   * Restore soft-deleted record by ID
   */
  createRestore() {
    return async (params, context = {}) => {
      if (!this.state.options.softDelete) {
        throw ApiError.notImplemented("Soft delete");
      }
      const db = this.getDb(context);
      const { id } = params;
      const existingRows = await db.select().from(this.table).where(eq(this.table.id, id)).limit(1);
      const existing = existingRows[0];
      if (!existing) {
        throw ApiError.notFound("Record", id);
      }
      const canUpdate = await this.enforceAccessControl(
        "update",
        context,
        existing,
        { deletedAt: null }
      );
      if (canUpdate === false) {
        throw ApiError.forbidden({
          operation: "update",
          resource: this.state.name,
          reason: "User does not have permission to restore this record"
        });
      }
      if (typeof canUpdate === "object") {
        const matchesConditions = await this.checkAccessConditions(
          canUpdate,
          existing
        );
        if (!matchesConditions) {
          throw ApiError.forbidden({
            operation: "update",
            resource: this.state.name,
            reason: "Record does not match access control conditions"
          });
        }
      }
      if (!existing.deletedAt) {
        return existing;
      }
      const updateFn = this.createUpdate();
      return await updateFn(
        {
          id,
          data: { deletedAt: null }
        },
        context
      );
    };
  }
  /**
   * Create updateMany operation - smart batched updates
   */
  createUpdateMany() {
    return async (params, context = {}) => {
      return this._executeUpdate(params, context);
    };
  }
  /**
   * Create deleteMany operation - smart batched deletes
   * 1. find to get all matching records (for hooks + access control)
   * 2. Loop through beforeDelete hooks
   * 3. Single batched DELETE WHERE query
   * 4. Loop through afterDelete hooks
   */
  createDeleteMany() {
    return async (params, context = {}) => {
      const db = this.getDb(context);
      const find2 = this.createFind();
      const { docs: records } = await find2({ where: params.where }, context);
      if (records.length === 0) {
        return { success: true, count: 0 };
      }
      for (const record of records) {
        const canDelete = await this.enforceAccessControl(
          "delete",
          context,
          record,
          params
        );
        if (canDelete === false) {
          throw ApiError.forbidden({
            operation: "delete",
            resource: this.state.name,
            reason: `User does not have permission to delete record ${record.id}`
          });
        }
        if (typeof canDelete === "object") {
          const matchesConditions = await this.checkAccessConditions(
            canDelete,
            record
          );
          if (!matchesConditions) {
            throw ApiError.forbidden({
              operation: "delete",
              resource: this.state.name,
              reason: `Record ${record.id} does not match access control conditions`
            });
          }
        }
        await this.executeHooks(
          this.state.hooks?.beforeDelete,
          this.createHookContext({
            data: record,
            original: record,
            operation: "delete",
            context,
            db
          })
        );
        await this.handleCascadeDeleteInternal(record.id, record, context);
      }
      let changeEvent = null;
      await withTransaction(db, async (tx) => {
        const recordIds = records.map((r2) => r2.id);
        for (const record of records) {
          await this.createVersion(tx, record, "delete", context);
        }
        if (this.state.options.softDelete) {
          await tx.update(this.table).set({ deletedAt: /* @__PURE__ */ new Date() }).where(inArray(this.table.id, recordIds));
        } else {
          await tx.delete(this.table).where(inArray(this.table.id, recordIds));
        }
        changeEvent = await this.appendRealtimeChange(
          {
            operation: "bulk_delete",
            payload: { count: records.length }
          },
          context,
          tx
        );
        for (const record of records) {
          onAfterCommit(async () => {
            await this.removeFromSearch(record.id, context);
          });
        }
      });
      for (const record of records) {
        await this.executeHooks(
          this.state.hooks?.afterDelete,
          this.createHookContext({
            data: record,
            original: record,
            operation: "delete",
            context,
            db
          })
        );
      }
      await this.notifyRealtimeChange(changeEvent);
      return { success: true, count: records.length };
    };
  }
  /**
   * Find versions of a record
   */
  createFindVersions() {
    return async (options, context = {}) => {
      const db = this.getDb(context);
      if (!this.versionsTable) return [];
      const normalized = this.normalizeContext(context);
      const canRead = await this.enforceAccessControl(
        "read",
        normalized,
        null,
        options
      );
      if (!canRead)
        throw ApiError.forbidden({
          operation: "read",
          resource: `${this.state.name} versions`,
          reason: "User does not have permission to read version history"
        });
      let query2;
      const useI18n = !!this.i18nVersionsTable && !!normalized.locale;
      const needsFallback = useI18n && normalized.localeFallback !== false && normalized.locale !== normalized.defaultLocale;
      const i18nVersionsCurrentTable = useI18n ? alias(this.i18nVersionsTable, "i18n_v_current") : null;
      const i18nVersionsFallbackTable = needsFallback ? alias(this.i18nVersionsTable, "i18n_v_fallback") : null;
      if (useI18n && i18nVersionsCurrentTable) {
        const selectObj = this.buildVersionsSelectObject(
          normalized,
          i18nVersionsCurrentTable,
          i18nVersionsFallbackTable
        );
        query2 = db.select(selectObj).from(this.versionsTable).$dynamic().leftJoin(
          i18nVersionsCurrentTable,
          and(
            eq(
              i18nVersionsCurrentTable.parentId,
              this.versionsTable.id
            ),
            eq(
              i18nVersionsCurrentTable.versionNumber,
              this.versionsTable.versionNumber
            ),
            eq(i18nVersionsCurrentTable.locale, normalized.locale)
          )
        );
        if (needsFallback && i18nVersionsFallbackTable) {
          query2 = query2.leftJoin(
            i18nVersionsFallbackTable,
            and(
              eq(
                i18nVersionsFallbackTable.parentId,
                this.versionsTable.id
              ),
              eq(
                i18nVersionsFallbackTable.versionNumber,
                this.versionsTable.versionNumber
              ),
              eq(
                i18nVersionsFallbackTable.locale,
                normalized.defaultLocale
              )
            )
          );
        }
        query2 = query2.where(eq(this.versionsTable.id, options.id)).orderBy(sql$1`${this.versionsTable.versionNumber} ASC`);
      } else {
        query2 = db.select(this.buildVersionsSelectObject(normalized)).from(this.versionsTable).where(eq(this.versionsTable.id, options.id)).orderBy(sql$1`${this.versionsTable.versionNumber} ASC`);
      }
      if (options.limit) {
        query2 = query2.limit(options.limit);
      }
      if (options.offset) {
        query2 = query2.offset(options.offset);
      }
      let rows = await query2;
      const hasLocalizedVersions = this.hasLocalizedFieldsInternal();
      if (useI18n && rows.length > 0 && hasLocalizedVersions) {
        rows = mergeI18nRows(rows, {
          localizedFields: this.getLocalizedFieldNames(),
          hasFallback: needsFallback
        });
      }
      return rows;
    };
  }
  /**
   * Revert to a specific version
   */
  createRevertToVersion() {
    return async (options, context = {}) => {
      const db = this.getDb(context);
      const normalized = this.normalizeContext(context);
      if (!this.versionsTable) throw ApiError.notImplemented("Versioning");
      const hasVersionId = typeof options.versionId === "string";
      const hasVersion = typeof options.version === "number";
      if (!hasVersionId && !hasVersion) {
        throw ApiError.badRequest("Version or versionId required");
      }
      const versionRows = await db.select().from(this.versionsTable).where(
        hasVersionId ? and(
          eq(this.versionsTable.id, options.id),
          eq(this.versionsTable.versionId, options.versionId)
        ) : and(
          eq(this.versionsTable.id, options.id),
          eq(this.versionsTable.versionNumber, options.version)
        )
      ).limit(1);
      const version2 = versionRows[0];
      if (!version2)
        throw ApiError.notFound(
          "Version",
          options.versionId || String(options.version)
        );
      const existingRows = await db.select().from(this.table).where(eq(this.table.id, options.id)).limit(1);
      const existing = existingRows[0];
      if (!existing) {
        throw ApiError.notFound("Record", options.id);
      }
      const localizedFieldNames = this.getLocalizedFieldNames();
      const localizedFieldSet = new Set(localizedFieldNames);
      const nonLocalized = {};
      for (const [name2] of Object.entries(this.state.fields)) {
        if (localizedFieldSet.has(name2)) continue;
        nonLocalized[name2] = version2[name2];
      }
      if (this.state.options.softDelete) {
        nonLocalized.deletedAt = version2.deletedAt ?? null;
      }
      const localizedForContext = {};
      if (this.i18nVersionsTable && normalized.locale) {
        const localeRows = await db.select().from(this.i18nVersionsTable).where(
          and(
            eq(this.i18nVersionsTable.parentId, options.id),
            eq(
              this.i18nVersionsTable.versionNumber,
              version2.versionNumber
            ),
            eq(this.i18nVersionsTable.locale, normalized.locale)
          )
        ).limit(1);
        const localeRow = localeRows[0];
        if (localeRow) {
          for (const fieldName of localizedFieldNames) {
            localizedForContext[fieldName] = localeRow[fieldName];
          }
        }
      }
      const restoreData = { ...nonLocalized, ...localizedForContext };
      const canUpdate = await this.enforceAccessControl(
        "update",
        normalized,
        existing,
        restoreData
      );
      if (canUpdate === false) {
        throw ApiError.forbidden({
          operation: "update",
          resource: this.state.name,
          reason: "User does not have permission to revert to this version"
        });
      }
      if (typeof canUpdate === "object") {
        const matchesConditions = await this.checkAccessConditions(
          canUpdate,
          existing
        );
        if (!matchesConditions) {
          throw ApiError.forbidden({
            operation: "update",
            resource: this.state.name,
            reason: "Record does not match access control conditions"
          });
        }
      }
      await this.executeHooks(
        this.state.hooks?.beforeChange,
        this.createHookContext({
          data: restoreData,
          original: existing,
          operation: "update",
          context: normalized,
          db
        })
      );
      const updated = await withTransaction(db, async (tx) => {
        if (Object.keys(nonLocalized).length > 0) {
          await tx.update(this.table).set({
            ...nonLocalized,
            ...this.state.options.timestamps !== false ? { updatedAt: /* @__PURE__ */ new Date() } : {}
          }).where(eq(this.table.id, options.id));
        }
        if (this.i18nTable && this.i18nVersionsTable) {
          await tx.delete(this.i18nTable).where(eq(this.i18nTable.parentId, options.id));
          const localeRows = await tx.select().from(this.i18nVersionsTable).where(
            and(
              eq(this.i18nVersionsTable.parentId, options.id),
              eq(
                this.i18nVersionsTable.versionNumber,
                version2.versionNumber
              )
            )
          );
          if (localeRows.length > 0) {
            const insertRows = localeRows.map((row) => {
              const {
                id: _id,
                parentId: _parentId,
                versionNumber: _versionNumber,
                locale,
                ...localizedFields
              } = row;
              return {
                parentId: options.id,
                locale,
                ...localizedFields
              };
            });
            await tx.insert(this.i18nTable).values(insertRows);
          }
        }
        const updatedRows = await tx.select().from(this.table).where(eq(this.table.id, options.id)).limit(1);
        const result2 = updatedRows[0];
        await this.createVersion(tx, result2, "update", normalized);
        await this.executeHooks(
          this.state.hooks?.afterChange,
          this.createHookContext({
            data: result2,
            original: existing,
            operation: "update",
            context: normalized,
            db: tx
          })
        );
        if (result2) {
          onAfterCommit(() => {
            this.indexToSearch(result2, normalized).catch((err2) => {
              console.error("[Search] Index failed:", err2);
            });
            return Promise.resolve();
          });
        }
        return result2;
      });
      return updated;
    };
  }
  /**
   * Create a new version of the record
   * Delegates to extracted createVersionRecord utility
   */
  async createVersion(tx, row, operation, context) {
    if (!this.versionsTable) return;
    await createVersionRecord({
      tx,
      row,
      operation,
      versionsTable: this.versionsTable,
      i18nVersionsTable: this.i18nVersionsTable,
      i18nTable: this.i18nTable,
      options: this.state.options,
      context
    });
  }
  /**
   * Execute hooks (supports arrays)
   * Delegates to shared executeHooks utility
   */
  async executeHooks(hooks, ctx) {
    return executeHooks(hooks, ctx);
  }
  /**
   * Create hook context with full CMS access
   * Delegates to shared createHookContext utility
   */
  createHookContext(params) {
    return createHookContext({
      ...params,
      cms: this.cms
    });
  }
  /**
   * Enforce access control
   * Delegates to extracted executeAccessRule utility
   * Falls back to CMS defaultAccess if collection doesn't define its own rules
   */
  async enforceAccessControl(operation, context, row, input) {
    const db = this.getDb(context);
    const normalized = this.normalizeContext(context);
    if (normalized.accessMode === "system") return true;
    const accessRule = this.state.access?.[operation] ?? this.cms?.defaultAccess?.[operation];
    return executeAccessRule(accessRule, {
      cms: this.cms,
      db,
      session: normalized.session,
      locale: normalized.locale,
      row,
      input
    });
  }
  /**
   * Check if a row matches access conditions
   * Delegates to extracted matchesAccessConditions utility
   */
  async checkAccessConditions(conditions, row) {
    return matchesAccessConditions(conditions, row);
  }
  /**
   * Filter fields from result based on field-level read access
   * Delegates to extracted getRestrictedReadFields utility
   * Uses field definition access rules
   */
  async filterFieldsForRead(result2, context) {
    if (!result2) return;
    this.getDb(context);
    const fieldAccess = this.getFieldAccessRules();
    const fieldsToRemove = await getRestrictedReadFields(result2, context, {
      cms: this.cms,
      fieldAccess
    });
    for (const fieldName of fieldsToRemove) {
      delete result2[fieldName];
    }
  }
  /**
   * Validate write access for all fields in input data
   * Delegates to extracted validateFieldsWriteAccess utility
   * Uses field definition access rules
   */
  async validateFieldWriteAccess(data, context, operation, existing) {
    this.getDb(context);
    const fieldAccess = this.getFieldAccessRules();
    await validateFieldsWriteAccess(
      data,
      fieldAccess,
      context,
      { cms: this.cms },
      this.state.name,
      operation,
      existing
    );
  }
  /**
   * Merge user WHERE with access control WHERE
   * Delegates to extracted mergeWhereWithAccess utility
   */
  mergeWhere(userWhere, accessWhere) {
    return mergeWhereWithAccess(userWhere, accessWhere);
  }
  /**
   * Build WHERE clause from WHERE object
   * Delegates to extracted buildWhereClause function
   *
   * @param where - WHERE object
   * @param useI18n - Whether to use i18n tables
   * @param customTable - Custom table (optional)
   * @param context - CRUD context
   * @param customState - Custom state (optional)
   * @param i18nCurrentTable - Aliased i18n table for current locale
   * @param i18nFallbackTable - Aliased i18n table for fallback locale
   */
  buildWhereClause(where, useI18n = false, customTable, context, customState, i18nCurrentTable, i18nFallbackTable) {
    return buildWhereClause(where, {
      table: customTable || this.table,
      state: customState || this.state,
      i18nCurrentTable: i18nCurrentTable ?? null,
      i18nFallbackTable: i18nFallbackTable ?? null,
      context,
      cms: this.cms,
      useI18n,
      db: this.db
    });
  }
  /**
   * Build SELECT object for query
   * Delegates to extracted buildSelectObject function
   *
   * @param columns - Column selection
   * @param extras - Extra fields
   * @param context - CRUD context
   * @param i18nCurrentTable - Aliased i18n table for current locale
   * @param i18nFallbackTable - Aliased i18n table for fallback locale
   */
  buildSelectObject(columns, extras, context, i18nCurrentTable, i18nFallbackTable) {
    return buildSelectObject(columns, extras, context, {
      table: this.table,
      state: this.state,
      i18nCurrentTable: i18nCurrentTable ?? null,
      i18nFallbackTable: i18nFallbackTable ?? null,
      getVirtualsWithAliases: this.getVirtualsWithAliases,
      getTitle: this.getTitleExpression
    });
  }
  /**
   * Build SELECT object for versions query
   * Delegates to extracted buildVersionsSelectObject function
   *
   * @param context - CRUD context
   * @param i18nVersionsCurrentTable - Aliased i18n versions table for current locale
   * @param i18nVersionsFallbackTable - Aliased i18n versions table for fallback locale
   */
  buildVersionsSelectObject(context, i18nVersionsCurrentTable, i18nVersionsFallbackTable) {
    if (!this.versionsTable) return {};
    return buildVersionsSelectObject(context, {
      versionsTable: this.versionsTable,
      i18nVersionsCurrentTable: i18nVersionsCurrentTable ?? null,
      i18nVersionsFallbackTable: i18nVersionsFallbackTable ?? null,
      state: this.state,
      getVirtualsForVersionsWithAliases: this.getVirtualsForVersionsWithAliases,
      getTitleForVersions: this.getTitleExpressionForVersions
    });
  }
  /**
   * Build order by clauses
   * Delegates to extracted buildOrderByClauses function
   *
   * @param orderBy - Order by specification
   * @param useI18n - Whether to use i18n tables
   * @param i18nCurrentTable - Aliased i18n table for current locale
   * @param i18nFallbackTable - Aliased i18n table for fallback locale
   */
  buildOrderByClauses(orderBy, useI18n = false, i18nCurrentTable, i18nFallbackTable) {
    return buildOrderByClauses(orderBy, {
      table: this.table,
      state: this.state,
      i18nCurrentTable: i18nCurrentTable ?? null,
      i18nFallbackTable: i18nFallbackTable ?? null,
      useI18n
    });
  }
  /**
   * Resolve field key from column
   * Delegates to shared resolveFieldKey utility
   */
  resolveFieldKey(state, column, table) {
    return resolveFieldKey(state, column, table);
  }
  /**
   * Cached nested localization schemas (extracted from field definitions).
   */
  _nestedLocalizationSchemas;
  /**
   * Get nested localization schemas for JSONB fields.
   * Extracts schemas from field definitions (cached after first call).
   */
  getNestedLocalizationSchemas() {
    if (this._nestedLocalizationSchemas === void 0) {
      if (this.state.fieldDefinitions) {
        this._nestedLocalizationSchemas = extractNestedLocalizationSchemas(
          this.state.fieldDefinitions
        );
      } else {
        this._nestedLocalizationSchemas = {};
      }
    }
    return this._nestedLocalizationSchemas;
  }
  /**
   * Split localized and non-localized fields.
   *
   * Uses field definition schemas to automatically detect which nested fields
   * are localized. No $i18n wrappers needed from client.
   *
   * @param input - Input data
   */
  splitLocalizedFields(input) {
    const localizedFieldNames = this.getLocalizedFieldNames();
    const nestedSchemas = this.getNestedLocalizationSchemas();
    return splitLocalizedFields(input, localizedFieldNames, nestedSchemas);
  }
  /**
   * Index record to search service
   * Delegates to extracted indexToSearch function
   */
  async indexToSearch(record, context) {
    if (!this.cms) return;
    return indexToSearch(record, context, {
      cms: this.cms,
      state: this.state,
      getTitle: this.getTitleExpression
    });
  }
  /**
   * Append a realtime change event
   * Delegates to shared appendRealtimeChange utility
   */
  async appendRealtimeChange(params, context, db) {
    return appendRealtimeChange(params, context, db, this.cms, this.state.name);
  }
  /**
   * Notify realtime subscribers of a change
   * Delegates to shared notifyRealtimeChange utility
   */
  async notifyRealtimeChange(change) {
    return notifyRealtimeChange(change, this.cms);
  }
  /**
   * Remove record from search index
   * Delegates to extracted removeFromSearch function
   */
  async removeFromSearch(recordId, context) {
    if (!this.cms) return;
    return removeFromSearch(recordId, context, {
      cms: this.cms,
      state: this.state
    });
  }
  /**
   * Create upload operation for collections with .upload() configured
   * Handles file upload to storage and creates a record with metadata
   */
  createUpload() {
    return async (file, context = {}, additionalData) => {
      if (!this.state.upload) {
        throw ApiError.notImplemented("Upload");
      }
      if (!this.cms?.storage) {
        throw ApiError.internal("Storage not configured");
      }
      const uploadOptions = this.state.upload;
      if (uploadOptions.maxSize && file.size > uploadOptions.maxSize) {
        throw ApiError.badRequest(
          `File size ${file.size} exceeds maximum allowed size ${uploadOptions.maxSize}`
        );
      }
      if (uploadOptions.allowedTypes && uploadOptions.allowedTypes.length > 0) {
        const isAllowed = uploadOptions.allowedTypes.some((pattern) => {
          if (pattern.endsWith("/*")) {
            const category = pattern.slice(0, -2);
            return file.type.startsWith(`${category}/`);
          }
          return file.type === pattern;
        });
        if (!isAllowed) {
          throw ApiError.badRequest(
            `File type "${file.type}" is not allowed. Allowed types: ${uploadOptions.allowedTypes.join(", ")}`
          );
        }
      }
      const key = `${crypto.randomUUID()}-${file.name}`;
      const visibility = uploadOptions.visibility || "public";
      const mimeType = file.type.split(";")[0]?.trim() || file.type;
      if (file.stream) {
        const { Readable } = await import("node:stream");
        const webStream = file.stream();
        const nodeStream = Readable.fromWeb(webStream);
        await this.cms.storage.use().putStream(key, nodeStream, {
          contentType: file.type,
          contentLength: file.size,
          visibility
        });
      } else {
        const buffer = await file.arrayBuffer();
        await this.cms.storage.use().put(key, new Uint8Array(buffer), {
          contentType: file.type,
          contentLength: file.size,
          visibility
        });
      }
      const createFn = this.createCreate();
      const record = await createFn(
        {
          key,
          filename: file.name,
          mimeType,
          size: file.size,
          visibility,
          ...additionalData
        },
        context
      );
      return record;
    };
  }
  /**
   * Create uploadMany operation for collections with .upload() configured
   * Handles multiple file uploads
   */
  createUploadMany() {
    return async (files, context = {}, additionalData) => {
      if (!this.state.upload) {
        throw ApiError.notImplemented("Upload");
      }
      const uploadFn = this.createUpload();
      const results = [];
      for (const file of files) {
        const record = await uploadFn(file, context, additionalData);
        results.push(record);
      }
      return results;
    };
  }
}
const defaultIdColumn$1 = () => text("id").primaryKey().default(sql$1`gen_random_uuid()`);
function getColumnConfig$1(column) {
  return column.config || {};
}
function cloneColumnType$1(sourceColumn, newName) {
  const config2 = getColumnConfig$1(sourceColumn);
  const columnType = config2.columnType || sourceColumn.constructor.name;
  switch (columnType) {
    case "PgUUID":
      return uuid$1(newName);
    case "PgText":
      return text(newName);
    case "PgVarchar":
      return varchar(newName, { length: config2.length });
    case "PgChar":
      return char(newName, { length: config2.length });
    case "PgInteger":
      return integer(newName);
    case "PgSerial":
      return integer(newName);
    case "PgSmallInt":
      return smallint(newName);
    case "PgSmallSerial":
      return smallint(newName);
    case "PgBigInt53":
    case "PgBigInt64":
      return bigint(newName, { mode: config2.mode || "number" });
    case "PgBigSerial53":
    case "PgBigSerial64":
      return bigint(newName, { mode: config2.mode || "number" });
    default:
      return text(newName);
  }
}
function isJsonbColumn(column) {
  const config2 = getColumnConfig$1(column);
  const columnType = config2.columnType || column?.constructor?.name;
  return columnType === "PgJsonb" || columnType === "PgJson";
}
function parseLocalizedField(localizedField) {
  if (localizedField.endsWith(":nested")) {
    return {
      name: localizedField.slice(0, -7),
      // Remove ":nested"
      mode: "nested"
    };
  }
  return {
    name: localizedField,
    mode: "whole"
  };
}
function getLocalizedFieldMode(localizedArray, fieldName) {
  for (const localizedField of localizedArray) {
    const parsed = parseLocalizedField(localizedField);
    if (parsed.name === fieldName) {
      return parsed.mode;
    }
  }
  return null;
}
class Collection {
  constructor(state, indexesFn) {
    this.indexesFn = indexesFn;
    this.state = state;
    this.name = state.name;
    this.table = this.generateMainTable(indexesFn);
    this.i18nTable = this.generateI18nTable();
    this.versionsTable = this.generateVersionsTable();
    this.i18nVersionsTable = this.generateI18nVersionsTable();
    if (!state.validation) {
      const localizedFieldNames = new Set(state.localized);
      const mainFields = {};
      const localizedFields = {};
      const hasUserDefinedId = "id" in state.fields;
      if (!hasUserDefinedId) {
        mainFields.id = defaultIdColumn$1();
      }
      for (const [key, column] of Object.entries(state.fields)) {
        if (localizedFieldNames.has(key)) {
          localizedFields[key] = column;
        } else {
          mainFields[key] = column;
        }
      }
      if (state.options.timestamps !== false) {
        Object.assign(mainFields, Collection.timestampsCols());
      }
      if (state.options.softDelete) {
        Object.assign(mainFields, Collection.softDeleteCols());
      }
      state.validation = createCollectionValidationSchemas(
        state.name,
        mainFields,
        localizedFields,
        {
          // Pass field definitions for relation field name normalization
          // This allows users to use `author` instead of `authorId` in input
          fieldDefinitions: state.fieldDefinitions
        }
      );
    }
    if (!state.virtuals) {
      state.virtuals = {};
    }
    this.$infer = {};
  }
  /**
   * @deprecated Use defaultIdColumn() instead. This is kept for backwards compatibility.
   */
  static pkCols = () => ({
    id: defaultIdColumn$1()
  });
  static timestampsCols = () => ({
    createdAt: timestamp("created_at", { mode: "date" }).defaultNow().notNull(),
    updatedAt: timestamp("updated_at", { mode: "date" }).defaultNow().notNull()
  });
  static softDeleteCols = () => ({
    deletedAt: timestamp("deleted_at", { mode: "date" })
  });
  /**
   * Creates version table columns with ID type matching the parent table
   * @param parentIdColumn - The ID column from the parent table to match type
   */
  static versionCols = (parentIdColumn) => ({
    // primary key of a version table - always uses default ID type
    versionId: text("version_id").primaryKey().default(sql$1`gen_random_uuid()`),
    // reference to the main record - matches parent ID type
    id: parentIdColumn ? cloneColumnType$1(parentIdColumn, "id").notNull() : text("id").notNull(),
    versionNumber: integer("version_number").notNull(),
    versionOperation: text("version_operation").notNull(),
    // 'create' | 'update' | 'delete'
    versionUserId: text("version_user_id"),
    // Nullable if unknown
    versionCreatedAt: timestamp("version_created_at", { mode: "date" }).defaultNow().notNull()
  });
  /**
   * Creates i18n version table columns with ID type matching the parent table
   * @param parentIdColumn - The ID column from the parent table to match type
   */
  static i18nVersionCols = (parentIdColumn) => ({
    id: text("id").primaryKey().default(sql$1`gen_random_uuid()`),
    parentId: parentIdColumn ? cloneColumnType$1(parentIdColumn, "parent_id").notNull() : text("parent_id").notNull(),
    versionNumber: integer("version_number").notNull(),
    locale: text("locale").notNull()
  });
  /**
   * Creates i18n table columns with ID type matching the parent table
   * @param parentIdColumn - The ID column from the parent table to match type
   */
  static i18nCols = (parentIdColumn) => ({
    id: text("id").primaryKey().default(sql$1`gen_random_uuid()`),
    parentId: parentIdColumn ? cloneColumnType$1(parentIdColumn, "parent_id").notNull() : text("parent_id").notNull(),
    locale: text("locale").notNull(),
    // Nested localized values from $i18n wrappers in any field
    _localized: jsonb("_localized")
  });
  static uploadCols = () => ({
    key: varchar("key", { length: 255 }).notNull(),
    filename: varchar("filename", { length: 255 }).notNull(),
    mimeType: varchar("mime_type", { length: 100 }).notNull(),
    size: integer("size").notNull(),
    visibility: varchar("visibility", {
      length: 20,
      enum: ["public", "private"]
    }).notNull().default("public")
  });
  name;
  table;
  i18nTable;
  versionsTable;
  i18nVersionsTable;
  state;
  /**
   * Type inference helper
   * Access with: collection.$infer.select, collection.$infer.insert, etc.
   */
  $infer;
  /**
   * Get virtual fields with specific context
   * This allows regenerating virtual field SQL with runtime context
   */
  getVirtuals(_context) {
    return this.state.virtuals || {};
  }
  /**
   * Get virtual fields with aliased i18n tables for use in queries.
   * This creates COALESCE expressions using the aliased tables instead of subqueries.
   *
   * @param _context - CRUD context
   * @param _i18nCurrentTable - Aliased i18n table for current locale
   * @param _i18nFallbackTable - Aliased i18n table for fallback locale (null if no fallback)
   */
  getVirtualsWithAliases(_context, _i18nCurrentTable, _i18nFallbackTable) {
    return this.state.virtuals || {};
  }
  getVirtualsForVersions(_context) {
    return this.state.virtuals || {};
  }
  /**
   * Get virtual fields for versions with aliased i18n tables.
   * Creates COALESCE expressions using the aliased tables instead of subqueries.
   *
   * @param _context - CRUD context
   * @param _i18nVersionsCurrentTable - Aliased i18n versions table for current locale
   * @param _i18nVersionsFallbackTable - Aliased i18n versions table for fallback locale
   */
  getVirtualsForVersionsWithAliases(_context, _i18nVersionsCurrentTable, _i18nVersionsFallbackTable) {
    return this.state.virtuals || {};
  }
  /**
   * Get title field name
   */
  getTitleFieldName() {
    return this.state.title;
  }
  /**
   * Get title column/expression with specific context
   * Resolves the title field name to the actual column or virtual SQL
   */
  getTitleExpression(context) {
    const titleField = this.state.title;
    if (!titleField) return null;
    if (titleField in this.state.fields) {
      const mode = getLocalizedFieldMode(
        this.state.localized,
        titleField
      );
      if (mode !== null) {
        const i18nAccessor = this.createI18nAccessor(context);
        return i18nAccessor[titleField];
      }
      return this.table[titleField];
    }
    const virtuals = this.getVirtuals(context);
    if (virtuals && titleField in virtuals) {
      return virtuals[titleField];
    }
    return null;
  }
  /**
   * Get title expression for versions table
   */
  getTitleExpressionForVersions(context) {
    const titleField = this.state.title;
    if (!titleField || !this.versionsTable) return null;
    if (titleField in this.state.fields) {
      const mode = getLocalizedFieldMode(
        this.state.localized,
        titleField
      );
      if (mode !== null) {
        const i18nAccessor = this.createI18nAccessorForVersions(
          this.versionsTable,
          this.i18nVersionsTable,
          context
        );
        return i18nAccessor[titleField];
      }
      return this.versionsTable[titleField];
    }
    const virtuals = this.getVirtualsForVersions(context);
    if (virtuals && titleField in virtuals) {
      return virtuals[titleField];
    }
    return null;
  }
  /**
   * Get raw title expression (for UPDATE queries) without COALESCE
   */
  getRawTitleExpression(context) {
    const titleField = this.state.title;
    if (!titleField) return null;
    if (titleField in this.state.fields) {
      const mode = getLocalizedFieldMode(
        this.state.localized,
        titleField
      );
      if (mode !== null) {
        const i18nAccessor = this.createRawI18nAccessor();
        return i18nAccessor[titleField];
      }
      return this.table[titleField];
    }
    const virtuals = this.getVirtuals(context);
    if (virtuals && titleField in virtuals) {
      return virtuals[titleField];
    }
    return null;
  }
  /**
   * Generate the main Drizzle table
   */
  generateMainTable(indexesFn) {
    const tableName = this.state.name;
    const columns = {};
    const hasUserDefinedId = "id" in this.state.fields;
    if (!hasUserDefinedId) {
      columns.id = defaultIdColumn$1();
    }
    for (const [fieldName, column] of Object.entries(this.state.fields)) {
      const mode = getLocalizedFieldMode(
        this.state.localized,
        fieldName
      );
      if (mode !== null) {
        if (mode === "nested" && isJsonbColumn(column)) {
          columns[fieldName] = column;
        }
        continue;
      }
      columns[fieldName] = column;
    }
    if (this.state.options.timestamps !== false) {
      Object.assign(columns, Collection.timestampsCols());
    }
    if (this.state.options.softDelete) {
      Object.assign(columns, Collection.softDeleteCols());
    }
    const table = pgTable(tableName, columns, (t2) => {
      const constraints = {};
      if (indexesFn) {
        Object.assign(constraints, indexesFn({ table: t2 }));
      }
      if (this.state.options.softDelete) {
        constraints[`${tableName}_deleted_at_idx`] = index$2().on(
          t2.deletedAt
        );
      }
      return Object.values(constraints);
    });
    return table;
  }
  /**
   * Generate the i18n table for localized fields
   * Uses the same ID type as the parent table for parentId foreign key
   *
   * Includes:
   * - Flat localized fields (non-JSONB) - entire column is localized
   * - JSONB whole-mode localized fields - entire JSONB per locale
   * - `_localized` JSONB column - stores nested localized values from $i18n wrappers
   *
   * Note: JSONB nested-mode fields do NOT get their own column in the i18n table.
   * Instead, they stay in the main table (with $i18n markers) and their extracted
   * localized values are stored in the `_localized` column.
   */
  generateI18nTable() {
    const hasLocalizedFields = this.state.localized.length > 0;
    if (!hasLocalizedFields) return null;
    const tableName = `${this.state.name}_i18n`;
    const parentIdColumn = this.table.id;
    const columns = {
      // Own ID - uses default type
      id: text("id").primaryKey().default(sql$1`gen_random_uuid()`),
      // Parent ID - matches parent table's ID type
      parentId: cloneColumnType$1(parentIdColumn, "parent_id").notNull().references(() => this.table.id, { onDelete: "cascade" }),
      locale: text("locale").notNull(),
      // Nested localized values from $i18n wrappers in nested-mode fields
      _localized: jsonb("_localized")
    };
    for (const localizedField of this.state.localized) {
      const parsed = parseLocalizedField(localizedField);
      const column = this.state.fields[parsed.name];
      if (!column) continue;
      const isJsonb = isJsonbColumn(column);
      if (!isJsonb) {
        columns[parsed.name] = column;
        continue;
      }
      if (parsed.mode === "whole") {
        columns[parsed.name] = column;
      }
    }
    return pgTable(tableName, columns, (t2) => ({
      parentLocaleIdx: uniqueIndex().on(t2.parentId, t2.locale)
    }));
  }
  /**
   * Generate the versions table
   * Uses the same ID type as the parent table for the id foreign key
   */
  generateVersionsTable() {
    const versioning = this.state.options.versioning;
    if (!versioning) return null;
    if (typeof versioning === "object" && !versioning.enabled) return null;
    const tableName = `${this.state.name}_versions`;
    const parentIdColumn = this.table.id;
    const columns = Collection.versionCols(parentIdColumn);
    for (const [fieldName, column] of Object.entries(this.state.fields)) {
      if (this.state.localized.includes(fieldName)) continue;
      if (fieldName === "id") continue;
      columns[fieldName] = column;
    }
    return pgTable(tableName, columns, (t2) => [
      index$2().on(t2.id, t2.versionNumber),
      index$2().on(t2.versionCreatedAt)
    ]);
  }
  /**
   * Generate the i18n versions table
   * Uses the same ID type as the parent table for parentId
   */
  generateI18nVersionsTable() {
    const versioning = this.state.options.versioning;
    if (!versioning) return null;
    if (typeof versioning === "object" && !versioning.enabled) return null;
    if (this.state.localized.length === 0) return null;
    const tableName = `${this.state.name}_i18n_versions`;
    const parentIdColumn = this.table.id;
    const columns = Collection.i18nVersionCols(parentIdColumn);
    columns._localized = jsonb("_localized");
    for (const localizedField of this.state.localized) {
      const parsed = parseLocalizedField(localizedField);
      const column = this.state.fields[parsed.name];
      if (!column) continue;
      const isJsonb = isJsonbColumn(column);
      if (!isJsonb) {
        columns[parsed.name] = column;
        continue;
      }
      if (parsed.mode === "whole") {
        columns[parsed.name] = column;
      }
    }
    return pgTable(tableName, columns, (t2) => [
      uniqueIndex().on(t2.parentId, t2.versionNumber, t2.locale),
      index$2().on(t2.parentId, t2.versionNumber)
    ]);
  }
  /**
   * Create i18n accessor object for localized fields
   * Returns SQL expressions with COALESCE pattern for each localized field
   */
  createI18nAccessorFor(table, i18nTable, context) {
    const accessor = {};
    const defaultLocale2 = context?.defaultLocale || DEFAULT_LOCALE;
    if (!i18nTable) return accessor;
    for (const localizedField of this.state.localized) {
      const parsed = parseLocalizedField(localizedField);
      const fieldName = parsed.name;
      const i18nRef = i18nTable;
      if (context?.localeFallback === false) {
        accessor[fieldName] = i18nRef[fieldName];
      } else {
        accessor[fieldName] = sql$1`COALESCE(
					${i18nRef[fieldName]},
					(SELECT ${i18nRef[fieldName]} FROM ${i18nTable}
					 WHERE ${i18nRef.parentId} = ${table.id}
					 AND ${i18nRef.locale} = ${defaultLocale2} LIMIT 1)
				)`;
      }
    }
    return accessor;
  }
  createI18nAccessorForVersions(table, i18nTable, context) {
    const accessor = {};
    const defaultLocale2 = context?.defaultLocale || DEFAULT_LOCALE;
    if (!i18nTable) return accessor;
    for (const localizedField of this.state.localized) {
      const parsed = parseLocalizedField(localizedField);
      const fieldName = parsed.name;
      const i18nRef = i18nTable;
      if (context?.localeFallback === false) {
        accessor[fieldName] = i18nRef[fieldName];
      } else {
        accessor[fieldName] = sql$1`COALESCE(
					${i18nRef[fieldName]},
					(SELECT ${i18nRef[fieldName]} FROM ${i18nTable}
					 WHERE ${i18nRef.parentId} = ${table.id}
					 AND ${i18nRef.versionNumber} = ${table.versionNumber}
					 AND ${i18nRef.locale} = ${defaultLocale2} LIMIT 1)
				)`;
      }
    }
    return accessor;
  }
  /**
   * Create raw i18n accessor object (direct column references)
   */
  createRawI18nAccessorFor(i18nTable) {
    const accessor = {};
    if (!i18nTable) return accessor;
    for (const localizedField of this.state.localized) {
      const parsed = parseLocalizedField(localizedField);
      const fieldName = parsed.name;
      accessor[fieldName] = i18nTable[fieldName];
    }
    return accessor;
  }
  createI18nAccessor(context) {
    return this.createI18nAccessorFor(this.table, this.i18nTable, context);
  }
  /**
   * Create i18n accessor using aliased tables for current and fallback locales.
   * Uses simple COALESCE(current, fallback) instead of subqueries.
   *
   * @param i18nCurrentTable - Aliased i18n table for current locale (null if no i18n)
   * @param i18nFallbackTable - Aliased i18n table for fallback locale (null if no fallback)
   * @param context - CRUD context
   */
  createI18nAccessorWithAliases(i18nCurrentTable, i18nFallbackTable, context) {
    const accessor = {};
    if (!i18nCurrentTable) return accessor;
    for (const localizedField of this.state.localized) {
      const parsed = parseLocalizedField(localizedField);
      const fieldName = parsed.name;
      const currentRef = i18nCurrentTable[fieldName];
      if (!i18nFallbackTable || context?.localeFallback === false) {
        accessor[fieldName] = currentRef;
      } else {
        const fallbackRef = i18nFallbackTable[fieldName];
        accessor[fieldName] = sql$1`COALESCE(${currentRef}, ${fallbackRef})`;
      }
    }
    return accessor;
  }
  /**
   * Create i18n accessor for versions using aliased tables for current and fallback locales.
   * Uses simple COALESCE(current, fallback) instead of subqueries.
   *
   * @param i18nVersionsCurrentTable - Aliased i18n versions table for current locale
   * @param i18nVersionsFallbackTable - Aliased i18n versions table for fallback locale
   * @param context - CRUD context
   */
  createI18nAccessorWithAliasesForVersions(i18nVersionsCurrentTable, i18nVersionsFallbackTable, context) {
    const accessor = {};
    if (!i18nVersionsCurrentTable) return accessor;
    for (const localizedField of this.state.localized) {
      const parsed = parseLocalizedField(localizedField);
      const fieldName = parsed.name;
      const currentRef = i18nVersionsCurrentTable[fieldName];
      if (!i18nVersionsFallbackTable || context?.localeFallback === false) {
        accessor[fieldName] = currentRef;
      } else {
        const fallbackRef = i18nVersionsFallbackTable[fieldName];
        accessor[fieldName] = sql$1`COALESCE(${currentRef}, ${fallbackRef})`;
      }
    }
    return accessor;
  }
  createRawI18nAccessor() {
    return this.createRawI18nAccessorFor(this.i18nTable);
  }
  /**
   * Generate CRUD operations (Drizzle RQB v2-like)
   */
  generateCRUD(db, cms2) {
    const crud = new CRUDGenerator(
      this.state,
      this.table,
      this.i18nTable,
      this.versionsTable,
      this.i18nVersionsTable,
      db,
      this.getVirtuals.bind(this),
      this.getVirtualsWithAliases.bind(this),
      this.getTitleExpression.bind(this),
      this.getVirtualsForVersions.bind(this),
      this.getVirtualsForVersionsWithAliases.bind(this),
      this.getTitleExpressionForVersions.bind(this),
      this.getRawTitleExpression.bind(this),
      cms2
    );
    return crud.generate();
  }
  // ...
  /**
   * Get metadata about the collection
   */
  getMeta() {
    const titleField = this.state.title;
    const titleMeta = {
      defined: !!titleField,
      type: null,
      fieldName: titleField || null
    };
    if (titleField) {
      if (titleField in this.state.fields) {
        titleMeta.type = "field";
      } else if (this.state.virtuals && titleField in this.state.virtuals) {
        titleMeta.type = "virtual";
      }
    }
    return {
      name: this.state.name,
      fields: Object.entries(this.state.fields).map(([name2, column]) => {
        const mode = getLocalizedFieldMode(
          this.state.localized,
          name2
        );
        return {
          name: name2,
          column,
          localized: mode !== null,
          localizationMode: mode,
          virtual: this.state.virtuals && name2 in this.state.virtuals
        };
      }),
      title: titleMeta,
      timestamps: this.state.options.timestamps !== false,
      softDelete: this.state.options.softDelete || false,
      virtualFields: this.state.virtuals ? Object.keys(this.state.virtuals) : [],
      localizedFields: Array.from(this.state.localized).map(
        (f) => parseLocalizedField(f)
      ),
      relations: Object.keys(this.state.relations)
    };
  }
}
const defineField = () => (impl) => impl;
function createFieldDefinition(fieldDef, config2) {
  const fieldConfig = config2 ?? {};
  const location = "virtual" in fieldConfig && (fieldConfig.virtual === true || typeof fieldConfig.virtual === "object" && fieldConfig.virtual !== null) ? "virtual" : fieldConfig.localized === true ? "i18n" : "main";
  const state = {
    type: fieldDef.type,
    config: fieldConfig,
    value: void 0,
    input: void 0,
    output: void 0,
    select: void 0,
    column: void 0,
    location,
    operators: void 0
  };
  return {
    state,
    $types: {},
    toColumn(name2) {
      if (location === "virtual") {
        return null;
      }
      return fieldDef.toColumn(name2, fieldConfig);
    },
    toZodSchema() {
      return fieldDef.toZodSchema(fieldConfig);
    },
    getOperators() {
      return fieldDef.getOperators(fieldConfig);
    },
    getMetadata() {
      return fieldDef.getMetadata(fieldConfig);
    },
    getNestedFields: fieldDef.getNestedFields ? () => fieldDef.getNestedFields(fieldConfig) : void 0,
    getSelectModifier: fieldDef.getSelectModifier ? () => fieldDef.getSelectModifier(fieldConfig) : void 0,
    getJoinBuilder: fieldDef.getJoinBuilder ? () => fieldDef.getJoinBuilder(fieldConfig) : void 0,
    fromDb: fieldDef.fromDb ? (dbValue) => fieldDef.fromDb(dbValue, fieldConfig) : void 0,
    toDb: fieldDef.toDb ? (value) => fieldDef.toDb(value, fieldConfig) : void 0
  };
}
function createFieldBuilder(fieldDefs) {
  return new Proxy({}, {
    get(_target, prop) {
      const fieldDef = fieldDefs[prop];
      if (!fieldDef) {
        throw new Error(
          `Unknown field type: "${prop}". Available types: ${Object.keys(fieldDefs).join(", ")}`
        );
      }
      return (config2) => createFieldDefinition(fieldDef, config2);
    },
    has(_target, prop) {
      return prop in fieldDefs;
    },
    ownKeys() {
      return Object.keys(fieldDefs);
    },
    getOwnPropertyDescriptor(_target, prop) {
      if (prop in fieldDefs) {
        return {
          configurable: true,
          enumerable: true,
          value: (config2) => createFieldDefinition(fieldDefs[prop], config2)
        };
      }
      return void 0;
    }
  });
}
function operator(fn2) {
  return fn2;
}
function getArrayOperators() {
  return {
    column: {
      // Contains the given element
      contains: operator(
        (col, value) => sql$1`${col} @> ${JSON.stringify([value])}::jsonb`
      ),
      // Contains all the given elements
      containsAll: operator(
        (col, values) => sql$1`${col} @> ${JSON.stringify(values)}::jsonb`
      ),
      // Contains any of the given elements
      containsAny: operator((col, values) => {
        if (values.length === 0) return sql$1`FALSE`;
        return sql$1`${col} ?| ARRAY[${sql$1.join(
          values.map((v) => sql$1`${JSON.stringify(v)}`),
          sql$1`, `
        )}]::text[]`;
      }),
      // Is contained by the given array
      containedBy: operator(
        (col, values) => sql$1`${col} <@ ${JSON.stringify(values)}::jsonb`
      ),
      // Array length equals
      length: operator(
        (col, value) => sql$1`jsonb_array_length(COALESCE(${col}, '[]'::jsonb)) = ${value}`
      ),
      // Array length greater than
      lengthGt: operator(
        (col, value) => sql$1`jsonb_array_length(COALESCE(${col}, '[]'::jsonb)) > ${value}`
      ),
      // Array length less than
      lengthLt: operator(
        (col, value) => sql$1`jsonb_array_length(COALESCE(${col}, '[]'::jsonb)) < ${value}`
      ),
      // Array length between
      lengthBetween: operator((col, value) => {
        return sql$1`jsonb_array_length(COALESCE(${col}, '[]'::jsonb)) BETWEEN ${value[0]} AND ${value[1]}`;
      }),
      // Is empty array
      isEmpty: operator(
        (col) => sql$1`(${col} = '[]'::jsonb OR ${col} IS NULL)`
      ),
      // Is not empty
      isNotEmpty: operator(
        (col) => sql$1`(${col} != '[]'::jsonb AND ${col} IS NOT NULL)`
      ),
      // Some element matches condition (requires subquery in practice)
      some: operator(() => sql$1`TRUE`),
      // Placeholder
      // Every element matches condition
      every: operator(() => sql$1`TRUE`),
      // Placeholder
      // No element matches condition
      none: operator(() => sql$1`TRUE`),
      // Placeholder
      isNull: operator(
        (col, value) => value ? sql$1`${col} IS NULL` : sql$1`${col} IS NOT NULL`
      ),
      isNotNull: operator(
        (col, value) => value ? sql$1`${col} IS NOT NULL` : sql$1`${col} IS NULL`
      )
    },
    jsonb: {
      contains: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`${col}#>'{${sql$1.raw(path)}}' @> ${JSON.stringify([value])}::jsonb`;
      }),
      containsAll: operator((col, values, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`${col}#>'{${sql$1.raw(path)}}' @> ${JSON.stringify(values)}::jsonb`;
      }),
      containedBy: operator((col, values, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`${col}#>'{${sql$1.raw(path)}}' <@ ${JSON.stringify(values)}::jsonb`;
      }),
      length: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`jsonb_array_length(COALESCE(${col}#>'{${sql$1.raw(path)}}', '[]'::jsonb)) = ${value}`;
      }),
      isEmpty: operator((col, _value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>'{${sql$1.raw(path)}}' = '[]'::jsonb OR ${col}#>'{${sql$1.raw(path)}}' IS NULL)`;
      }),
      isNotEmpty: operator((col, _value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>'{${sql$1.raw(path)}}' != '[]'::jsonb AND ${col}#>'{${sql$1.raw(path)}}' IS NOT NULL)`;
      }),
      isNull: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return value ? sql$1`${col}#>'{${sql$1.raw(path)}}' IS NULL` : sql$1`${col}#>'{${sql$1.raw(path)}}' IS NOT NULL`;
      }),
      isNotNull: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return value ? sql$1`${col}#>'{${sql$1.raw(path)}}' IS NOT NULL` : sql$1`${col}#>'{${sql$1.raw(path)}}' IS NULL`;
      })
    }
  };
}
function resolveItemField(of) {
  return typeof of === "function" ? of() : of;
}
const arrayField = defineField()({
  type: "array",
  _value: void 0,
  toColumn(name2, config2) {
    let column = jsonb(name2);
    if (config2.required && config2.nullable !== true) {
      column = column.notNull();
    }
    if (config2.default !== void 0) {
      const defaultValue = typeof config2.default === "function" ? config2.default() : config2.default;
      column = column.default(defaultValue);
    }
    return column;
  },
  toZodSchema(config2) {
    const itemField = resolveItemField(config2.of);
    let schema2 = z$1.array(itemField.toZodSchema());
    if (config2.minItems !== void 0) {
      schema2 = schema2.min(config2.minItems);
    }
    if (config2.maxItems !== void 0) {
      schema2 = schema2.max(config2.maxItems);
    }
    if (!config2.required && config2.nullable !== false) {
      return schema2.nullish();
    }
    return schema2;
  },
  getOperators(config2) {
    return getArrayOperators();
  },
  getMetadata(config2) {
    const itemField = resolveItemField(config2.of);
    return {
      type: "array",
      label: config2.label,
      description: config2.description,
      required: config2.required ?? false,
      localized: config2.localized ?? false,
      readOnly: config2.input === false,
      writeOnly: config2.output === false,
      nestedFields: {
        item: itemField.getMetadata()
      },
      validation: {
        minItems: config2.minItems,
        maxItems: config2.maxItems
      },
      meta: config2.meta
    };
  }
});
function getBooleanOperators() {
  return {
    column: {
      eq: operator((col, value) => eq(col, value)),
      ne: operator((col, value) => ne(col, value)),
      is: operator((col, value) => eq(col, value)),
      isNot: operator((col, value) => ne(col, value)),
      isTrue: operator((col) => eq(col, true)),
      isFalse: operator((col) => eq(col, false)),
      isNull: operator(
        (col, value) => value ? sql$1`${col} IS NULL` : sql$1`${col} IS NOT NULL`
      ),
      isNotNull: operator(
        (col, value) => value ? sql$1`${col} IS NOT NULL` : sql$1`${col} IS NULL`
      )
    },
    jsonb: {
      eq: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>>'{${sql$1.raw(path)}}')::boolean = ${value}`;
      }),
      ne: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>>'{${sql$1.raw(path)}}')::boolean != ${value}`;
      }),
      is: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>>'{${sql$1.raw(path)}}')::boolean = ${value}`;
      }),
      isNot: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>>'{${sql$1.raw(path)}}')::boolean != ${value}`;
      }),
      isTrue: operator((col, _value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>>'{${sql$1.raw(path)}}')::boolean = true`;
      }),
      isFalse: operator((col, _value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>>'{${sql$1.raw(path)}}')::boolean = false`;
      }),
      isNull: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return value ? sql$1`${col}#>'{${sql$1.raw(path)}}' IS NULL` : sql$1`${col}#>'{${sql$1.raw(path)}}' IS NOT NULL`;
      }),
      isNotNull: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return value ? sql$1`${col}#>'{${sql$1.raw(path)}}' IS NOT NULL` : sql$1`${col}#>'{${sql$1.raw(path)}}' IS NULL`;
      })
    }
  };
}
const booleanField = defineField()({
  type: "boolean",
  _value: void 0,
  toColumn(name2, config2) {
    let column = boolean(name2);
    if (config2.required && config2.nullable !== true) {
      column = column.notNull();
    }
    let defaultValue;
    if (config2.default !== void 0) {
      defaultValue = typeof config2.default === "function" ? config2.default() : config2.default;
    } else if (config2.defaultTrue) {
      defaultValue = true;
    } else if (config2.defaultFalse) {
      defaultValue = false;
    }
    if (defaultValue !== void 0) {
      column = column.default(defaultValue);
    }
    return column;
  },
  toZodSchema(config2) {
    const schema2 = z$1.boolean();
    if (!config2.required && config2.nullable !== false) {
      return schema2.nullish();
    }
    return schema2;
  },
  getOperators(config2) {
    return getBooleanOperators();
  },
  getMetadata(config2) {
    return {
      type: "boolean",
      label: config2.label,
      description: config2.description,
      required: config2.required ?? false,
      localized: config2.localized ?? false,
      readOnly: config2.input === false,
      writeOnly: config2.output === false,
      meta: config2.meta
    };
  }
});
function getDateOperators() {
  return {
    column: {
      eq: operator((col, value) => eq(col, value)),
      ne: operator((col, value) => ne(col, value)),
      gt: operator((col, value) => gt(col, value)),
      gte: operator((col, value) => gte(col, value)),
      lt: operator((col, value) => lt(col, value)),
      lte: operator((col, value) => lte(col, value)),
      between: operator(
        (col, value) => between(col, value[0], value[1])
      ),
      before: operator((col, value) => lt(col, value)),
      after: operator((col, value) => gt(col, value)),
      isNull: operator(
        (col, value) => value ? sql$1`${col} IS NULL` : sql$1`${col} IS NOT NULL`
      ),
      isNotNull: operator(
        (col, value) => value ? sql$1`${col} IS NOT NULL` : sql$1`${col} IS NULL`
      )
    },
    jsonb: {
      eq: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>>'{${sql$1.raw(path)}}')::date = ${value}::date`;
      }),
      ne: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>>'{${sql$1.raw(path)}}')::date != ${value}::date`;
      }),
      gt: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>>'{${sql$1.raw(path)}}')::date > ${value}::date`;
      }),
      gte: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>>'{${sql$1.raw(path)}}')::date >= ${value}::date`;
      }),
      lt: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>>'{${sql$1.raw(path)}}')::date < ${value}::date`;
      }),
      lte: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>>'{${sql$1.raw(path)}}')::date <= ${value}::date`;
      }),
      between: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>>'{${sql$1.raw(path)}}')::date BETWEEN ${value[0]}::date AND ${value[1]}::date`;
      }),
      isNull: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return value ? sql$1`${col}#>'{${sql$1.raw(path)}}' IS NULL` : sql$1`${col}#>'{${sql$1.raw(path)}}' IS NOT NULL`;
      }),
      isNotNull: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return value ? sql$1`${col}#>'{${sql$1.raw(path)}}' IS NOT NULL` : sql$1`${col}#>'{${sql$1.raw(path)}}' IS NULL`;
      })
    }
  };
}
const dateField = defineField()({
  type: "date",
  _value: void 0,
  toColumn(name2, config2) {
    let column = date(name2, { mode: "string" });
    if (config2.required && config2.nullable !== true) {
      column = column.notNull();
    }
    if (config2.autoNow) {
      column = column.defaultNow();
    } else if (config2.default !== void 0) {
      const defaultValue = typeof config2.default === "function" ? config2.default() : config2.default;
      column = column.default(defaultValue);
    }
    return column;
  },
  toZodSchema(config2) {
    let schema2 = z$1.string().date();
    if (config2.min) {
      const minDate = typeof config2.min === "string" ? config2.min : config2.min.toISOString().split("T")[0];
      schema2 = schema2.refine((val) => val >= minDate, {
        message: `Date must be on or after ${minDate}`
      });
    }
    if (config2.max) {
      const maxDate = typeof config2.max === "string" ? config2.max : config2.max.toISOString().split("T")[0];
      schema2 = schema2.refine((val) => val <= maxDate, {
        message: `Date must be on or before ${maxDate}`
      });
    }
    if (!config2.required && config2.nullable !== false) {
      return schema2.nullish();
    }
    return schema2;
  },
  getOperators() {
    return getDateOperators();
  },
  getMetadata(config2) {
    const minDate = config2.min ? typeof config2.min === "string" ? config2.min : config2.min.toISOString().split("T")[0] : void 0;
    const maxDate = config2.max ? typeof config2.max === "string" ? config2.max : config2.max.toISOString().split("T")[0] : void 0;
    return {
      type: "date",
      label: config2.label,
      description: config2.description,
      required: config2.required ?? false,
      localized: config2.localized ?? false,
      readOnly: config2.input === false,
      writeOnly: config2.output === false,
      meta: config2.meta,
      // Date-specific constraints for admin UI
      min: minDate,
      max: maxDate
    };
  }
});
function getDatetimeOperators() {
  return {
    column: {
      eq: operator(
        (col, value) => eq(col, new Date(value))
      ),
      ne: operator(
        (col, value) => ne(col, new Date(value))
      ),
      gt: operator(
        (col, value) => gt(col, new Date(value))
      ),
      gte: operator(
        (col, value) => gte(col, new Date(value))
      ),
      lt: operator(
        (col, value) => lt(col, new Date(value))
      ),
      lte: operator(
        (col, value) => lte(col, new Date(value))
      ),
      between: operator(
        (col, value) => between(
          col,
          new Date(value[0]),
          new Date(value[1])
        )
      ),
      before: operator(
        (col, value) => lt(col, new Date(value))
      ),
      after: operator(
        (col, value) => gt(col, new Date(value))
      ),
      isNull: operator(
        (col, value) => value ? sql$1`${col} IS NULL` : sql$1`${col} IS NOT NULL`
      ),
      isNotNull: operator(
        (col, value) => value ? sql$1`${col} IS NOT NULL` : sql$1`${col} IS NULL`
      )
    },
    jsonb: {
      eq: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>>'{${sql$1.raw(path)}}')::timestamptz = ${value}::timestamptz`;
      }),
      ne: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>>'{${sql$1.raw(path)}}')::timestamptz != ${value}::timestamptz`;
      }),
      gt: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>>'{${sql$1.raw(path)}}')::timestamptz > ${value}::timestamptz`;
      }),
      gte: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>>'{${sql$1.raw(path)}}')::timestamptz >= ${value}::timestamptz`;
      }),
      lt: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>>'{${sql$1.raw(path)}}')::timestamptz < ${value}::timestamptz`;
      }),
      lte: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>>'{${sql$1.raw(path)}}')::timestamptz <= ${value}::timestamptz`;
      }),
      between: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>>'{${sql$1.raw(path)}}')::timestamptz BETWEEN ${value[0]}::timestamptz AND ${value[1]}::timestamptz`;
      }),
      isNull: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return value ? sql$1`${col}#>'{${sql$1.raw(path)}}' IS NULL` : sql$1`${col}#>'{${sql$1.raw(path)}}' IS NOT NULL`;
      }),
      isNotNull: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return value ? sql$1`${col}#>'{${sql$1.raw(path)}}' IS NOT NULL` : sql$1`${col}#>'{${sql$1.raw(path)}}' IS NULL`;
      })
    }
  };
}
const datetimeField = defineField()({
  type: "datetime",
  _value: void 0,
  toColumn(name2, config2) {
    const { precision = 3, withTimezone = true } = config2;
    let column = timestamp(name2, {
      precision,
      withTimezone,
      mode: "date"
    });
    if (config2.required && config2.nullable !== true) {
      column = column.notNull();
    }
    if (config2.autoNow) {
      column = column.defaultNow();
    } else if (config2.default !== void 0) {
      const defaultValue = typeof config2.default === "function" ? config2.default() : config2.default;
      column = column.default(defaultValue);
    }
    return column;
  },
  toZodSchema(config2) {
    let schema2 = z$1.coerce.date();
    if (config2.min) {
      const minDate = typeof config2.min === "string" ? new Date(config2.min) : config2.min;
      schema2 = schema2.min(minDate);
    }
    if (config2.max) {
      const maxDate = typeof config2.max === "string" ? new Date(config2.max) : config2.max;
      schema2 = schema2.max(maxDate);
    }
    if (!config2.required && config2.nullable !== false) {
      return schema2.nullish();
    }
    return schema2;
  },
  getOperators() {
    return getDatetimeOperators();
  },
  getMetadata(config2) {
    const minDate = config2.min ? typeof config2.min === "string" ? config2.min : config2.min.toISOString() : void 0;
    const maxDate = config2.max ? typeof config2.max === "string" ? config2.max : config2.max.toISOString() : void 0;
    return {
      type: "datetime",
      label: config2.label,
      description: config2.description,
      required: config2.required ?? false,
      localized: config2.localized ?? false,
      readOnly: config2.input === false,
      writeOnly: config2.output === false,
      meta: config2.meta,
      // Datetime-specific constraints for admin UI
      min: minDate,
      max: maxDate,
      precision: config2.precision,
      withTimezone: config2.withTimezone
    };
  }
});
const stringColumnOperators = {
  eq: operator((col, value) => eq(col, value)),
  ne: operator((col, value) => ne(col, value)),
  in: operator((col, values) => inArray(col, values)),
  notIn: operator((col, values) => notInArray(col, values)),
  like: operator((col, value) => like(col, value)),
  ilike: operator((col, value) => ilike(col, value)),
  notLike: operator((col, value) => notLike(col, value)),
  notIlike: operator((col, value) => notIlike(col, value)),
  contains: operator(
    (col, value) => sql$1`${col} LIKE '%' || ${value} || '%'`
  ),
  startsWith: operator(
    (col, value) => sql$1`${col} LIKE ${value} || '%'`
  ),
  endsWith: operator(
    (col, value) => sql$1`${col} LIKE '%' || ${value}`
  ),
  isNull: operator(
    (col, value) => value ? isNull$2(col) : isNotNull$1(col)
  ),
  isNotNull: operator(
    (col, value) => value ? isNotNull$1(col) : isNull$2(col)
  )
};
const stringJsonbOperators = {
  eq: operator((col, value, ctx) => {
    const path = ctx.jsonbPath?.join(",") ?? "";
    return sql$1`${col}#>>'{${sql$1.raw(path)}}' = ${value}`;
  }),
  ne: operator((col, value, ctx) => {
    const path = ctx.jsonbPath?.join(",") ?? "";
    return sql$1`${col}#>>'{${sql$1.raw(path)}}' != ${value}`;
  }),
  in: operator((col, values, ctx) => {
    const path = ctx.jsonbPath?.join(",") ?? "";
    return sql$1`${col}#>>'{${sql$1.raw(path)}}' = ANY(${values}::text[])`;
  }),
  notIn: operator((col, values, ctx) => {
    const path = ctx.jsonbPath?.join(",") ?? "";
    return sql$1`NOT (${col}#>>'{${sql$1.raw(path)}}' = ANY(${values}::text[]))`;
  }),
  like: operator((col, value, ctx) => {
    const path = ctx.jsonbPath?.join(",") ?? "";
    return sql$1`${col}#>>'{${sql$1.raw(path)}}' LIKE ${value}`;
  }),
  ilike: operator((col, value, ctx) => {
    const path = ctx.jsonbPath?.join(",") ?? "";
    return sql$1`${col}#>>'{${sql$1.raw(path)}}' ILIKE ${value}`;
  }),
  contains: operator((col, value, ctx) => {
    const path = ctx.jsonbPath?.join(",") ?? "";
    return sql$1`${col}#>>'{${sql$1.raw(path)}}' LIKE '%' || ${value} || '%'`;
  }),
  startsWith: operator((col, value, ctx) => {
    const path = ctx.jsonbPath?.join(",") ?? "";
    return sql$1`${col}#>>'{${sql$1.raw(path)}}' LIKE ${value} || '%'`;
  }),
  endsWith: operator((col, value, ctx) => {
    const path = ctx.jsonbPath?.join(",") ?? "";
    return sql$1`${col}#>>'{${sql$1.raw(path)}}' LIKE '%' || ${value}`;
  }),
  isNull: operator((col, value, ctx) => {
    const path = ctx.jsonbPath?.join(",") ?? "";
    return value ? sql$1`${col}#>'{${sql$1.raw(path)}}' IS NULL` : sql$1`${col}#>'{${sql$1.raw(path)}}' IS NOT NULL`;
  }),
  isNotNull: operator((col, value, ctx) => {
    const path = ctx.jsonbPath?.join(",") ?? "";
    return value ? sql$1`${col}#>'{${sql$1.raw(path)}}' IS NOT NULL` : sql$1`${col}#>'{${sql$1.raw(path)}}' IS NULL`;
  })
};
function getEmailOperators() {
  return {
    column: {
      ...stringColumnOperators,
      in: operator((col, values) => inArray(col, values)),
      // Email-specific operators
      domain: operator(
        (col, value) => ilike(col, `%@${value}`)
      ),
      domainIn: operator((col, values) => {
        if (values.length === 0) return sql$1`FALSE`;
        if (values.length === 1) return ilike(col, `%@${values[0]}`);
        return sql$1`(${sql$1.join(
          values.map((d) => ilike(col, `%@${d}`)),
          sql$1` OR `
        )})`;
      })
    },
    jsonb: {
      ...stringJsonbOperators,
      domain: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`${col}#>>'{${sql$1.raw(path)}}' ILIKE ${"%@" + value}`;
      })
    }
  };
}
const emailField = defineField()({
  type: "email",
  _value: void 0,
  toColumn(name2, config2) {
    const { maxLength = 255 } = config2;
    let column = varchar(name2, { length: maxLength });
    if (config2.required && config2.nullable !== true) {
      column = column.notNull();
    }
    if (config2.default !== void 0) {
      const defaultValue = typeof config2.default === "function" ? config2.default() : config2.default;
      column = column.default(defaultValue);
    }
    return column;
  },
  toZodSchema(config2) {
    const { lowercase = true } = config2;
    let schema2 = z$1.string().email();
    if (config2.maxLength) {
      schema2 = schema2.max(config2.maxLength);
    }
    if (lowercase) {
      schema2 = schema2.toLowerCase();
    }
    if (config2.allowedDomains && config2.allowedDomains.length > 0) {
      const domains = config2.allowedDomains.map((d) => d.toLowerCase());
      schema2 = schema2.refine(
        (email) => {
          const domain = email.split("@")[1]?.toLowerCase();
          return domain && domains.includes(domain);
        },
        {
          message: `Email domain must be one of: ${config2.allowedDomains.join(", ")}`
        }
      );
    }
    if (config2.blockedDomains && config2.blockedDomains.length > 0) {
      const domains = config2.blockedDomains.map((d) => d.toLowerCase());
      schema2 = schema2.refine(
        (email) => {
          const domain = email.split("@")[1]?.toLowerCase();
          return !domain || !domains.includes(domain);
        },
        {
          message: `Email domain is not allowed: ${config2.blockedDomains.join(", ")}`
        }
      );
    }
    if (!config2.required && config2.nullable !== false) {
      return schema2.nullish();
    }
    return schema2;
  },
  getOperators(config2) {
    return getEmailOperators();
  },
  getMetadata(config2) {
    return {
      type: "email",
      label: config2.label,
      description: config2.description,
      required: config2.required ?? false,
      localized: config2.localized ?? false,
      readOnly: config2.input === false,
      writeOnly: config2.output === false,
      validation: {
        maxLength: config2.maxLength ?? 255
      },
      meta: config2.meta
    };
  }
});
function getJsonOperators() {
  return {
    column: {
      // Contains the given key-value pairs (for objects)
      contains: operator(
        (col, value) => sql$1`${col} @> ${JSON.stringify(value)}::jsonb`
      ),
      // Is contained by the given value
      containedBy: operator(
        (col, value) => sql$1`${col} <@ ${JSON.stringify(value)}::jsonb`
      ),
      // Has the given key (for objects)
      hasKey: operator((col, value) => sql$1`${col} ? ${value}`),
      // Has all the given keys
      hasKeys: operator(
        (col, values) => sql$1`${col} ?& ${sql$1.raw(`ARRAY[${values.map((v) => `'${v}'`).join(",")}]`)}`
      ),
      // Has any of the given keys
      hasAnyKeys: operator(
        (col, values) => sql$1`${col} ?| ${sql$1.raw(`ARRAY[${values.map((v) => `'${v}'`).join(",")}]`)}`
      ),
      // Value at path equals
      pathEquals: operator(
        (col, value) => {
          return sql$1`${col}#>>'{${sql$1.raw(value.path.join(","))}}' = ${value.val}`;
        }
      ),
      // Value at path exists
      pathExists: operator((col, value) => {
        return sql$1`${col}#>'{${sql$1.raw(value.join(","))}}' IS NOT NULL`;
      }),
      // JSON path query (PostgreSQL 12+)
      jsonPath: operator(
        (col, value) => sql$1`${col} @@ ${value}::jsonpath`
      ),
      // Equals (exact match)
      eq: operator(
        (col, value) => sql$1`${col} = ${JSON.stringify(value)}::jsonb`
      ),
      // Not equals
      ne: operator(
        (col, value) => sql$1`${col} != ${JSON.stringify(value)}::jsonb`
      ),
      // Type of JSON value
      typeof: operator((col, value) => {
        return sql$1`jsonb_typeof(${col}) = ${value}`;
      }),
      // Is empty (empty object, array, or null)
      isEmpty: operator(
        (col) => sql$1`(${col} IN ('[]'::jsonb, '{}'::jsonb, 'null'::jsonb) OR ${col} IS NULL)`
      ),
      // Is not empty
      isNotEmpty: operator(
        (col) => sql$1`(${col} NOT IN ('[]'::jsonb, '{}'::jsonb, 'null'::jsonb) AND ${col} IS NOT NULL)`
      ),
      isNull: operator(
        (col, value) => value ? sql$1`${col} IS NULL` : sql$1`${col} IS NOT NULL`
      ),
      isNotNull: operator(
        (col, value) => value ? sql$1`${col} IS NOT NULL` : sql$1`${col} IS NULL`
      )
    },
    jsonb: {
      contains: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`${col}#>'{${sql$1.raw(path)}}' @> ${JSON.stringify(value)}::jsonb`;
      }),
      containedBy: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`${col}#>'{${sql$1.raw(path)}}' <@ ${JSON.stringify(value)}::jsonb`;
      }),
      hasKey: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`${col}#>'{${sql$1.raw(path)}}' ? ${value}`;
      }),
      eq: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`${col}#>'{${sql$1.raw(path)}}' = ${JSON.stringify(value)}::jsonb`;
      }),
      ne: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`${col}#>'{${sql$1.raw(path)}}' != ${JSON.stringify(value)}::jsonb`;
      }),
      isEmpty: operator((col, _value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>'{${sql$1.raw(path)}}' IN ('[]'::jsonb, '{}'::jsonb, 'null'::jsonb) OR ${col}#>'{${sql$1.raw(path)}}' IS NULL)`;
      }),
      isNotEmpty: operator((col, _value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>'{${sql$1.raw(path)}}' NOT IN ('[]'::jsonb, '{}'::jsonb, 'null'::jsonb) AND ${col}#>'{${sql$1.raw(path)}}' IS NOT NULL)`;
      }),
      isNull: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return value ? sql$1`${col}#>'{${sql$1.raw(path)}}' IS NULL` : sql$1`${col}#>'{${sql$1.raw(path)}}' IS NOT NULL`;
      }),
      isNotNull: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return value ? sql$1`${col}#>'{${sql$1.raw(path)}}' IS NOT NULL` : sql$1`${col}#>'{${sql$1.raw(path)}}' IS NULL`;
      })
    }
  };
}
const jsonField = defineField()({
  type: "json",
  _value: void 0,
  toColumn(name2, config2) {
    const { mode = "jsonb" } = config2;
    let column = mode === "json" ? json(name2) : jsonb(name2);
    if (config2.required && config2.nullable !== true) {
      column = column.notNull();
    }
    if (config2.default !== void 0) {
      const defaultValue = typeof config2.default === "function" ? config2.default() : config2.default;
      column = column.default(defaultValue);
    }
    return column;
  },
  toZodSchema(config2) {
    const jsonSchema = z$1.any();
    if (!config2.required && config2.nullable !== false) {
      return jsonSchema.nullish();
    }
    return jsonSchema;
  },
  getOperators(config2) {
    return getJsonOperators();
  },
  getMetadata(config2) {
    return {
      type: "json",
      label: config2.label,
      description: config2.description,
      required: config2.required ?? false,
      localized: config2.localized ?? false,
      readOnly: config2.input === false,
      writeOnly: config2.output === false,
      meta: config2.meta
    };
  }
});
function getNumberOperators() {
  return {
    column: {
      eq: operator((col, value) => eq(col, value)),
      ne: operator((col, value) => ne(col, value)),
      gt: operator((col, value) => gt(col, value)),
      gte: operator((col, value) => gte(col, value)),
      lt: operator((col, value) => lt(col, value)),
      lte: operator((col, value) => lte(col, value)),
      between: operator(
        (col, value) => between(col, value[0], value[1])
      ),
      in: operator((col, values) => inArray(col, values)),
      notIn: operator(
        (col, values) => notInArray(col, values)
      ),
      isNull: operator(
        (col, value) => value ? sql$1`${col} IS NULL` : sql$1`${col} IS NOT NULL`
      ),
      isNotNull: operator(
        (col, value) => value ? sql$1`${col} IS NOT NULL` : sql$1`${col} IS NULL`
      )
    },
    jsonb: {
      eq: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>>'{${sql$1.raw(path)}}')::numeric = ${value}`;
      }),
      ne: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>>'{${sql$1.raw(path)}}')::numeric != ${value}`;
      }),
      gt: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>>'{${sql$1.raw(path)}}')::numeric > ${value}`;
      }),
      gte: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>>'{${sql$1.raw(path)}}')::numeric >= ${value}`;
      }),
      lt: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>>'{${sql$1.raw(path)}}')::numeric < ${value}`;
      }),
      lte: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>>'{${sql$1.raw(path)}}')::numeric <= ${value}`;
      }),
      between: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>>'{${sql$1.raw(path)}}')::numeric BETWEEN ${value[0]} AND ${value[1]}`;
      }),
      isNull: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return value ? sql$1`${col}#>'{${sql$1.raw(path)}}' IS NULL` : sql$1`${col}#>'{${sql$1.raw(path)}}' IS NOT NULL`;
      }),
      isNotNull: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return value ? sql$1`${col}#>'{${sql$1.raw(path)}}' IS NOT NULL` : sql$1`${col}#>'{${sql$1.raw(path)}}' IS NULL`;
      })
    }
  };
}
const numberField = defineField()({
  type: "number",
  _value: void 0,
  toColumn(name2, config2) {
    const { mode = "integer", precision = 10, scale = 2 } = config2;
    let column;
    switch (mode) {
      case "smallint":
        column = smallint(name2);
        break;
      case "bigint":
        column = bigint(name2, { mode: "number" });
        break;
      case "real":
        column = real(name2);
        break;
      case "double":
        column = doublePrecision(name2);
        break;
      case "decimal":
        column = numeric(name2, { precision, scale });
        break;
      case "integer":
      default:
        column = integer(name2);
        break;
    }
    if (config2.required && config2.nullable !== true) {
      column = column.notNull();
    }
    if (config2.default !== void 0) {
      const defaultValue = typeof config2.default === "function" ? config2.default() : config2.default;
      column = column.default(defaultValue);
    }
    return column;
  },
  toZodSchema(config2) {
    let schema2 = z$1.number();
    if (config2.min !== void 0) {
      schema2 = schema2.min(config2.min);
    }
    if (config2.max !== void 0) {
      schema2 = schema2.max(config2.max);
    }
    if (config2.positive) {
      schema2 = schema2.positive();
    }
    if (config2.negative) {
      schema2 = schema2.negative();
    }
    if (config2.nonNegative) {
      schema2 = schema2.nonnegative();
    }
    if (config2.nonPositive) {
      schema2 = schema2.nonpositive();
    }
    if (config2.int || config2.mode === "integer" || config2.mode === "smallint") {
      schema2 = schema2.int();
    }
    if (config2.finite ?? config2.mode === "decimal") {
      schema2 = schema2.finite();
    }
    if (config2.safe) {
      schema2 = schema2.safe();
    }
    if (config2.step !== void 0) {
      const step = config2.step;
      schema2 = schema2.refine(
        (val) => {
          const remainder = Math.abs(val % step);
          const tolerance = 1e-10;
          return remainder < tolerance || Math.abs(remainder - step) < tolerance;
        },
        { message: `Value must be a multiple of ${step}` }
      );
    }
    if (!config2.required && config2.nullable !== false) {
      return schema2.nullish();
    }
    return schema2;
  },
  getOperators(config2) {
    return getNumberOperators();
  },
  getMetadata(config2) {
    const isInteger2 = config2.int || config2.mode === "integer" || config2.mode === "smallint" || config2.mode === "bigint" || config2.mode === void 0;
    return {
      type: "number",
      label: config2.label,
      description: config2.description,
      required: config2.required ?? false,
      localized: config2.localized ?? false,
      readOnly: config2.input === false,
      writeOnly: config2.output === false,
      validation: {
        min: config2.min,
        max: config2.max
      },
      meta: config2.meta,
      // Number-specific metadata for admin UI
      mode: config2.mode,
      integer: isInteger2,
      step: config2.step
    };
  }
});
function getObjectOperators() {
  return {
    column: {
      // Contains the given key-value pairs
      contains: operator(
        (col, value) => sql$1`${col} @> ${JSON.stringify(value)}::jsonb`
      ),
      // Is contained by the given object
      containedBy: operator(
        (col, value) => sql$1`${col} <@ ${JSON.stringify(value)}::jsonb`
      ),
      // Has the given key
      hasKey: operator((col, value) => sql$1`${col} ? ${value}`),
      // Has all the given keys
      hasKeys: operator(
        (col, values) => sql$1`${col} ?& ${sql$1.raw(`ARRAY[${values.map((v) => `'${v}'`).join(",")}]`)}`
      ),
      // Has any of the given keys
      hasAnyKeys: operator(
        (col, values) => sql$1`${col} ?| ${sql$1.raw(`ARRAY[${values.map((v) => `'${v}'`).join(",")}]`)}`
      ),
      // Value at path equals
      pathEquals: operator(
        (col, value) => {
          return sql$1`${col}#>>'{${sql$1.raw(value.path.join(","))}}' = ${value.val}`;
        }
      ),
      // JSON path query
      jsonPath: operator(
        (col, value) => sql$1`${col} @@ ${value}::jsonpath`
      ),
      // Is empty object
      isEmpty: operator(
        (col) => sql$1`(${col} = '{}'::jsonb OR ${col} IS NULL)`
      ),
      // Is not empty
      isNotEmpty: operator(
        (col) => sql$1`(${col} != '{}'::jsonb AND ${col} IS NOT NULL)`
      ),
      isNull: operator(
        (col, value) => value ? sql$1`${col} IS NULL` : sql$1`${col} IS NOT NULL`
      ),
      isNotNull: operator(
        (col, value) => value ? sql$1`${col} IS NOT NULL` : sql$1`${col} IS NULL`
      )
    },
    jsonb: {
      contains: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`${col}#>'{${sql$1.raw(path)}}' @> ${JSON.stringify(value)}::jsonb`;
      }),
      containedBy: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`${col}#>'{${sql$1.raw(path)}}' <@ ${JSON.stringify(value)}::jsonb`;
      }),
      hasKey: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`${col}#>'{${sql$1.raw(path)}}' ? ${value}`;
      }),
      hasKeys: operator((col, values, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`${col}#>'{${sql$1.raw(path)}}' ?& ${sql$1.raw(`ARRAY[${values.map((v) => `'${v}'`).join(",")}]`)}`;
      }),
      isEmpty: operator((col, _value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>'{${sql$1.raw(path)}}' = '{}'::jsonb OR ${col}#>'{${sql$1.raw(path)}}' IS NULL)`;
      }),
      isNotEmpty: operator((col, _value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>'{${sql$1.raw(path)}}' != '{}'::jsonb AND ${col}#>'{${sql$1.raw(path)}}' IS NOT NULL)`;
      }),
      isNull: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return value ? sql$1`${col}#>'{${sql$1.raw(path)}}' IS NULL` : sql$1`${col}#>'{${sql$1.raw(path)}}' IS NOT NULL`;
      }),
      isNotNull: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return value ? sql$1`${col}#>'{${sql$1.raw(path)}}' IS NOT NULL` : sql$1`${col}#>'{${sql$1.raw(path)}}' IS NULL`;
      })
    }
  };
}
function resolveFields(fields2) {
  return typeof fields2 === "function" ? fields2() : fields2;
}
const objectField = defineField()({
  type: "object",
  _value: void 0,
  toColumn(name2, config2) {
    const { mode = "jsonb" } = config2;
    let column = mode === "json" ? json(name2) : jsonb(name2);
    if (config2.required && config2.nullable !== true) {
      column = column.notNull();
    }
    if (config2.default !== void 0) {
      const defaultValue = typeof config2.default === "function" ? config2.default() : config2.default;
      column = column.default(defaultValue);
    }
    return column;
  },
  toZodSchema(config2) {
    const nestedFields = resolveFields(config2.fields);
    const shape = {};
    for (const [fieldName, fieldDef] of Object.entries(nestedFields)) {
      shape[fieldName] = fieldDef.toZodSchema();
    }
    const schema2 = z$1.object(shape);
    if (!config2.required && config2.nullable !== false) {
      return schema2.nullish();
    }
    return schema2;
  },
  getOperators(config2) {
    return getObjectOperators();
  },
  getMetadata(config2) {
    const nestedFields = resolveFields(config2.fields);
    const nestedMetadata = {};
    for (const [fieldName, fieldDef] of Object.entries(nestedFields)) {
      nestedMetadata[fieldName] = fieldDef.getMetadata();
    }
    return {
      type: "object",
      label: config2.label,
      description: config2.description,
      required: config2.required ?? false,
      localized: config2.localized ?? false,
      readOnly: config2.input === false,
      writeOnly: config2.output === false,
      nestedFields: nestedMetadata,
      meta: config2.meta
    };
  }
});
function resolveTargetName(target) {
  if (typeof target === "string") {
    return target;
  }
  if (typeof target === "function") {
    try {
      return target().name;
    } catch {
      return void 0;
    }
  }
  if (typeof target === "object") {
    return Object.keys(target);
  }
  return void 0;
}
function resolveJunctionName(target) {
  if (!target) return void 0;
  if (typeof target === "string") {
    return target;
  }
  if (typeof target === "function") {
    try {
      return target().name;
    } catch {
      return void 0;
    }
  }
  return void 0;
}
function isPolymorphicTarget(target) {
  return typeof target === "object" && target !== null && typeof target !== "function";
}
function inferRelationType(config2) {
  const isPolymorphic = isPolymorphicTarget(config2.to);
  if (isPolymorphic) {
    if (config2.hasMany && config2.morphName) {
      return "morphMany";
    }
    return "morphTo";
  }
  if (config2.multiple) {
    return "multiple";
  }
  if (config2.hasMany && config2.through) {
    return "manyToMany";
  }
  if (config2.hasMany) {
    return "hasMany";
  }
  return "belongsTo";
}
function getBelongsToOperators() {
  return {
    column: {
      eq: operator((col, value) => eq(col, value)),
      ne: operator((col, value) => ne(col, value)),
      in: operator((col, values) => inArray(col, values)),
      notIn: operator(
        (col, values) => notInArray(col, values)
      ),
      isNull: operator(
        (col, value) => value ? sql$1`${col} IS NULL` : sql$1`${col} IS NOT NULL`
      ),
      isNotNull: operator(
        (col, value) => value ? sql$1`${col} IS NOT NULL` : sql$1`${col} IS NULL`
      )
    },
    jsonb: {
      eq: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`${col}#>>'{${sql$1.raw(path)}}' = ${value}`;
      }),
      ne: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`${col}#>>'{${sql$1.raw(path)}}' != ${value}`;
      }),
      in: operator((col, values, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`${col}#>>'{${sql$1.raw(path)}}' = ANY(${values}::text[])`;
      }),
      notIn: operator((col, values, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`NOT (${col}#>>'{${sql$1.raw(path)}}' = ANY(${values}::text[]))`;
      }),
      isNull: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return value ? sql$1`${col}#>'{${sql$1.raw(path)}}' IS NULL` : sql$1`${col}#>'{${sql$1.raw(path)}}' IS NOT NULL`;
      }),
      isNotNull: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return value ? sql$1`${col}#>'{${sql$1.raw(path)}}' IS NOT NULL` : sql$1`${col}#>'{${sql$1.raw(path)}}' IS NULL`;
      })
    }
  };
}
function getMultipleOperators() {
  return {
    column: {
      contains: operator(
        (col, value) => sql$1`${col} @> ${JSON.stringify([value])}::jsonb`
      ),
      containsAll: operator(
        (col, values) => sql$1`${col} @> ${JSON.stringify(values)}::jsonb`
      ),
      containsAny: operator(
        (col, values) => sql$1`${col} ?| ARRAY[${sql$1.join(
          values.map((v) => sql$1`${v}`),
          sql$1`, `
        )}]::text[]`
      ),
      isEmpty: operator(
        (col) => sql$1`(${col} = '[]'::jsonb OR ${col} IS NULL)`
      ),
      isNotEmpty: operator(
        (col) => sql$1`(${col} != '[]'::jsonb AND ${col} IS NOT NULL)`
      ),
      count: operator(
        (col, value) => sql$1`jsonb_array_length(COALESCE(${col}, '[]'::jsonb)) = ${value}`
      ),
      isNull: operator(
        (col, value) => value ? sql$1`${col} IS NULL` : sql$1`${col} IS NOT NULL`
      ),
      isNotNull: operator(
        (col, value) => value ? sql$1`${col} IS NOT NULL` : sql$1`${col} IS NULL`
      )
    },
    jsonb: {
      contains: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`${col}#>'{${sql$1.raw(path)}}' @> ${JSON.stringify([value])}::jsonb`;
      }),
      containsAll: operator((col, values, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`${col}#>'{${sql$1.raw(path)}}' @> ${JSON.stringify(values)}::jsonb`;
      }),
      containsAny: operator((col, values, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`${col}#>'{${sql$1.raw(path)}}' ?| ARRAY[${sql$1.join(
          values.map((v) => sql$1`${v}`),
          sql$1`, `
        )}]::text[]`;
      }),
      isEmpty: operator((col, _value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>'{${sql$1.raw(path)}}' = '[]'::jsonb OR ${col}#>'{${sql$1.raw(path)}}' IS NULL)`;
      }),
      isNotEmpty: operator((col, _value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>'{${sql$1.raw(path)}}' != '[]'::jsonb AND ${col}#>'{${sql$1.raw(path)}}' IS NOT NULL)`;
      }),
      count: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`jsonb_array_length(COALESCE(${col}#>'{${sql$1.raw(path)}}', '[]'::jsonb)) = ${value}`;
      }),
      isNull: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return value ? sql$1`${col}#>'{${sql$1.raw(path)}}' IS NULL` : sql$1`${col}#>'{${sql$1.raw(path)}}' IS NOT NULL`;
      }),
      isNotNull: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return value ? sql$1`${col}#>'{${sql$1.raw(path)}}' IS NOT NULL` : sql$1`${col}#>'{${sql$1.raw(path)}}' IS NULL`;
      })
    }
  };
}
function getToManyOperators() {
  return {
    column: {
      // Placeholder operators - actual implementation in query builder
      some: operator(() => sql$1`TRUE`),
      none: operator(() => sql$1`TRUE`),
      every: operator(() => sql$1`TRUE`),
      count: operator(() => sql$1`0`)
    },
    jsonb: {
      some: operator(() => sql$1`TRUE`),
      none: operator(() => sql$1`TRUE`),
      every: operator(() => sql$1`TRUE`),
      count: operator(() => sql$1`0`)
    }
  };
}
const relationField = defineField()({
  type: "relation",
  _value: void 0,
  toColumn(name2, config2) {
    const relationType = inferRelationType(config2);
    if (relationType === "hasMany" || relationType === "manyToMany" || relationType === "morphMany") {
      return null;
    }
    if (relationType === "multiple") {
      let column2 = jsonb(name2);
      if (config2.required && config2.nullable !== true) {
        column2 = column2.notNull();
      }
      if (config2.default !== void 0) {
        const defaultValue = typeof config2.default === "function" ? config2.default() : config2.default;
        column2 = column2.default(JSON.stringify(defaultValue));
      }
      return column2;
    }
    if (relationType === "morphTo") {
      const types2 = config2.to;
      const typeNames = Object.keys(types2);
      const maxTypeLength = Math.max(...typeNames.map((t2) => t2.length), 50);
      let typeColumn = varchar(`${name2}Type`, { length: maxTypeLength });
      let idColumn = varchar(`${name2}Id`, { length: 36 });
      if (config2.required && config2.nullable !== true) {
        typeColumn = typeColumn.notNull();
        idColumn = idColumn.notNull();
      }
      return [typeColumn, idColumn];
    }
    let column = varchar(name2, { length: 36 });
    if (config2.required && config2.nullable !== true) {
      column = column.notNull();
    }
    if (config2.default !== void 0) {
      const defaultValue = typeof config2.default === "function" ? config2.default() : config2.default;
      column = column.default(defaultValue);
    }
    if (typeof config2.to === "function") {
      const targetGetter = config2.to;
      try {
        const target = targetGetter();
        if (target.table?.id) {
          column = column.references(() => target.table.id, {
            onDelete: config2.onDelete,
            onUpdate: config2.onUpdate
          });
        }
      } catch {
      }
    }
    return column;
  },
  toZodSchema(config2) {
    const relationType = inferRelationType(config2);
    if (relationType === "morphTo") {
      const types2 = config2.to;
      const typeNames = Object.keys(types2);
      const schema22 = z$1.object({
        type: z$1.enum(typeNames),
        id: z$1.string().uuid()
      });
      if (!config2.required && config2.nullable !== false) {
        return schema22.nullish();
      }
      return schema22;
    }
    if (relationType === "multiple" || relationType === "hasMany" || relationType === "manyToMany" || relationType === "morphMany") {
      const schema22 = z$1.array(z$1.string().uuid());
      if (!config2.required && config2.nullable !== false) {
        return schema22.nullish();
      }
      return schema22;
    }
    const schema2 = z$1.string().uuid();
    if (!config2.required && config2.nullable !== false) {
      return schema2.nullish();
    }
    return schema2;
  },
  getOperators(config2) {
    const relationType = inferRelationType(config2);
    if (relationType === "multiple") {
      return getMultipleOperators();
    }
    if (relationType === "hasMany" || relationType === "manyToMany" || relationType === "morphMany") {
      return getToManyOperators();
    }
    return getBelongsToOperators();
  },
  getMetadata(config2) {
    const relationType = inferRelationType(config2);
    const targetCollection = resolveTargetName(config2.to) ?? "__unresolved__";
    const through = resolveJunctionName(config2.through);
    return {
      type: "relation",
      label: config2.label,
      description: config2.description,
      required: config2.required ?? false,
      localized: config2.localized ?? false,
      readOnly: config2.input === false,
      writeOnly: config2.output === false,
      relationType,
      targetCollection,
      foreignKey: config2.foreignKey,
      through,
      sourceField: config2.sourceField,
      targetField: config2.targetField,
      morphName: config2.morphName,
      morphType: config2.morphType,
      onDelete: config2.onDelete,
      onUpdate: config2.onUpdate,
      relationName: config2.relationName,
      // Store original configs for runtime resolution
      _toConfig: config2.to,
      _throughConfig: config2.through,
      meta: config2.meta
    };
  }
});
function isStaticOptions(options) {
  return Array.isArray(options);
}
function getStaticOptions(options) {
  return isStaticOptions(options) ? options : [];
}
function getSingleSelectOperators() {
  return {
    column: {
      eq: operator((col, value) => eq(col, value)),
      ne: operator((col, value) => ne(col, value)),
      in: operator((col, values) => inArray(col, values)),
      notIn: operator(
        (col, values) => notInArray(col, values)
      ),
      isNull: operator(
        (col, value) => value ? sql$1`${col} IS NULL` : sql$1`${col} IS NOT NULL`
      ),
      isNotNull: operator(
        (col, value) => value ? sql$1`${col} IS NOT NULL` : sql$1`${col} IS NULL`
      )
    },
    jsonb: {
      eq: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`${col}#>>'{${sql$1.raw(path)}}' = ${value}`;
      }),
      ne: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`${col}#>>'{${sql$1.raw(path)}}' != ${value}`;
      }),
      in: operator((col, values, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`${col}#>>'{${sql$1.raw(path)}}' = ANY(${values}::text[])`;
      }),
      notIn: operator((col, values, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`NOT (${col}#>>'{${sql$1.raw(path)}}' = ANY(${values}::text[]))`;
      }),
      isNull: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return value ? sql$1`${col}#>'{${sql$1.raw(path)}}' IS NULL` : sql$1`${col}#>'{${sql$1.raw(path)}}' IS NOT NULL`;
      }),
      isNotNull: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return value ? sql$1`${col}#>'{${sql$1.raw(path)}}' IS NOT NULL` : sql$1`${col}#>'{${sql$1.raw(path)}}' IS NULL`;
      })
    }
  };
}
function getMultiSelectOperators() {
  return {
    column: {
      // Contains all specified values
      containsAll: operator(
        (col, values) => sql$1`${col} @> ${JSON.stringify(values)}::jsonb`
      ),
      // Contains any of specified values
      containsAny: operator(
        (col, values) => sql$1`${col} ?| ARRAY[${sql$1.join(
          values.map((v) => sql$1`${v}`),
          sql$1`, `
        )}]::text[]`
      ),
      // Exactly equals (same values, same order)
      eq: operator(
        (col, values) => sql$1`${col} = ${JSON.stringify(values)}::jsonb`
      ),
      // Is empty array
      isEmpty: operator(
        (col) => sql$1`${col} = '[]'::jsonb OR ${col} IS NULL`
      ),
      // Is not empty
      isNotEmpty: operator(
        (col) => sql$1`${col} != '[]'::jsonb AND ${col} IS NOT NULL`
      ),
      // Length equals
      length: operator(
        (col, value) => sql$1`jsonb_array_length(${col}) = ${value}`
      ),
      isNull: operator(
        (col, value) => value ? sql$1`${col} IS NULL` : sql$1`${col} IS NOT NULL`
      ),
      isNotNull: operator(
        (col, value) => value ? sql$1`${col} IS NOT NULL` : sql$1`${col} IS NULL`
      )
    },
    jsonb: {
      containsAll: operator((col, values, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`${col}#>'{${sql$1.raw(path)}}' @> ${JSON.stringify(values)}::jsonb`;
      }),
      containsAny: operator((col, values, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`${col}#>'{${sql$1.raw(path)}}' ?| ARRAY[${sql$1.join(
          values.map((v) => sql$1`${v}`),
          sql$1`, `
        )}]::text[]`;
      }),
      eq: operator((col, values, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`${col}#>'{${sql$1.raw(path)}}' = ${JSON.stringify(values)}::jsonb`;
      }),
      isEmpty: operator((col, _value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>'{${sql$1.raw(path)}}' = '[]'::jsonb OR ${col}#>'{${sql$1.raw(path)}}' IS NULL)`;
      }),
      isNotEmpty: operator((col, _value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>'{${sql$1.raw(path)}}' != '[]'::jsonb AND ${col}#>'{${sql$1.raw(path)}}' IS NOT NULL)`;
      }),
      length: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`jsonb_array_length(${col}#>'{${sql$1.raw(path)}}') = ${value}`;
      }),
      isNull: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return value ? sql$1`${col}#>'{${sql$1.raw(path)}}' IS NULL` : sql$1`${col}#>'{${sql$1.raw(path)}}' IS NOT NULL`;
      }),
      isNotNull: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return value ? sql$1`${col}#>'{${sql$1.raw(path)}}' IS NOT NULL` : sql$1`${col}#>'{${sql$1.raw(path)}}' IS NULL`;
      })
    }
  };
}
const enumCache = /* @__PURE__ */ new Map();
const selectField = defineField()({
  type: "select",
  _value: void 0,
  toColumn(name2, config2) {
    const { multiple = false, enumType = false, enumName } = config2;
    const staticOptions = getStaticOptions(config2.options);
    let column;
    if (multiple) {
      column = jsonb(name2);
    } else if (enumType && staticOptions.length > 0) {
      const enumValues = staticOptions.map((o2) => String(o2.value));
      const finalEnumName = enumName ?? `${name2}_enum`;
      let enumDef = enumCache.get(finalEnumName);
      if (!enumDef) {
        enumDef = pgEnum(finalEnumName, enumValues);
        enumCache.set(finalEnumName, enumDef);
      }
      column = enumDef(name2);
    } else {
      const maxLength = staticOptions.length > 0 ? Math.max(...staticOptions.map((o2) => String(o2.value).length), 50) : 255;
      column = varchar(name2, { length: maxLength });
    }
    if (config2.required && config2.nullable !== true) {
      column = column.notNull();
    }
    if (config2.default !== void 0) {
      const defaultValue = typeof config2.default === "function" ? config2.default() : config2.default;
      column = column.default(
        multiple ? JSON.stringify(defaultValue) : defaultValue
      );
    }
    return column;
  },
  toZodSchema(config2) {
    const { multiple = false } = config2;
    const staticOptions = getStaticOptions(config2.options);
    if (!isStaticOptions(config2.options)) {
      if (multiple) {
        const schema2 = z$1.array(z$1.string());
        if (!config2.required && config2.nullable !== false) {
          return schema2.nullish();
        }
        return schema2;
      } else {
        const schema2 = z$1.string();
        if (!config2.required && config2.nullable !== false) {
          return schema2.nullish();
        }
        return schema2;
      }
    }
    const validValues = staticOptions.map((o2) => String(o2.value));
    if (multiple) {
      const schema2 = z$1.array(z$1.enum(validValues));
      if (!config2.required && config2.nullable !== false) {
        return schema2.nullish();
      }
      return schema2;
    } else {
      const schema2 = z$1.enum(validValues);
      if (!config2.required && config2.nullable !== false) {
        return schema2.nullish();
      }
      return schema2;
    }
  },
  getOperators(config2) {
    return config2.multiple ? getMultiSelectOperators() : getSingleSelectOperators();
  },
  getMetadata(config2) {
    const staticOptions = getStaticOptions(config2.options);
    const hasDynamicOptions = !isStaticOptions(config2.options);
    return {
      type: "select",
      label: config2.label,
      description: config2.description,
      required: config2.required ?? false,
      localized: config2.localized ?? false,
      readOnly: config2.input === false,
      writeOnly: config2.output === false,
      // Only include static options in metadata
      options: hasDynamicOptions ? [] : staticOptions.map((o2) => ({
        value: o2.value,
        label: o2.label
      })),
      multiple: config2.multiple,
      meta: config2.meta
    };
  }
});
function getTextOperators(_config) {
  return {
    column: stringColumnOperators,
    jsonb: stringJsonbOperators
  };
}
const textField = defineField()({
  type: "text",
  _value: void 0,
  toColumn(name2, config2) {
    const { mode = "varchar", maxLength = 255 } = config2;
    let column = mode === "text" ? text(name2) : varchar(name2, { length: maxLength });
    if (config2.required && config2.nullable !== true) {
      column = column.notNull();
    }
    if (config2.default !== void 0) {
      const defaultValue = typeof config2.default === "function" ? config2.default() : config2.default;
      column = column.default(defaultValue);
    }
    return column;
  },
  toZodSchema(config2) {
    let schema2 = z$1.string();
    if (config2.maxLength !== void 0) {
      schema2 = schema2.max(config2.maxLength);
    }
    if (config2.minLength !== void 0) {
      schema2 = schema2.min(config2.minLength);
    }
    if (config2.pattern) {
      const regex = typeof config2.pattern === "string" ? new RegExp(config2.pattern) : config2.pattern;
      schema2 = schema2.regex(regex);
    }
    if (config2.trim) {
      schema2 = schema2.trim();
    }
    if (config2.lowercase) {
      schema2 = schema2.toLowerCase();
    }
    if (config2.uppercase) {
      schema2 = schema2.toUpperCase();
    }
    if (!config2.required && config2.nullable !== false) {
      return schema2.nullish();
    }
    return schema2;
  },
  getOperators(config2) {
    return getTextOperators();
  },
  getMetadata(config2) {
    return {
      type: "text",
      label: config2.label,
      description: config2.description,
      required: config2.required ?? false,
      localized: config2.localized ?? false,
      readOnly: config2.input === false,
      writeOnly: config2.output === false,
      validation: {
        maxLength: config2.maxLength,
        minLength: config2.minLength,
        pattern: config2.pattern?.toString()
      },
      meta: config2.meta
    };
  }
});
function getTextareaOperators() {
  return {
    column: {
      ...stringColumnOperators,
      isEmpty: operator(
        (col) => sql$1`(${col} IS NULL OR ${col} = '')`
      ),
      isNotEmpty: operator(
        (col) => sql$1`(${col} IS NOT NULL AND ${col} != '')`
      )
    },
    jsonb: {
      ...stringJsonbOperators,
      isEmpty: operator((col, _value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>>'{${sql$1.raw(path)}}' IS NULL OR ${col}#>>'{${sql$1.raw(path)}}' = '')`;
      }),
      isNotEmpty: operator((col, _value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>>'{${sql$1.raw(path)}}' IS NOT NULL AND ${col}#>>'{${sql$1.raw(path)}}' != '')`;
      })
    }
  };
}
const textareaField = defineField()({
  type: "textarea",
  _value: void 0,
  toColumn(name2, config2) {
    let column = text(name2);
    if (config2.required && config2.nullable !== true) {
      column = column.notNull();
    }
    if (config2.default !== void 0) {
      const defaultValue = typeof config2.default === "function" ? config2.default() : config2.default;
      column = column.default(defaultValue);
    }
    return column;
  },
  toZodSchema(config2) {
    const { trim: trim2 = true } = config2;
    let schema2 = z$1.string();
    if (config2.maxLength !== void 0) {
      schema2 = schema2.max(config2.maxLength);
    }
    if (config2.minLength !== void 0) {
      schema2 = schema2.min(config2.minLength);
    }
    if (trim2) {
      schema2 = schema2.trim();
    }
    if (!config2.required && config2.nullable !== false) {
      return schema2.nullish();
    }
    return schema2;
  },
  getOperators(config2) {
    return getTextareaOperators();
  },
  getMetadata(config2) {
    return {
      type: "textarea",
      label: config2.label,
      description: config2.description,
      required: config2.required ?? false,
      localized: config2.localized ?? false,
      readOnly: config2.input === false,
      writeOnly: config2.output === false,
      validation: {
        maxLength: config2.maxLength,
        minLength: config2.minLength
      },
      meta: config2.meta
    };
  }
});
function getTimeOperators() {
  return {
    column: {
      eq: operator((col, value) => eq(col, value)),
      ne: operator((col, value) => ne(col, value)),
      gt: operator((col, value) => gt(col, value)),
      gte: operator((col, value) => gte(col, value)),
      lt: operator((col, value) => lt(col, value)),
      lte: operator((col, value) => lte(col, value)),
      between: operator(
        (col, value) => between(col, value[0], value[1])
      ),
      before: operator((col, value) => lt(col, value)),
      after: operator((col, value) => gt(col, value)),
      isNull: operator(
        (col, value) => value ? sql$1`${col} IS NULL` : sql$1`${col} IS NOT NULL`
      ),
      isNotNull: operator(
        (col, value) => value ? sql$1`${col} IS NOT NULL` : sql$1`${col} IS NULL`
      )
    },
    jsonb: {
      eq: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>>'{${sql$1.raw(path)}}')::time = ${value}::time`;
      }),
      ne: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>>'{${sql$1.raw(path)}}')::time != ${value}::time`;
      }),
      gt: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>>'{${sql$1.raw(path)}}')::time > ${value}::time`;
      }),
      gte: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>>'{${sql$1.raw(path)}}')::time >= ${value}::time`;
      }),
      lt: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>>'{${sql$1.raw(path)}}')::time < ${value}::time`;
      }),
      lte: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>>'{${sql$1.raw(path)}}')::time <= ${value}::time`;
      }),
      between: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(${col}#>>'{${sql$1.raw(path)}}')::time BETWEEN ${value[0]}::time AND ${value[1]}::time`;
      }),
      isNull: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return value ? sql$1`${col}#>'{${sql$1.raw(path)}}' IS NULL` : sql$1`${col}#>'{${sql$1.raw(path)}}' IS NOT NULL`;
      }),
      isNotNull: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return value ? sql$1`${col}#>'{${sql$1.raw(path)}}' IS NOT NULL` : sql$1`${col}#>'{${sql$1.raw(path)}}' IS NULL`;
      })
    }
  };
}
const timeField = defineField()({
  type: "time",
  _value: void 0,
  toColumn(name2, config2) {
    const { precision = 0 } = config2;
    let column = time$1(name2, { precision });
    if (config2.required && config2.nullable !== true) {
      column = column.notNull();
    }
    if (config2.default !== void 0) {
      const defaultValue = typeof config2.default === "function" ? config2.default() : config2.default;
      column = column.default(defaultValue);
    }
    return column;
  },
  toZodSchema(config2) {
    const withSeconds = config2.withSeconds !== false;
    const timePattern = withSeconds ? /^([01]\d|2[0-3]):([0-5]\d):([0-5]\d)(\.\d+)?$/ : /^([01]\d|2[0-3]):([0-5]\d)$/;
    let schema2 = z$1.string().regex(timePattern, {
      message: withSeconds ? "Invalid time format. Expected HH:MM:SS" : "Invalid time format. Expected HH:MM"
    });
    if (config2.min) {
      schema2 = schema2.refine((val) => val >= config2.min, {
        message: `Time must be at or after ${config2.min}`
      });
    }
    if (config2.max) {
      schema2 = schema2.refine((val) => val <= config2.max, {
        message: `Time must be at or before ${config2.max}`
      });
    }
    if (!config2.required && config2.nullable !== false) {
      return schema2.nullish();
    }
    return schema2;
  },
  getOperators() {
    return getTimeOperators();
  },
  getMetadata(config2) {
    return {
      type: "time",
      label: config2.label,
      description: config2.description,
      required: config2.required ?? false,
      localized: config2.localized ?? false,
      readOnly: config2.input === false,
      writeOnly: config2.output === false,
      meta: config2.meta,
      // Time-specific constraints for admin UI
      min: config2.min,
      max: config2.max,
      withSeconds: config2.withSeconds,
      precision: config2.precision
    };
  }
});
function getSingleUploadOperators() {
  return {
    column: stringColumnOperators,
    jsonb: stringJsonbOperators
  };
}
function getToManyUploadOperators() {
  const toManyOps = {
    // Placeholder operators - actual implementation in query builder
    some: operator(() => sql$1`TRUE`),
    none: operator(() => sql$1`TRUE`),
    every: operator(() => sql$1`TRUE`),
    count: operator(() => sql$1`0`)
  };
  return {
    column: toManyOps,
    jsonb: toManyOps
  };
}
const uploadField = defineField()({
  type: "upload",
  _value: void 0,
  toColumn(name2, config2) {
    if (config2.through) {
      return null;
    }
    let column = varchar(name2, { length: 36 });
    if (config2.required && config2.nullable !== true) {
      column = column.notNull();
    }
    if (config2.default !== void 0) {
      const defaultValue = typeof config2.default === "function" ? config2.default() : config2.default;
      column = column.default(defaultValue);
    }
    return column;
  },
  toZodSchema(config2) {
    if (config2.through) {
      const schema22 = z$1.array(z$1.string().uuid());
      if (!config2.required && config2.nullable !== false) {
        return schema22.nullish();
      }
      return schema22;
    }
    const schema2 = z$1.string().uuid();
    if (!config2.required && config2.nullable !== false) {
      return schema2.nullish();
    }
    return schema2;
  },
  getOperators(config2) {
    return config2.through ? getToManyUploadOperators() : getSingleUploadOperators();
  },
  getMetadata(config2) {
    return {
      type: "relation",
      label: config2.label,
      description: config2.description,
      required: config2.required ?? false,
      localized: config2.localized ?? false,
      readOnly: config2.input === false,
      writeOnly: config2.output === false,
      targetCollection: config2.to ?? "assets",
      relationType: config2.through ? "manyToMany" : "belongsTo",
      through: config2.through,
      sourceField: config2.sourceField,
      targetField: config2.targetField,
      // Mark as upload field for reliable detection in admin UI
      // This avoids fragile detection based on targetCollection name
      isUpload: true,
      meta: config2.meta
    };
  }
});
function getUrlOperators() {
  return {
    column: {
      ...stringColumnOperators,
      // URL-specific operators
      host: operator(
        (col, value) => ilike(col, `%://${value}%`)
      ),
      hostIn: operator((col, values) => {
        if (values.length === 0) return sql$1`FALSE`;
        if (values.length === 1) return ilike(col, `%://${values[0]}%`);
        return sql$1`(${sql$1.join(
          values.map((h) => ilike(col, `%://${h}%`)),
          sql$1` OR `
        )})`;
      }),
      protocol: operator(
        (col, value) => like(col, `${value}://%`)
      )
    },
    jsonb: {
      ...stringJsonbOperators,
      host: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`${col}#>>'{${sql$1.raw(path)}}' ILIKE ${"%://" + value + "%"}`;
      }),
      protocol: operator((col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`${col}#>>'{${sql$1.raw(path)}}' LIKE ${value + "://%"}`;
      })
    }
  };
}
const urlField = defineField()({
  type: "url",
  _value: void 0,
  toColumn(name2, config2) {
    const { maxLength = 2048, textMode = false } = config2;
    let column = textMode ? text(name2) : varchar(name2, { length: maxLength });
    if (config2.required && config2.nullable !== true) {
      column = column.notNull();
    }
    if (config2.default !== void 0) {
      const defaultValue = typeof config2.default === "function" ? config2.default() : config2.default;
      column = column.default(defaultValue);
    }
    return column;
  },
  toZodSchema(config2) {
    const { protocols = ["http", "https"], maxLength = 2048 } = config2;
    let schema2 = z$1.string().url();
    schema2 = schema2.max(maxLength);
    if (protocols.length > 0) {
      const protocolPattern = new RegExp(`^(${protocols.join("|")})://`, "i");
      schema2 = schema2.refine((url) => protocolPattern.test(url), {
        message: `URL must use one of these protocols: ${protocols.join(", ")}`
      });
    }
    if (config2.allowedHosts && config2.allowedHosts.length > 0) {
      const hosts = config2.allowedHosts.map((h) => h.toLowerCase());
      schema2 = schema2.refine(
        (url) => {
          try {
            const host = new URL(url).host.toLowerCase();
            return hosts.some((h) => host === h || host.endsWith(`.${h}`));
          } catch {
            return false;
          }
        },
        {
          message: `URL host must be one of: ${config2.allowedHosts.join(", ")}`
        }
      );
    }
    if (config2.blockedHosts && config2.blockedHosts.length > 0) {
      const hosts = config2.blockedHosts.map((h) => h.toLowerCase());
      schema2 = schema2.refine(
        (url) => {
          try {
            const host = new URL(url).host.toLowerCase();
            return !hosts.some((h) => host === h || host.endsWith(`.${h}`));
          } catch {
            return true;
          }
        },
        {
          message: `URL host is not allowed: ${config2.blockedHosts.join(", ")}`
        }
      );
    }
    if (!config2.required && config2.nullable !== false) {
      return schema2.nullish();
    }
    return schema2;
  },
  getOperators(config2) {
    return getUrlOperators();
  },
  getMetadata(config2) {
    return {
      type: "url",
      label: config2.label,
      description: config2.description,
      required: config2.required ?? false,
      localized: config2.localized ?? false,
      readOnly: config2.input === false,
      writeOnly: config2.output === false,
      validation: {
        maxLength: config2.maxLength ?? 2048
      },
      meta: config2.meta
    };
  }
});
const builtinFields = {
  // Text-based
  text: textField,
  textarea: textareaField,
  email: emailField,
  url: urlField,
  // Numeric
  number: numberField,
  // Boolean
  boolean: booleanField,
  // Date/Time
  date: dateField,
  datetime: datetimeField,
  time: timeField,
  // Selection
  select: selectField,
  // Upload
  upload: uploadField,
  // Relations
  relation: relationField,
  // Complex types
  object: objectField,
  array: arrayField,
  json: jsonField
};
const defaultFields = builtinFields;
class CollectionBuilder {
  /**
   * Internal state. Public for type extraction.
   * Use build() or property accessors instead of accessing this directly.
   */
  state;
  _builtCollection;
  // Store callback functions for lazy evaluation
  _indexesFn;
  constructor(state) {
    this.state = state;
  }
  fields(factoryOrColumns) {
    if (typeof factoryOrColumns === "function") {
      const factory = factoryOrColumns;
      const questpieFields = this.state["~questpieApp"]?.state?.fields ?? builtinFields;
      const builderProxy = createFieldBuilder(questpieFields);
      const fieldDefs = factory(builderProxy);
      const columns2 = {};
      const localizedFields = [];
      const relationFields = [];
      const sqlVirtuals = {};
      for (const [name2, fieldDef] of Object.entries(fieldDefs)) {
        if (fieldDef.state?.location === "i18n") {
          localizedFields.push(name2);
        }
        if (fieldDef.state?.location === "virtual") {
          const virtualValue = fieldDef.state.config?.virtual;
          if (virtualValue && virtualValue !== true) {
            sqlVirtuals[name2] = virtualValue;
          }
        }
        const metadata = fieldDef.getMetadata?.();
        if (metadata?.type === "relation") {
          relationFields.push({
            name: name2,
            metadata
          });
        }
        const column = fieldDef.toColumn(name2);
        if (column !== null) {
          if (Array.isArray(column)) {
            for (const col of column) {
              const colName = col.name ?? `${name2}_${columns2.length}`;
              columns2[colName] = col;
            }
          } else {
            columns2[name2] = column;
          }
        }
      }
      const pendingRelations = relationFields;
      const newState2 = {
        ...this.state,
        fields: columns2,
        localized: localizedFields,
        fieldDefinitions: fieldDefs,
        virtuals: Object.keys(sqlVirtuals).length > 0 ? {
          ...this.state.virtuals || {},
          ...sqlVirtuals
        } : this.state.virtuals,
        // Store pending relations for deferred resolution in build()
        _pendingRelations: pendingRelations
      };
      const newBuilder2 = new CollectionBuilder(newState2);
      newBuilder2._indexesFn = this._indexesFn;
      return newBuilder2;
    }
    const columns = factoryOrColumns;
    const newState = {
      ...this.state,
      fields: columns,
      localized: [],
      fieldDefinitions: {}
    };
    const newBuilder = new CollectionBuilder(newState);
    newBuilder._indexesFn = this._indexesFn;
    return newBuilder;
  }
  /**
   * Convert RelationFieldMetadata to RelationConfig for CRUD operations.
   */
  convertRelationMetadataToConfig(fieldName, metadata, columns) {
    const { relationType, foreignKey, _toConfig, _throughConfig } = metadata;
    let { targetCollection, through } = metadata;
    if (targetCollection === "__unresolved__" && _toConfig) {
      if (typeof _toConfig === "function") {
        targetCollection = _toConfig().name;
      }
    }
    if (through === "__unresolved__" && _throughConfig) {
      through = _throughConfig().name;
    }
    const targetName = Array.isArray(targetCollection) ? targetCollection[0] : targetCollection;
    switch (relationType) {
      case "belongsTo": {
        return {
          type: "one",
          collection: targetName,
          fields: columns[fieldName] ? [columns[fieldName]] : void 0,
          references: ["id"],
          relationName: metadata.relationName,
          onDelete: metadata.onDelete,
          onUpdate: metadata.onUpdate
        };
      }
      case "hasMany": {
        return {
          type: "many",
          collection: targetName,
          references: ["id"],
          relationName: metadata.relationName,
          onDelete: metadata.onDelete,
          onUpdate: metadata.onUpdate
        };
      }
      case "manyToMany": {
        return {
          type: "manyToMany",
          collection: targetName,
          references: ["id"],
          through,
          sourceField: metadata.sourceField,
          targetField: metadata.targetField,
          onDelete: metadata.onDelete,
          onUpdate: metadata.onUpdate
        };
      }
      case "multiple": {
        return {
          type: "one",
          // Query-wise it's similar to belongsTo
          collection: targetName,
          references: ["id"],
          relationName: metadata.relationName
        };
      }
      case "morphTo": {
        return {
          type: "one",
          collection: targetName,
          references: ["id"],
          relationName: metadata.relationName,
          onDelete: metadata.onDelete,
          onUpdate: metadata.onUpdate
        };
      }
      case "morphMany": {
        return {
          type: "many",
          collection: targetName,
          references: ["id"],
          relationName: metadata.relationName
        };
      }
      default:
        return null;
    }
  }
  /**
   * Define indexes and constraints.
   * Callback receives context object with table.
   *
   * @example
   * ```ts
   * collection("posts")
   *   .fields((f) => ({ ... }))
   *   .indexes(({ table }) => [
   *     uniqueIndex().on(table.slug),
   *     index().on(table.createdAt),
   *   ])
   * ```
   */
  indexes(fn2) {
    const newState = {
      ...this.state,
      indexes: {}
    };
    const newBuilder = new CollectionBuilder(newState);
    newBuilder._indexesFn = fn2;
    return newBuilder;
  }
  /**
   * Define title field (used for _title computed column and display).
   * Callback receives a field proxy where accessing any field returns its name.
   *
   * @example
   * ```ts
   * collection("posts")
   *   .fields((f) => ({ title: f.text({ required: true }) }))
   *   .title(({ f }) => f.title)
   * ```
   */
  title(fn2) {
    const fieldProxy = new Proxy({}, {
      get: (_target, prop) => prop
    });
    const titleFieldName = fn2({ f: fieldProxy });
    const newState = {
      ...this.state,
      title: titleFieldName
    };
    const newBuilder = new CollectionBuilder(newState);
    newBuilder._indexesFn = this._indexesFn;
    return newBuilder;
  }
  /**
   * Set collection options (timestamps, softDelete, versioning).
   *
   * @example
   * ```ts
   * collection("posts")
   *   .fields((f) => ({ ... }))
   *   .options({
   *     timestamps: true,
   *     softDelete: true,
   *     versioning: true,
   *   })
   * ```
   */
  options(options) {
    const newState = {
      ...this.state,
      options
    };
    const newBuilder = new CollectionBuilder(newState);
    newBuilder._indexesFn = this._indexesFn;
    return newBuilder;
  }
  /**
   * Set lifecycle hooks.
   *
   * @example
   * ```ts
   * collection("posts")
   *   .fields((f) => ({ ... }))
   *   .hooks({
   *     beforeChange: async ({ data, operation }) => {
   *       if (operation === "create") {
   *         data.slug = slugify(data.title);
   *       }
   *     },
   *   })
   * ```
   */
  hooks(hooks) {
    const existingHooks = this.state.hooks;
    const mergedHooks = { ...existingHooks || {} };
    for (const [hookName, hookValue] of Object.entries(hooks)) {
      const current = mergedHooks[hookName];
      if (!current) {
        mergedHooks[hookName] = hookValue;
        continue;
      }
      const currentArray = Array.isArray(current) ? current : [current];
      const nextArray = Array.isArray(hookValue) ? hookValue : [hookValue];
      mergedHooks[hookName] = [...currentArray, ...nextArray];
    }
    const newState = {
      ...this.state,
      hooks: mergedHooks
    };
    const newBuilder = new CollectionBuilder(newState);
    newBuilder._indexesFn = this._indexesFn;
    return newBuilder;
  }
  /**
   * Set access control rules.
   *
   * @example
   * ```ts
   * collection("posts")
   *   .fields((f) => ({ ... }))
   *   .access({
   *     read: true,
   *     create: ({ user }) => user?.role === "admin",
   *     update: ({ user, id }) => user?.id === id,
   *     delete: ({ user }) => user?.role === "admin",
   *   })
   * ```
   */
  access(access) {
    const newState = {
      ...this.state,
      access
    };
    const newBuilder = new CollectionBuilder(newState);
    newBuilder._indexesFn = this._indexesFn;
    return newBuilder;
  }
  /**
   * Define RPC functions for this collection.
   *
   * @example
   * ```ts
   * collection("posts")
   *   .fields((f) => ({ ... }))
   *   .functions({
   *     publish: {
   *       input: z.object({ id: z.string() }),
   *       handler: async ({ input, app }) => {
   *         await app.api.collections.posts.updateById({
   *           id: input.id,
   *           data: { status: "published" },
   *         });
   *       },
   *     },
   *   })
   * ```
   */
  functions(functions) {
    const newState = {
      ...this.state,
      functions: {
        ...this.state.functions,
        ...functions
      }
    };
    const newBuilder = new CollectionBuilder(newState);
    newBuilder._indexesFn = this._indexesFn;
    return newBuilder;
  }
  /**
   * Configure search indexing for this collection.
   * Enables full-text search with BM25 ranking, trigrams, and optional embeddings.
   *
   * @example
   * ```ts
   * collection("posts")
   *   .fields((f) => ({ ... }))
   *   .searchable({
   *     content: (record) => extractTextFromJson(record.content),
   *     metadata: (record) => ({ status: record.status }),
   *     embeddings: async (record, ctx) => await ctx.cms.embeddings.generate(text),
   *   })
   * ```
   */
  searchable(searchable) {
    const newState = {
      ...this.state,
      searchable
    };
    const newBuilder = new CollectionBuilder(newState);
    newBuilder._indexesFn = this._indexesFn;
    return newBuilder;
  }
  /**
   * Configure runtime validation schemas for create/update operations.
   * Schemas are generated from field definitions automatically.
   *
   * @example
   * ```ts
   * collection("posts")
   *   .fields((f) => ({ ... }))
   *   .validation({
   *     exclude: { id: true, createdAt: true, updatedAt: true },
   *     refine: {
   *       email: (s) => s.email("Invalid email"),
   *       age: (s) => s.min(0, "Age must be positive"),
   *     },
   *   })
   * ```
   */
  validation(options) {
    const mainFields = {};
    const localizedFields = {};
    if (this.state.fieldDefinitions) {
      for (const [key, fieldDef] of Object.entries(
        this.state.fieldDefinitions
      )) {
        const column = this.state.fields[key];
        if (!column) continue;
        if (fieldDef.state?.location === "i18n") {
          localizedFields[key] = column;
        } else {
          mainFields[key] = column;
        }
      }
    }
    const validationSchemas = createCollectionValidationSchemas(
      this.state.name,
      mainFields,
      localizedFields,
      options
    );
    const newState = {
      ...this.state,
      validation: validationSchemas
    };
    const newBuilder = new CollectionBuilder(newState);
    newBuilder._indexesFn = this._indexesFn;
    return newBuilder;
  }
  /**
   * Configure this collection for file uploads.
   * Automatically:
   * - Adds upload fields (key, filename, mimeType, size, visibility)
   * - Extends output type with { url: string } for typed URL access
   * - Adds afterRead hook for URL generation based on visibility
   * - Enables upload() and uploadMany() CRUD methods
   * - Registers HTTP routes: POST /:collection/upload, GET /:collection/files/:key
   *
   * @example
   * ```ts
   * collection("media")
   *   .fields((f) => ({
   *     alt: f.text(),
   *     folder: f.text(),
   *   }))
   *   .upload({
   *     visibility: "public",
   *     maxSize: 10_000_000,
   *     allowedTypes: ["image/*"],
   *   })
   * ```
   */
  upload(options = {}) {
    const uploadFields = Collection.uploadCols();
    const uploadAfterReadHook = async ({ data, app }) => {
      if (!app?.storage || !data?.key) return;
      const fileVisibility = data.visibility || "public";
      if (fileVisibility === "private") {
        data.url = await app.storage.use().getSignedUrl(data.key);
      } else {
        data.url = await app.storage.use().getUrl(data.key);
      }
    };
    const uploadAfterChangeHook = async ({
      data,
      original,
      app,
      operation
    }) => {
      if (operation !== "update") return;
      if (!app?.storage || !data?.key) return;
      if (!original || original.visibility === data.visibility) return;
      await app.storage.use().setVisibility(data.key, data.visibility);
    };
    const existingAfterRead = this.state.hooks?.afterRead;
    const mergedAfterRead = existingAfterRead ? Array.isArray(existingAfterRead) ? [...existingAfterRead, uploadAfterReadHook] : [existingAfterRead, uploadAfterReadHook] : uploadAfterReadHook;
    const existingAfterChange = this.state.hooks?.afterChange;
    const mergedAfterChange = existingAfterChange ? Array.isArray(existingAfterChange) ? [...existingAfterChange, uploadAfterChangeHook] : [existingAfterChange, uploadAfterChangeHook] : uploadAfterChangeHook;
    const newState = {
      ...this.state,
      fields: {
        ...this.state.fields,
        ...uploadFields
      },
      output: {
        ...this.state.output || {},
        url: ""
      },
      hooks: {
        ...this.state.hooks,
        afterRead: mergedAfterRead,
        afterChange: mergedAfterChange
      },
      upload: options
    };
    const newBuilder = new CollectionBuilder(newState);
    newBuilder._indexesFn = this._indexesFn;
    return newBuilder;
  }
  /**
   * Build the final collection.
   * Generates Drizzle tables and sets up all type inference.
   * Can be called explicitly or happens lazily on first property access.
   */
  build() {
    if (!this._builtCollection) {
      const stateWithResolvedRelations = this.resolveePendingRelations();
      this._builtCollection = new Collection(
        stateWithResolvedRelations,
        this._indexesFn
      );
    }
    return this._builtCollection;
  }
  /**
   * Resolve pending relation metadata to RelationConfig.
   * Called during build() when all collections are defined and callbacks can be safely invoked.
   */
  resolveePendingRelations() {
    const pendingRelations = this.state._pendingRelations;
    if (!pendingRelations || pendingRelations.length === 0) {
      return this.state;
    }
    const columns = this.state.fields;
    const resolvedRelations = {
      ...this.state.relations
    };
    for (const { name: name2, metadata } of pendingRelations) {
      const relationConfig = this.convertRelationMetadataToConfig(
        name2,
        metadata,
        columns
      );
      if (relationConfig) {
        resolvedRelations[name2] = relationConfig;
      }
    }
    return {
      ...this.state,
      relations: resolvedRelations
    };
  }
  /**
   * Lazy build getters - automatically build on first access
   */
  get table() {
    return this.build().table;
  }
  get i18nTable() {
    return this.build().i18nTable;
  }
  get versionsTable() {
    return this.build().versionsTable;
  }
  get i18nVersionsTable() {
    return this.build().i18nVersionsTable;
  }
  get name() {
    return this.state.name;
  }
  get $infer() {
    return this.build().$infer;
  }
  /**
   * Merge another collection builder into this one.
   * Combines fields, hooks, access control, etc.
   * Both builders must have the same collection name.
   */
  merge(other) {
    const mergedHooks = this.mergeHooks(this.state.hooks, other.state.hooks);
    const mergedAccess = {
      ...this.state.access,
      ...other.state.access
    };
    const mergedState = {
      name: this.state.name,
      fields: { ...this.state.fields, ...other.state.fields },
      indexes: { ...this.state.indexes, ...other.state.indexes },
      title: other.state.title !== void 0 ? other.state.title : this.state.title,
      options: { ...this.state.options, ...other.state.options },
      hooks: mergedHooks,
      access: mergedAccess,
      functions: {
        ...this.state.functions,
        ...other.state.functions
      },
      searchable: other.state.searchable ?? this.state.searchable,
      fieldDefinitions: {
        ...this.state.fieldDefinitions || {},
        ...other.state.fieldDefinitions || {}
      }
    };
    const newBuilder = new CollectionBuilder(mergedState);
    newBuilder._indexesFn = other._indexesFn || this._indexesFn;
    return newBuilder;
  }
  /**
   * Helper to merge hooks - combines hook arrays
   */
  mergeHooks(hooks1, hooks2) {
    const merged = {};
    const hookKeys = Array.from(
      /* @__PURE__ */ new Set([...Object.keys(hooks1 || {}), ...Object.keys(hooks2 || {})])
    );
    for (const key of hookKeys) {
      const hook1 = hooks1?.[key];
      const hook2 = hooks2?.[key];
      if (!hook1 && !hook2) continue;
      if (!hook1) {
        merged[key] = hook2;
        continue;
      }
      if (!hook2) {
        merged[key] = hook1;
        continue;
      }
      const arr1 = Array.isArray(hook1) ? hook1 : [hook1];
      const arr2 = Array.isArray(hook2) ? hook2 : [hook2];
      merged[key] = [...arr1, ...arr2];
    }
    return merged;
  }
}
function expandAlphabet(alphabet) {
  switch (alphabet) {
    case "a-z":
      return "abcdefghijklmnopqrstuvwxyz";
    case "A-Z":
      return "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    case "0-9":
      return "0123456789";
    case "-_":
      return "-_";
    default:
      throw new Error(`Unsupported alphabet: ${alphabet}`);
  }
}
function createRandomStringGenerator(...baseAlphabets) {
  const baseCharSet = baseAlphabets.map(expandAlphabet).join("");
  if (baseCharSet.length === 0) {
    throw new Error(
      "No valid characters provided for random string generation."
    );
  }
  const baseCharSetLength = baseCharSet.length;
  return (length, ...alphabets) => {
    if (length <= 0) {
      throw new Error("Length must be a positive integer.");
    }
    let charSet = baseCharSet;
    let charSetLength = baseCharSetLength;
    if (alphabets.length > 0) {
      charSet = alphabets.map(expandAlphabet).join("");
      charSetLength = charSet.length;
    }
    const maxValid = Math.floor(256 / charSetLength) * charSetLength;
    const buf = new Uint8Array(length * 2);
    const bufLength = buf.length;
    let result2 = "";
    let bufIndex = bufLength;
    let rand;
    while (result2.length < length) {
      if (bufIndex >= bufLength) {
        crypto.getRandomValues(buf);
        bufIndex = 0;
      }
      rand = buf[bufIndex++];
      if (rand < maxValid) {
        result2 += charSet[rand % charSetLength];
      }
    }
    return result2;
  };
}
const generateRandomString = createRandomStringGenerator("a-z", "0-9", "A-Z", "-_");
function constantTimeEqual(a, b) {
  if (typeof a === "string") a = new TextEncoder().encode(a);
  if (typeof b === "string") b = new TextEncoder().encode(b);
  const aBuffer = new Uint8Array(a);
  const bBuffer = new Uint8Array(b);
  let c2 = aBuffer.length ^ bBuffer.length;
  const length = Math.max(aBuffer.length, bBuffer.length);
  for (let i = 0; i < length; i++) c2 |= (i < aBuffer.length ? aBuffer[i] : 0) ^ (i < bBuffer.length ? bBuffer[i] : 0);
  return c2 === 0;
}
function isBytes$1(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function anumber$1(n2, title = "") {
  if (!Number.isSafeInteger(n2) || n2 < 0) {
    const prefix = title && `"${title}" `;
    throw new Error(`${prefix}expected integer >= 0, got ${n2}`);
  }
}
function abytes$1(value, length, title = "") {
  const bytes = isBytes$1(value);
  const len = value?.length;
  const needsLen = length !== void 0;
  if (!bytes || needsLen && len !== length) {
    const prefix = title && `"${title}" `;
    const ofLen = needsLen ? ` of length ${length}` : "";
    const got = bytes ? `length=${len}` : `type=${typeof value}`;
    throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
  }
  return value;
}
function ahash(h) {
  if (typeof h !== "function" || typeof h.create !== "function")
    throw new Error("Hash must wrapped by utils.createHasher");
  anumber$1(h.outputLen);
  anumber$1(h.blockLen);
}
function aexists$1(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput$1(out, instance) {
  abytes$1(out, void 0, "digestInto() output");
  const min2 = instance.outputLen;
  if (out.length < min2) {
    throw new Error('"digestInto() output" expected to be of length >=' + min2);
  }
}
function u32$1(arr) {
  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
function clean$1(...arrays) {
  for (let i = 0; i < arrays.length; i++) {
    arrays[i].fill(0);
  }
}
function createView$1(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr(word, shift) {
  return word << 32 - shift | word >>> shift;
}
function rotl$1(word, shift) {
  return word << shift | word >>> 32 - shift >>> 0;
}
const isLE$1 = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
function byteSwap(word) {
  return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
}
function byteSwap32(arr) {
  for (let i = 0; i < arr.length; i++) {
    arr[i] = byteSwap(arr[i]);
  }
  return arr;
}
const swap32IfBE = isLE$1 ? (u) => u : byteSwap32;
const hasHexBuiltin$1 = /* @__PURE__ */ (() => (
  // @ts-ignore
  typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
))();
const asciis$1 = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase16$1(ch) {
  if (ch >= asciis$1._0 && ch <= asciis$1._9)
    return ch - asciis$1._0;
  if (ch >= asciis$1.A && ch <= asciis$1.F)
    return ch - (asciis$1.A - 10);
  if (ch >= asciis$1.a && ch <= asciis$1.f)
    return ch - (asciis$1.a - 10);
  return;
}
function hexToBytes$1(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  if (hasHexBuiltin$1)
    return Uint8Array.fromHex(hex2);
  const hl = hex2.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16$1(hex2.charCodeAt(hi));
    const n2 = asciiToBase16$1(hex2.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char2 = hex2[hi] + hex2[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char2 + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
const nextTick = async () => {
};
async function asyncLoop(iters, tick, cb) {
  let ts = Date.now();
  for (let i = 0; i < iters; i++) {
    cb(i);
    const diff2 = Date.now() - ts;
    if (diff2 >= 0 && diff2 < tick)
      continue;
    await nextTick();
    ts += diff2;
  }
}
function utf8ToBytes$1(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
function kdfInputToBytes(data, errorTitle = "") {
  if (typeof data === "string")
    return utf8ToBytes$1(data);
  return abytes$1(data, void 0, errorTitle);
}
function checkOpts$1(defaults2, opts) {
  if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]")
    throw new Error("options must be object or undefined");
  const merged = Object.assign(defaults2, opts);
  return merged;
}
function createHasher(hashCons, info2 = {}) {
  const hashC = (msg, opts) => hashCons(opts).update(msg).digest();
  const tmp = hashCons(void 0);
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  Object.assign(hashC, info2);
  return Object.freeze(hashC);
}
const oidNist = (suffix) => ({
  oid: Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2, suffix])
});
class _HMAC {
  oHash;
  iHash;
  blockLen;
  outputLen;
  finished = false;
  destroyed = false;
  constructor(hash, key) {
    ahash(hash);
    abytes$1(key, void 0, "key");
    this.iHash = hash.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash.create();
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54 ^ 92;
    this.oHash.update(pad);
    clean$1(pad);
  }
  update(buf) {
    aexists$1(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    aexists$1(this);
    abytes$1(out, this.outputLen, "output");
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to ||= Object.create(Object.getPrototypeOf(this), {});
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
}
const hmac = (hash, key, message2) => new _HMAC(hash, key).update(message2).digest();
hmac.create = (hash, key) => new _HMAC(hash, key);
function extract(hash, ikm, salt) {
  ahash(hash);
  if (salt === void 0)
    salt = new Uint8Array(hash.outputLen);
  return hmac(hash, salt, ikm);
}
const HKDF_COUNTER = /* @__PURE__ */ Uint8Array.of(0);
const EMPTY_BUFFER = /* @__PURE__ */ Uint8Array.of();
function expand(hash, prk, info2, length = 32) {
  ahash(hash);
  anumber$1(length, "length");
  const olen = hash.outputLen;
  if (length > 255 * olen)
    throw new Error("Length must be <= 255*HashLen");
  const blocks2 = Math.ceil(length / olen);
  if (info2 === void 0)
    info2 = EMPTY_BUFFER;
  else
    abytes$1(info2, void 0, "info");
  const okm = new Uint8Array(blocks2 * olen);
  const HMAC = hmac.create(hash, prk);
  const HMACTmp = HMAC._cloneInto();
  const T = new Uint8Array(HMAC.outputLen);
  for (let counter = 0; counter < blocks2; counter++) {
    HKDF_COUNTER[0] = counter + 1;
    HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T).update(info2).update(HKDF_COUNTER).digestInto(T);
    okm.set(T, olen * counter);
    HMAC._cloneInto(HMACTmp);
  }
  HMAC.destroy();
  HMACTmp.destroy();
  clean$1(T, HKDF_COUNTER);
  return okm.slice(0, length);
}
const hkdf = (hash, ikm, salt, info2, length) => expand(hash, extract(hash, ikm, salt), info2, length);
function Chi(a, b, c2) {
  return a & b ^ ~a & c2;
}
function Maj(a, b, c2) {
  return a & b ^ a & c2 ^ b & c2;
}
class HashMD {
  blockLen;
  outputLen;
  padOffset;
  isLE;
  // For partial updates less than block size
  buffer;
  view;
  finished = false;
  length = 0;
  pos = 0;
  destroyed = false;
  constructor(blockLen, outputLen, padOffset, isLE2) {
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView$1(this.buffer);
  }
  update(data) {
    aexists$1(this);
    abytes$1(data);
    const { view, buffer, blockLen } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView$1(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists$1(this);
    aoutput$1(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    clean$1(this.buffer.subarray(pos));
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer[i] = 0;
    view.setBigUint64(blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView$1(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen must be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE2);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res2 = buffer.slice(0, outputLen);
    this.destroy();
    return res2;
  }
  _cloneInto(to) {
    to ||= new this.constructor();
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.destroyed = destroyed;
    to.finished = finished;
    to.length = length;
    to.pos = pos;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
}
const SHA256_IV = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
const SHA256_K = /* @__PURE__ */ Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA2_32B extends HashMD {
  constructor(outputLen) {
    super(64, outputLen, 8, false);
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset2) {
    for (let i = 0; i < 16; i++, offset2 += 4)
      SHA256_W[i] = view.getUint32(offset2, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    clean$1(SHA256_W);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    clean$1(this.buffer);
  }
}
class _SHA256 extends SHA2_32B {
  // We cannot use array here since array allows indexing by variable
  // which means optimizer/compiler cannot use registers.
  A = SHA256_IV[0] | 0;
  B = SHA256_IV[1] | 0;
  C = SHA256_IV[2] | 0;
  D = SHA256_IV[3] | 0;
  E = SHA256_IV[4] | 0;
  F = SHA256_IV[5] | 0;
  G = SHA256_IV[6] | 0;
  H = SHA256_IV[7] | 0;
  constructor() {
    super(32);
  }
}
const sha256 = /* @__PURE__ */ createHasher(
  () => new _SHA256(),
  /* @__PURE__ */ oidNist(1)
);
const encoder$1 = new TextEncoder();
const decoder = new TextDecoder();
const MAX_INT32 = 2 ** 32;
function concat(...buffers) {
  const size = buffers.reduce((acc, { length }) => acc + length, 0);
  const buf = new Uint8Array(size);
  let i = 0;
  for (const buffer of buffers) {
    buf.set(buffer, i);
    i += buffer.length;
  }
  return buf;
}
function writeUInt32BE(buf, value, offset2) {
  if (value < 0 || value >= MAX_INT32) {
    throw new RangeError(`value must be >= 0 and <= ${MAX_INT32 - 1}. Received ${value}`);
  }
  buf.set([value >>> 24, value >>> 16, value >>> 8, value & 255], offset2);
}
function uint64be(value) {
  const high = Math.floor(value / MAX_INT32);
  const low = value % MAX_INT32;
  const buf = new Uint8Array(8);
  writeUInt32BE(buf, high, 0);
  writeUInt32BE(buf, low, 4);
  return buf;
}
function uint32be(value) {
  const buf = new Uint8Array(4);
  writeUInt32BE(buf, value);
  return buf;
}
function encode$1(string) {
  const bytes = new Uint8Array(string.length);
  for (let i = 0; i < string.length; i++) {
    const code = string.charCodeAt(i);
    if (code > 127) {
      throw new TypeError("non-ASCII string encountered in encode()");
    }
    bytes[i] = code;
  }
  return bytes;
}
function encodeBase64(input) {
  if (Uint8Array.prototype.toBase64) {
    return input.toBase64();
  }
  const CHUNK_SIZE2 = 32768;
  const arr = [];
  for (let i = 0; i < input.length; i += CHUNK_SIZE2) {
    arr.push(String.fromCharCode.apply(null, input.subarray(i, i + CHUNK_SIZE2)));
  }
  return btoa(arr.join(""));
}
function decodeBase64(encoded) {
  if (Uint8Array.fromBase64) {
    return Uint8Array.fromBase64(encoded);
  }
  const binary2 = atob(encoded);
  const bytes = new Uint8Array(binary2.length);
  for (let i = 0; i < binary2.length; i++) {
    bytes[i] = binary2.charCodeAt(i);
  }
  return bytes;
}
function decode(input) {
  if (Uint8Array.fromBase64) {
    return Uint8Array.fromBase64(typeof input === "string" ? input : decoder.decode(input), {
      alphabet: "base64url"
    });
  }
  let encoded = input;
  if (encoded instanceof Uint8Array) {
    encoded = decoder.decode(encoded);
  }
  encoded = encoded.replace(/-/g, "+").replace(/_/g, "/");
  try {
    return decodeBase64(encoded);
  } catch {
    throw new TypeError("The input to be decoded is not correctly encoded.");
  }
}
function encode(input) {
  let unencoded = input;
  if (typeof unencoded === "string") {
    unencoded = encoder$1.encode(unencoded);
  }
  if (Uint8Array.prototype.toBase64) {
    return unencoded.toBase64({ alphabet: "base64url", omitPadding: true });
  }
  return encodeBase64(unencoded).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
class JOSEError extends Error {
  static code = "ERR_JOSE_GENERIC";
  code = "ERR_JOSE_GENERIC";
  constructor(message2, options) {
    super(message2, options);
    this.name = this.constructor.name;
    Error.captureStackTrace?.(this, this.constructor);
  }
}
class JWTClaimValidationFailed extends JOSEError {
  static code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
  code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
  claim;
  reason;
  payload;
  constructor(message2, payload, claim = "unspecified", reason = "unspecified") {
    super(message2, { cause: { claim, reason, payload } });
    this.claim = claim;
    this.reason = reason;
    this.payload = payload;
  }
}
class JWTExpired extends JOSEError {
  static code = "ERR_JWT_EXPIRED";
  code = "ERR_JWT_EXPIRED";
  claim;
  reason;
  payload;
  constructor(message2, payload, claim = "unspecified", reason = "unspecified") {
    super(message2, { cause: { claim, reason, payload } });
    this.claim = claim;
    this.reason = reason;
    this.payload = payload;
  }
}
class JOSEAlgNotAllowed extends JOSEError {
  static code = "ERR_JOSE_ALG_NOT_ALLOWED";
  code = "ERR_JOSE_ALG_NOT_ALLOWED";
}
class JOSENotSupported extends JOSEError {
  static code = "ERR_JOSE_NOT_SUPPORTED";
  code = "ERR_JOSE_NOT_SUPPORTED";
}
class JWEDecryptionFailed extends JOSEError {
  static code = "ERR_JWE_DECRYPTION_FAILED";
  code = "ERR_JWE_DECRYPTION_FAILED";
  constructor(message2 = "decryption operation failed", options) {
    super(message2, options);
  }
}
class JWEInvalid extends JOSEError {
  static code = "ERR_JWE_INVALID";
  code = "ERR_JWE_INVALID";
}
class JWSInvalid extends JOSEError {
  static code = "ERR_JWS_INVALID";
  code = "ERR_JWS_INVALID";
}
class JWTInvalid extends JOSEError {
  static code = "ERR_JWT_INVALID";
  code = "ERR_JWT_INVALID";
}
class JWKInvalid extends JOSEError {
  static code = "ERR_JWK_INVALID";
  code = "ERR_JWK_INVALID";
}
class JWKSInvalid extends JOSEError {
  static code = "ERR_JWKS_INVALID";
  code = "ERR_JWKS_INVALID";
}
class JWKSNoMatchingKey extends JOSEError {
  static code = "ERR_JWKS_NO_MATCHING_KEY";
  code = "ERR_JWKS_NO_MATCHING_KEY";
  constructor(message2 = "no applicable key found in the JSON Web Key Set", options) {
    super(message2, options);
  }
}
class JWKSMultipleMatchingKeys extends JOSEError {
  [Symbol.asyncIterator];
  static code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
  code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
  constructor(message2 = "multiple matching keys found in the JSON Web Key Set", options) {
    super(message2, options);
  }
}
class JWKSTimeout extends JOSEError {
  static code = "ERR_JWKS_TIMEOUT";
  code = "ERR_JWKS_TIMEOUT";
  constructor(message2 = "request timed out", options) {
    super(message2, options);
  }
}
class JWSSignatureVerificationFailed extends JOSEError {
  static code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
  code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
  constructor(message2 = "signature verification failed", options) {
    super(message2, options);
  }
}
function bitLength(alg2) {
  switch (alg2) {
    case "A128GCM":
    case "A128GCMKW":
    case "A192GCM":
    case "A192GCMKW":
    case "A256GCM":
    case "A256GCMKW":
      return 96;
    case "A128CBC-HS256":
    case "A192CBC-HS384":
    case "A256CBC-HS512":
      return 128;
    default:
      throw new JOSENotSupported(`Unsupported JWE Algorithm: ${alg2}`);
  }
}
const generateIv = (alg2) => crypto.getRandomValues(new Uint8Array(bitLength(alg2) >> 3));
function checkIvLength(enc2, iv) {
  if (iv.length << 3 !== bitLength(enc2)) {
    throw new JWEInvalid("Invalid Initialization Vector length");
  }
}
function checkCekLength(cek, expected) {
  const actual = cek.byteLength << 3;
  if (actual !== expected) {
    throw new JWEInvalid(`Invalid Content Encryption Key length. Expected ${expected} bits, got ${actual} bits`);
  }
}
const unusable = (name2, prop = "algorithm.name") => new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name2}`);
const isAlgorithm = (algorithm2, name2) => algorithm2.name === name2;
function getHashLength(hash) {
  return parseInt(hash.name.slice(4), 10);
}
function getNamedCurve(alg2) {
  switch (alg2) {
    case "ES256":
      return "P-256";
    case "ES384":
      return "P-384";
    case "ES512":
      return "P-521";
    default:
      throw new Error("unreachable");
  }
}
function checkUsage(key, usage) {
  if (usage && !key.usages.includes(usage)) {
    throw new TypeError(`CryptoKey does not support this operation, its usages must include ${usage}.`);
  }
}
function checkSigCryptoKey(key, alg2, usage) {
  switch (alg2) {
    case "HS256":
    case "HS384":
    case "HS512": {
      if (!isAlgorithm(key.algorithm, "HMAC"))
        throw unusable("HMAC");
      const expected = parseInt(alg2.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "RS256":
    case "RS384":
    case "RS512": {
      if (!isAlgorithm(key.algorithm, "RSASSA-PKCS1-v1_5"))
        throw unusable("RSASSA-PKCS1-v1_5");
      const expected = parseInt(alg2.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "PS256":
    case "PS384":
    case "PS512": {
      if (!isAlgorithm(key.algorithm, "RSA-PSS"))
        throw unusable("RSA-PSS");
      const expected = parseInt(alg2.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "Ed25519":
    case "EdDSA": {
      if (!isAlgorithm(key.algorithm, "Ed25519"))
        throw unusable("Ed25519");
      break;
    }
    case "ML-DSA-44":
    case "ML-DSA-65":
    case "ML-DSA-87": {
      if (!isAlgorithm(key.algorithm, alg2))
        throw unusable(alg2);
      break;
    }
    case "ES256":
    case "ES384":
    case "ES512": {
      if (!isAlgorithm(key.algorithm, "ECDSA"))
        throw unusable("ECDSA");
      const expected = getNamedCurve(alg2);
      const actual = key.algorithm.namedCurve;
      if (actual !== expected)
        throw unusable(expected, "algorithm.namedCurve");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  checkUsage(key, usage);
}
function checkEncCryptoKey(key, alg2, usage) {
  switch (alg2) {
    case "A128GCM":
    case "A192GCM":
    case "A256GCM": {
      if (!isAlgorithm(key.algorithm, "AES-GCM"))
        throw unusable("AES-GCM");
      const expected = parseInt(alg2.slice(1, 4), 10);
      const actual = key.algorithm.length;
      if (actual !== expected)
        throw unusable(expected, "algorithm.length");
      break;
    }
    case "A128KW":
    case "A192KW":
    case "A256KW": {
      if (!isAlgorithm(key.algorithm, "AES-KW"))
        throw unusable("AES-KW");
      const expected = parseInt(alg2.slice(1, 4), 10);
      const actual = key.algorithm.length;
      if (actual !== expected)
        throw unusable(expected, "algorithm.length");
      break;
    }
    case "ECDH": {
      switch (key.algorithm.name) {
        case "ECDH":
        case "X25519":
          break;
        default:
          throw unusable("ECDH or X25519");
      }
      break;
    }
    case "PBES2-HS256+A128KW":
    case "PBES2-HS384+A192KW":
    case "PBES2-HS512+A256KW":
      if (!isAlgorithm(key.algorithm, "PBKDF2"))
        throw unusable("PBKDF2");
      break;
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512": {
      if (!isAlgorithm(key.algorithm, "RSA-OAEP"))
        throw unusable("RSA-OAEP");
      const expected = parseInt(alg2.slice(9), 10) || 1;
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  checkUsage(key, usage);
}
function message(msg, actual, ...types2) {
  types2 = types2.filter(Boolean);
  if (types2.length > 2) {
    const last = types2.pop();
    msg += `one of type ${types2.join(", ")}, or ${last}.`;
  } else if (types2.length === 2) {
    msg += `one of type ${types2[0]} or ${types2[1]}.`;
  } else {
    msg += `of type ${types2[0]}.`;
  }
  if (actual == null) {
    msg += ` Received ${actual}`;
  } else if (typeof actual === "function" && actual.name) {
    msg += ` Received function ${actual.name}`;
  } else if (typeof actual === "object" && actual != null) {
    if (actual.constructor?.name) {
      msg += ` Received an instance of ${actual.constructor.name}`;
    }
  }
  return msg;
}
const invalidKeyInput = (actual, ...types2) => message("Key must be ", actual, ...types2);
const withAlg = (alg2, actual, ...types2) => message(`Key for the ${alg2} algorithm must be `, actual, ...types2);
function assertCryptoKey(key) {
  if (!isCryptoKey(key)) {
    throw new Error("CryptoKey instance expected");
  }
}
const isCryptoKey = (key) => {
  if (key?.[Symbol.toStringTag] === "CryptoKey")
    return true;
  try {
    return key instanceof CryptoKey;
  } catch {
    return false;
  }
};
const isKeyObject = (key) => key?.[Symbol.toStringTag] === "KeyObject";
const isKeyLike = (key) => isCryptoKey(key) || isKeyObject(key);
async function timingSafeEqual(a, b) {
  if (!(a instanceof Uint8Array)) {
    throw new TypeError("First argument must be a buffer");
  }
  if (!(b instanceof Uint8Array)) {
    throw new TypeError("Second argument must be a buffer");
  }
  const algorithm2 = { name: "HMAC", hash: "SHA-256" };
  const key = await crypto.subtle.generateKey(algorithm2, false, ["sign"]);
  const aHmac = new Uint8Array(await crypto.subtle.sign(algorithm2, key, a));
  const bHmac = new Uint8Array(await crypto.subtle.sign(algorithm2, key, b));
  let out = 0;
  let i = -1;
  while (++i < 32) {
    out |= aHmac[i] ^ bHmac[i];
  }
  return out === 0;
}
async function cbcDecrypt(enc2, cek, ciphertext, iv, tag2, aad) {
  if (!(cek instanceof Uint8Array)) {
    throw new TypeError(invalidKeyInput(cek, "Uint8Array"));
  }
  const keySize = parseInt(enc2.slice(1, 4), 10);
  const encKey = await crypto.subtle.importKey("raw", cek.subarray(keySize >> 3), "AES-CBC", false, ["decrypt"]);
  const macKey = await crypto.subtle.importKey("raw", cek.subarray(0, keySize >> 3), {
    hash: `SHA-${keySize << 1}`,
    name: "HMAC"
  }, false, ["sign"]);
  const macData = concat(aad, iv, ciphertext, uint64be(aad.length << 3));
  const expectedTag = new Uint8Array((await crypto.subtle.sign("HMAC", macKey, macData)).slice(0, keySize >> 3));
  let macCheckPassed;
  try {
    macCheckPassed = await timingSafeEqual(tag2, expectedTag);
  } catch {
  }
  if (!macCheckPassed) {
    throw new JWEDecryptionFailed();
  }
  let plaintext;
  try {
    plaintext = new Uint8Array(await crypto.subtle.decrypt({ iv, name: "AES-CBC" }, encKey, ciphertext));
  } catch {
  }
  if (!plaintext) {
    throw new JWEDecryptionFailed();
  }
  return plaintext;
}
async function gcmDecrypt(enc2, cek, ciphertext, iv, tag2, aad) {
  let encKey;
  if (cek instanceof Uint8Array) {
    encKey = await crypto.subtle.importKey("raw", cek, "AES-GCM", false, ["decrypt"]);
  } else {
    checkEncCryptoKey(cek, enc2, "decrypt");
    encKey = cek;
  }
  try {
    return new Uint8Array(await crypto.subtle.decrypt({
      additionalData: aad,
      iv,
      name: "AES-GCM",
      tagLength: 128
    }, encKey, concat(ciphertext, tag2)));
  } catch {
    throw new JWEDecryptionFailed();
  }
}
async function decrypt$1(enc2, cek, ciphertext, iv, tag2, aad) {
  if (!isCryptoKey(cek) && !(cek instanceof Uint8Array)) {
    throw new TypeError(invalidKeyInput(cek, "CryptoKey", "KeyObject", "Uint8Array", "JSON Web Key"));
  }
  if (!iv) {
    throw new JWEInvalid("JWE Initialization Vector missing");
  }
  if (!tag2) {
    throw new JWEInvalid("JWE Authentication Tag missing");
  }
  checkIvLength(enc2, iv);
  switch (enc2) {
    case "A128CBC-HS256":
    case "A192CBC-HS384":
    case "A256CBC-HS512":
      if (cek instanceof Uint8Array)
        checkCekLength(cek, parseInt(enc2.slice(-3), 10));
      return cbcDecrypt(enc2, cek, ciphertext, iv, tag2, aad);
    case "A128GCM":
    case "A192GCM":
    case "A256GCM":
      if (cek instanceof Uint8Array)
        checkCekLength(cek, parseInt(enc2.slice(1, 4), 10));
      return gcmDecrypt(enc2, cek, ciphertext, iv, tag2, aad);
    default:
      throw new JOSENotSupported("Unsupported JWE Content Encryption Algorithm");
  }
}
function isDisjoint(...headers) {
  const sources = headers.filter(Boolean);
  if (sources.length === 0 || sources.length === 1) {
    return true;
  }
  let acc;
  for (const header of sources) {
    const parameters = Object.keys(header);
    if (!acc || acc.size === 0) {
      acc = new Set(parameters);
      continue;
    }
    for (const parameter of parameters) {
      if (acc.has(parameter)) {
        return false;
      }
      acc.add(parameter);
    }
  }
  return true;
}
const isObjectLike = (value) => typeof value === "object" && value !== null;
function isObject$1(input) {
  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(input) === null) {
    return true;
  }
  let proto2 = input;
  while (Object.getPrototypeOf(proto2) !== null) {
    proto2 = Object.getPrototypeOf(proto2);
  }
  return Object.getPrototypeOf(input) === proto2;
}
function checkKeySize(key, alg2) {
  if (key.algorithm.length !== parseInt(alg2.slice(1, 4), 10)) {
    throw new TypeError(`Invalid key size for alg: ${alg2}`);
  }
}
function getCryptoKey$3(key, alg2, usage) {
  if (key instanceof Uint8Array) {
    return crypto.subtle.importKey("raw", key, "AES-KW", true, [usage]);
  }
  checkEncCryptoKey(key, alg2, usage);
  return key;
}
async function wrap$2(alg2, key, cek) {
  const cryptoKey = await getCryptoKey$3(key, alg2, "wrapKey");
  checkKeySize(cryptoKey, alg2);
  const cryptoKeyCek = await crypto.subtle.importKey("raw", cek, { hash: "SHA-256", name: "HMAC" }, true, ["sign"]);
  return new Uint8Array(await crypto.subtle.wrapKey("raw", cryptoKeyCek, cryptoKey, "AES-KW"));
}
async function unwrap$2(alg2, key, encryptedKey) {
  const cryptoKey = await getCryptoKey$3(key, alg2, "unwrapKey");
  checkKeySize(cryptoKey, alg2);
  const cryptoKeyCek = await crypto.subtle.unwrapKey("raw", encryptedKey, cryptoKey, "AES-KW", { hash: "SHA-256", name: "HMAC" }, true, ["sign"]);
  return new Uint8Array(await crypto.subtle.exportKey("raw", cryptoKeyCek));
}
async function digest(algorithm2, data) {
  const subtleDigest = `SHA-${algorithm2.slice(-3)}`;
  return new Uint8Array(await crypto.subtle.digest(subtleDigest, data));
}
function lengthAndInput(input) {
  return concat(uint32be(input.length), input);
}
async function concatKdf(Z, L, OtherInfo) {
  const dkLen = L >> 3;
  const hashLen = 32;
  const reps = Math.ceil(dkLen / hashLen);
  const dk = new Uint8Array(reps * hashLen);
  for (let i = 1; i <= reps; i++) {
    const hashInput = new Uint8Array(4 + Z.length + OtherInfo.length);
    hashInput.set(uint32be(i), 0);
    hashInput.set(Z, 4);
    hashInput.set(OtherInfo, 4 + Z.length);
    const hashResult = await digest("sha256", hashInput);
    dk.set(hashResult, (i - 1) * hashLen);
  }
  return dk.slice(0, dkLen);
}
async function deriveKey$1(publicKey, privateKey, algorithm2, keyLength, apu = new Uint8Array(), apv = new Uint8Array()) {
  checkEncCryptoKey(publicKey, "ECDH");
  checkEncCryptoKey(privateKey, "ECDH", "deriveBits");
  const algorithmID = lengthAndInput(encode$1(algorithm2));
  const partyUInfo = lengthAndInput(apu);
  const partyVInfo = lengthAndInput(apv);
  const suppPubInfo = uint32be(keyLength);
  const suppPrivInfo = new Uint8Array();
  const otherInfo = concat(algorithmID, partyUInfo, partyVInfo, suppPubInfo, suppPrivInfo);
  const Z = new Uint8Array(await crypto.subtle.deriveBits({
    name: publicKey.algorithm.name,
    public: publicKey
  }, privateKey, getEcdhBitLength(publicKey)));
  return concatKdf(Z, keyLength, otherInfo);
}
function getEcdhBitLength(publicKey) {
  if (publicKey.algorithm.name === "X25519") {
    return 256;
  }
  return Math.ceil(parseInt(publicKey.algorithm.namedCurve.slice(-3), 10) / 8) << 3;
}
function allowed(key) {
  switch (key.algorithm.namedCurve) {
    case "P-256":
    case "P-384":
    case "P-521":
      return true;
    default:
      return key.algorithm.name === "X25519";
  }
}
function getCryptoKey$2(key, alg2) {
  if (key instanceof Uint8Array) {
    return crypto.subtle.importKey("raw", key, "PBKDF2", false, [
      "deriveBits"
    ]);
  }
  checkEncCryptoKey(key, alg2, "deriveBits");
  return key;
}
const concatSalt = (alg2, p2sInput) => concat(encode$1(alg2), Uint8Array.of(0), p2sInput);
async function deriveKey(p2s, alg2, p2c, key) {
  if (!(p2s instanceof Uint8Array) || p2s.length < 8) {
    throw new JWEInvalid("PBES2 Salt Input must be 8 or more octets");
  }
  const salt = concatSalt(alg2, p2s);
  const keylen = parseInt(alg2.slice(13, 16), 10);
  const subtleAlg = {
    hash: `SHA-${alg2.slice(8, 11)}`,
    iterations: p2c,
    name: "PBKDF2",
    salt
  };
  const cryptoKey = await getCryptoKey$2(key, alg2);
  return new Uint8Array(await crypto.subtle.deriveBits(subtleAlg, cryptoKey, keylen));
}
async function wrap$1(alg2, key, cek, p2c = 2048, p2s = crypto.getRandomValues(new Uint8Array(16))) {
  const derived = await deriveKey(p2s, alg2, p2c, key);
  const encryptedKey = await wrap$2(alg2.slice(-6), derived, cek);
  return { encryptedKey, p2c, p2s: encode(p2s) };
}
async function unwrap$1(alg2, key, encryptedKey, p2c, p2s) {
  const derived = await deriveKey(p2s, alg2, p2c, key);
  return unwrap$2(alg2.slice(-6), derived, encryptedKey);
}
function checkKeyLength(alg2, key) {
  if (alg2.startsWith("RS") || alg2.startsWith("PS")) {
    const { modulusLength } = key.algorithm;
    if (typeof modulusLength !== "number" || modulusLength < 2048) {
      throw new TypeError(`${alg2} requires key modulusLength to be 2048 bits or larger`);
    }
  }
}
const subtleAlgorithm$1 = (alg2) => {
  switch (alg2) {
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512":
      return "RSA-OAEP";
    default:
      throw new JOSENotSupported(`alg ${alg2} is not supported either by JOSE or your javascript runtime`);
  }
};
async function encrypt$1(alg2, key, cek) {
  checkEncCryptoKey(key, alg2, "encrypt");
  checkKeyLength(alg2, key);
  return new Uint8Array(await crypto.subtle.encrypt(subtleAlgorithm$1(alg2), key, cek));
}
async function decrypt(alg2, key, encryptedKey) {
  checkEncCryptoKey(key, alg2, "decrypt");
  checkKeyLength(alg2, key);
  return new Uint8Array(await crypto.subtle.decrypt(subtleAlgorithm$1(alg2), key, encryptedKey));
}
function cekLength(alg2) {
  switch (alg2) {
    case "A128GCM":
      return 128;
    case "A192GCM":
      return 192;
    case "A256GCM":
    case "A128CBC-HS256":
      return 256;
    case "A192CBC-HS384":
      return 384;
    case "A256CBC-HS512":
      return 512;
    default:
      throw new JOSENotSupported(`Unsupported JWE Algorithm: ${alg2}`);
  }
}
const generateCek = (alg2) => crypto.getRandomValues(new Uint8Array(cekLength(alg2) >> 3));
function subtleMapping(jwk) {
  let algorithm2;
  let keyUsages;
  switch (jwk.kty) {
    case "AKP": {
      switch (jwk.alg) {
        case "ML-DSA-44":
        case "ML-DSA-65":
        case "ML-DSA-87":
          algorithm2 = { name: jwk.alg };
          keyUsages = jwk.priv ? ["sign"] : ["verify"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "RSA": {
      switch (jwk.alg) {
        case "PS256":
        case "PS384":
        case "PS512":
          algorithm2 = { name: "RSA-PSS", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RS256":
        case "RS384":
        case "RS512":
          algorithm2 = { name: "RSASSA-PKCS1-v1_5", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512":
          algorithm2 = {
            name: "RSA-OAEP",
            hash: `SHA-${parseInt(jwk.alg.slice(-3), 10) || 1}`
          };
          keyUsages = jwk.d ? ["decrypt", "unwrapKey"] : ["encrypt", "wrapKey"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "EC": {
      switch (jwk.alg) {
        case "ES256":
          algorithm2 = { name: "ECDSA", namedCurve: "P-256" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES384":
          algorithm2 = { name: "ECDSA", namedCurve: "P-384" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES512":
          algorithm2 = { name: "ECDSA", namedCurve: "P-521" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm2 = { name: "ECDH", namedCurve: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "OKP": {
      switch (jwk.alg) {
        case "Ed25519":
        case "EdDSA":
          algorithm2 = { name: "Ed25519" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm2 = { name: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    default:
      throw new JOSENotSupported('Invalid or unsupported JWK "kty" (Key Type) Parameter value');
  }
  return { algorithm: algorithm2, keyUsages };
}
async function jwkToKey(jwk) {
  if (!jwk.alg) {
    throw new TypeError('"alg" argument is required when "jwk.alg" is not present');
  }
  const { algorithm: algorithm2, keyUsages } = subtleMapping(jwk);
  const keyData = { ...jwk };
  if (keyData.kty !== "AKP") {
    delete keyData.alg;
  }
  delete keyData.use;
  return crypto.subtle.importKey("jwk", keyData, algorithm2, jwk.ext ?? (jwk.d || jwk.priv ? false : true), jwk.key_ops ?? keyUsages);
}
async function importJWK(jwk, alg2, options) {
  if (!isObject$1(jwk)) {
    throw new TypeError("JWK must be an object");
  }
  let ext;
  alg2 ??= jwk.alg;
  ext ??= jwk.ext;
  switch (jwk.kty) {
    case "oct":
      if (typeof jwk.k !== "string" || !jwk.k) {
        throw new TypeError('missing "k" (Key Value) Parameter value');
      }
      return decode(jwk.k);
    case "RSA":
      if ("oth" in jwk && jwk.oth !== void 0) {
        throw new JOSENotSupported('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');
      }
      return jwkToKey({ ...jwk, alg: alg2, ext });
    case "AKP": {
      if (typeof jwk.alg !== "string" || !jwk.alg) {
        throw new TypeError('missing "alg" (Algorithm) Parameter value');
      }
      if (alg2 !== void 0 && alg2 !== jwk.alg) {
        throw new TypeError("JWK alg and alg option value mismatch");
      }
      return jwkToKey({ ...jwk, ext });
    }
    case "EC":
    case "OKP":
      return jwkToKey({ ...jwk, alg: alg2, ext });
    default:
      throw new JOSENotSupported('Unsupported "kty" (Key Type) Parameter value');
  }
}
async function cbcEncrypt(enc2, plaintext, cek, iv, aad) {
  if (!(cek instanceof Uint8Array)) {
    throw new TypeError(invalidKeyInput(cek, "Uint8Array"));
  }
  const keySize = parseInt(enc2.slice(1, 4), 10);
  const encKey = await crypto.subtle.importKey("raw", cek.subarray(keySize >> 3), "AES-CBC", false, ["encrypt"]);
  const macKey = await crypto.subtle.importKey("raw", cek.subarray(0, keySize >> 3), {
    hash: `SHA-${keySize << 1}`,
    name: "HMAC"
  }, false, ["sign"]);
  const ciphertext = new Uint8Array(await crypto.subtle.encrypt({
    iv,
    name: "AES-CBC"
  }, encKey, plaintext));
  const macData = concat(aad, iv, ciphertext, uint64be(aad.length << 3));
  const tag2 = new Uint8Array((await crypto.subtle.sign("HMAC", macKey, macData)).slice(0, keySize >> 3));
  return { ciphertext, tag: tag2, iv };
}
async function gcmEncrypt(enc2, plaintext, cek, iv, aad) {
  let encKey;
  if (cek instanceof Uint8Array) {
    encKey = await crypto.subtle.importKey("raw", cek, "AES-GCM", false, ["encrypt"]);
  } else {
    checkEncCryptoKey(cek, enc2, "encrypt");
    encKey = cek;
  }
  const encrypted = new Uint8Array(await crypto.subtle.encrypt({
    additionalData: aad,
    iv,
    name: "AES-GCM",
    tagLength: 128
  }, encKey, plaintext));
  const tag2 = encrypted.slice(-16);
  const ciphertext = encrypted.slice(0, -16);
  return { ciphertext, tag: tag2, iv };
}
async function encrypt(enc2, plaintext, cek, iv, aad) {
  if (!isCryptoKey(cek) && !(cek instanceof Uint8Array)) {
    throw new TypeError(invalidKeyInput(cek, "CryptoKey", "KeyObject", "Uint8Array", "JSON Web Key"));
  }
  if (iv) {
    checkIvLength(enc2, iv);
  } else {
    iv = generateIv(enc2);
  }
  switch (enc2) {
    case "A128CBC-HS256":
    case "A192CBC-HS384":
    case "A256CBC-HS512":
      if (cek instanceof Uint8Array) {
        checkCekLength(cek, parseInt(enc2.slice(-3), 10));
      }
      return cbcEncrypt(enc2, plaintext, cek, iv, aad);
    case "A128GCM":
    case "A192GCM":
    case "A256GCM":
      if (cek instanceof Uint8Array) {
        checkCekLength(cek, parseInt(enc2.slice(1, 4), 10));
      }
      return gcmEncrypt(enc2, plaintext, cek, iv, aad);
    default:
      throw new JOSENotSupported("Unsupported JWE Content Encryption Algorithm");
  }
}
async function wrap(alg2, key, cek, iv) {
  const jweAlgorithm = alg2.slice(0, 7);
  const wrapped = await encrypt(jweAlgorithm, cek, key, iv, new Uint8Array());
  return {
    encryptedKey: wrapped.ciphertext,
    iv: encode(wrapped.iv),
    tag: encode(wrapped.tag)
  };
}
async function unwrap(alg2, key, encryptedKey, iv, tag2) {
  const jweAlgorithm = alg2.slice(0, 7);
  return decrypt$1(jweAlgorithm, key, encryptedKey, iv, tag2, new Uint8Array());
}
async function decryptKeyManagement(alg2, key, encryptedKey, joseHeader, options) {
  switch (alg2) {
    case "dir": {
      if (encryptedKey !== void 0)
        throw new JWEInvalid("Encountered unexpected JWE Encrypted Key");
      return key;
    }
    case "ECDH-ES":
      if (encryptedKey !== void 0)
        throw new JWEInvalid("Encountered unexpected JWE Encrypted Key");
    case "ECDH-ES+A128KW":
    case "ECDH-ES+A192KW":
    case "ECDH-ES+A256KW": {
      if (!isObject$1(joseHeader.epk))
        throw new JWEInvalid(`JOSE Header "epk" (Ephemeral Public Key) missing or invalid`);
      assertCryptoKey(key);
      if (!allowed(key))
        throw new JOSENotSupported("ECDH with the provided key is not allowed or not supported by your javascript runtime");
      const epk = await importJWK(joseHeader.epk, alg2);
      assertCryptoKey(epk);
      let partyUInfo;
      let partyVInfo;
      if (joseHeader.apu !== void 0) {
        if (typeof joseHeader.apu !== "string")
          throw new JWEInvalid(`JOSE Header "apu" (Agreement PartyUInfo) invalid`);
        try {
          partyUInfo = decode(joseHeader.apu);
        } catch {
          throw new JWEInvalid("Failed to base64url decode the apu");
        }
      }
      if (joseHeader.apv !== void 0) {
        if (typeof joseHeader.apv !== "string")
          throw new JWEInvalid(`JOSE Header "apv" (Agreement PartyVInfo) invalid`);
        try {
          partyVInfo = decode(joseHeader.apv);
        } catch {
          throw new JWEInvalid("Failed to base64url decode the apv");
        }
      }
      const sharedSecret = await deriveKey$1(epk, key, alg2 === "ECDH-ES" ? joseHeader.enc : alg2, alg2 === "ECDH-ES" ? cekLength(joseHeader.enc) : parseInt(alg2.slice(-5, -2), 10), partyUInfo, partyVInfo);
      if (alg2 === "ECDH-ES")
        return sharedSecret;
      if (encryptedKey === void 0)
        throw new JWEInvalid("JWE Encrypted Key missing");
      return unwrap$2(alg2.slice(-6), sharedSecret, encryptedKey);
    }
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512": {
      if (encryptedKey === void 0)
        throw new JWEInvalid("JWE Encrypted Key missing");
      assertCryptoKey(key);
      return decrypt(alg2, key, encryptedKey);
    }
    case "PBES2-HS256+A128KW":
    case "PBES2-HS384+A192KW":
    case "PBES2-HS512+A256KW": {
      if (encryptedKey === void 0)
        throw new JWEInvalid("JWE Encrypted Key missing");
      if (typeof joseHeader.p2c !== "number")
        throw new JWEInvalid(`JOSE Header "p2c" (PBES2 Count) missing or invalid`);
      const p2cLimit = options?.maxPBES2Count || 1e4;
      if (joseHeader.p2c > p2cLimit)
        throw new JWEInvalid(`JOSE Header "p2c" (PBES2 Count) out is of acceptable bounds`);
      if (typeof joseHeader.p2s !== "string")
        throw new JWEInvalid(`JOSE Header "p2s" (PBES2 Salt) missing or invalid`);
      let p2s;
      try {
        p2s = decode(joseHeader.p2s);
      } catch {
        throw new JWEInvalid("Failed to base64url decode the p2s");
      }
      return unwrap$1(alg2, key, encryptedKey, joseHeader.p2c, p2s);
    }
    case "A128KW":
    case "A192KW":
    case "A256KW": {
      if (encryptedKey === void 0)
        throw new JWEInvalid("JWE Encrypted Key missing");
      return unwrap$2(alg2, key, encryptedKey);
    }
    case "A128GCMKW":
    case "A192GCMKW":
    case "A256GCMKW": {
      if (encryptedKey === void 0)
        throw new JWEInvalid("JWE Encrypted Key missing");
      if (typeof joseHeader.iv !== "string")
        throw new JWEInvalid(`JOSE Header "iv" (Initialization Vector) missing or invalid`);
      if (typeof joseHeader.tag !== "string")
        throw new JWEInvalid(`JOSE Header "tag" (Authentication Tag) missing or invalid`);
      let iv;
      try {
        iv = decode(joseHeader.iv);
      } catch {
        throw new JWEInvalid("Failed to base64url decode the iv");
      }
      let tag2;
      try {
        tag2 = decode(joseHeader.tag);
      } catch {
        throw new JWEInvalid("Failed to base64url decode the tag");
      }
      return unwrap(alg2, key, encryptedKey, iv, tag2);
    }
    default: {
      throw new JOSENotSupported('Invalid or unsupported "alg" (JWE Algorithm) header value');
    }
  }
}
function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
  if (joseHeader.crit !== void 0 && protectedHeader?.crit === void 0) {
    throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
  }
  if (!protectedHeader || protectedHeader.crit === void 0) {
    return /* @__PURE__ */ new Set();
  }
  if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input) => typeof input !== "string" || input.length === 0)) {
    throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
  }
  let recognized;
  if (recognizedOption !== void 0) {
    recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
  } else {
    recognized = recognizedDefault;
  }
  for (const parameter of protectedHeader.crit) {
    if (!recognized.has(parameter)) {
      throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
    }
    if (joseHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" is missing`);
    }
    if (recognized.get(parameter) && protectedHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
    }
  }
  return new Set(protectedHeader.crit);
}
function validateAlgorithms(option2, algorithms) {
  if (algorithms !== void 0 && (!Array.isArray(algorithms) || algorithms.some((s2) => typeof s2 !== "string"))) {
    throw new TypeError(`"${option2}" option must be an array of strings`);
  }
  if (!algorithms) {
    return void 0;
  }
  return new Set(algorithms);
}
const isJWK = (key) => isObject$1(key) && typeof key.kty === "string";
const isPrivateJWK = (key) => key.kty !== "oct" && (key.kty === "AKP" && typeof key.priv === "string" || typeof key.d === "string");
const isPublicJWK = (key) => key.kty !== "oct" && key.d === void 0 && key.priv === void 0;
const isSecretJWK = (key) => key.kty === "oct" && typeof key.k === "string";
let cache$1;
const handleJWK = async (key, jwk, alg2, freeze2 = false) => {
  cache$1 ||= /* @__PURE__ */ new WeakMap();
  let cached = cache$1.get(key);
  if (cached?.[alg2]) {
    return cached[alg2];
  }
  const cryptoKey = await jwkToKey({ ...jwk, alg: alg2 });
  if (freeze2)
    Object.freeze(key);
  if (!cached) {
    cache$1.set(key, { [alg2]: cryptoKey });
  } else {
    cached[alg2] = cryptoKey;
  }
  return cryptoKey;
};
const handleKeyObject = (keyObject, alg2) => {
  cache$1 ||= /* @__PURE__ */ new WeakMap();
  let cached = cache$1.get(keyObject);
  if (cached?.[alg2]) {
    return cached[alg2];
  }
  const isPublic = keyObject.type === "public";
  const extractable = isPublic ? true : false;
  let cryptoKey;
  if (keyObject.asymmetricKeyType === "x25519") {
    switch (alg2) {
      case "ECDH-ES":
      case "ECDH-ES+A128KW":
      case "ECDH-ES+A192KW":
      case "ECDH-ES+A256KW":
        break;
      default:
        throw new TypeError("given KeyObject instance cannot be used for this algorithm");
    }
    cryptoKey = keyObject.toCryptoKey(keyObject.asymmetricKeyType, extractable, isPublic ? [] : ["deriveBits"]);
  }
  if (keyObject.asymmetricKeyType === "ed25519") {
    if (alg2 !== "EdDSA" && alg2 !== "Ed25519") {
      throw new TypeError("given KeyObject instance cannot be used for this algorithm");
    }
    cryptoKey = keyObject.toCryptoKey(keyObject.asymmetricKeyType, extractable, [
      isPublic ? "verify" : "sign"
    ]);
  }
  switch (keyObject.asymmetricKeyType) {
    case "ml-dsa-44":
    case "ml-dsa-65":
    case "ml-dsa-87": {
      if (alg2 !== keyObject.asymmetricKeyType.toUpperCase()) {
        throw new TypeError("given KeyObject instance cannot be used for this algorithm");
      }
      cryptoKey = keyObject.toCryptoKey(keyObject.asymmetricKeyType, extractable, [
        isPublic ? "verify" : "sign"
      ]);
    }
  }
  if (keyObject.asymmetricKeyType === "rsa") {
    let hash;
    switch (alg2) {
      case "RSA-OAEP":
        hash = "SHA-1";
        break;
      case "RS256":
      case "PS256":
      case "RSA-OAEP-256":
        hash = "SHA-256";
        break;
      case "RS384":
      case "PS384":
      case "RSA-OAEP-384":
        hash = "SHA-384";
        break;
      case "RS512":
      case "PS512":
      case "RSA-OAEP-512":
        hash = "SHA-512";
        break;
      default:
        throw new TypeError("given KeyObject instance cannot be used for this algorithm");
    }
    if (alg2.startsWith("RSA-OAEP")) {
      return keyObject.toCryptoKey({
        name: "RSA-OAEP",
        hash
      }, extractable, isPublic ? ["encrypt"] : ["decrypt"]);
    }
    cryptoKey = keyObject.toCryptoKey({
      name: alg2.startsWith("PS") ? "RSA-PSS" : "RSASSA-PKCS1-v1_5",
      hash
    }, extractable, [isPublic ? "verify" : "sign"]);
  }
  if (keyObject.asymmetricKeyType === "ec") {
    const nist = /* @__PURE__ */ new Map([
      ["prime256v1", "P-256"],
      ["secp384r1", "P-384"],
      ["secp521r1", "P-521"]
    ]);
    const namedCurve = nist.get(keyObject.asymmetricKeyDetails?.namedCurve);
    if (!namedCurve) {
      throw new TypeError("given KeyObject instance cannot be used for this algorithm");
    }
    if (alg2 === "ES256" && namedCurve === "P-256") {
      cryptoKey = keyObject.toCryptoKey({
        name: "ECDSA",
        namedCurve
      }, extractable, [isPublic ? "verify" : "sign"]);
    }
    if (alg2 === "ES384" && namedCurve === "P-384") {
      cryptoKey = keyObject.toCryptoKey({
        name: "ECDSA",
        namedCurve
      }, extractable, [isPublic ? "verify" : "sign"]);
    }
    if (alg2 === "ES512" && namedCurve === "P-521") {
      cryptoKey = keyObject.toCryptoKey({
        name: "ECDSA",
        namedCurve
      }, extractable, [isPublic ? "verify" : "sign"]);
    }
    if (alg2.startsWith("ECDH-ES")) {
      cryptoKey = keyObject.toCryptoKey({
        name: "ECDH",
        namedCurve
      }, extractable, isPublic ? [] : ["deriveBits"]);
    }
  }
  if (!cryptoKey) {
    throw new TypeError("given KeyObject instance cannot be used for this algorithm");
  }
  if (!cached) {
    cache$1.set(keyObject, { [alg2]: cryptoKey });
  } else {
    cached[alg2] = cryptoKey;
  }
  return cryptoKey;
};
async function normalizeKey(key, alg2) {
  if (key instanceof Uint8Array) {
    return key;
  }
  if (isCryptoKey(key)) {
    return key;
  }
  if (isKeyObject(key)) {
    if (key.type === "secret") {
      return key.export();
    }
    if ("toCryptoKey" in key && typeof key.toCryptoKey === "function") {
      try {
        return handleKeyObject(key, alg2);
      } catch (err2) {
        if (err2 instanceof TypeError) {
          throw err2;
        }
      }
    }
    let jwk = key.export({ format: "jwk" });
    return handleJWK(key, jwk, alg2);
  }
  if (isJWK(key)) {
    if (key.k) {
      return decode(key.k);
    }
    return handleJWK(key, key, alg2, true);
  }
  throw new Error("unreachable");
}
const tag = (key) => key?.[Symbol.toStringTag];
const jwkMatchesOp = (alg2, key, usage) => {
  if (key.use !== void 0) {
    let expected;
    switch (usage) {
      case "sign":
      case "verify":
        expected = "sig";
        break;
      case "encrypt":
      case "decrypt":
        expected = "enc";
        break;
    }
    if (key.use !== expected) {
      throw new TypeError(`Invalid key for this operation, its "use" must be "${expected}" when present`);
    }
  }
  if (key.alg !== void 0 && key.alg !== alg2) {
    throw new TypeError(`Invalid key for this operation, its "alg" must be "${alg2}" when present`);
  }
  if (Array.isArray(key.key_ops)) {
    let expectedKeyOp;
    switch (true) {
      case (usage === "sign" || usage === "verify"):
      case alg2 === "dir":
      case alg2.includes("CBC-HS"):
        expectedKeyOp = usage;
        break;
      case alg2.startsWith("PBES2"):
        expectedKeyOp = "deriveBits";
        break;
      case /^A\d{3}(?:GCM)?(?:KW)?$/.test(alg2):
        if (!alg2.includes("GCM") && alg2.endsWith("KW")) {
          expectedKeyOp = usage === "encrypt" ? "wrapKey" : "unwrapKey";
        } else {
          expectedKeyOp = usage;
        }
        break;
      case (usage === "encrypt" && alg2.startsWith("RSA")):
        expectedKeyOp = "wrapKey";
        break;
      case usage === "decrypt":
        expectedKeyOp = alg2.startsWith("RSA") ? "unwrapKey" : "deriveBits";
        break;
    }
    if (expectedKeyOp && key.key_ops?.includes?.(expectedKeyOp) === false) {
      throw new TypeError(`Invalid key for this operation, its "key_ops" must include "${expectedKeyOp}" when present`);
    }
  }
  return true;
};
const symmetricTypeCheck = (alg2, key, usage) => {
  if (key instanceof Uint8Array)
    return;
  if (isJWK(key)) {
    if (isSecretJWK(key) && jwkMatchesOp(alg2, key, usage))
      return;
    throw new TypeError(`JSON Web Key for symmetric algorithms must have JWK "kty" (Key Type) equal to "oct" and the JWK "k" (Key Value) present`);
  }
  if (!isKeyLike(key)) {
    throw new TypeError(withAlg(alg2, key, "CryptoKey", "KeyObject", "JSON Web Key", "Uint8Array"));
  }
  if (key.type !== "secret") {
    throw new TypeError(`${tag(key)} instances for symmetric algorithms must be of type "secret"`);
  }
};
const asymmetricTypeCheck = (alg2, key, usage) => {
  if (isJWK(key)) {
    switch (usage) {
      case "decrypt":
      case "sign":
        if (isPrivateJWK(key) && jwkMatchesOp(alg2, key, usage))
          return;
        throw new TypeError(`JSON Web Key for this operation must be a private JWK`);
      case "encrypt":
      case "verify":
        if (isPublicJWK(key) && jwkMatchesOp(alg2, key, usage))
          return;
        throw new TypeError(`JSON Web Key for this operation must be a public JWK`);
    }
  }
  if (!isKeyLike(key)) {
    throw new TypeError(withAlg(alg2, key, "CryptoKey", "KeyObject", "JSON Web Key"));
  }
  if (key.type === "secret") {
    throw new TypeError(`${tag(key)} instances for asymmetric algorithms must not be of type "secret"`);
  }
  if (key.type === "public") {
    switch (usage) {
      case "sign":
        throw new TypeError(`${tag(key)} instances for asymmetric algorithm signing must be of type "private"`);
      case "decrypt":
        throw new TypeError(`${tag(key)} instances for asymmetric algorithm decryption must be of type "private"`);
    }
  }
  if (key.type === "private") {
    switch (usage) {
      case "verify":
        throw new TypeError(`${tag(key)} instances for asymmetric algorithm verifying must be of type "public"`);
      case "encrypt":
        throw new TypeError(`${tag(key)} instances for asymmetric algorithm encryption must be of type "public"`);
    }
  }
};
function checkKeyType(alg2, key, usage) {
  switch (alg2.substring(0, 2)) {
    case "A1":
    case "A2":
    case "di":
    case "HS":
    case "PB":
      symmetricTypeCheck(alg2, key, usage);
      break;
    default:
      asymmetricTypeCheck(alg2, key, usage);
  }
}
async function flattenedDecrypt(jwe, key, options) {
  if (!isObject$1(jwe)) {
    throw new JWEInvalid("Flattened JWE must be an object");
  }
  if (jwe.protected === void 0 && jwe.header === void 0 && jwe.unprotected === void 0) {
    throw new JWEInvalid("JOSE Header missing");
  }
  if (jwe.iv !== void 0 && typeof jwe.iv !== "string") {
    throw new JWEInvalid("JWE Initialization Vector incorrect type");
  }
  if (typeof jwe.ciphertext !== "string") {
    throw new JWEInvalid("JWE Ciphertext missing or incorrect type");
  }
  if (jwe.tag !== void 0 && typeof jwe.tag !== "string") {
    throw new JWEInvalid("JWE Authentication Tag incorrect type");
  }
  if (jwe.protected !== void 0 && typeof jwe.protected !== "string") {
    throw new JWEInvalid("JWE Protected Header incorrect type");
  }
  if (jwe.encrypted_key !== void 0 && typeof jwe.encrypted_key !== "string") {
    throw new JWEInvalid("JWE Encrypted Key incorrect type");
  }
  if (jwe.aad !== void 0 && typeof jwe.aad !== "string") {
    throw new JWEInvalid("JWE AAD incorrect type");
  }
  if (jwe.header !== void 0 && !isObject$1(jwe.header)) {
    throw new JWEInvalid("JWE Shared Unprotected Header incorrect type");
  }
  if (jwe.unprotected !== void 0 && !isObject$1(jwe.unprotected)) {
    throw new JWEInvalid("JWE Per-Recipient Unprotected Header incorrect type");
  }
  let parsedProt;
  if (jwe.protected) {
    try {
      const protectedHeader2 = decode(jwe.protected);
      parsedProt = JSON.parse(decoder.decode(protectedHeader2));
    } catch {
      throw new JWEInvalid("JWE Protected Header is invalid");
    }
  }
  if (!isDisjoint(parsedProt, jwe.header, jwe.unprotected)) {
    throw new JWEInvalid("JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint");
  }
  const joseHeader = {
    ...parsedProt,
    ...jwe.header,
    ...jwe.unprotected
  };
  validateCrit(JWEInvalid, /* @__PURE__ */ new Map(), options?.crit, parsedProt, joseHeader);
  if (joseHeader.zip !== void 0) {
    throw new JOSENotSupported('JWE "zip" (Compression Algorithm) Header Parameter is not supported.');
  }
  const { alg: alg2, enc: enc2 } = joseHeader;
  if (typeof alg2 !== "string" || !alg2) {
    throw new JWEInvalid("missing JWE Algorithm (alg) in JWE Header");
  }
  if (typeof enc2 !== "string" || !enc2) {
    throw new JWEInvalid("missing JWE Encryption Algorithm (enc) in JWE Header");
  }
  const keyManagementAlgorithms = options && validateAlgorithms("keyManagementAlgorithms", options.keyManagementAlgorithms);
  const contentEncryptionAlgorithms = options && validateAlgorithms("contentEncryptionAlgorithms", options.contentEncryptionAlgorithms);
  if (keyManagementAlgorithms && !keyManagementAlgorithms.has(alg2) || !keyManagementAlgorithms && alg2.startsWith("PBES2")) {
    throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter value not allowed');
  }
  if (contentEncryptionAlgorithms && !contentEncryptionAlgorithms.has(enc2)) {
    throw new JOSEAlgNotAllowed('"enc" (Encryption Algorithm) Header Parameter value not allowed');
  }
  let encryptedKey;
  if (jwe.encrypted_key !== void 0) {
    try {
      encryptedKey = decode(jwe.encrypted_key);
    } catch {
      throw new JWEInvalid("Failed to base64url decode the encrypted_key");
    }
  }
  let resolvedKey = false;
  if (typeof key === "function") {
    key = await key(parsedProt, jwe);
    resolvedKey = true;
  }
  checkKeyType(alg2 === "dir" ? enc2 : alg2, key, "decrypt");
  const k = await normalizeKey(key, alg2);
  let cek;
  try {
    cek = await decryptKeyManagement(alg2, k, encryptedKey, joseHeader, options);
  } catch (err2) {
    if (err2 instanceof TypeError || err2 instanceof JWEInvalid || err2 instanceof JOSENotSupported) {
      throw err2;
    }
    cek = generateCek(enc2);
  }
  let iv;
  let tag2;
  if (jwe.iv !== void 0) {
    try {
      iv = decode(jwe.iv);
    } catch {
      throw new JWEInvalid("Failed to base64url decode the iv");
    }
  }
  if (jwe.tag !== void 0) {
    try {
      tag2 = decode(jwe.tag);
    } catch {
      throw new JWEInvalid("Failed to base64url decode the tag");
    }
  }
  const protectedHeader = jwe.protected !== void 0 ? encode$1(jwe.protected) : new Uint8Array();
  let additionalData;
  if (jwe.aad !== void 0) {
    additionalData = concat(protectedHeader, encode$1("."), encode$1(jwe.aad));
  } else {
    additionalData = protectedHeader;
  }
  let ciphertext;
  try {
    ciphertext = decode(jwe.ciphertext);
  } catch {
    throw new JWEInvalid("Failed to base64url decode the ciphertext");
  }
  const plaintext = await decrypt$1(enc2, cek, ciphertext, iv, tag2, additionalData);
  const result2 = { plaintext };
  if (jwe.protected !== void 0) {
    result2.protectedHeader = parsedProt;
  }
  if (jwe.aad !== void 0) {
    try {
      result2.additionalAuthenticatedData = decode(jwe.aad);
    } catch {
      throw new JWEInvalid("Failed to base64url decode the aad");
    }
  }
  if (jwe.unprotected !== void 0) {
    result2.sharedUnprotectedHeader = jwe.unprotected;
  }
  if (jwe.header !== void 0) {
    result2.unprotectedHeader = jwe.header;
  }
  if (resolvedKey) {
    return { ...result2, key: k };
  }
  return result2;
}
async function compactDecrypt(jwe, key, options) {
  if (jwe instanceof Uint8Array) {
    jwe = decoder.decode(jwe);
  }
  if (typeof jwe !== "string") {
    throw new JWEInvalid("Compact JWE must be a string or Uint8Array");
  }
  const { 0: protectedHeader, 1: encryptedKey, 2: iv, 3: ciphertext, 4: tag2, length } = jwe.split(".");
  if (length !== 5) {
    throw new JWEInvalid("Invalid Compact JWE");
  }
  const decrypted = await flattenedDecrypt({
    ciphertext,
    iv: iv || void 0,
    protected: protectedHeader,
    tag: tag2 || void 0,
    encrypted_key: encryptedKey || void 0
  }, key, options);
  const result2 = { plaintext: decrypted.plaintext, protectedHeader: decrypted.protectedHeader };
  if (typeof key === "function") {
    return { ...result2, key: decrypted.key };
  }
  return result2;
}
const unprotected = /* @__PURE__ */ Symbol();
async function keyToJWK(key) {
  if (isKeyObject(key)) {
    if (key.type === "secret") {
      key = key.export();
    } else {
      return key.export({ format: "jwk" });
    }
  }
  if (key instanceof Uint8Array) {
    return {
      kty: "oct",
      k: encode(key)
    };
  }
  if (!isCryptoKey(key)) {
    throw new TypeError(invalidKeyInput(key, "CryptoKey", "KeyObject", "Uint8Array"));
  }
  if (!key.extractable) {
    throw new TypeError("non-extractable CryptoKey cannot be exported as a JWK");
  }
  const { ext, key_ops, alg: alg2, use: use2, ...jwk } = await crypto.subtle.exportKey("jwk", key);
  if (jwk.kty === "AKP") {
    jwk.alg = alg2;
  }
  return jwk;
}
async function exportJWK(key) {
  return keyToJWK(key);
}
async function encryptKeyManagement(alg2, enc2, key, providedCek, providedParameters = {}) {
  let encryptedKey;
  let parameters;
  let cek;
  switch (alg2) {
    case "dir": {
      cek = key;
      break;
    }
    case "ECDH-ES":
    case "ECDH-ES+A128KW":
    case "ECDH-ES+A192KW":
    case "ECDH-ES+A256KW": {
      assertCryptoKey(key);
      if (!allowed(key)) {
        throw new JOSENotSupported("ECDH with the provided key is not allowed or not supported by your javascript runtime");
      }
      const { apu, apv } = providedParameters;
      let ephemeralKey;
      if (providedParameters.epk) {
        ephemeralKey = await normalizeKey(providedParameters.epk, alg2);
      } else {
        ephemeralKey = (await crypto.subtle.generateKey(key.algorithm, true, ["deriveBits"])).privateKey;
      }
      const { x, y, crv, kty } = await exportJWK(ephemeralKey);
      const sharedSecret = await deriveKey$1(key, ephemeralKey, alg2 === "ECDH-ES" ? enc2 : alg2, alg2 === "ECDH-ES" ? cekLength(enc2) : parseInt(alg2.slice(-5, -2), 10), apu, apv);
      parameters = { epk: { x, crv, kty } };
      if (kty === "EC")
        parameters.epk.y = y;
      if (apu)
        parameters.apu = encode(apu);
      if (apv)
        parameters.apv = encode(apv);
      if (alg2 === "ECDH-ES") {
        cek = sharedSecret;
        break;
      }
      cek = providedCek || generateCek(enc2);
      const kwAlg = alg2.slice(-6);
      encryptedKey = await wrap$2(kwAlg, sharedSecret, cek);
      break;
    }
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512": {
      cek = providedCek || generateCek(enc2);
      assertCryptoKey(key);
      encryptedKey = await encrypt$1(alg2, key, cek);
      break;
    }
    case "PBES2-HS256+A128KW":
    case "PBES2-HS384+A192KW":
    case "PBES2-HS512+A256KW": {
      cek = providedCek || generateCek(enc2);
      const { p2c, p2s } = providedParameters;
      ({ encryptedKey, ...parameters } = await wrap$1(alg2, key, cek, p2c, p2s));
      break;
    }
    case "A128KW":
    case "A192KW":
    case "A256KW": {
      cek = providedCek || generateCek(enc2);
      encryptedKey = await wrap$2(alg2, key, cek);
      break;
    }
    case "A128GCMKW":
    case "A192GCMKW":
    case "A256GCMKW": {
      cek = providedCek || generateCek(enc2);
      const { iv } = providedParameters;
      ({ encryptedKey, ...parameters } = await wrap(alg2, key, cek, iv));
      break;
    }
    default: {
      throw new JOSENotSupported('Invalid or unsupported "alg" (JWE Algorithm) header value');
    }
  }
  return { cek, encryptedKey, parameters };
}
class FlattenedEncrypt {
  #plaintext;
  #protectedHeader;
  #sharedUnprotectedHeader;
  #unprotectedHeader;
  #aad;
  #cek;
  #iv;
  #keyManagementParameters;
  constructor(plaintext) {
    if (!(plaintext instanceof Uint8Array)) {
      throw new TypeError("plaintext must be an instance of Uint8Array");
    }
    this.#plaintext = plaintext;
  }
  setKeyManagementParameters(parameters) {
    if (this.#keyManagementParameters) {
      throw new TypeError("setKeyManagementParameters can only be called once");
    }
    this.#keyManagementParameters = parameters;
    return this;
  }
  setProtectedHeader(protectedHeader) {
    if (this.#protectedHeader) {
      throw new TypeError("setProtectedHeader can only be called once");
    }
    this.#protectedHeader = protectedHeader;
    return this;
  }
  setSharedUnprotectedHeader(sharedUnprotectedHeader) {
    if (this.#sharedUnprotectedHeader) {
      throw new TypeError("setSharedUnprotectedHeader can only be called once");
    }
    this.#sharedUnprotectedHeader = sharedUnprotectedHeader;
    return this;
  }
  setUnprotectedHeader(unprotectedHeader) {
    if (this.#unprotectedHeader) {
      throw new TypeError("setUnprotectedHeader can only be called once");
    }
    this.#unprotectedHeader = unprotectedHeader;
    return this;
  }
  setAdditionalAuthenticatedData(aad) {
    this.#aad = aad;
    return this;
  }
  setContentEncryptionKey(cek) {
    if (this.#cek) {
      throw new TypeError("setContentEncryptionKey can only be called once");
    }
    this.#cek = cek;
    return this;
  }
  setInitializationVector(iv) {
    if (this.#iv) {
      throw new TypeError("setInitializationVector can only be called once");
    }
    this.#iv = iv;
    return this;
  }
  async encrypt(key, options) {
    if (!this.#protectedHeader && !this.#unprotectedHeader && !this.#sharedUnprotectedHeader) {
      throw new JWEInvalid("either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()");
    }
    if (!isDisjoint(this.#protectedHeader, this.#unprotectedHeader, this.#sharedUnprotectedHeader)) {
      throw new JWEInvalid("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");
    }
    const joseHeader = {
      ...this.#protectedHeader,
      ...this.#unprotectedHeader,
      ...this.#sharedUnprotectedHeader
    };
    validateCrit(JWEInvalid, /* @__PURE__ */ new Map(), options?.crit, this.#protectedHeader, joseHeader);
    if (joseHeader.zip !== void 0) {
      throw new JOSENotSupported('JWE "zip" (Compression Algorithm) Header Parameter is not supported.');
    }
    const { alg: alg2, enc: enc2 } = joseHeader;
    if (typeof alg2 !== "string" || !alg2) {
      throw new JWEInvalid('JWE "alg" (Algorithm) Header Parameter missing or invalid');
    }
    if (typeof enc2 !== "string" || !enc2) {
      throw new JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');
    }
    let encryptedKey;
    if (this.#cek && (alg2 === "dir" || alg2 === "ECDH-ES")) {
      throw new TypeError(`setContentEncryptionKey cannot be called with JWE "alg" (Algorithm) Header ${alg2}`);
    }
    checkKeyType(alg2 === "dir" ? enc2 : alg2, key, "encrypt");
    let cek;
    {
      let parameters;
      const k = await normalizeKey(key, alg2);
      ({ cek, encryptedKey, parameters } = await encryptKeyManagement(alg2, enc2, k, this.#cek, this.#keyManagementParameters));
      if (parameters) {
        if (options && unprotected in options) {
          if (!this.#unprotectedHeader) {
            this.setUnprotectedHeader(parameters);
          } else {
            this.#unprotectedHeader = { ...this.#unprotectedHeader, ...parameters };
          }
        } else if (!this.#protectedHeader) {
          this.setProtectedHeader(parameters);
        } else {
          this.#protectedHeader = { ...this.#protectedHeader, ...parameters };
        }
      }
    }
    let additionalData;
    let protectedHeaderS;
    let protectedHeaderB;
    let aadMember;
    if (this.#protectedHeader) {
      protectedHeaderS = encode(JSON.stringify(this.#protectedHeader));
      protectedHeaderB = encode$1(protectedHeaderS);
    } else {
      protectedHeaderS = "";
      protectedHeaderB = new Uint8Array();
    }
    if (this.#aad) {
      aadMember = encode(this.#aad);
      const aadMemberBytes = encode$1(aadMember);
      additionalData = concat(protectedHeaderB, encode$1("."), aadMemberBytes);
    } else {
      additionalData = protectedHeaderB;
    }
    const { ciphertext, tag: tag2, iv } = await encrypt(enc2, this.#plaintext, cek, this.#iv, additionalData);
    const jwe = {
      ciphertext: encode(ciphertext)
    };
    if (iv) {
      jwe.iv = encode(iv);
    }
    if (tag2) {
      jwe.tag = encode(tag2);
    }
    if (encryptedKey) {
      jwe.encrypted_key = encode(encryptedKey);
    }
    if (aadMember) {
      jwe.aad = aadMember;
    }
    if (this.#protectedHeader) {
      jwe.protected = protectedHeaderS;
    }
    if (this.#sharedUnprotectedHeader) {
      jwe.unprotected = this.#sharedUnprotectedHeader;
    }
    if (this.#unprotectedHeader) {
      jwe.header = this.#unprotectedHeader;
    }
    return jwe;
  }
}
function subtleAlgorithm(alg2, algorithm2) {
  const hash = `SHA-${alg2.slice(-3)}`;
  switch (alg2) {
    case "HS256":
    case "HS384":
    case "HS512":
      return { hash, name: "HMAC" };
    case "PS256":
    case "PS384":
    case "PS512":
      return { hash, name: "RSA-PSS", saltLength: parseInt(alg2.slice(-3), 10) >> 3 };
    case "RS256":
    case "RS384":
    case "RS512":
      return { hash, name: "RSASSA-PKCS1-v1_5" };
    case "ES256":
    case "ES384":
    case "ES512":
      return { hash, name: "ECDSA", namedCurve: algorithm2.namedCurve };
    case "Ed25519":
    case "EdDSA":
      return { name: "Ed25519" };
    case "ML-DSA-44":
    case "ML-DSA-65":
    case "ML-DSA-87":
      return { name: alg2 };
    default:
      throw new JOSENotSupported(`alg ${alg2} is not supported either by JOSE or your javascript runtime`);
  }
}
async function getSigKey(alg2, key, usage) {
  if (key instanceof Uint8Array) {
    if (!alg2.startsWith("HS")) {
      throw new TypeError(invalidKeyInput(key, "CryptoKey", "KeyObject", "JSON Web Key"));
    }
    return crypto.subtle.importKey("raw", key, { hash: `SHA-${alg2.slice(-3)}`, name: "HMAC" }, false, [usage]);
  }
  checkSigCryptoKey(key, alg2, usage);
  return key;
}
async function verify(alg2, key, signature, data) {
  const cryptoKey = await getSigKey(alg2, key, "verify");
  checkKeyLength(alg2, cryptoKey);
  const algorithm2 = subtleAlgorithm(alg2, cryptoKey.algorithm);
  try {
    return await crypto.subtle.verify(algorithm2, cryptoKey, signature, data);
  } catch {
    return false;
  }
}
async function flattenedVerify(jws, key, options) {
  if (!isObject$1(jws)) {
    throw new JWSInvalid("Flattened JWS must be an object");
  }
  if (jws.protected === void 0 && jws.header === void 0) {
    throw new JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
  }
  if (jws.protected !== void 0 && typeof jws.protected !== "string") {
    throw new JWSInvalid("JWS Protected Header incorrect type");
  }
  if (jws.payload === void 0) {
    throw new JWSInvalid("JWS Payload missing");
  }
  if (typeof jws.signature !== "string") {
    throw new JWSInvalid("JWS Signature missing or incorrect type");
  }
  if (jws.header !== void 0 && !isObject$1(jws.header)) {
    throw new JWSInvalid("JWS Unprotected Header incorrect type");
  }
  let parsedProt = {};
  if (jws.protected) {
    try {
      const protectedHeader = decode(jws.protected);
      parsedProt = JSON.parse(decoder.decode(protectedHeader));
    } catch {
      throw new JWSInvalid("JWS Protected Header is invalid");
    }
  }
  if (!isDisjoint(parsedProt, jws.header)) {
    throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
  }
  const joseHeader = {
    ...parsedProt,
    ...jws.header
  };
  const extensions = validateCrit(JWSInvalid, /* @__PURE__ */ new Map([["b64", true]]), options?.crit, parsedProt, joseHeader);
  let b64 = true;
  if (extensions.has("b64")) {
    b64 = parsedProt.b64;
    if (typeof b64 !== "boolean") {
      throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
    }
  }
  const { alg: alg2 } = joseHeader;
  if (typeof alg2 !== "string" || !alg2) {
    throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
  }
  const algorithms = options && validateAlgorithms("algorithms", options.algorithms);
  if (algorithms && !algorithms.has(alg2)) {
    throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter value not allowed');
  }
  if (b64) {
    if (typeof jws.payload !== "string") {
      throw new JWSInvalid("JWS Payload must be a string");
    }
  } else if (typeof jws.payload !== "string" && !(jws.payload instanceof Uint8Array)) {
    throw new JWSInvalid("JWS Payload must be a string or an Uint8Array instance");
  }
  let resolvedKey = false;
  if (typeof key === "function") {
    key = await key(parsedProt, jws);
    resolvedKey = true;
  }
  checkKeyType(alg2, key, "verify");
  const data = concat(jws.protected !== void 0 ? encode$1(jws.protected) : new Uint8Array(), encode$1("."), typeof jws.payload === "string" ? b64 ? encode$1(jws.payload) : encoder$1.encode(jws.payload) : jws.payload);
  let signature;
  try {
    signature = decode(jws.signature);
  } catch {
    throw new JWSInvalid("Failed to base64url decode the signature");
  }
  const k = await normalizeKey(key, alg2);
  const verified = await verify(alg2, k, signature, data);
  if (!verified) {
    throw new JWSSignatureVerificationFailed();
  }
  let payload;
  if (b64) {
    try {
      payload = decode(jws.payload);
    } catch {
      throw new JWSInvalid("Failed to base64url decode the payload");
    }
  } else if (typeof jws.payload === "string") {
    payload = encoder$1.encode(jws.payload);
  } else {
    payload = jws.payload;
  }
  const result2 = { payload };
  if (jws.protected !== void 0) {
    result2.protectedHeader = parsedProt;
  }
  if (jws.header !== void 0) {
    result2.unprotectedHeader = jws.header;
  }
  if (resolvedKey) {
    return { ...result2, key: k };
  }
  return result2;
}
async function compactVerify(jws, key, options) {
  if (jws instanceof Uint8Array) {
    jws = decoder.decode(jws);
  }
  if (typeof jws !== "string") {
    throw new JWSInvalid("Compact JWS must be a string or Uint8Array");
  }
  const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split(".");
  if (length !== 3) {
    throw new JWSInvalid("Invalid Compact JWS");
  }
  const verified = await flattenedVerify({ payload, protected: protectedHeader, signature }, key, options);
  const result2 = { payload: verified.payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result2, key: verified.key };
  }
  return result2;
}
const epoch = (date2) => Math.floor(date2.getTime() / 1e3);
const minute = 60;
const hour = minute * 60;
const day = hour * 24;
const week = day * 7;
const year = day * 365.25;
const REGEX$1 = /^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i;
function secs(str) {
  const matched = REGEX$1.exec(str);
  if (!matched || matched[4] && matched[1]) {
    throw new TypeError("Invalid time period format");
  }
  const value = parseFloat(matched[2]);
  const unit = matched[3].toLowerCase();
  let numericDate;
  switch (unit) {
    case "sec":
    case "secs":
    case "second":
    case "seconds":
    case "s":
      numericDate = Math.round(value);
      break;
    case "minute":
    case "minutes":
    case "min":
    case "mins":
    case "m":
      numericDate = Math.round(value * minute);
      break;
    case "hour":
    case "hours":
    case "hr":
    case "hrs":
    case "h":
      numericDate = Math.round(value * hour);
      break;
    case "day":
    case "days":
    case "d":
      numericDate = Math.round(value * day);
      break;
    case "week":
    case "weeks":
    case "w":
      numericDate = Math.round(value * week);
      break;
    default:
      numericDate = Math.round(value * year);
      break;
  }
  if (matched[1] === "-" || matched[4] === "ago") {
    return -numericDate;
  }
  return numericDate;
}
function validateInput(label, input) {
  if (!Number.isFinite(input)) {
    throw new TypeError(`Invalid ${label} input`);
  }
  return input;
}
const normalizeTyp = (value) => {
  if (value.includes("/")) {
    return value.toLowerCase();
  }
  return `application/${value.toLowerCase()}`;
};
const checkAudiencePresence = (audPayload, audOption) => {
  if (typeof audPayload === "string") {
    return audOption.includes(audPayload);
  }
  if (Array.isArray(audPayload)) {
    return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
  }
  return false;
};
function validateClaimsSet(protectedHeader, encodedPayload, options = {}) {
  let payload;
  try {
    payload = JSON.parse(decoder.decode(encodedPayload));
  } catch {
  }
  if (!isObject$1(payload)) {
    throw new JWTInvalid("JWT Claims Set must be a top-level JSON object");
  }
  const { typ } = options;
  if (typ && (typeof protectedHeader.typ !== "string" || normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
    throw new JWTClaimValidationFailed('unexpected "typ" JWT header value', payload, "typ", "check_failed");
  }
  const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;
  const presenceCheck = [...requiredClaims];
  if (maxTokenAge !== void 0)
    presenceCheck.push("iat");
  if (audience !== void 0)
    presenceCheck.push("aud");
  if (subject !== void 0)
    presenceCheck.push("sub");
  if (issuer !== void 0)
    presenceCheck.push("iss");
  for (const claim of new Set(presenceCheck.reverse())) {
    if (!(claim in payload)) {
      throw new JWTClaimValidationFailed(`missing required "${claim}" claim`, payload, claim, "missing");
    }
  }
  if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {
    throw new JWTClaimValidationFailed('unexpected "iss" claim value', payload, "iss", "check_failed");
  }
  if (subject && payload.sub !== subject) {
    throw new JWTClaimValidationFailed('unexpected "sub" claim value', payload, "sub", "check_failed");
  }
  if (audience && !checkAudiencePresence(payload.aud, typeof audience === "string" ? [audience] : audience)) {
    throw new JWTClaimValidationFailed('unexpected "aud" claim value', payload, "aud", "check_failed");
  }
  let tolerance;
  switch (typeof options.clockTolerance) {
    case "string":
      tolerance = secs(options.clockTolerance);
      break;
    case "number":
      tolerance = options.clockTolerance;
      break;
    case "undefined":
      tolerance = 0;
      break;
    default:
      throw new TypeError("Invalid clockTolerance option type");
  }
  const { currentDate } = options;
  const now2 = epoch(currentDate || /* @__PURE__ */ new Date());
  if ((payload.iat !== void 0 || maxTokenAge) && typeof payload.iat !== "number") {
    throw new JWTClaimValidationFailed('"iat" claim must be a number', payload, "iat", "invalid");
  }
  if (payload.nbf !== void 0) {
    if (typeof payload.nbf !== "number") {
      throw new JWTClaimValidationFailed('"nbf" claim must be a number', payload, "nbf", "invalid");
    }
    if (payload.nbf > now2 + tolerance) {
      throw new JWTClaimValidationFailed('"nbf" claim timestamp check failed', payload, "nbf", "check_failed");
    }
  }
  if (payload.exp !== void 0) {
    if (typeof payload.exp !== "number") {
      throw new JWTClaimValidationFailed('"exp" claim must be a number', payload, "exp", "invalid");
    }
    if (payload.exp <= now2 - tolerance) {
      throw new JWTExpired('"exp" claim timestamp check failed', payload, "exp", "check_failed");
    }
  }
  if (maxTokenAge) {
    const age = now2 - payload.iat;
    const max2 = typeof maxTokenAge === "number" ? maxTokenAge : secs(maxTokenAge);
    if (age - tolerance > max2) {
      throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)', payload, "iat", "check_failed");
    }
    if (age < 0 - tolerance) {
      throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', payload, "iat", "check_failed");
    }
  }
  return payload;
}
class JWTClaimsBuilder {
  #payload;
  constructor(payload) {
    if (!isObject$1(payload)) {
      throw new TypeError("JWT Claims Set MUST be an object");
    }
    this.#payload = structuredClone(payload);
  }
  data() {
    return encoder$1.encode(JSON.stringify(this.#payload));
  }
  get iss() {
    return this.#payload.iss;
  }
  set iss(value) {
    this.#payload.iss = value;
  }
  get sub() {
    return this.#payload.sub;
  }
  set sub(value) {
    this.#payload.sub = value;
  }
  get aud() {
    return this.#payload.aud;
  }
  set aud(value) {
    this.#payload.aud = value;
  }
  set jti(value) {
    this.#payload.jti = value;
  }
  set nbf(value) {
    if (typeof value === "number") {
      this.#payload.nbf = validateInput("setNotBefore", value);
    } else if (value instanceof Date) {
      this.#payload.nbf = validateInput("setNotBefore", epoch(value));
    } else {
      this.#payload.nbf = epoch(/* @__PURE__ */ new Date()) + secs(value);
    }
  }
  set exp(value) {
    if (typeof value === "number") {
      this.#payload.exp = validateInput("setExpirationTime", value);
    } else if (value instanceof Date) {
      this.#payload.exp = validateInput("setExpirationTime", epoch(value));
    } else {
      this.#payload.exp = epoch(/* @__PURE__ */ new Date()) + secs(value);
    }
  }
  set iat(value) {
    if (value === void 0) {
      this.#payload.iat = epoch(/* @__PURE__ */ new Date());
    } else if (value instanceof Date) {
      this.#payload.iat = validateInput("setIssuedAt", epoch(value));
    } else if (typeof value === "string") {
      this.#payload.iat = validateInput("setIssuedAt", epoch(/* @__PURE__ */ new Date()) + secs(value));
    } else {
      this.#payload.iat = validateInput("setIssuedAt", value);
    }
  }
}
async function jwtVerify(jwt, key, options) {
  const verified = await compactVerify(jwt, key, options);
  if (verified.protectedHeader.crit?.includes("b64") && verified.protectedHeader.b64 === false) {
    throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
  }
  const payload = validateClaimsSet(verified.protectedHeader, verified.payload, options);
  const result2 = { payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result2, key: verified.key };
  }
  return result2;
}
async function jwtDecrypt(jwt, key, options) {
  const decrypted = await compactDecrypt(jwt, key, options);
  const payload = validateClaimsSet(decrypted.protectedHeader, decrypted.plaintext, options);
  const { protectedHeader } = decrypted;
  if (protectedHeader.iss !== void 0 && protectedHeader.iss !== payload.iss) {
    throw new JWTClaimValidationFailed('replicated "iss" claim header parameter mismatch', payload, "iss", "mismatch");
  }
  if (protectedHeader.sub !== void 0 && protectedHeader.sub !== payload.sub) {
    throw new JWTClaimValidationFailed('replicated "sub" claim header parameter mismatch', payload, "sub", "mismatch");
  }
  if (protectedHeader.aud !== void 0 && JSON.stringify(protectedHeader.aud) !== JSON.stringify(payload.aud)) {
    throw new JWTClaimValidationFailed('replicated "aud" claim header parameter mismatch', payload, "aud", "mismatch");
  }
  const result2 = { payload, protectedHeader };
  if (typeof key === "function") {
    return { ...result2, key: decrypted.key };
  }
  return result2;
}
class CompactEncrypt {
  #flattened;
  constructor(plaintext) {
    this.#flattened = new FlattenedEncrypt(plaintext);
  }
  setContentEncryptionKey(cek) {
    this.#flattened.setContentEncryptionKey(cek);
    return this;
  }
  setInitializationVector(iv) {
    this.#flattened.setInitializationVector(iv);
    return this;
  }
  setProtectedHeader(protectedHeader) {
    this.#flattened.setProtectedHeader(protectedHeader);
    return this;
  }
  setKeyManagementParameters(parameters) {
    this.#flattened.setKeyManagementParameters(parameters);
    return this;
  }
  async encrypt(key, options) {
    const jwe = await this.#flattened.encrypt(key, options);
    return [jwe.protected, jwe.encrypted_key, jwe.iv, jwe.ciphertext, jwe.tag].join(".");
  }
}
async function sign$1(alg2, key, data) {
  const cryptoKey = await getSigKey(alg2, key, "sign");
  checkKeyLength(alg2, cryptoKey);
  const signature = await crypto.subtle.sign(subtleAlgorithm(alg2, cryptoKey.algorithm), cryptoKey, data);
  return new Uint8Array(signature);
}
class FlattenedSign {
  #payload;
  #protectedHeader;
  #unprotectedHeader;
  constructor(payload) {
    if (!(payload instanceof Uint8Array)) {
      throw new TypeError("payload must be an instance of Uint8Array");
    }
    this.#payload = payload;
  }
  setProtectedHeader(protectedHeader) {
    if (this.#protectedHeader) {
      throw new TypeError("setProtectedHeader can only be called once");
    }
    this.#protectedHeader = protectedHeader;
    return this;
  }
  setUnprotectedHeader(unprotectedHeader) {
    if (this.#unprotectedHeader) {
      throw new TypeError("setUnprotectedHeader can only be called once");
    }
    this.#unprotectedHeader = unprotectedHeader;
    return this;
  }
  async sign(key, options) {
    if (!this.#protectedHeader && !this.#unprotectedHeader) {
      throw new JWSInvalid("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");
    }
    if (!isDisjoint(this.#protectedHeader, this.#unprotectedHeader)) {
      throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
    }
    const joseHeader = {
      ...this.#protectedHeader,
      ...this.#unprotectedHeader
    };
    const extensions = validateCrit(JWSInvalid, /* @__PURE__ */ new Map([["b64", true]]), options?.crit, this.#protectedHeader, joseHeader);
    let b64 = true;
    if (extensions.has("b64")) {
      b64 = this.#protectedHeader.b64;
      if (typeof b64 !== "boolean") {
        throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
      }
    }
    const { alg: alg2 } = joseHeader;
    if (typeof alg2 !== "string" || !alg2) {
      throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
    }
    checkKeyType(alg2, key, "sign");
    let payloadS;
    let payloadB;
    if (b64) {
      payloadS = encode(this.#payload);
      payloadB = encode$1(payloadS);
    } else {
      payloadB = this.#payload;
      payloadS = "";
    }
    let protectedHeaderString;
    let protectedHeaderBytes;
    if (this.#protectedHeader) {
      protectedHeaderString = encode(JSON.stringify(this.#protectedHeader));
      protectedHeaderBytes = encode$1(protectedHeaderString);
    } else {
      protectedHeaderString = "";
      protectedHeaderBytes = new Uint8Array();
    }
    const data = concat(protectedHeaderBytes, encode$1("."), payloadB);
    const k = await normalizeKey(key, alg2);
    const signature = await sign$1(alg2, k, data);
    const jws = {
      signature: encode(signature),
      payload: payloadS
    };
    if (this.#unprotectedHeader) {
      jws.header = this.#unprotectedHeader;
    }
    if (this.#protectedHeader) {
      jws.protected = protectedHeaderString;
    }
    return jws;
  }
}
class CompactSign {
  #flattened;
  constructor(payload) {
    this.#flattened = new FlattenedSign(payload);
  }
  setProtectedHeader(protectedHeader) {
    this.#flattened.setProtectedHeader(protectedHeader);
    return this;
  }
  async sign(key, options) {
    const jws = await this.#flattened.sign(key, options);
    if (jws.payload === void 0) {
      throw new TypeError("use the flattened module for creating JWS with b64: false");
    }
    return `${jws.protected}.${jws.payload}.${jws.signature}`;
  }
}
class SignJWT {
  #protectedHeader;
  #jwt;
  constructor(payload = {}) {
    this.#jwt = new JWTClaimsBuilder(payload);
  }
  setIssuer(issuer) {
    this.#jwt.iss = issuer;
    return this;
  }
  setSubject(subject) {
    this.#jwt.sub = subject;
    return this;
  }
  setAudience(audience) {
    this.#jwt.aud = audience;
    return this;
  }
  setJti(jwtId) {
    this.#jwt.jti = jwtId;
    return this;
  }
  setNotBefore(input) {
    this.#jwt.nbf = input;
    return this;
  }
  setExpirationTime(input) {
    this.#jwt.exp = input;
    return this;
  }
  setIssuedAt(input) {
    this.#jwt.iat = input;
    return this;
  }
  setProtectedHeader(protectedHeader) {
    this.#protectedHeader = protectedHeader;
    return this;
  }
  async sign(key, options) {
    const sig = new CompactSign(this.#jwt.data());
    sig.setProtectedHeader(this.#protectedHeader);
    if (Array.isArray(this.#protectedHeader?.crit) && this.#protectedHeader.crit.includes("b64") && this.#protectedHeader.b64 === false) {
      throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
    }
    return sig.sign(key, options);
  }
}
class EncryptJWT {
  #cek;
  #iv;
  #keyManagementParameters;
  #protectedHeader;
  #replicateIssuerAsHeader;
  #replicateSubjectAsHeader;
  #replicateAudienceAsHeader;
  #jwt;
  constructor(payload = {}) {
    this.#jwt = new JWTClaimsBuilder(payload);
  }
  setIssuer(issuer) {
    this.#jwt.iss = issuer;
    return this;
  }
  setSubject(subject) {
    this.#jwt.sub = subject;
    return this;
  }
  setAudience(audience) {
    this.#jwt.aud = audience;
    return this;
  }
  setJti(jwtId) {
    this.#jwt.jti = jwtId;
    return this;
  }
  setNotBefore(input) {
    this.#jwt.nbf = input;
    return this;
  }
  setExpirationTime(input) {
    this.#jwt.exp = input;
    return this;
  }
  setIssuedAt(input) {
    this.#jwt.iat = input;
    return this;
  }
  setProtectedHeader(protectedHeader) {
    if (this.#protectedHeader) {
      throw new TypeError("setProtectedHeader can only be called once");
    }
    this.#protectedHeader = protectedHeader;
    return this;
  }
  setKeyManagementParameters(parameters) {
    if (this.#keyManagementParameters) {
      throw new TypeError("setKeyManagementParameters can only be called once");
    }
    this.#keyManagementParameters = parameters;
    return this;
  }
  setContentEncryptionKey(cek) {
    if (this.#cek) {
      throw new TypeError("setContentEncryptionKey can only be called once");
    }
    this.#cek = cek;
    return this;
  }
  setInitializationVector(iv) {
    if (this.#iv) {
      throw new TypeError("setInitializationVector can only be called once");
    }
    this.#iv = iv;
    return this;
  }
  replicateIssuerAsHeader() {
    this.#replicateIssuerAsHeader = true;
    return this;
  }
  replicateSubjectAsHeader() {
    this.#replicateSubjectAsHeader = true;
    return this;
  }
  replicateAudienceAsHeader() {
    this.#replicateAudienceAsHeader = true;
    return this;
  }
  async encrypt(key, options) {
    const enc2 = new CompactEncrypt(this.#jwt.data());
    if (this.#protectedHeader && (this.#replicateIssuerAsHeader || this.#replicateSubjectAsHeader || this.#replicateAudienceAsHeader)) {
      this.#protectedHeader = {
        ...this.#protectedHeader,
        iss: this.#replicateIssuerAsHeader ? this.#jwt.iss : void 0,
        sub: this.#replicateSubjectAsHeader ? this.#jwt.sub : void 0,
        aud: this.#replicateAudienceAsHeader ? this.#jwt.aud : void 0
      };
    }
    enc2.setProtectedHeader(this.#protectedHeader);
    if (this.#iv) {
      enc2.setInitializationVector(this.#iv);
    }
    if (this.#cek) {
      enc2.setContentEncryptionKey(this.#cek);
    }
    if (this.#keyManagementParameters) {
      enc2.setKeyManagementParameters(this.#keyManagementParameters);
    }
    return enc2.encrypt(key, options);
  }
}
const check = (value, description) => {
  if (typeof value !== "string" || !value) {
    throw new JWKInvalid(`${description} missing or invalid`);
  }
};
async function calculateJwkThumbprint(key, digestAlgorithm) {
  let jwk;
  if (isJWK(key)) {
    jwk = key;
  } else if (isKeyLike(key)) {
    jwk = await exportJWK(key);
  } else {
    throw new TypeError(invalidKeyInput(key, "CryptoKey", "KeyObject", "JSON Web Key"));
  }
  digestAlgorithm ??= "sha256";
  if (digestAlgorithm !== "sha256" && digestAlgorithm !== "sha384" && digestAlgorithm !== "sha512") {
    throw new TypeError('digestAlgorithm must one of "sha256", "sha384", or "sha512"');
  }
  let components;
  switch (jwk.kty) {
    case "AKP":
      check(jwk.alg, '"alg" (Algorithm) Parameter');
      check(jwk.pub, '"pub" (Public key) Parameter');
      components = { alg: jwk.alg, kty: jwk.kty, pub: jwk.pub };
      break;
    case "EC":
      check(jwk.crv, '"crv" (Curve) Parameter');
      check(jwk.x, '"x" (X Coordinate) Parameter');
      check(jwk.y, '"y" (Y Coordinate) Parameter');
      components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x, y: jwk.y };
      break;
    case "OKP":
      check(jwk.crv, '"crv" (Subtype of Key Pair) Parameter');
      check(jwk.x, '"x" (Public Key) Parameter');
      components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x };
      break;
    case "RSA":
      check(jwk.e, '"e" (Exponent) Parameter');
      check(jwk.n, '"n" (Modulus) Parameter');
      components = { e: jwk.e, kty: jwk.kty, n: jwk.n };
      break;
    case "oct":
      check(jwk.k, '"k" (Key Value) Parameter');
      components = { k: jwk.k, kty: jwk.kty };
      break;
    default:
      throw new JOSENotSupported('"kty" (Key Type) Parameter missing or unsupported');
  }
  const data = encode$1(JSON.stringify(components));
  return encode(await digest(digestAlgorithm, data));
}
function getKtyFromAlg(alg2) {
  switch (typeof alg2 === "string" && alg2.slice(0, 2)) {
    case "RS":
    case "PS":
      return "RSA";
    case "ES":
      return "EC";
    case "Ed":
      return "OKP";
    case "ML":
      return "AKP";
    default:
      throw new JOSENotSupported('Unsupported "alg" value for a JSON Web Key Set');
  }
}
function isJWKSLike(jwks) {
  return jwks && typeof jwks === "object" && Array.isArray(jwks.keys) && jwks.keys.every(isJWKLike);
}
function isJWKLike(key) {
  return isObject$1(key);
}
class LocalJWKSet {
  #jwks;
  #cached = /* @__PURE__ */ new WeakMap();
  constructor(jwks) {
    if (!isJWKSLike(jwks)) {
      throw new JWKSInvalid("JSON Web Key Set malformed");
    }
    this.#jwks = structuredClone(jwks);
  }
  jwks() {
    return this.#jwks;
  }
  async getKey(protectedHeader, token2) {
    const { alg: alg2, kid } = { ...protectedHeader, ...token2?.header };
    const kty = getKtyFromAlg(alg2);
    const candidates = this.#jwks.keys.filter((jwk2) => {
      let candidate = kty === jwk2.kty;
      if (candidate && typeof kid === "string") {
        candidate = kid === jwk2.kid;
      }
      if (candidate && (typeof jwk2.alg === "string" || kty === "AKP")) {
        candidate = alg2 === jwk2.alg;
      }
      if (candidate && typeof jwk2.use === "string") {
        candidate = jwk2.use === "sig";
      }
      if (candidate && Array.isArray(jwk2.key_ops)) {
        candidate = jwk2.key_ops.includes("verify");
      }
      if (candidate) {
        switch (alg2) {
          case "ES256":
            candidate = jwk2.crv === "P-256";
            break;
          case "ES384":
            candidate = jwk2.crv === "P-384";
            break;
          case "ES512":
            candidate = jwk2.crv === "P-521";
            break;
          case "Ed25519":
          case "EdDSA":
            candidate = jwk2.crv === "Ed25519";
            break;
        }
      }
      return candidate;
    });
    const { 0: jwk, length } = candidates;
    if (length === 0) {
      throw new JWKSNoMatchingKey();
    }
    if (length !== 1) {
      const error2 = new JWKSMultipleMatchingKeys();
      const _cached = this.#cached;
      error2[Symbol.asyncIterator] = async function* () {
        for (const jwk2 of candidates) {
          try {
            yield await importWithAlgCache(_cached, jwk2, alg2);
          } catch {
          }
        }
      };
      throw error2;
    }
    return importWithAlgCache(this.#cached, jwk, alg2);
  }
}
async function importWithAlgCache(cache2, jwk, alg2) {
  const cached = cache2.get(jwk) || cache2.set(jwk, {}).get(jwk);
  if (cached[alg2] === void 0) {
    const key = await importJWK({ ...jwk, ext: true }, alg2);
    if (key instanceof Uint8Array || key.type !== "public") {
      throw new JWKSInvalid("JSON Web Key Set members must be public keys");
    }
    cached[alg2] = key;
  }
  return cached[alg2];
}
function createLocalJWKSet(jwks) {
  const set = new LocalJWKSet(jwks);
  const localJWKSet = async (protectedHeader, token2) => set.getKey(protectedHeader, token2);
  Object.defineProperties(localJWKSet, {
    jwks: {
      value: () => structuredClone(set.jwks()),
      enumerable: false,
      configurable: false,
      writable: false
    }
  });
  return localJWKSet;
}
function isCloudflareWorkers() {
  return typeof WebSocketPair !== "undefined" || typeof navigator !== "undefined" && navigator.userAgent === "Cloudflare-Workers" || typeof EdgeRuntime !== "undefined" && EdgeRuntime === "vercel";
}
let USER_AGENT;
if (typeof navigator === "undefined" || !navigator.userAgent?.startsWith?.("Mozilla/5.0 ")) {
  const NAME = "jose";
  const VERSION2 = "v6.1.3";
  USER_AGENT = `${NAME}/${VERSION2}`;
}
const customFetch = /* @__PURE__ */ Symbol();
async function fetchJwks(url, headers, signal, fetchImpl = fetch) {
  const response = await fetchImpl(url, {
    method: "GET",
    signal,
    redirect: "manual",
    headers
  }).catch((err2) => {
    if (err2.name === "TimeoutError") {
      throw new JWKSTimeout();
    }
    throw err2;
  });
  if (response.status !== 200) {
    throw new JOSEError("Expected 200 OK from the JSON Web Key Set HTTP response");
  }
  try {
    return await response.json();
  } catch {
    throw new JOSEError("Failed to parse the JSON Web Key Set HTTP response as JSON");
  }
}
const jwksCache = /* @__PURE__ */ Symbol();
function isFreshJwksCache(input, cacheMaxAge) {
  if (typeof input !== "object" || input === null) {
    return false;
  }
  if (!("uat" in input) || typeof input.uat !== "number" || Date.now() - input.uat >= cacheMaxAge) {
    return false;
  }
  if (!("jwks" in input) || !isObject$1(input.jwks) || !Array.isArray(input.jwks.keys) || !Array.prototype.every.call(input.jwks.keys, isObject$1)) {
    return false;
  }
  return true;
}
class RemoteJWKSet {
  #url;
  #timeoutDuration;
  #cooldownDuration;
  #cacheMaxAge;
  #jwksTimestamp;
  #pendingFetch;
  #headers;
  #customFetch;
  #local;
  #cache;
  constructor(url, options) {
    if (!(url instanceof URL)) {
      throw new TypeError("url must be an instance of URL");
    }
    this.#url = new URL(url.href);
    this.#timeoutDuration = typeof options?.timeoutDuration === "number" ? options?.timeoutDuration : 5e3;
    this.#cooldownDuration = typeof options?.cooldownDuration === "number" ? options?.cooldownDuration : 3e4;
    this.#cacheMaxAge = typeof options?.cacheMaxAge === "number" ? options?.cacheMaxAge : 6e5;
    this.#headers = new Headers(options?.headers);
    if (USER_AGENT && !this.#headers.has("User-Agent")) {
      this.#headers.set("User-Agent", USER_AGENT);
    }
    if (!this.#headers.has("accept")) {
      this.#headers.set("accept", "application/json");
      this.#headers.append("accept", "application/jwk-set+json");
    }
    this.#customFetch = options?.[customFetch];
    if (options?.[jwksCache] !== void 0) {
      this.#cache = options?.[jwksCache];
      if (isFreshJwksCache(options?.[jwksCache], this.#cacheMaxAge)) {
        this.#jwksTimestamp = this.#cache.uat;
        this.#local = createLocalJWKSet(this.#cache.jwks);
      }
    }
  }
  pendingFetch() {
    return !!this.#pendingFetch;
  }
  coolingDown() {
    return typeof this.#jwksTimestamp === "number" ? Date.now() < this.#jwksTimestamp + this.#cooldownDuration : false;
  }
  fresh() {
    return typeof this.#jwksTimestamp === "number" ? Date.now() < this.#jwksTimestamp + this.#cacheMaxAge : false;
  }
  jwks() {
    return this.#local?.jwks();
  }
  async getKey(protectedHeader, token2) {
    if (!this.#local || !this.fresh()) {
      await this.reload();
    }
    try {
      return await this.#local(protectedHeader, token2);
    } catch (err2) {
      if (err2 instanceof JWKSNoMatchingKey) {
        if (this.coolingDown() === false) {
          await this.reload();
          return this.#local(protectedHeader, token2);
        }
      }
      throw err2;
    }
  }
  async reload() {
    if (this.#pendingFetch && isCloudflareWorkers()) {
      this.#pendingFetch = void 0;
    }
    this.#pendingFetch ||= fetchJwks(this.#url.href, this.#headers, AbortSignal.timeout(this.#timeoutDuration), this.#customFetch).then((json2) => {
      this.#local = createLocalJWKSet(json2);
      if (this.#cache) {
        this.#cache.uat = Date.now();
        this.#cache.jwks = json2;
      }
      this.#jwksTimestamp = Date.now();
      this.#pendingFetch = void 0;
    }).catch((err2) => {
      this.#pendingFetch = void 0;
      throw err2;
    });
    await this.#pendingFetch;
  }
}
function createRemoteJWKSet(url, options) {
  const set = new RemoteJWKSet(url, options);
  const remoteJWKSet = async (protectedHeader, token2) => set.getKey(protectedHeader, token2);
  Object.defineProperties(remoteJWKSet, {
    coolingDown: {
      get: () => set.coolingDown(),
      enumerable: true,
      configurable: false
    },
    fresh: {
      get: () => set.fresh(),
      enumerable: true,
      configurable: false
    },
    reload: {
      value: () => set.reload(),
      enumerable: true,
      configurable: false,
      writable: false
    },
    reloading: {
      get: () => set.pendingFetch(),
      enumerable: true,
      configurable: false
    },
    jwks: {
      value: () => set.jwks(),
      enumerable: true,
      configurable: false,
      writable: false
    }
  });
  return remoteJWKSet;
}
function decodeProtectedHeader(token2) {
  let protectedB64u;
  if (typeof token2 === "string") {
    const parts = token2.split(".");
    if (parts.length === 3 || parts.length === 5) {
      [protectedB64u] = parts;
    }
  } else if (typeof token2 === "object" && token2) {
    if ("protected" in token2) {
      protectedB64u = token2.protected;
    } else {
      throw new TypeError("Token does not contain a Protected Header");
    }
  }
  try {
    if (typeof protectedB64u !== "string" || !protectedB64u) {
      throw new Error();
    }
    const result2 = JSON.parse(decoder.decode(decode(protectedB64u)));
    if (!isObject$1(result2)) {
      throw new Error();
    }
    return result2;
  } catch {
    throw new TypeError("Invalid Token or Protected Header formatting");
  }
}
function decodeJwt(jwt) {
  if (typeof jwt !== "string")
    throw new JWTInvalid("JWTs must use Compact JWS serialization, JWT must be a string");
  const { 1: payload, length } = jwt.split(".");
  if (length === 5)
    throw new JWTInvalid("Only JWTs using Compact JWS serialization can be decoded");
  if (length !== 3)
    throw new JWTInvalid("Invalid JWT");
  if (!payload)
    throw new JWTInvalid("JWTs must contain a payload");
  let decoded;
  try {
    decoded = decode(payload);
  } catch {
    throw new JWTInvalid("Failed to base64url decode the payload");
  }
  let result2;
  try {
    result2 = JSON.parse(decoder.decode(decoded));
  } catch {
    throw new JWTInvalid("Failed to parse the decoded payload as JSON");
  }
  if (!isObject$1(result2))
    throw new JWTInvalid("Invalid JWT Claims Set");
  return result2;
}
async function signJWT(payload, secret, expiresIn = 3600) {
  return await new SignJWT(payload).setProtectedHeader({ alg: "HS256" }).setIssuedAt().setExpirationTime(Math.floor(Date.now() / 1e3) + expiresIn).sign(new TextEncoder().encode(secret));
}
async function verifyJWT(token2, secret) {
  try {
    return (await jwtVerify(token2, new TextEncoder().encode(secret))).payload;
  } catch {
    return null;
  }
}
const info = new Uint8Array([
  66,
  101,
  116,
  116,
  101,
  114,
  65,
  117,
  116,
  104,
  46,
  106,
  115,
  32,
  71,
  101,
  110,
  101,
  114,
  97,
  116,
  101,
  100,
  32,
  69,
  110,
  99,
  114,
  121,
  112,
  116,
  105,
  111,
  110,
  32,
  75,
  101,
  121
]);
const now$1 = () => Date.now() / 1e3 | 0;
const alg = "dir";
const enc = "A256CBC-HS512";
async function symmetricEncodeJWT(payload, secret, salt, expiresIn = 3600) {
  const encryptionSecret = hkdf(sha256, new TextEncoder().encode(secret), new TextEncoder().encode(salt), info, 64);
  const thumbprint = await calculateJwkThumbprint({
    kty: "oct",
    k: encode(encryptionSecret)
  }, "sha256");
  return await new EncryptJWT(payload).setProtectedHeader({
    alg,
    enc,
    kid: thumbprint
  }).setIssuedAt().setExpirationTime(now$1() + expiresIn).setJti(crypto.randomUUID()).encrypt(encryptionSecret);
}
async function symmetricDecodeJWT(token2, secret, salt) {
  if (!token2) return null;
  try {
    const { payload } = await jwtDecrypt(token2, async ({ kid }) => {
      const encryptionSecret = hkdf(sha256, new TextEncoder().encode(secret), new TextEncoder().encode(salt), info, 64);
      if (kid === void 0) return encryptionSecret;
      if (kid === await calculateJwkThumbprint({
        kty: "oct",
        k: encode(encryptionSecret)
      }, "sha256")) return encryptionSecret;
      throw new Error("no matching decryption secret");
    }, {
      clockTolerance: 15,
      keyManagementAlgorithms: [alg],
      contentEncryptionAlgorithms: [enc, "A256GCM"]
    });
    return payload;
  } catch {
    return null;
  }
}
function defineErrorCodes(codes) {
  return codes;
}
function filterOutputFields(data, additionalFields) {
  if (!data || !additionalFields) return data;
  const returnFiltered = Object.entries(additionalFields).filter(([, { returned }]) => returned === false).map(([key]) => key);
  return Object.entries(structuredClone(data)).filter(([key]) => !returnFiltered.includes(key)).reduce((acc, [key, value]) => ({
    ...acc,
    [key]: value
  }), {});
}
function deprecate(fn2, message2, logger2) {
  let warned = false;
  return function(...args) {
    if (!warned) {
      (logger2?.warn ?? console.warn)(`[Deprecation] ${message2}`);
      warned = true;
    }
    return fn2.apply(this, args);
  };
}
const generateId$1 = (size) => {
  return createRandomStringGenerator("a-z", "A-Z", "0-9")(size || 32);
};
function isValidIP(ip) {
  return z.ipv4().safeParse(ip).success || z.ipv6().safeParse(ip).success;
}
function isIPv6(ip) {
  return z.ipv6().safeParse(ip).success;
}
function extractIPv4FromMapped(ipv6) {
  const lower = ipv6.toLowerCase();
  if (lower.startsWith("::ffff:")) {
    const ipv4Part = lower.substring(7);
    if (z.ipv4().safeParse(ipv4Part).success) return ipv4Part;
  }
  const parts = ipv6.split(":");
  if (parts.length === 7 && parts[5]?.toLowerCase() === "ffff") {
    const ipv4Part = parts[6];
    if (ipv4Part && z.ipv4().safeParse(ipv4Part).success) return ipv4Part;
  }
  if (lower.includes("::ffff:") || lower.includes(":ffff:")) {
    const groups = expandIPv6(ipv6);
    if (groups.length === 8 && groups[0] === "0000" && groups[1] === "0000" && groups[2] === "0000" && groups[3] === "0000" && groups[4] === "0000" && groups[5] === "ffff" && groups[6] && groups[7]) return `${Number.parseInt(groups[6].substring(0, 2), 16)}.${Number.parseInt(groups[6].substring(2, 4), 16)}.${Number.parseInt(groups[7].substring(0, 2), 16)}.${Number.parseInt(groups[7].substring(2, 4), 16)}`;
  }
  return null;
}
function expandIPv6(ipv6) {
  if (ipv6.includes("::")) {
    const sides = ipv6.split("::");
    const left2 = sides[0] ? sides[0].split(":") : [];
    const right2 = sides[1] ? sides[1].split(":") : [];
    const missingGroups = 8 - left2.length - right2.length;
    const zeros = Array(missingGroups).fill("0000");
    const paddedLeft = left2.map((g) => g.padStart(4, "0"));
    const paddedRight = right2.map((g) => g.padStart(4, "0"));
    return [
      ...paddedLeft,
      ...zeros,
      ...paddedRight
    ];
  }
  return ipv6.split(":").map((g) => g.padStart(4, "0"));
}
function normalizeIPv6(ipv6, subnetPrefix) {
  const groups = expandIPv6(ipv6);
  if (subnetPrefix < 128) {
    let bitsRemaining = subnetPrefix;
    return groups.map((group) => {
      if (bitsRemaining <= 0) return "0000";
      if (bitsRemaining >= 16) {
        bitsRemaining -= 16;
        return group;
      }
      const masked = Number.parseInt(group, 16) & (65535 << 16 - bitsRemaining & 65535);
      bitsRemaining = 0;
      return masked.toString(16).padStart(4, "0");
    }).join(":").toLowerCase();
  }
  return groups.join(":").toLowerCase();
}
function normalizeIP(ip, options = {}) {
  if (z.ipv4().safeParse(ip).success) return ip.toLowerCase();
  if (!isIPv6(ip)) return ip.toLowerCase();
  const ipv4 = extractIPv4FromMapped(ip);
  if (ipv4) return ipv4.toLowerCase();
  return normalizeIPv6(ip, options.ipv6Subnet || 64);
}
function createRateLimitKey(ip, path) {
  return `${ip}|${path}`;
}
const _envShim = /* @__PURE__ */ Object.create(null);
const _getEnv = (useShim) => globalThis.process?.env || globalThis.Deno?.env.toObject() || globalThis.__env__ || (useShim ? _envShim : globalThis);
const env = new Proxy(_envShim, {
  get(_, prop) {
    return _getEnv()[prop] ?? _envShim[prop];
  },
  has(_, prop) {
    return prop in _getEnv() || prop in _envShim;
  },
  set(_, prop, value) {
    const env$1 = _getEnv(true);
    env$1[prop] = value;
    return true;
  },
  deleteProperty(_, prop) {
    if (!prop) return false;
    const env$1 = _getEnv(true);
    delete env$1[prop];
    return true;
  },
  ownKeys() {
    const env$1 = _getEnv(true);
    return Object.keys(env$1);
  }
});
function toBoolean(val) {
  return val ? val !== "false" : false;
}
const nodeENV = typeof process !== "undefined" && process.env && process.env.NODE_ENV || "";
const isProduction = nodeENV === "production";
const isDevelopment = () => nodeENV === "dev" || nodeENV === "development";
const isTest = () => nodeENV === "test" || toBoolean(env.TEST);
function getEnvVar(key, fallback) {
  if (typeof process !== "undefined" && process.env) return process.env[key] ?? fallback;
  if (typeof Deno !== "undefined") return Deno.env.get(key) ?? fallback;
  if (typeof Bun !== "undefined") return Bun.env[key] ?? fallback;
  return fallback;
}
function getBooleanEnvVar(key, fallback = true) {
  const value = getEnvVar(key);
  if (!value) return fallback;
  return value !== "0" && value.toLowerCase() !== "false" && value !== "";
}
const ENV = Object.freeze({
  get BETTER_AUTH_SECRET() {
    return getEnvVar("BETTER_AUTH_SECRET");
  },
  get AUTH_SECRET() {
    return getEnvVar("AUTH_SECRET");
  },
  get BETTER_AUTH_TELEMETRY() {
    return getEnvVar("BETTER_AUTH_TELEMETRY");
  },
  get BETTER_AUTH_TELEMETRY_ID() {
    return getEnvVar("BETTER_AUTH_TELEMETRY_ID");
  },
  get NODE_ENV() {
    return getEnvVar("NODE_ENV", "development");
  },
  get PACKAGE_VERSION() {
    return getEnvVar("PACKAGE_VERSION", "0.0.0");
  },
  get BETTER_AUTH_TELEMETRY_ENDPOINT() {
    return getEnvVar("BETTER_AUTH_TELEMETRY_ENDPOINT", "");
  }
});
const COLORS_2 = 1;
const COLORS_16 = 4;
const COLORS_256 = 8;
const COLORS_16m = 24;
const TERM_ENVS = {
  eterm: COLORS_16,
  cons25: COLORS_16,
  console: COLORS_16,
  cygwin: COLORS_16,
  dtterm: COLORS_16,
  gnome: COLORS_16,
  hurd: COLORS_16,
  jfbterm: COLORS_16,
  konsole: COLORS_16,
  kterm: COLORS_16,
  mlterm: COLORS_16,
  mosh: COLORS_16m,
  putty: COLORS_16,
  st: COLORS_16,
  "rxvt-unicode-24bit": COLORS_16m,
  terminator: COLORS_16m,
  "xterm-kitty": COLORS_16m
};
const CI_ENVS_MAP = new Map(Object.entries({
  APPVEYOR: COLORS_256,
  BUILDKITE: COLORS_256,
  CIRCLECI: COLORS_16m,
  DRONE: COLORS_256,
  GITEA_ACTIONS: COLORS_16m,
  GITHUB_ACTIONS: COLORS_16m,
  GITLAB_CI: COLORS_256,
  TRAVIS: COLORS_256
}));
const TERM_ENVS_REG_EXP = [
  /ansi/,
  /color/,
  /linux/,
  /direct/,
  /^con[0-9]*x[0-9]/,
  /^rxvt/,
  /^screen/,
  /^xterm/,
  /^vt100/,
  /^vt220/
];
function getColorDepth() {
  if (getEnvVar("FORCE_COLOR") !== void 0) switch (getEnvVar("FORCE_COLOR")) {
    case "":
    case "1":
    case "true":
      return COLORS_16;
    case "2":
      return COLORS_256;
    case "3":
      return COLORS_16m;
    default:
      return COLORS_2;
  }
  if (getEnvVar("NODE_DISABLE_COLORS") !== void 0 && getEnvVar("NODE_DISABLE_COLORS") !== "" || getEnvVar("NO_COLOR") !== void 0 && getEnvVar("NO_COLOR") !== "" || getEnvVar("TERM") === "dumb") return COLORS_2;
  if (getEnvVar("TMUX")) return COLORS_16m;
  if ("TF_BUILD" in env && "AGENT_NAME" in env) return COLORS_16;
  if ("CI" in env) {
    for (const { 0: envName, 1: colors } of CI_ENVS_MAP) if (envName in env) return colors;
    if (getEnvVar("CI_NAME") === "codeship") return COLORS_256;
    return COLORS_2;
  }
  if ("TEAMCITY_VERSION" in env) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.exec(getEnvVar("TEAMCITY_VERSION")) !== null ? COLORS_16 : COLORS_2;
  switch (getEnvVar("TERM_PROGRAM")) {
    case "iTerm.app":
      if (!getEnvVar("TERM_PROGRAM_VERSION") || /^[0-2]\./.exec(getEnvVar("TERM_PROGRAM_VERSION")) !== null) return COLORS_256;
      return COLORS_16m;
    case "HyperTerm":
    case "MacTerm":
      return COLORS_16m;
    case "Apple_Terminal":
      return COLORS_256;
  }
  if (getEnvVar("COLORTERM") === "truecolor" || getEnvVar("COLORTERM") === "24bit") return COLORS_16m;
  if (getEnvVar("TERM")) {
    if (/truecolor/.exec(getEnvVar("TERM")) !== null) return COLORS_16m;
    if (/^xterm-256/.exec(getEnvVar("TERM")) !== null) return COLORS_256;
    const termEnv = getEnvVar("TERM").toLowerCase();
    if (TERM_ENVS[termEnv]) return TERM_ENVS[termEnv];
    if (TERM_ENVS_REG_EXP.some((term) => term.exec(termEnv) !== null)) return COLORS_16;
  }
  if (getEnvVar("COLORTERM")) return COLORS_16;
  return COLORS_2;
}
const TTY_COLORS = {
  reset: "\x1B[0m",
  bright: "\x1B[1m",
  dim: "\x1B[2m",
  fg: {
    red: "\x1B[31m",
    green: "\x1B[32m",
    yellow: "\x1B[33m",
    blue: "\x1B[34m",
    magenta: "\x1B[35m"
  },
  bg: {
    black: "\x1B[40m"
  }
};
const levels$1 = [
  "debug",
  "info",
  "success",
  "warn",
  "error"
];
function shouldPublishLog(currentLogLevel, logLevel) {
  return levels$1.indexOf(logLevel) >= levels$1.indexOf(currentLogLevel);
}
const levelColors = {
  info: TTY_COLORS.fg.blue,
  success: TTY_COLORS.fg.green,
  warn: TTY_COLORS.fg.yellow,
  error: TTY_COLORS.fg.red,
  debug: TTY_COLORS.fg.magenta
};
const formatMessage = (level, message2, colorsEnabled) => {
  const timestamp2 = (/* @__PURE__ */ new Date()).toISOString();
  if (colorsEnabled) return `${TTY_COLORS.dim}${timestamp2}${TTY_COLORS.reset} ${levelColors[level]}${level.toUpperCase()}${TTY_COLORS.reset} ${TTY_COLORS.bright}[Better Auth]:${TTY_COLORS.reset} ${message2}`;
  return `${timestamp2} ${level.toUpperCase()} [Better Auth]: ${message2}`;
};
const createLogger = (options) => {
  const enabled = options?.disabled !== true;
  const logLevel = options?.level ?? "warn";
  const colorsEnabled = options?.disableColors !== void 0 ? !options.disableColors : getColorDepth() !== 1;
  const LogFunc = (level, message2, args = []) => {
    if (!enabled || !shouldPublishLog(logLevel, level)) return;
    const formattedMessage = formatMessage(level, message2, colorsEnabled);
    if (!options || typeof options.log !== "function") {
      if (level === "error") console.error(formattedMessage, ...args);
      else if (level === "warn") console.warn(formattedMessage, ...args);
      else console.log(formattedMessage, ...args);
      return;
    }
    options.log(level === "success" ? "info" : level, message2, ...args);
  };
  return {
    ...Object.fromEntries(levels$1.map((level) => [level, (...[message2, ...args]) => LogFunc(level, message2, args)])),
    get level() {
      return logLevel;
    }
  };
};
const logger = createLogger();
function safeJSONParse(data) {
  function reviver(_, value) {
    if (typeof value === "string") {
      if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d+)?Z$/.test(value)) {
        const date2 = new Date(value);
        if (!isNaN(date2.getTime())) return date2;
      }
    }
    return value;
  }
  try {
    if (typeof data !== "string") return data;
    return JSON.parse(data, reviver);
  } catch (e2) {
    logger.error("Error parsing JSON", { error: e2 });
    return null;
  }
}
function normalizePathname(requestUrl, basePath) {
  let pathname;
  try {
    pathname = new URL(requestUrl).pathname.replace(/\/+$/, "") || "/";
  } catch {
    return "/";
  }
  if (basePath === "/" || basePath === "") return pathname;
  if (pathname === basePath) return "/";
  if (pathname.startsWith(basePath + "/")) return pathname.slice(basePath.length).replace(/\/+$/, "") || "/";
  return pathname;
}
const BASE_ERROR_CODES = defineErrorCodes({
  USER_NOT_FOUND: "User not found",
  FAILED_TO_CREATE_USER: "Failed to create user",
  FAILED_TO_CREATE_SESSION: "Failed to create session",
  FAILED_TO_UPDATE_USER: "Failed to update user",
  FAILED_TO_GET_SESSION: "Failed to get session",
  INVALID_PASSWORD: "Invalid password",
  INVALID_EMAIL: "Invalid email",
  INVALID_EMAIL_OR_PASSWORD: "Invalid email or password",
  SOCIAL_ACCOUNT_ALREADY_LINKED: "Social account already linked",
  PROVIDER_NOT_FOUND: "Provider not found",
  INVALID_TOKEN: "Invalid token",
  ID_TOKEN_NOT_SUPPORTED: "id_token not supported",
  FAILED_TO_GET_USER_INFO: "Failed to get user info",
  USER_EMAIL_NOT_FOUND: "User email not found",
  EMAIL_NOT_VERIFIED: "Email not verified",
  PASSWORD_TOO_SHORT: "Password too short",
  PASSWORD_TOO_LONG: "Password too long",
  USER_ALREADY_EXISTS: "User already exists.",
  USER_ALREADY_EXISTS_USE_ANOTHER_EMAIL: "User already exists. Use another email.",
  EMAIL_CAN_NOT_BE_UPDATED: "Email can not be updated",
  CREDENTIAL_ACCOUNT_NOT_FOUND: "Credential account not found",
  SESSION_EXPIRED: "Session expired. Re-authenticate to perform this action.",
  FAILED_TO_UNLINK_LAST_ACCOUNT: "You can't unlink your last account",
  ACCOUNT_NOT_FOUND: "Account not found",
  USER_ALREADY_HAS_PASSWORD: "User already has a password. Provide that to delete the account.",
  CROSS_SITE_NAVIGATION_LOGIN_BLOCKED: "Cross-site navigation login blocked. This request appears to be a CSRF attack.",
  VERIFICATION_EMAIL_NOT_ENABLED: "Verification email isn't enabled",
  EMAIL_ALREADY_VERIFIED: "Email is already verified",
  EMAIL_MISMATCH: "Email mismatch",
  SESSION_NOT_FRESH: "Session is not fresh",
  LINKED_ACCOUNT_ALREADY_EXISTS: "Linked account already exists",
  INVALID_ORIGIN: "Invalid origin",
  INVALID_CALLBACK_URL: "Invalid callbackURL",
  INVALID_REDIRECT_URL: "Invalid redirectURL",
  INVALID_ERROR_CALLBACK_URL: "Invalid errorCallbackURL",
  INVALID_NEW_USER_CALLBACK_URL: "Invalid newUserCallbackURL",
  MISSING_OR_NULL_ORIGIN: "Missing or null Origin",
  CALLBACK_URL_REQUIRED: "callbackURL is required",
  FAILED_TO_CREATE_VERIFICATION: "Unable to create verification",
  FIELD_NOT_ALLOWED: "Field not allowed to be set",
  ASYNC_VALIDATION_NOT_SUPPORTED: "Async validation is not supported",
  VALIDATION_ERROR: "Validation Error",
  MISSING_FIELD: "Field is required"
});
var BetterAuthError = class extends Error {
  constructor(message2, options) {
    super(message2, options);
    this.name = "BetterAuthError";
    this.message = message2;
    this.stack = "";
  }
};
const hexadecimal = "0123456789abcdef";
const hex = {
  encode: (data) => {
    if (typeof data === "string") {
      data = new TextEncoder().encode(data);
    }
    if (data.byteLength === 0) {
      return "";
    }
    const buffer = new Uint8Array(data);
    let result2 = "";
    for (const byte of buffer) {
      result2 += byte.toString(16).padStart(2, "0");
    }
    return result2;
  },
  decode: (data) => {
    if (!data) {
      return "";
    }
    if (typeof data === "string") {
      if (data.length % 2 !== 0) {
        throw new Error("Invalid hexadecimal string");
      }
      if (!new RegExp(`^[${hexadecimal}]+$`).test(data)) {
        throw new Error("Invalid hexadecimal string");
      }
      const result2 = new Uint8Array(data.length / 2);
      for (let i = 0; i < data.length; i += 2) {
        result2[i / 2] = parseInt(data.slice(i, i + 2), 16);
      }
      return new TextDecoder().decode(result2);
    }
    return new TextDecoder().decode(data);
  }
};
function pbkdf2Init(hash, _password, _salt, _opts) {
  ahash(hash);
  const opts = checkOpts$1({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c: c2, dkLen, asyncTick } = opts;
  anumber$1(c2, "c");
  anumber$1(dkLen, "dkLen");
  anumber$1(asyncTick, "asyncTick");
  if (c2 < 1)
    throw new Error("iterations (c) must be >= 1");
  const password = kdfInputToBytes(_password, "password");
  const salt = kdfInputToBytes(_salt, "salt");
  const DK = new Uint8Array(dkLen);
  const PRF = hmac.create(hash, password);
  const PRFSalt = PRF._cloneInto().update(salt);
  return { c: c2, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  clean$1(u);
  return DK;
}
function pbkdf2(hash, password, salt, opts) {
  const { c: c2, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView$1(arr);
  const u = new Uint8Array(PRF.outputLen);
  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
    const Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
    Ti.set(u.subarray(0, Ti.length));
    for (let ui = 1; ui < c2; ui++) {
      PRF._cloneInto(prfW).update(u).digestInto(u);
      for (let i = 0; i < Ti.length; i++)
        Ti[i] ^= u[i];
    }
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}
function XorAndSalsa(prev, pi, input, ii, out, oi) {
  let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];
  let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];
  let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];
  let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];
  let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];
  let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];
  let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];
  let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let i = 0; i < 8; i += 2) {
    x04 ^= rotl$1(x00 + x12 | 0, 7);
    x08 ^= rotl$1(x04 + x00 | 0, 9);
    x12 ^= rotl$1(x08 + x04 | 0, 13);
    x00 ^= rotl$1(x12 + x08 | 0, 18);
    x09 ^= rotl$1(x05 + x01 | 0, 7);
    x13 ^= rotl$1(x09 + x05 | 0, 9);
    x01 ^= rotl$1(x13 + x09 | 0, 13);
    x05 ^= rotl$1(x01 + x13 | 0, 18);
    x14 ^= rotl$1(x10 + x06 | 0, 7);
    x02 ^= rotl$1(x14 + x10 | 0, 9);
    x06 ^= rotl$1(x02 + x14 | 0, 13);
    x10 ^= rotl$1(x06 + x02 | 0, 18);
    x03 ^= rotl$1(x15 + x11 | 0, 7);
    x07 ^= rotl$1(x03 + x15 | 0, 9);
    x11 ^= rotl$1(x07 + x03 | 0, 13);
    x15 ^= rotl$1(x11 + x07 | 0, 18);
    x01 ^= rotl$1(x00 + x03 | 0, 7);
    x02 ^= rotl$1(x01 + x00 | 0, 9);
    x03 ^= rotl$1(x02 + x01 | 0, 13);
    x00 ^= rotl$1(x03 + x02 | 0, 18);
    x06 ^= rotl$1(x05 + x04 | 0, 7);
    x07 ^= rotl$1(x06 + x05 | 0, 9);
    x04 ^= rotl$1(x07 + x06 | 0, 13);
    x05 ^= rotl$1(x04 + x07 | 0, 18);
    x11 ^= rotl$1(x10 + x09 | 0, 7);
    x08 ^= rotl$1(x11 + x10 | 0, 9);
    x09 ^= rotl$1(x08 + x11 | 0, 13);
    x10 ^= rotl$1(x09 + x08 | 0, 18);
    x12 ^= rotl$1(x15 + x14 | 0, 7);
    x13 ^= rotl$1(x12 + x15 | 0, 9);
    x14 ^= rotl$1(x13 + x12 | 0, 13);
    x15 ^= rotl$1(x14 + x13 | 0, 18);
  }
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
}
function BlockMix(input, ii, out, oi, r2) {
  let head = oi + 0;
  let tail = oi + 16 * r2;
  for (let i = 0; i < 16; i++)
    out[tail + i] = input[ii + (2 * r2 - 1) * 16 + i];
  for (let i = 0; i < r2; i++, head += 16, ii += 16) {
    XorAndSalsa(out, tail, input, ii, out, head);
    if (i > 0)
      tail += 16;
    XorAndSalsa(out, head, input, ii += 16, out, tail);
  }
}
function scryptInit(password, salt, _opts) {
  const opts = checkOpts$1({
    dkLen: 32,
    asyncTick: 10,
    maxmem: 1024 ** 3 + 1024
  }, _opts);
  const { N, r: r2, p, dkLen, asyncTick, maxmem, onProgress } = opts;
  anumber$1(N, "N");
  anumber$1(r2, "r");
  anumber$1(p, "p");
  anumber$1(dkLen, "dkLen");
  anumber$1(asyncTick, "asyncTick");
  anumber$1(maxmem, "maxmem");
  if (onProgress !== void 0 && typeof onProgress !== "function")
    throw new Error("progressCb must be a function");
  const blockSize = 128 * r2;
  const blockSize32 = blockSize / 4;
  const pow32 = Math.pow(2, 32);
  if (N <= 1 || (N & N - 1) !== 0 || N > pow32)
    throw new Error('"N" expected a power of 2, and 2^1 <= N <= 2^32');
  if (p < 1 || p > (pow32 - 1) * 32 / blockSize)
    throw new Error('"p" expected integer 1..((2^32 - 1) * 32) / (128 * r)');
  if (dkLen < 1 || dkLen > (pow32 - 1) * 32)
    throw new Error('"dkLen" expected integer 1..(2^32 - 1) * 32');
  const memUsed = blockSize * (N + p);
  if (memUsed > maxmem)
    throw new Error('"maxmem" limit was hit, expected 128*r*(N+p) <= "maxmem"=' + maxmem);
  const B = pbkdf2(sha256, password, salt, { c: 1, dkLen: blockSize * p });
  const B32 = u32$1(B);
  const V2 = u32$1(new Uint8Array(blockSize * N));
  const tmp = u32$1(new Uint8Array(blockSize));
  let blockMixCb = () => {
  };
  if (onProgress) {
    const totalBlockMix = 2 * N * p;
    const callbackPer = Math.max(Math.floor(totalBlockMix / 1e4), 1);
    let blockMixCnt = 0;
    blockMixCb = () => {
      blockMixCnt++;
      if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
        onProgress(blockMixCnt / totalBlockMix);
    };
  }
  return { N, r: r2, p, dkLen, blockSize32, V: V2, B32, B, tmp, blockMixCb, asyncTick };
}
function scryptOutput(password, dkLen, B, V2, tmp) {
  const res2 = pbkdf2(sha256, password, B, { c: 1, dkLen });
  clean$1(B, V2, tmp);
  return res2;
}
async function scryptAsync(password, salt, opts) {
  const { N, r: r2, p, dkLen, blockSize32, V: V2, B32, B, tmp, blockMixCb, asyncTick } = scryptInit(password, salt, opts);
  swap32IfBE(B32);
  for (let pi = 0; pi < p; pi++) {
    const Pi = blockSize32 * pi;
    for (let i = 0; i < blockSize32; i++)
      V2[i] = B32[Pi + i];
    let pos = 0;
    await asyncLoop(N - 1, asyncTick, () => {
      BlockMix(V2, pos, V2, pos += blockSize32, r2);
      blockMixCb();
    });
    BlockMix(V2, (N - 1) * blockSize32, B32, Pi, r2);
    blockMixCb();
    await asyncLoop(N, asyncTick, () => {
      const j = (B32[Pi + blockSize32 - 16] & N - 1) >>> 0;
      for (let k = 0; k < blockSize32; k++)
        tmp[k] = B32[Pi + k] ^ V2[j * blockSize32 + k];
      BlockMix(tmp, 0, B32, Pi, r2);
      blockMixCb();
    });
  }
  swap32IfBE(B32);
  return scryptOutput(password, dkLen, B, V2, tmp);
}
const config$1 = {
  N: 16384,
  r: 16,
  p: 1,
  dkLen: 64
};
async function generateKey(password, salt) {
  return await scryptAsync(password.normalize("NFKC"), salt, {
    N: config$1.N,
    p: config$1.p,
    r: config$1.r,
    dkLen: config$1.dkLen,
    maxmem: 128 * config$1.N * config$1.r * 2
  });
}
const hashPassword = async (password) => {
  const salt = hex.encode(crypto.getRandomValues(new Uint8Array(16)));
  const key = await generateKey(password, salt);
  return `${salt}:${hex.encode(key)}`;
};
const verifyPassword$1 = async ({ hash, password }) => {
  const [salt, key] = hash.split(":");
  if (!salt || !key) throw new BetterAuthError("Invalid password hash");
  return constantTimeEqual(await generateKey(password, salt), hexToBytes$1(key));
};
function getWebcryptoSubtle() {
  const cr = typeof globalThis !== "undefined" && globalThis.crypto;
  if (cr && typeof cr.subtle === "object" && cr.subtle != null)
    return cr.subtle;
  throw new Error("crypto.subtle must be defined");
}
function getAlphabet(urlSafe) {
  return urlSafe ? "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_" : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
}
function base64Encode(data, alphabet, padding) {
  let result2 = "";
  let buffer = 0;
  let shift = 0;
  for (const byte of data) {
    buffer = buffer << 8 | byte;
    shift += 8;
    while (shift >= 6) {
      shift -= 6;
      result2 += alphabet[buffer >> shift & 63];
    }
  }
  if (shift > 0) {
    result2 += alphabet[buffer << 6 - shift & 63];
  }
  if (padding) {
    const padCount = (4 - result2.length % 4) % 4;
    result2 += "=".repeat(padCount);
  }
  return result2;
}
function base64Decode(data, alphabet) {
  const decodeMap2 = /* @__PURE__ */ new Map();
  for (let i = 0; i < alphabet.length; i++) {
    decodeMap2.set(alphabet[i], i);
  }
  const result2 = [];
  let buffer = 0;
  let bitsCollected = 0;
  for (const char2 of data) {
    if (char2 === "=")
      break;
    const value = decodeMap2.get(char2);
    if (value === void 0) {
      throw new Error(`Invalid Base64 character: ${char2}`);
    }
    buffer = buffer << 6 | value;
    bitsCollected += 6;
    if (bitsCollected >= 8) {
      bitsCollected -= 8;
      result2.push(buffer >> bitsCollected & 255);
    }
  }
  return Uint8Array.from(result2);
}
const base64$1 = {
  encode(data, options = {}) {
    const alphabet = getAlphabet(false);
    const buffer = typeof data === "string" ? new TextEncoder().encode(data) : new Uint8Array(data);
    return base64Encode(buffer, alphabet, options.padding ?? true);
  },
  decode(data) {
    if (typeof data !== "string") {
      data = new TextDecoder().decode(data);
    }
    const urlSafe = data.includes("-") || data.includes("_");
    const alphabet = getAlphabet(urlSafe);
    return base64Decode(data, alphabet);
  }
};
const base64Url = {
  encode(data, options = {}) {
    const alphabet = getAlphabet(true);
    const buffer = typeof data === "string" ? new TextEncoder().encode(data) : new Uint8Array(data);
    return base64Encode(buffer, alphabet, options.padding ?? true);
  },
  decode(data) {
    const urlSafe = data.includes("-") || data.includes("_");
    const alphabet = getAlphabet(urlSafe);
    return base64Decode(data, alphabet);
  }
};
function createHash(algorithm2, encoding) {
  return {
    digest: async (input) => {
      const encoder2 = new TextEncoder();
      const data = typeof input === "string" ? encoder2.encode(input) : input;
      const hashBuffer = await getWebcryptoSubtle().digest(algorithm2, data);
      return hashBuffer;
    }
  };
}
function isBytes(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function abool(b) {
  if (typeof b !== "boolean")
    throw new Error(`boolean expected, not ${b}`);
}
function anumber(n2) {
  if (!Number.isSafeInteger(n2) || n2 < 0)
    throw new Error("positive integer expected, got " + n2);
}
function abytes(value, length, title = "") {
  const bytes = isBytes(value);
  const len = value?.length;
  const needsLen = length !== void 0;
  if (!bytes || needsLen && len !== length) {
    const prefix = title && `"${title}" `;
    const ofLen = needsLen ? ` of length ${length}` : "";
    const got = bytes ? `length=${len}` : `type=${typeof value}`;
    throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
  }
  return value;
}
function aexists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance) {
  abytes(out, void 0, "output");
  const min2 = instance.outputLen;
  if (out.length < min2) {
    throw new Error("digestInto() expects output buffer of length at least " + min2);
  }
}
function u32(arr) {
  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
function clean(...arrays) {
  for (let i = 0; i < arrays.length; i++) {
    arrays[i].fill(0);
  }
}
function createView(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
const isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
const hasHexBuiltin = /* @__PURE__ */ (() => (
  // @ts-ignore
  typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
))();
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function bytesToHex(bytes) {
  abytes(bytes);
  if (hasHexBuiltin)
    return bytes.toHex();
  let hex2 = "";
  for (let i = 0; i < bytes.length; i++) {
    hex2 += hexes[bytes[i]];
  }
  return hex2;
}
const asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase16(ch) {
  if (ch >= asciis._0 && ch <= asciis._9)
    return ch - asciis._0;
  if (ch >= asciis.A && ch <= asciis.F)
    return ch - (asciis.A - 10);
  if (ch >= asciis.a && ch <= asciis.f)
    return ch - (asciis.a - 10);
  return;
}
function hexToBytes(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  if (hasHexBuiltin)
    return Uint8Array.fromHex(hex2);
  const hl = hex2.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex2.charCodeAt(hi));
    const n2 = asciiToBase16(hex2.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char2 = hex2[hi] + hex2[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char2 + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
function concatBytes(...arrays) {
  let sum2 = 0;
  for (let i = 0; i < arrays.length; i++) {
    const a = arrays[i];
    abytes(a);
    sum2 += a.length;
  }
  const res2 = new Uint8Array(sum2);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const a = arrays[i];
    res2.set(a, pad);
    pad += a.length;
  }
  return res2;
}
function checkOpts(defaults2, opts) {
  if (opts == null || typeof opts !== "object")
    throw new Error("options must be defined");
  const merged = Object.assign(defaults2, opts);
  return merged;
}
function equalBytes(a, b) {
  if (a.length !== b.length)
    return false;
  let diff2 = 0;
  for (let i = 0; i < a.length; i++)
    diff2 |= a[i] ^ b[i];
  return diff2 === 0;
}
const wrapCipher = /* @__NO_SIDE_EFFECTS__ */ (params, constructor) => {
  function wrappedCipher(key, ...args) {
    abytes(key, void 0, "key");
    if (!isLE)
      throw new Error("Non little-endian hardware is not yet supported");
    if (params.nonceLength !== void 0) {
      const nonce = args[0];
      abytes(nonce, params.varSizeNonce ? void 0 : params.nonceLength, "nonce");
    }
    const tagl = params.tagLength;
    if (tagl && args[1] !== void 0)
      abytes(args[1], void 0, "AAD");
    const cipher = constructor(key, ...args);
    const checkOutput = (fnLength, output) => {
      if (output !== void 0) {
        if (fnLength !== 2)
          throw new Error("cipher output not supported");
        abytes(output, void 0, "output");
      }
    };
    let called = false;
    const wrCipher = {
      encrypt(data, output) {
        if (called)
          throw new Error("cannot encrypt() twice with same key + nonce");
        called = true;
        abytes(data);
        checkOutput(cipher.encrypt.length, output);
        return cipher.encrypt(data, output);
      },
      decrypt(data, output) {
        abytes(data);
        if (tagl && data.length < tagl)
          throw new Error('"ciphertext" expected length bigger than tagLength=' + tagl);
        checkOutput(cipher.decrypt.length, output);
        return cipher.decrypt(data, output);
      }
    };
    return wrCipher;
  }
  Object.assign(wrappedCipher, params);
  return wrappedCipher;
};
function getOutput(expectedLength, out, onlyAligned = true) {
  if (out === void 0)
    return new Uint8Array(expectedLength);
  if (out.length !== expectedLength)
    throw new Error('"output" expected Uint8Array of length ' + expectedLength + ", got: " + out.length);
  if (onlyAligned && !isAligned32$1(out))
    throw new Error("invalid output, must be aligned");
  return out;
}
function u64Lengths(dataLength, aadLength, isLE2) {
  abool(isLE2);
  const num = new Uint8Array(16);
  const view = createView(num);
  view.setBigUint64(0, BigInt(aadLength), isLE2);
  view.setBigUint64(8, BigInt(dataLength), isLE2);
  return num;
}
function isAligned32$1(bytes) {
  return bytes.byteOffset % 4 === 0;
}
function copyBytes(bytes) {
  return Uint8Array.from(bytes);
}
function randomBytes(bytesLength = 32) {
  const cr = typeof globalThis === "object" ? globalThis.crypto : null;
  if (typeof cr?.getRandomValues !== "function")
    throw new Error("crypto.getRandomValues must be defined");
  return cr.getRandomValues(new Uint8Array(bytesLength));
}
function managedNonce(fn2, randomBytes_ = randomBytes) {
  const { nonceLength } = fn2;
  anumber(nonceLength);
  const addNonce = (nonce, ciphertext) => {
    const out = concatBytes(nonce, ciphertext);
    ciphertext.fill(0);
    return out;
  };
  return ((key, ...args) => ({
    encrypt(plaintext) {
      abytes(plaintext);
      const nonce = randomBytes_(nonceLength);
      const encrypted = fn2(key, nonce, ...args).encrypt(plaintext);
      if (encrypted instanceof Promise)
        return encrypted.then((ct) => addNonce(nonce, ct));
      return addNonce(nonce, encrypted);
    },
    decrypt(ciphertext) {
      abytes(ciphertext);
      const nonce = ciphertext.subarray(0, nonceLength);
      const decrypted = ciphertext.subarray(nonceLength);
      return fn2(key, nonce, ...args).decrypt(decrypted);
    }
  }));
}
const encodeStr = (str) => Uint8Array.from(str.split(""), (c2) => c2.charCodeAt(0));
const sigma16 = encodeStr("expand 16-byte k");
const sigma32 = encodeStr("expand 32-byte k");
const sigma16_32 = u32(sigma16);
const sigma32_32 = u32(sigma32);
function rotl(a, b) {
  return a << b | a >>> 32 - b;
}
function isAligned32(b) {
  return b.byteOffset % 4 === 0;
}
const BLOCK_LEN = 64;
const BLOCK_LEN32 = 16;
const MAX_COUNTER = 2 ** 32 - 1;
const U32_EMPTY = Uint32Array.of();
function runCipher(core, sigma, key, nonce, data, output, counter, rounds) {
  const len = data.length;
  const block = new Uint8Array(BLOCK_LEN);
  const b32 = u32(block);
  const isAligned = isAligned32(data) && isAligned32(output);
  const d32 = isAligned ? u32(data) : U32_EMPTY;
  const o32 = isAligned ? u32(output) : U32_EMPTY;
  for (let pos = 0; pos < len; counter++) {
    core(sigma, key, nonce, b32, counter, rounds);
    if (counter >= MAX_COUNTER)
      throw new Error("arx: counter overflow");
    const take = Math.min(BLOCK_LEN, len - pos);
    if (isAligned && take === BLOCK_LEN) {
      const pos32 = pos / 4;
      if (pos % 4 !== 0)
        throw new Error("arx: invalid block position");
      for (let j = 0, posj; j < BLOCK_LEN32; j++) {
        posj = pos32 + j;
        o32[posj] = d32[posj] ^ b32[j];
      }
      pos += BLOCK_LEN;
      continue;
    }
    for (let j = 0, posj; j < take; j++) {
      posj = pos + j;
      output[posj] = data[posj] ^ block[j];
    }
    pos += take;
  }
}
function createCipher(core, opts) {
  const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = checkOpts({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, opts);
  if (typeof core !== "function")
    throw new Error("core must be a function");
  anumber(counterLength);
  anumber(rounds);
  abool(counterRight);
  abool(allowShortKeys);
  return (key, nonce, data, output, counter = 0) => {
    abytes(key, void 0, "key");
    abytes(nonce, void 0, "nonce");
    abytes(data, void 0, "data");
    const len = data.length;
    if (output === void 0)
      output = new Uint8Array(len);
    abytes(output, void 0, "output");
    anumber(counter);
    if (counter < 0 || counter >= MAX_COUNTER)
      throw new Error("arx: counter overflow");
    if (output.length < len)
      throw new Error(`arx: output (${output.length}) is shorter than data (${len})`);
    const toClean = [];
    let l2 = key.length;
    let k;
    let sigma;
    if (l2 === 32) {
      toClean.push(k = copyBytes(key));
      sigma = sigma32_32;
    } else if (l2 === 16 && allowShortKeys) {
      k = new Uint8Array(32);
      k.set(key);
      k.set(key, 16);
      sigma = sigma16_32;
      toClean.push(k);
    } else {
      abytes(key, 32, "arx key");
      throw new Error("invalid key size");
    }
    if (!isAligned32(nonce))
      toClean.push(nonce = copyBytes(nonce));
    const k32 = u32(k);
    if (extendNonceFn) {
      if (nonce.length !== 24)
        throw new Error(`arx: extended nonce must be 24 bytes`);
      extendNonceFn(sigma, k32, u32(nonce.subarray(0, 16)), k32);
      nonce = nonce.subarray(16);
    }
    const nonceNcLen = 16 - counterLength;
    if (nonceNcLen !== nonce.length)
      throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);
    if (nonceNcLen !== 12) {
      const nc = new Uint8Array(12);
      nc.set(nonce, counterRight ? 0 : 12 - nonce.length);
      nonce = nc;
      toClean.push(nonce);
    }
    const n32 = u32(nonce);
    runCipher(core, sigma, k32, n32, data, output, counter, rounds);
    clean(...toClean);
    return output;
  };
}
function u8to16(a, i) {
  return a[i++] & 255 | (a[i++] & 255) << 8;
}
class Poly1305 {
  blockLen = 16;
  outputLen = 16;
  buffer = new Uint8Array(16);
  r = new Uint16Array(10);
  // Allocating 1 array with .subarray() here is slower than 3
  h = new Uint16Array(10);
  pad = new Uint16Array(8);
  pos = 0;
  finished = false;
  // Can be speed-up using BigUint64Array, at the cost of complexity
  constructor(key) {
    key = copyBytes(abytes(key, 32, "key"));
    const t0 = u8to16(key, 0);
    const t1 = u8to16(key, 2);
    const t2 = u8to16(key, 4);
    const t3 = u8to16(key, 6);
    const t4 = u8to16(key, 8);
    const t5 = u8to16(key, 10);
    const t6 = u8to16(key, 12);
    const t7 = u8to16(key, 14);
    this.r[0] = t0 & 8191;
    this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
    this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
    this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
    this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
    this.r[5] = t4 >>> 1 & 8190;
    this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
    this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
    this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
    this.r[9] = t7 >>> 5 & 127;
    for (let i = 0; i < 8; i++)
      this.pad[i] = u8to16(key, 16 + 2 * i);
  }
  process(data, offset2, isLast = false) {
    const hibit = isLast ? 0 : 1 << 11;
    const { h, r: r2 } = this;
    const r0 = r2[0];
    const r1 = r2[1];
    const r22 = r2[2];
    const r3 = r2[3];
    const r4 = r2[4];
    const r5 = r2[5];
    const r6 = r2[6];
    const r7 = r2[7];
    const r8 = r2[8];
    const r9 = r2[9];
    const t0 = u8to16(data, offset2 + 0);
    const t1 = u8to16(data, offset2 + 2);
    const t2 = u8to16(data, offset2 + 4);
    const t3 = u8to16(data, offset2 + 6);
    const t4 = u8to16(data, offset2 + 8);
    const t5 = u8to16(data, offset2 + 10);
    const t6 = u8to16(data, offset2 + 12);
    const t7 = u8to16(data, offset2 + 14);
    let h0 = h[0] + (t0 & 8191);
    let h1 = h[1] + ((t0 >>> 13 | t1 << 3) & 8191);
    let h2 = h[2] + ((t1 >>> 10 | t2 << 6) & 8191);
    let h3 = h[3] + ((t2 >>> 7 | t3 << 9) & 8191);
    let h4 = h[4] + ((t3 >>> 4 | t4 << 12) & 8191);
    let h5 = h[5] + (t4 >>> 1 & 8191);
    let h6 = h[6] + ((t4 >>> 14 | t5 << 2) & 8191);
    let h7 = h[7] + ((t5 >>> 11 | t6 << 5) & 8191);
    let h8 = h[8] + ((t6 >>> 8 | t7 << 8) & 8191);
    let h9 = h[9] + (t7 >>> 5 | hibit);
    let c2 = 0;
    let d0 = c2 + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);
    c2 = d0 >>> 13;
    d0 &= 8191;
    d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r22) + h9 * (5 * r1);
    c2 += d0 >>> 13;
    d0 &= 8191;
    let d1 = c2 + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);
    c2 = d1 >>> 13;
    d1 &= 8191;
    d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r22);
    c2 += d1 >>> 13;
    d1 &= 8191;
    let d2 = c2 + h0 * r22 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);
    c2 = d2 >>> 13;
    d2 &= 8191;
    d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);
    c2 += d2 >>> 13;
    d2 &= 8191;
    let d3 = c2 + h0 * r3 + h1 * r22 + h2 * r1 + h3 * r0 + h4 * (5 * r9);
    c2 = d3 >>> 13;
    d3 &= 8191;
    d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);
    c2 += d3 >>> 13;
    d3 &= 8191;
    let d4 = c2 + h0 * r4 + h1 * r3 + h2 * r22 + h3 * r1 + h4 * r0;
    c2 = d4 >>> 13;
    d4 &= 8191;
    d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);
    c2 += d4 >>> 13;
    d4 &= 8191;
    let d5 = c2 + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r22 + h4 * r1;
    c2 = d5 >>> 13;
    d5 &= 8191;
    d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);
    c2 += d5 >>> 13;
    d5 &= 8191;
    let d6 = c2 + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r22;
    c2 = d6 >>> 13;
    d6 &= 8191;
    d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);
    c2 += d6 >>> 13;
    d6 &= 8191;
    let d7 = c2 + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;
    c2 = d7 >>> 13;
    d7 &= 8191;
    d7 += h5 * r22 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);
    c2 += d7 >>> 13;
    d7 &= 8191;
    let d8 = c2 + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;
    c2 = d8 >>> 13;
    d8 &= 8191;
    d8 += h5 * r3 + h6 * r22 + h7 * r1 + h8 * r0 + h9 * (5 * r9);
    c2 += d8 >>> 13;
    d8 &= 8191;
    let d9 = c2 + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;
    c2 = d9 >>> 13;
    d9 &= 8191;
    d9 += h5 * r4 + h6 * r3 + h7 * r22 + h8 * r1 + h9 * r0;
    c2 += d9 >>> 13;
    d9 &= 8191;
    c2 = (c2 << 2) + c2 | 0;
    c2 = c2 + d0 | 0;
    d0 = c2 & 8191;
    c2 = c2 >>> 13;
    d1 += c2;
    h[0] = d0;
    h[1] = d1;
    h[2] = d2;
    h[3] = d3;
    h[4] = d4;
    h[5] = d5;
    h[6] = d6;
    h[7] = d7;
    h[8] = d8;
    h[9] = d9;
  }
  finalize() {
    const { h, pad } = this;
    const g = new Uint16Array(10);
    let c2 = h[1] >>> 13;
    h[1] &= 8191;
    for (let i = 2; i < 10; i++) {
      h[i] += c2;
      c2 = h[i] >>> 13;
      h[i] &= 8191;
    }
    h[0] += c2 * 5;
    c2 = h[0] >>> 13;
    h[0] &= 8191;
    h[1] += c2;
    c2 = h[1] >>> 13;
    h[1] &= 8191;
    h[2] += c2;
    g[0] = h[0] + 5;
    c2 = g[0] >>> 13;
    g[0] &= 8191;
    for (let i = 1; i < 10; i++) {
      g[i] = h[i] + c2;
      c2 = g[i] >>> 13;
      g[i] &= 8191;
    }
    g[9] -= 1 << 13;
    let mask = (c2 ^ 1) - 1;
    for (let i = 0; i < 10; i++)
      g[i] &= mask;
    mask = ~mask;
    for (let i = 0; i < 10; i++)
      h[i] = h[i] & mask | g[i];
    h[0] = (h[0] | h[1] << 13) & 65535;
    h[1] = (h[1] >>> 3 | h[2] << 10) & 65535;
    h[2] = (h[2] >>> 6 | h[3] << 7) & 65535;
    h[3] = (h[3] >>> 9 | h[4] << 4) & 65535;
    h[4] = (h[4] >>> 12 | h[5] << 1 | h[6] << 14) & 65535;
    h[5] = (h[6] >>> 2 | h[7] << 11) & 65535;
    h[6] = (h[7] >>> 5 | h[8] << 8) & 65535;
    h[7] = (h[8] >>> 8 | h[9] << 5) & 65535;
    let f = h[0] + pad[0];
    h[0] = f & 65535;
    for (let i = 1; i < 8; i++) {
      f = (h[i] + pad[i] | 0) + (f >>> 16) | 0;
      h[i] = f & 65535;
    }
    clean(g);
  }
  update(data) {
    aexists(this);
    abytes(data);
    data = copyBytes(data);
    const { buffer, blockLen } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(data, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(buffer, 0, false);
        this.pos = 0;
      }
    }
    return this;
  }
  destroy() {
    clean(this.h, this.r, this.buffer, this.pad);
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    this.finished = true;
    const { buffer, h } = this;
    let { pos } = this;
    if (pos) {
      buffer[pos++] = 1;
      for (; pos < 16; pos++)
        buffer[pos] = 0;
      this.process(buffer, 0, true);
    }
    this.finalize();
    let opos = 0;
    for (let i = 0; i < 8; i++) {
      out[opos++] = h[i] >>> 0;
      out[opos++] = h[i] >>> 8;
    }
    return out;
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res2 = buffer.slice(0, outputLen);
    this.destroy();
    return res2;
  }
}
function wrapConstructorWithKey(hashCons) {
  const hashC = (msg, key) => hashCons(key).update(msg).digest();
  const tmp = hashCons(new Uint8Array(32));
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (key) => hashCons(key);
  return hashC;
}
const poly1305 = /* @__PURE__ */ (() => wrapConstructorWithKey((key) => new Poly1305(key)))();
function chachaCore(s2, k, n2, out, cnt, rounds = 20) {
  let y00 = s2[0], y01 = s2[1], y02 = s2[2], y03 = s2[3], y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], y12 = cnt, y13 = n2[0], y14 = n2[1], y15 = n2[2];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let r2 = 0; r2 < rounds; r2 += 2) {
    x00 = x00 + x04 | 0;
    x12 = rotl(x12 ^ x00, 16);
    x08 = x08 + x12 | 0;
    x04 = rotl(x04 ^ x08, 12);
    x00 = x00 + x04 | 0;
    x12 = rotl(x12 ^ x00, 8);
    x08 = x08 + x12 | 0;
    x04 = rotl(x04 ^ x08, 7);
    x01 = x01 + x05 | 0;
    x13 = rotl(x13 ^ x01, 16);
    x09 = x09 + x13 | 0;
    x05 = rotl(x05 ^ x09, 12);
    x01 = x01 + x05 | 0;
    x13 = rotl(x13 ^ x01, 8);
    x09 = x09 + x13 | 0;
    x05 = rotl(x05 ^ x09, 7);
    x02 = x02 + x06 | 0;
    x14 = rotl(x14 ^ x02, 16);
    x10 = x10 + x14 | 0;
    x06 = rotl(x06 ^ x10, 12);
    x02 = x02 + x06 | 0;
    x14 = rotl(x14 ^ x02, 8);
    x10 = x10 + x14 | 0;
    x06 = rotl(x06 ^ x10, 7);
    x03 = x03 + x07 | 0;
    x15 = rotl(x15 ^ x03, 16);
    x11 = x11 + x15 | 0;
    x07 = rotl(x07 ^ x11, 12);
    x03 = x03 + x07 | 0;
    x15 = rotl(x15 ^ x03, 8);
    x11 = x11 + x15 | 0;
    x07 = rotl(x07 ^ x11, 7);
    x00 = x00 + x05 | 0;
    x15 = rotl(x15 ^ x00, 16);
    x10 = x10 + x15 | 0;
    x05 = rotl(x05 ^ x10, 12);
    x00 = x00 + x05 | 0;
    x15 = rotl(x15 ^ x00, 8);
    x10 = x10 + x15 | 0;
    x05 = rotl(x05 ^ x10, 7);
    x01 = x01 + x06 | 0;
    x12 = rotl(x12 ^ x01, 16);
    x11 = x11 + x12 | 0;
    x06 = rotl(x06 ^ x11, 12);
    x01 = x01 + x06 | 0;
    x12 = rotl(x12 ^ x01, 8);
    x11 = x11 + x12 | 0;
    x06 = rotl(x06 ^ x11, 7);
    x02 = x02 + x07 | 0;
    x13 = rotl(x13 ^ x02, 16);
    x08 = x08 + x13 | 0;
    x07 = rotl(x07 ^ x08, 12);
    x02 = x02 + x07 | 0;
    x13 = rotl(x13 ^ x02, 8);
    x08 = x08 + x13 | 0;
    x07 = rotl(x07 ^ x08, 7);
    x03 = x03 + x04 | 0;
    x14 = rotl(x14 ^ x03, 16);
    x09 = x09 + x14 | 0;
    x04 = rotl(x04 ^ x09, 12);
    x03 = x03 + x04 | 0;
    x14 = rotl(x14 ^ x03, 8);
    x09 = x09 + x14 | 0;
    x04 = rotl(x04 ^ x09, 7);
  }
  let oi = 0;
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
}
function hchacha(s2, k, i, out) {
  let x00 = s2[0], x01 = s2[1], x02 = s2[2], x03 = s2[3], x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3], x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7], x12 = i[0], x13 = i[1], x14 = i[2], x15 = i[3];
  for (let r2 = 0; r2 < 20; r2 += 2) {
    x00 = x00 + x04 | 0;
    x12 = rotl(x12 ^ x00, 16);
    x08 = x08 + x12 | 0;
    x04 = rotl(x04 ^ x08, 12);
    x00 = x00 + x04 | 0;
    x12 = rotl(x12 ^ x00, 8);
    x08 = x08 + x12 | 0;
    x04 = rotl(x04 ^ x08, 7);
    x01 = x01 + x05 | 0;
    x13 = rotl(x13 ^ x01, 16);
    x09 = x09 + x13 | 0;
    x05 = rotl(x05 ^ x09, 12);
    x01 = x01 + x05 | 0;
    x13 = rotl(x13 ^ x01, 8);
    x09 = x09 + x13 | 0;
    x05 = rotl(x05 ^ x09, 7);
    x02 = x02 + x06 | 0;
    x14 = rotl(x14 ^ x02, 16);
    x10 = x10 + x14 | 0;
    x06 = rotl(x06 ^ x10, 12);
    x02 = x02 + x06 | 0;
    x14 = rotl(x14 ^ x02, 8);
    x10 = x10 + x14 | 0;
    x06 = rotl(x06 ^ x10, 7);
    x03 = x03 + x07 | 0;
    x15 = rotl(x15 ^ x03, 16);
    x11 = x11 + x15 | 0;
    x07 = rotl(x07 ^ x11, 12);
    x03 = x03 + x07 | 0;
    x15 = rotl(x15 ^ x03, 8);
    x11 = x11 + x15 | 0;
    x07 = rotl(x07 ^ x11, 7);
    x00 = x00 + x05 | 0;
    x15 = rotl(x15 ^ x00, 16);
    x10 = x10 + x15 | 0;
    x05 = rotl(x05 ^ x10, 12);
    x00 = x00 + x05 | 0;
    x15 = rotl(x15 ^ x00, 8);
    x10 = x10 + x15 | 0;
    x05 = rotl(x05 ^ x10, 7);
    x01 = x01 + x06 | 0;
    x12 = rotl(x12 ^ x01, 16);
    x11 = x11 + x12 | 0;
    x06 = rotl(x06 ^ x11, 12);
    x01 = x01 + x06 | 0;
    x12 = rotl(x12 ^ x01, 8);
    x11 = x11 + x12 | 0;
    x06 = rotl(x06 ^ x11, 7);
    x02 = x02 + x07 | 0;
    x13 = rotl(x13 ^ x02, 16);
    x08 = x08 + x13 | 0;
    x07 = rotl(x07 ^ x08, 12);
    x02 = x02 + x07 | 0;
    x13 = rotl(x13 ^ x02, 8);
    x08 = x08 + x13 | 0;
    x07 = rotl(x07 ^ x08, 7);
    x03 = x03 + x04 | 0;
    x14 = rotl(x14 ^ x03, 16);
    x09 = x09 + x14 | 0;
    x04 = rotl(x04 ^ x09, 12);
    x03 = x03 + x04 | 0;
    x14 = rotl(x14 ^ x03, 8);
    x09 = x09 + x14 | 0;
    x04 = rotl(x04 ^ x09, 7);
  }
  let oi = 0;
  out[oi++] = x00;
  out[oi++] = x01;
  out[oi++] = x02;
  out[oi++] = x03;
  out[oi++] = x12;
  out[oi++] = x13;
  out[oi++] = x14;
  out[oi++] = x15;
}
const xchacha20 = /* @__PURE__ */ createCipher(chachaCore, {
  counterRight: false,
  counterLength: 8,
  extendNonceFn: hchacha,
  allowShortKeys: false
});
const ZEROS16 = /* @__PURE__ */ new Uint8Array(16);
const updatePadded = (h, msg) => {
  h.update(msg);
  const leftover = msg.length % 16;
  if (leftover)
    h.update(ZEROS16.subarray(leftover));
};
const ZEROS32 = /* @__PURE__ */ new Uint8Array(32);
function computeTag(fn2, key, nonce, ciphertext, AAD) {
  if (AAD !== void 0)
    abytes(AAD, void 0, "AAD");
  const authKey = fn2(key, nonce, ZEROS32);
  const lengths = u64Lengths(ciphertext.length, AAD ? AAD.length : 0, true);
  const h = poly1305.create(authKey);
  if (AAD)
    updatePadded(h, AAD);
  updatePadded(h, ciphertext);
  h.update(lengths);
  const res2 = h.digest();
  clean(authKey, lengths);
  return res2;
}
const _poly1305_aead = (xorStream) => (key, nonce, AAD) => {
  const tagLength = 16;
  return {
    encrypt(plaintext, output) {
      const plength = plaintext.length;
      output = getOutput(plength + tagLength, output, false);
      output.set(plaintext);
      const oPlain = output.subarray(0, -tagLength);
      xorStream(key, nonce, oPlain, oPlain, 1);
      const tag2 = computeTag(xorStream, key, nonce, oPlain, AAD);
      output.set(tag2, plength);
      clean(tag2);
      return output;
    },
    decrypt(ciphertext, output) {
      output = getOutput(ciphertext.length - tagLength, output, false);
      const data = ciphertext.subarray(0, -tagLength);
      const passedTag = ciphertext.subarray(-tagLength);
      const tag2 = computeTag(xorStream, key, nonce, data, AAD);
      if (!equalBytes(passedTag, tag2))
        throw new Error("invalid tag");
      output.set(ciphertext.subarray(0, -tagLength));
      xorStream(key, nonce, output, output, 1);
      clean(tag2);
      return output;
    }
  };
};
const xchacha20poly1305 = /* @__PURE__ */ wrapCipher({ blockSize: 64, nonceLength: 24, tagLength: 16 }, _poly1305_aead(xchacha20));
const symmetricEncrypt = async ({ key, data }) => {
  const keyAsBytes = await createHash("SHA-256").digest(key);
  const dataAsBytes = utf8ToBytes(data);
  return bytesToHex(managedNonce(xchacha20poly1305)(new Uint8Array(keyAsBytes)).encrypt(dataAsBytes));
};
const symmetricDecrypt = async ({ key, data }) => {
  const keyAsBytes = await createHash("SHA-256").digest(key);
  const dataAsBytes = hexToBytes(data);
  const chacha = managedNonce(xchacha20poly1305)(new Uint8Array(keyAsBytes));
  return new TextDecoder().decode(chacha.decrypt(dataAsBytes));
};
const getDate = (span, unit = "ms") => {
  return new Date(Date.now() + (unit === "sec" ? span * 1e3 : span));
};
const getAuthTables = (options) => {
  const pluginSchema = (options.plugins ?? []).reduce((acc, plugin) => {
    const schema2 = plugin.schema;
    if (!schema2) return acc;
    for (const [key, value] of Object.entries(schema2)) acc[key] = {
      fields: {
        ...acc[key]?.fields,
        ...value.fields
      },
      modelName: value.modelName || key
    };
    return acc;
  }, {});
  const shouldAddRateLimitTable = options.rateLimit?.storage === "database";
  const rateLimitTable = { rateLimit: {
    modelName: options.rateLimit?.modelName || "rateLimit",
    fields: {
      key: {
        type: "string",
        unique: true,
        required: true,
        fieldName: options.rateLimit?.fields?.key || "key"
      },
      count: {
        type: "number",
        required: true,
        fieldName: options.rateLimit?.fields?.count || "count"
      },
      lastRequest: {
        type: "number",
        bigint: true,
        required: true,
        fieldName: options.rateLimit?.fields?.lastRequest || "lastRequest",
        defaultValue: () => Date.now()
      }
    }
  } };
  const { user, session, account, verification, ...pluginTables } = pluginSchema;
  const sessionTable = { session: {
    modelName: options.session?.modelName || "session",
    fields: {
      expiresAt: {
        type: "date",
        required: true,
        fieldName: options.session?.fields?.expiresAt || "expiresAt"
      },
      token: {
        type: "string",
        required: true,
        fieldName: options.session?.fields?.token || "token",
        unique: true
      },
      createdAt: {
        type: "date",
        required: true,
        fieldName: options.session?.fields?.createdAt || "createdAt",
        defaultValue: () => /* @__PURE__ */ new Date()
      },
      updatedAt: {
        type: "date",
        required: true,
        fieldName: options.session?.fields?.updatedAt || "updatedAt",
        onUpdate: () => /* @__PURE__ */ new Date()
      },
      ipAddress: {
        type: "string",
        required: false,
        fieldName: options.session?.fields?.ipAddress || "ipAddress"
      },
      userAgent: {
        type: "string",
        required: false,
        fieldName: options.session?.fields?.userAgent || "userAgent"
      },
      userId: {
        type: "string",
        fieldName: options.session?.fields?.userId || "userId",
        references: {
          model: options.user?.modelName || "user",
          field: "id",
          onDelete: "cascade"
        },
        required: true,
        index: true
      },
      ...session?.fields,
      ...options.session?.additionalFields
    },
    order: 2
  } };
  return {
    user: {
      modelName: options.user?.modelName || "user",
      fields: {
        name: {
          type: "string",
          required: true,
          fieldName: options.user?.fields?.name || "name",
          sortable: true
        },
        email: {
          type: "string",
          unique: true,
          required: true,
          fieldName: options.user?.fields?.email || "email",
          sortable: true
        },
        emailVerified: {
          type: "boolean",
          defaultValue: false,
          required: true,
          fieldName: options.user?.fields?.emailVerified || "emailVerified",
          input: false
        },
        image: {
          type: "string",
          required: false,
          fieldName: options.user?.fields?.image || "image"
        },
        createdAt: {
          type: "date",
          defaultValue: () => /* @__PURE__ */ new Date(),
          required: true,
          fieldName: options.user?.fields?.createdAt || "createdAt"
        },
        updatedAt: {
          type: "date",
          defaultValue: () => /* @__PURE__ */ new Date(),
          onUpdate: () => /* @__PURE__ */ new Date(),
          required: true,
          fieldName: options.user?.fields?.updatedAt || "updatedAt"
        },
        ...user?.fields,
        ...options.user?.additionalFields
      },
      order: 1
    },
    ...!options.secondaryStorage || options.session?.storeSessionInDatabase ? sessionTable : {},
    account: {
      modelName: options.account?.modelName || "account",
      fields: {
        accountId: {
          type: "string",
          required: true,
          fieldName: options.account?.fields?.accountId || "accountId"
        },
        providerId: {
          type: "string",
          required: true,
          fieldName: options.account?.fields?.providerId || "providerId"
        },
        userId: {
          type: "string",
          references: {
            model: options.user?.modelName || "user",
            field: "id",
            onDelete: "cascade"
          },
          required: true,
          fieldName: options.account?.fields?.userId || "userId",
          index: true
        },
        accessToken: {
          type: "string",
          required: false,
          returned: false,
          fieldName: options.account?.fields?.accessToken || "accessToken"
        },
        refreshToken: {
          type: "string",
          required: false,
          returned: false,
          fieldName: options.account?.fields?.refreshToken || "refreshToken"
        },
        idToken: {
          type: "string",
          required: false,
          returned: false,
          fieldName: options.account?.fields?.idToken || "idToken"
        },
        accessTokenExpiresAt: {
          type: "date",
          required: false,
          returned: false,
          fieldName: options.account?.fields?.accessTokenExpiresAt || "accessTokenExpiresAt"
        },
        refreshTokenExpiresAt: {
          type: "date",
          required: false,
          returned: false,
          fieldName: options.account?.fields?.refreshTokenExpiresAt || "refreshTokenExpiresAt"
        },
        scope: {
          type: "string",
          required: false,
          fieldName: options.account?.fields?.scope || "scope"
        },
        password: {
          type: "string",
          required: false,
          returned: false,
          fieldName: options.account?.fields?.password || "password"
        },
        createdAt: {
          type: "date",
          required: true,
          fieldName: options.account?.fields?.createdAt || "createdAt",
          defaultValue: () => /* @__PURE__ */ new Date()
        },
        updatedAt: {
          type: "date",
          required: true,
          fieldName: options.account?.fields?.updatedAt || "updatedAt",
          onUpdate: () => /* @__PURE__ */ new Date()
        },
        ...account?.fields,
        ...options.account?.additionalFields
      },
      order: 3
    },
    verification: {
      modelName: options.verification?.modelName || "verification",
      fields: {
        identifier: {
          type: "string",
          required: true,
          fieldName: options.verification?.fields?.identifier || "identifier",
          index: true
        },
        value: {
          type: "string",
          required: true,
          fieldName: options.verification?.fields?.value || "value"
        },
        expiresAt: {
          type: "date",
          required: true,
          fieldName: options.verification?.fields?.expiresAt || "expiresAt"
        },
        createdAt: {
          type: "date",
          required: true,
          defaultValue: () => /* @__PURE__ */ new Date(),
          fieldName: options.verification?.fields?.createdAt || "createdAt"
        },
        updatedAt: {
          type: "date",
          required: true,
          defaultValue: () => /* @__PURE__ */ new Date(),
          onUpdate: () => /* @__PURE__ */ new Date(),
          fieldName: options.verification?.fields?.updatedAt || "updatedAt"
        },
        ...verification?.fields,
        ...options.verification?.additionalFields
      },
      order: 4
    },
    ...pluginTables,
    ...shouldAddRateLimitTable ? rateLimitTable : {}
  };
};
const coreSchema = z.object({
  id: z.string(),
  createdAt: z.date().default(() => /* @__PURE__ */ new Date()),
  updatedAt: z.date().default(() => /* @__PURE__ */ new Date())
});
const accountSchema = coreSchema.extend({
  providerId: z.string(),
  accountId: z.string(),
  userId: z.coerce.string(),
  accessToken: z.string().nullish(),
  refreshToken: z.string().nullish(),
  idToken: z.string().nullish(),
  accessTokenExpiresAt: z.date().nullish(),
  refreshTokenExpiresAt: z.date().nullish(),
  scope: z.string().nullish(),
  password: z.string().nullish()
});
const rateLimitSchema = z.object({
  key: z.string(),
  count: z.number(),
  lastRequest: z.number()
});
const sessionSchema = coreSchema.extend({
  userId: z.coerce.string(),
  expiresAt: z.date(),
  token: z.string(),
  ipAddress: z.string().nullish(),
  userAgent: z.string().nullish()
});
const userSchema = coreSchema.extend({
  email: z.string().transform((val) => val.toLowerCase()),
  emailVerified: z.boolean().default(false),
  name: z.string(),
  image: z.string().nullish()
});
const verificationSchema = coreSchema.extend({
  value: z.string(),
  expiresAt: z.date(),
  identifier: z.string()
});
const import___better_auth_core_db = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  accountSchema,
  coreSchema,
  getAuthTables,
  rateLimitSchema,
  sessionSchema,
  userSchema,
  verificationSchema
}, Symbol.toStringTag, { value: "Module" }));
function isErrorStackTraceLimitWritable$1() {
  const desc2 = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
  if (desc2 === void 0) return Object.isExtensible(Error);
  return Object.prototype.hasOwnProperty.call(desc2, "writable") ? desc2.writable : desc2.set !== void 0;
}
function hideInternalStackFrames$1(stack) {
  const lines = stack.split("\n    at ");
  if (lines.length <= 1) return stack;
  lines.splice(1, 1);
  return lines.join("\n    at ");
}
function makeErrorForHideStackFrame$1(Base, clazz) {
  class HideStackFramesError extends Base {
    #hiddenStack;
    constructor(...args) {
      if (isErrorStackTraceLimitWritable$1()) {
        const limit = Error.stackTraceLimit;
        Error.stackTraceLimit = 0;
        super(...args);
        Error.stackTraceLimit = limit;
      } else super(...args);
      const stack = (/* @__PURE__ */ new Error()).stack;
      if (stack) this.#hiddenStack = hideInternalStackFrames$1(stack.replace(/^Error/, this.name));
    }
    get errorStack() {
      return this.#hiddenStack;
    }
  }
  Object.defineProperty(HideStackFramesError.prototype, "constructor", {
    get() {
      return clazz;
    },
    enumerable: false,
    configurable: true
  });
  return HideStackFramesError;
}
const statusCodes$1 = {
  OK: 200,
  CREATED: 201,
  ACCEPTED: 202,
  NO_CONTENT: 204,
  MULTIPLE_CHOICES: 300,
  MOVED_PERMANENTLY: 301,
  FOUND: 302,
  SEE_OTHER: 303,
  NOT_MODIFIED: 304,
  TEMPORARY_REDIRECT: 307,
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  PAYMENT_REQUIRED: 402,
  FORBIDDEN: 403,
  NOT_FOUND: 404,
  METHOD_NOT_ALLOWED: 405,
  NOT_ACCEPTABLE: 406,
  PROXY_AUTHENTICATION_REQUIRED: 407,
  REQUEST_TIMEOUT: 408,
  CONFLICT: 409,
  GONE: 410,
  LENGTH_REQUIRED: 411,
  PRECONDITION_FAILED: 412,
  PAYLOAD_TOO_LARGE: 413,
  URI_TOO_LONG: 414,
  UNSUPPORTED_MEDIA_TYPE: 415,
  RANGE_NOT_SATISFIABLE: 416,
  EXPECTATION_FAILED: 417,
  "I'M_A_TEAPOT": 418,
  MISDIRECTED_REQUEST: 421,
  UNPROCESSABLE_ENTITY: 422,
  LOCKED: 423,
  FAILED_DEPENDENCY: 424,
  TOO_EARLY: 425,
  UPGRADE_REQUIRED: 426,
  PRECONDITION_REQUIRED: 428,
  TOO_MANY_REQUESTS: 429,
  REQUEST_HEADER_FIELDS_TOO_LARGE: 431,
  UNAVAILABLE_FOR_LEGAL_REASONS: 451,
  INTERNAL_SERVER_ERROR: 500,
  NOT_IMPLEMENTED: 501,
  BAD_GATEWAY: 502,
  SERVICE_UNAVAILABLE: 503,
  GATEWAY_TIMEOUT: 504,
  HTTP_VERSION_NOT_SUPPORTED: 505,
  VARIANT_ALSO_NEGOTIATES: 506,
  INSUFFICIENT_STORAGE: 507,
  LOOP_DETECTED: 508,
  NOT_EXTENDED: 510,
  NETWORK_AUTHENTICATION_REQUIRED: 511
};
var InternalAPIError$1 = class InternalAPIError extends Error {
  constructor(status = "INTERNAL_SERVER_ERROR", body = void 0, headers = {}, statusCode = typeof status === "number" ? status : statusCodes$1[status]) {
    super(body?.message, body?.cause ? { cause: body.cause } : void 0);
    this.status = status;
    this.body = body;
    this.headers = headers;
    this.statusCode = statusCode;
    this.name = "APIError";
    this.status = status;
    this.headers = headers;
    this.statusCode = statusCode;
    this.body = body ? {
      code: body?.message?.toUpperCase().replace(/ /g, "_").replace(/[^A-Z0-9_]/g, ""),
      ...body
    } : void 0;
  }
};
var ValidationError$2 = class ValidationError extends InternalAPIError$1 {
  constructor(message2, issues) {
    super(400, {
      message: message2,
      code: "VALIDATION_ERROR"
    });
    this.message = message2;
    this.issues = issues;
    this.issues = issues;
  }
};
var BetterCallError$1 = class BetterCallError extends Error {
  constructor(message2) {
    super(message2);
    this.name = "BetterCallError";
  }
};
const APIError$1 = makeErrorForHideStackFrame$1(InternalAPIError$1, Error);
const jsonContentTypeRegex = /^application\/([a-z0-9.+-]*\+)?json/i;
async function getBody$1(request, allowedMediaTypes) {
  const contentType = request.headers.get("content-type") || "";
  const normalizedContentType = contentType.toLowerCase();
  if (!request.body) return;
  if (allowedMediaTypes && allowedMediaTypes.length > 0) {
    if (!allowedMediaTypes.some((allowed2) => {
      const normalizedContentTypeBase = normalizedContentType.split(";")[0].trim();
      const normalizedAllowed = allowed2.toLowerCase().trim();
      return normalizedContentTypeBase === normalizedAllowed || normalizedContentTypeBase.includes(normalizedAllowed);
    })) {
      if (!normalizedContentType) throw new APIError$1(415, {
        message: `Content-Type is required. Allowed types: ${allowedMediaTypes.join(", ")}`,
        code: "UNSUPPORTED_MEDIA_TYPE"
      });
      throw new APIError$1(415, {
        message: `Content-Type "${contentType}" is not allowed. Allowed types: ${allowedMediaTypes.join(", ")}`,
        code: "UNSUPPORTED_MEDIA_TYPE"
      });
    }
  }
  if (jsonContentTypeRegex.test(normalizedContentType)) return await request.json();
  if (normalizedContentType.includes("application/x-www-form-urlencoded")) {
    const formData = await request.formData();
    const result2 = {};
    formData.forEach((value, key) => {
      result2[key] = value.toString();
    });
    return result2;
  }
  if (normalizedContentType.includes("multipart/form-data")) {
    const formData = await request.formData();
    const result2 = {};
    formData.forEach((value, key) => {
      result2[key] = value;
    });
    return result2;
  }
  if (normalizedContentType.includes("text/plain")) return await request.text();
  if (normalizedContentType.includes("application/octet-stream")) return await request.arrayBuffer();
  if (normalizedContentType.includes("application/pdf") || normalizedContentType.includes("image/") || normalizedContentType.includes("video/")) return await request.blob();
  if (normalizedContentType.includes("application/stream") || request.body instanceof ReadableStream) return request.body;
  return await request.text();
}
function isAPIError$1(error2) {
  return error2 instanceof APIError$1 || error2?.name === "APIError";
}
function tryDecode$1(str) {
  try {
    return str.includes("%") ? decodeURIComponent(str) : str;
  } catch {
    return str;
  }
}
async function tryCatch$1(promise) {
  try {
    return {
      data: await promise,
      error: null
    };
  } catch (error2) {
    return {
      data: null,
      error: error2
    };
  }
}
function isRequest$1(obj) {
  return obj instanceof Request || Object.prototype.toString.call(obj) === "[object Request]";
}
function isJSONSerializable$2(value) {
  if (value === void 0) return false;
  const t2 = typeof value;
  if (t2 === "string" || t2 === "number" || t2 === "boolean" || t2 === null) return true;
  if (t2 !== "object") return false;
  if (Array.isArray(value)) return true;
  if (value.buffer) return false;
  return value.constructor && value.constructor.name === "Object" || typeof value.toJSON === "function";
}
function safeStringify$1(obj, replacer, space) {
  let id = 0;
  const seen = /* @__PURE__ */ new WeakMap();
  const safeReplacer = (key, value) => {
    if (typeof value === "bigint") return value.toString();
    if (typeof value === "object" && value !== null) {
      if (seen.has(value)) return `[Circular ref-${seen.get(value)}]`;
      seen.set(value, id++);
    }
    return value;
  };
  return JSON.stringify(obj, safeReplacer, space);
}
function isJSONResponse$1(value) {
  if (!value || typeof value !== "object") return false;
  return "_flag" in value && value._flag === "json";
}
function toResponse$1(data, init2) {
  if (data instanceof Response) {
    if (init2?.headers instanceof Headers) init2.headers.forEach((value, key) => {
      data.headers.set(key, value);
    });
    return data;
  }
  if (isJSONResponse$1(data)) {
    const body$1 = data.body;
    const routerResponse = data.routerResponse;
    if (routerResponse instanceof Response) return routerResponse;
    const headers$1 = new Headers();
    if (routerResponse?.headers) {
      const headers$2 = new Headers(routerResponse.headers);
      for (const [key, value] of headers$2.entries()) headers$2.set(key, value);
    }
    if (data.headers) for (const [key, value] of new Headers(data.headers).entries()) headers$1.set(key, value);
    if (init2?.headers) for (const [key, value] of new Headers(init2.headers).entries()) headers$1.set(key, value);
    headers$1.set("Content-Type", "application/json");
    return new Response(JSON.stringify(body$1), {
      ...routerResponse,
      headers: headers$1,
      status: data.status ?? init2?.status ?? routerResponse?.status,
      statusText: init2?.statusText ?? routerResponse?.statusText
    });
  }
  if (isAPIError$1(data)) return toResponse$1(data.body, {
    status: init2?.status ?? data.statusCode,
    statusText: data.status.toString(),
    headers: init2?.headers || data.headers
  });
  let body = data;
  let headers = new Headers(init2?.headers);
  if (!data) {
    if (data === null) body = JSON.stringify(null);
    headers.set("content-type", "application/json");
  } else if (typeof data === "string") {
    body = data;
    headers.set("Content-Type", "text/plain");
  } else if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {
    body = data;
    headers.set("Content-Type", "application/octet-stream");
  } else if (data instanceof Blob) {
    body = data;
    headers.set("Content-Type", data.type || "application/octet-stream");
  } else if (data instanceof FormData) body = data;
  else if (data instanceof URLSearchParams) {
    body = data;
    headers.set("Content-Type", "application/x-www-form-urlencoded");
  } else if (data instanceof ReadableStream) {
    body = data;
    headers.set("Content-Type", "application/octet-stream");
  } else if (isJSONSerializable$2(data)) {
    body = safeStringify$1(data);
    headers.set("Content-Type", "application/json");
  }
  return new Response(body, {
    ...init2,
    headers
  });
}
const algorithm$1 = {
  name: "HMAC",
  hash: "SHA-256"
};
const getCryptoKey$1 = async (secret) => {
  const secretBuf = typeof secret === "string" ? new TextEncoder().encode(secret) : secret;
  return await getWebcryptoSubtle().importKey("raw", secretBuf, algorithm$1, false, ["sign", "verify"]);
};
const verifySignature$1 = async (base64Signature, value, secret) => {
  try {
    const signatureBinStr = atob(base64Signature);
    const signature = new Uint8Array(signatureBinStr.length);
    for (let i = 0, len = signatureBinStr.length; i < len; i++) signature[i] = signatureBinStr.charCodeAt(i);
    return await getWebcryptoSubtle().verify(algorithm$1, secret, signature, new TextEncoder().encode(value));
  } catch (e2) {
    return false;
  }
};
const makeSignature$1 = async (value, secret) => {
  const key = await getCryptoKey$1(secret);
  const signature = await getWebcryptoSubtle().sign(algorithm$1.name, key, new TextEncoder().encode(value));
  return btoa(String.fromCharCode(...new Uint8Array(signature)));
};
const signCookieValue$1 = async (value, secret) => {
  const signature = await makeSignature$1(value, secret);
  value = `${value}.${signature}`;
  value = encodeURIComponent(value);
  return value;
};
const getCookieKey$1 = (key, prefix) => {
  let finalKey = key;
  if (prefix) if (prefix === "secure") finalKey = "__Secure-" + key;
  else if (prefix === "host") finalKey = "__Host-" + key;
  else return;
  return finalKey;
};
function parseCookies$1(str) {
  if (typeof str !== "string") throw new TypeError("argument str must be a string");
  const cookies2 = /* @__PURE__ */ new Map();
  let index2 = 0;
  while (index2 < str.length) {
    const eqIdx = str.indexOf("=", index2);
    if (eqIdx === -1) break;
    let endIdx = str.indexOf(";", index2);
    if (endIdx === -1) endIdx = str.length;
    else if (endIdx < eqIdx) {
      index2 = str.lastIndexOf(";", eqIdx - 1) + 1;
      continue;
    }
    const key = str.slice(index2, eqIdx).trim();
    if (!cookies2.has(key)) {
      let val = str.slice(eqIdx + 1, endIdx).trim();
      if (val.codePointAt(0) === 34) val = val.slice(1, -1);
      cookies2.set(key, tryDecode$1(val));
    }
    index2 = endIdx + 1;
  }
  return cookies2;
}
const _serialize$1 = (key, value, opt = {}) => {
  let cookie;
  if (opt?.prefix === "secure") cookie = `${`__Secure-${key}`}=${value}`;
  else if (opt?.prefix === "host") cookie = `${`__Host-${key}`}=${value}`;
  else cookie = `${key}=${value}`;
  if (key.startsWith("__Secure-") && !opt.secure) opt.secure = true;
  if (key.startsWith("__Host-")) {
    if (!opt.secure) opt.secure = true;
    if (opt.path !== "/") opt.path = "/";
    if (opt.domain) opt.domain = void 0;
  }
  if (opt && typeof opt.maxAge === "number" && opt.maxAge >= 0) {
    if (opt.maxAge > 3456e4) throw new Error("Cookies Max-Age SHOULD NOT be greater than 400 days (34560000 seconds) in duration.");
    cookie += `; Max-Age=${Math.floor(opt.maxAge)}`;
  }
  if (opt.domain && opt.prefix !== "host") cookie += `; Domain=${opt.domain}`;
  if (opt.path) cookie += `; Path=${opt.path}`;
  if (opt.expires) {
    if (opt.expires.getTime() - Date.now() > 3456e7) throw new Error("Cookies Expires SHOULD NOT be greater than 400 days (34560000 seconds) in the future.");
    cookie += `; Expires=${opt.expires.toUTCString()}`;
  }
  if (opt.httpOnly) cookie += "; HttpOnly";
  if (opt.secure) cookie += "; Secure";
  if (opt.sameSite) cookie += `; SameSite=${opt.sameSite.charAt(0).toUpperCase() + opt.sameSite.slice(1)}`;
  if (opt.partitioned) {
    if (!opt.secure) opt.secure = true;
    cookie += "; Partitioned";
  }
  return cookie;
};
const serializeCookie$1 = (key, value, opt) => {
  value = encodeURIComponent(value);
  return _serialize$1(key, value, opt);
};
const serializeSignedCookie$1 = async (key, value, secret, opt) => {
  value = await signCookieValue$1(value, secret);
  return _serialize$1(key, value, opt);
};
async function runValidation$1(options, context = {}) {
  let request = {
    body: context.body,
    query: context.query
  };
  if (options.body) {
    const result2 = await options.body["~standard"].validate(context.body);
    if (result2.issues) return {
      data: null,
      error: fromError$1(result2.issues, "body")
    };
    request.body = result2.value;
  }
  if (options.query) {
    const result2 = await options.query["~standard"].validate(context.query);
    if (result2.issues) return {
      data: null,
      error: fromError$1(result2.issues, "query")
    };
    request.query = result2.value;
  }
  if (options.requireHeaders && !context.headers) return {
    data: null,
    error: {
      message: "Headers is required",
      issues: []
    }
  };
  if (options.requireRequest && !context.request) return {
    data: null,
    error: {
      message: "Request is required",
      issues: []
    }
  };
  return {
    data: request,
    error: null
  };
}
function fromError$1(error2, validating) {
  return {
    message: error2.map((e2) => {
      return `[${e2.path?.length ? `${validating}.` + e2.path.map((x) => typeof x === "object" ? x.key : x).join(".") : validating}] ${e2.message}`;
    }).join("; "),
    issues: error2
  };
}
const createInternalContext$1 = async (context, { options, path }) => {
  const headers = new Headers();
  let responseStatus = void 0;
  const { data, error: error2 } = await runValidation$1(options, context);
  if (error2) throw new ValidationError$2(error2.message, error2.issues);
  const requestHeaders = "headers" in context ? context.headers instanceof Headers ? context.headers : new Headers(context.headers) : "request" in context && isRequest$1(context.request) ? context.request.headers : null;
  const requestCookies = requestHeaders?.get("cookie");
  const parsedCookies = requestCookies ? parseCookies$1(requestCookies) : void 0;
  const internalContext = {
    ...context,
    body: data.body,
    query: data.query,
    path: context.path || path || "virtual:",
    context: "context" in context && context.context ? context.context : {},
    returned: void 0,
    headers: context?.headers,
    request: context?.request,
    params: "params" in context ? context.params : void 0,
    method: context.method ?? (Array.isArray(options.method) ? options.method[0] : options.method === "*" ? "GET" : options.method),
    setHeader: (key, value) => {
      headers.set(key, value);
    },
    getHeader: (key) => {
      if (!requestHeaders) return null;
      return requestHeaders.get(key);
    },
    getCookie: (key, prefix) => {
      const finalKey = getCookieKey$1(key, prefix);
      if (!finalKey) return null;
      return parsedCookies?.get(finalKey) || null;
    },
    getSignedCookie: async (key, secret, prefix) => {
      const finalKey = getCookieKey$1(key, prefix);
      if (!finalKey) return null;
      const value = parsedCookies?.get(finalKey);
      if (!value) return null;
      const signatureStartPos = value.lastIndexOf(".");
      if (signatureStartPos < 1) return null;
      const signedValue = value.substring(0, signatureStartPos);
      const signature = value.substring(signatureStartPos + 1);
      if (signature.length !== 44 || !signature.endsWith("=")) return null;
      return await verifySignature$1(signature, signedValue, await getCryptoKey$1(secret)) ? signedValue : false;
    },
    setCookie: (key, value, options$1) => {
      const cookie = serializeCookie$1(key, value, options$1);
      headers.append("set-cookie", cookie);
      return cookie;
    },
    setSignedCookie: async (key, value, secret, options$1) => {
      const cookie = await serializeSignedCookie$1(key, value, secret, options$1);
      headers.append("set-cookie", cookie);
      return cookie;
    },
    redirect: (url) => {
      headers.set("location", url);
      return new APIError$1("FOUND", void 0, headers);
    },
    error: (status, body, headers$1) => {
      return new APIError$1(status, body, headers$1);
    },
    setStatus: (status) => {
      responseStatus = status;
    },
    json: (json2, routerResponse) => {
      if (!context.asResponse) return json2;
      return {
        body: routerResponse?.body || json2,
        routerResponse,
        _flag: "json"
      };
    },
    responseHeaders: headers,
    get responseStatus() {
      return responseStatus;
    }
  };
  for (const middleware of options.use || []) {
    const response = await middleware({
      ...internalContext,
      returnHeaders: true,
      asResponse: false
    });
    if (response.response) Object.assign(internalContext.context, response.response);
    if (response.headers) response.headers.forEach((value, key) => {
      internalContext.responseHeaders.set(key, value);
    });
  }
  return internalContext;
};
function createEndpoint$1(pathOrOptions, handlerOrOptions, handlerOrNever) {
  const path = typeof pathOrOptions === "string" ? pathOrOptions : void 0;
  const options = typeof handlerOrOptions === "object" ? handlerOrOptions : pathOrOptions;
  const handler2 = typeof handlerOrOptions === "function" ? handlerOrOptions : handlerOrNever;
  if ((options.method === "GET" || options.method === "HEAD") && options.body) throw new BetterCallError$1("Body is not allowed with GET or HEAD methods");
  if (path && /\/{2,}/.test(path)) throw new BetterCallError$1("Path cannot contain consecutive slashes");
  const internalHandler = async (...inputCtx) => {
    const context = inputCtx[0] || {};
    const { data: internalContext, error: validationError } = await tryCatch$1(createInternalContext$1(context, {
      options,
      path
    }));
    if (validationError) {
      if (!(validationError instanceof ValidationError$2)) throw validationError;
      if (options.onValidationError) await options.onValidationError({
        message: validationError.message,
        issues: validationError.issues
      });
      throw new APIError$1(400, {
        message: validationError.message,
        code: "VALIDATION_ERROR"
      });
    }
    const response = await handler2(internalContext).catch(async (e2) => {
      if (isAPIError$1(e2)) {
        const onAPIError = options.onAPIError;
        if (onAPIError) await onAPIError(e2);
        if (context.asResponse) return e2;
      }
      throw e2;
    });
    const headers = internalContext.responseHeaders;
    const status = internalContext.responseStatus;
    return context.asResponse ? toResponse$1(response, {
      headers,
      status
    }) : context.returnHeaders ? context.returnStatus ? {
      headers,
      response,
      status
    } : {
      headers,
      response
    } : context.returnStatus ? {
      response,
      status
    } : response;
  };
  internalHandler.options = options;
  internalHandler.path = path;
  return internalHandler;
}
createEndpoint$1.create = (opts) => {
  return (path, options, handler2) => {
    return createEndpoint$1(path, {
      ...options,
      use: [...options?.use || [], ...opts?.use || []]
    }, handler2);
  };
};
const paths = {};
function getTypeFromZodType(zodType) {
  switch (zodType.constructor.name) {
    case "ZodString":
      return "string";
    case "ZodNumber":
      return "number";
    case "ZodBoolean":
      return "boolean";
    case "ZodObject":
      return "object";
    case "ZodArray":
      return "array";
    default:
      return "string";
  }
}
function getParameters(options) {
  const parameters = [];
  if (options.metadata?.openapi?.parameters) {
    parameters.push(...options.metadata.openapi.parameters);
    return parameters;
  }
  if (options.query instanceof ZodObject) Object.entries(options.query.shape).forEach(([key, value]) => {
    if (value instanceof ZodObject) parameters.push({
      name: key,
      in: "query",
      schema: {
        type: getTypeFromZodType(value),
        ..."minLength" in value && value.minLength ? { minLength: value.minLength } : {},
        description: value.description
      }
    });
  });
  return parameters;
}
function getRequestBody(options) {
  if (options.metadata?.openapi?.requestBody) return options.metadata.openapi.requestBody;
  if (!options.body) return void 0;
  if (options.body instanceof ZodObject || options.body instanceof ZodOptional) {
    const shape = options.body.shape;
    if (!shape) return void 0;
    const properties = {};
    const required = [];
    Object.entries(shape).forEach(([key, value]) => {
      if (value instanceof ZodObject) {
        properties[key] = {
          type: getTypeFromZodType(value),
          description: value.description
        };
        if (!(value instanceof ZodOptional)) required.push(key);
      }
    });
    return {
      required: options.body instanceof ZodOptional ? false : options.body ? true : false,
      content: { "application/json": { schema: {
        type: "object",
        properties,
        required
      } } }
    };
  }
}
function getResponse(responses) {
  return {
    "400": {
      content: { "application/json": { schema: {
        type: "object",
        properties: { message: { type: "string" } },
        required: ["message"]
      } } },
      description: "Bad Request. Usually due to missing parameters, or invalid parameters."
    },
    "401": {
      content: { "application/json": { schema: {
        type: "object",
        properties: { message: { type: "string" } },
        required: ["message"]
      } } },
      description: "Unauthorized. Due to missing or invalid authentication."
    },
    "403": {
      content: { "application/json": { schema: {
        type: "object",
        properties: { message: { type: "string" } }
      } } },
      description: "Forbidden. You do not have permission to access this resource or to perform this action."
    },
    "404": {
      content: { "application/json": { schema: {
        type: "object",
        properties: { message: { type: "string" } }
      } } },
      description: "Not Found. The requested resource was not found."
    },
    "429": {
      content: { "application/json": { schema: {
        type: "object",
        properties: { message: { type: "string" } }
      } } },
      description: "Too Many Requests. You have exceeded the rate limit. Try again later."
    },
    "500": {
      content: { "application/json": { schema: {
        type: "object",
        properties: { message: { type: "string" } }
      } } },
      description: "Internal Server Error. This is a problem with the server that you cannot fix."
    },
    ...responses
  };
}
async function generator(endpoints, config2) {
  const components = { schemas: {} };
  Object.entries(endpoints).forEach(([_, value]) => {
    const options = value.options;
    if (!value.path || options.metadata?.SERVER_ONLY) return;
    if (options.method === "GET") paths[value.path] = { get: {
      tags: ["Default", ...options.metadata?.openapi?.tags || []],
      description: options.metadata?.openapi?.description,
      operationId: options.metadata?.openapi?.operationId,
      security: [{ bearerAuth: [] }],
      parameters: getParameters(options),
      responses: getResponse(options.metadata?.openapi?.responses)
    } };
    if (options.method === "POST") {
      const body = getRequestBody(options);
      paths[value.path] = { post: {
        tags: ["Default", ...options.metadata?.openapi?.tags || []],
        description: options.metadata?.openapi?.description,
        operationId: options.metadata?.openapi?.operationId,
        security: [{ bearerAuth: [] }],
        parameters: getParameters(options),
        ...body ? { requestBody: body } : { requestBody: { content: { "application/json": { schema: {
          type: "object",
          properties: {}
        } } } } },
        responses: getResponse(options.metadata?.openapi?.responses)
      } };
    }
  });
  return {
    openapi: "3.1.1",
    info: {
      title: "Better Auth",
      description: "API Reference for your Better Auth Instance",
      version: "1.1.0"
    },
    components,
    security: [{ apiKeyCookie: [] }],
    servers: [{ url: config2?.url }],
    tags: [{
      name: "Default",
      description: "Default endpoints that are included with Better Auth by default. These endpoints are not part of any plugin."
    }],
    paths
  };
}
const getHTML = (apiReference, config2) => `<!doctype html>
<html>
  <head>
    <title>Scalar API Reference</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1" />
  </head>
  <body>
    <script
      id="api-reference"
      type="application/json">
    ${JSON.stringify(apiReference)}
    <\/script>
	 <script>
      var configuration = {
	  	favicon: ${config2?.logo ? `data:image/svg+xml;utf8,${encodeURIComponent(config2.logo)}` : void 0} ,
	   	theme: ${config2?.theme || "saturn"},
        metaData: {
			title: ${config2?.title || "Open API Reference"},
			description: ${config2?.description || "Better Call Open API"},
		}
      }
      document.getElementById('api-reference').dataset.configuration =
        JSON.stringify(configuration)
    <\/script>
	  <script src="https://cdn.jsdelivr.net/npm/@scalar/api-reference"><\/script>
  </body>
</html>`;
const createRouter$1 = (endpoints, config2) => {
  if (!config2?.openapi?.disabled) {
    const openapi = {
      path: "/api/reference",
      ...config2?.openapi
    };
    endpoints["openapi"] = createEndpoint$1(openapi.path, { method: "GET" }, async (c2) => {
      const schema2 = await generator(endpoints);
      return new Response(getHTML(schema2, openapi.scalar), { headers: { "Content-Type": "text/html" } });
    });
  }
  const router2 = createRouter();
  const middlewareRouter = createRouter();
  for (const endpoint of Object.values(endpoints)) {
    if (!endpoint.options || !endpoint.path) continue;
    if (endpoint.options?.metadata?.SERVER_ONLY) continue;
    const methods2 = Array.isArray(endpoint.options?.method) ? endpoint.options.method : [endpoint.options?.method];
    for (const method of methods2) addRoute(router2, method, endpoint.path, endpoint);
  }
  if (config2?.routerMiddleware?.length) for (const { path, middleware } of config2.routerMiddleware) addRoute(middlewareRouter, "*", path, middleware);
  const processRequest = async (request) => {
    const url = new URL(request.url);
    const pathname = url.pathname;
    const path = config2?.basePath && config2.basePath !== "/" ? pathname.split(config2.basePath).reduce((acc, curr, index2) => {
      if (index2 !== 0) if (index2 > 1) acc.push(`${config2.basePath}${curr}`);
      else acc.push(curr);
      return acc;
    }, []).join("") : url.pathname;
    if (!path?.length) return new Response(null, {
      status: 404,
      statusText: "Not Found"
    });
    if (/\/{2,}/.test(path)) return new Response(null, {
      status: 404,
      statusText: "Not Found"
    });
    const route = findRoute(router2, request.method, path);
    if (path.endsWith("/") !== route?.data?.path?.endsWith("/") && !config2?.skipTrailingSlashes) return new Response(null, {
      status: 404,
      statusText: "Not Found"
    });
    if (!route?.data) return new Response(null, {
      status: 404,
      statusText: "Not Found"
    });
    const query2 = {};
    url.searchParams.forEach((value, key) => {
      if (key in query2) if (Array.isArray(query2[key])) query2[key].push(value);
      else query2[key] = [query2[key], value];
      else query2[key] = value;
    });
    const handler2 = route.data;
    try {
      const allowedMediaTypes = handler2.options.metadata?.allowedMediaTypes || config2?.allowedMediaTypes;
      const context = {
        path,
        method: request.method,
        headers: request.headers,
        params: route.params ? JSON.parse(JSON.stringify(route.params)) : {},
        request,
        body: handler2.options.disableBody ? void 0 : await getBody$1(handler2.options.cloneRequest ? request.clone() : request, allowedMediaTypes),
        query: query2,
        _flag: "router",
        asResponse: true,
        context: config2?.routerContext
      };
      const middlewareRoutes = findAllRoutes(middlewareRouter, "*", path);
      if (middlewareRoutes?.length) for (const { data: middleware, params } of middlewareRoutes) {
        const res2 = await middleware({
          ...context,
          params,
          asResponse: false
        });
        if (res2 instanceof Response) return res2;
      }
      return await handler2(context);
    } catch (error2) {
      if (config2?.onError) try {
        const errorResponse = await config2.onError(error2);
        if (errorResponse instanceof Response) return toResponse$1(errorResponse);
      } catch (error$1) {
        if (isAPIError$1(error$1)) return toResponse$1(error$1);
        throw error$1;
      }
      if (config2?.throwError) throw error2;
      if (isAPIError$1(error2)) return toResponse$1(error2);
      console.error(`# SERVER_ERROR: `, error2);
      return new Response(null, {
        status: 500,
        statusText: "Internal Server Error"
      });
    }
  };
  return {
    handler: async (request) => {
      const onReq = await config2?.onRequest?.(request);
      if (onReq instanceof Response) return onReq;
      const res2 = await processRequest(isRequest$1(onReq) ? onReq : request);
      const onRes = await config2?.onResponse?.(res2);
      if (onRes instanceof Response) return onRes;
      return res2;
    },
    endpoints
  };
};
const cache = /* @__PURE__ */ new WeakMap();
function parseOutputData(data, schema2) {
  const fields2 = schema2.fields;
  const parsedData = {};
  for (const key in data) {
    const field = fields2[key];
    if (!field) {
      parsedData[key] = data[key];
      continue;
    }
    if (field.returned === false && key !== "id") continue;
    parsedData[key] = data[key];
  }
  return parsedData;
}
function getFields(options, table, mode) {
  const cacheKey = `${table}:${mode}`;
  if (!cache.has(options)) cache.set(options, /* @__PURE__ */ new Map());
  const tableCache = cache.get(options);
  if (tableCache.has(cacheKey)) return tableCache.get(cacheKey);
  const coreSchema2 = mode === "output" ? getAuthTables(options)[table]?.fields ?? {} : {};
  const additionalFields = table === "user" || table === "session" || table === "account" ? options[table]?.additionalFields : void 0;
  let schema2 = {
    ...coreSchema2,
    ...additionalFields ?? {}
  };
  for (const plugin of options.plugins || []) if (plugin.schema && plugin.schema[table]) schema2 = {
    ...schema2,
    ...plugin.schema[table].fields
  };
  tableCache.set(cacheKey, schema2);
  return schema2;
}
function parseUserOutput(options, user) {
  return parseOutputData(user, { fields: getFields(options, "user", "output") });
}
function parseSessionOutput(options, session) {
  return parseOutputData(session, { fields: getFields(options, "session", "output") });
}
function parseAccountOutput(options, account) {
  const { accessToken: _accessToken, refreshToken: _refreshToken, idToken: _idToken, accessTokenExpiresAt: _accessTokenExpiresAt, refreshTokenExpiresAt: _refreshTokenExpiresAt, password: _password, ...rest } = parseOutputData(account, { fields: getFields(options, "account", "output") });
  return rest;
}
function parseInputData(data, schema2) {
  const action = schema2.action || "create";
  const fields2 = schema2.fields;
  const parsedData = Object.assign(/* @__PURE__ */ Object.create(null), null);
  for (const key in fields2) {
    if (key in data) {
      if (fields2[key].input === false) {
        if (fields2[key].defaultValue !== void 0) {
          if (action !== "update") {
            parsedData[key] = fields2[key].defaultValue;
            continue;
          }
        }
        if (data[key]) throw new APIError$1("BAD_REQUEST", { message: `${key} is not allowed to be set` });
        continue;
      }
      if (fields2[key].validator?.input && data[key] !== void 0) {
        const result2 = fields2[key].validator.input["~standard"].validate(data[key]);
        if (result2 instanceof Promise) throw new APIError$1("INTERNAL_SERVER_ERROR", { message: "Async validation is not supported for additional fields" });
        if ("issues" in result2 && result2.issues) throw new APIError$1("BAD_REQUEST", { message: result2.issues[0]?.message || "Validation Error" });
        parsedData[key] = result2.value;
        continue;
      }
      if (fields2[key].transform?.input && data[key] !== void 0) {
        parsedData[key] = fields2[key].transform?.input(data[key]);
        continue;
      }
      parsedData[key] = data[key];
      continue;
    }
    if (fields2[key].defaultValue !== void 0 && action === "create") {
      if (typeof fields2[key].defaultValue === "function") {
        parsedData[key] = fields2[key].defaultValue();
        continue;
      }
      parsedData[key] = fields2[key].defaultValue;
      continue;
    }
    if (fields2[key].required && action === "create") throw new APIError$1("BAD_REQUEST", { message: `${key} is required` });
  }
  return parsedData;
}
function parseUserInput(options, user = {}, action) {
  return parseInputData(user, {
    fields: getFields(options, "user", "input"),
    action
  });
}
function parseAdditionalUserInput(options, user) {
  const schema2 = getFields(options, "user", "input");
  return parseInputData(user || {}, { fields: schema2 });
}
function parseAccountInput(options, account) {
  return parseInputData(account, { fields: getFields(options, "account", "input") });
}
function parseSessionInput(options, session) {
  return parseInputData(session, { fields: getFields(options, "session", "input") });
}
function mergeSchema(schema2, newSchema) {
  if (!newSchema) return schema2;
  for (const table in newSchema) {
    const newModelName = newSchema[table]?.modelName;
    if (newModelName) schema2[table].modelName = newModelName;
    for (const field in schema2[table].fields) {
      const newField = newSchema[table]?.fields?.[field];
      if (!newField) continue;
      schema2[table].fields[field].fieldName = newField;
    }
  }
  return schema2;
}
const ALLOWED_COOKIE_SIZE = 4096;
const ESTIMATED_EMPTY_COOKIE_SIZE = 200;
const CHUNK_SIZE = ALLOWED_COOKIE_SIZE - ESTIMATED_EMPTY_COOKIE_SIZE;
function parseCookiesFromContext(ctx) {
  const cookieHeader = ctx.headers?.get("cookie");
  if (!cookieHeader) return {};
  const cookies2 = {};
  const pairs = cookieHeader.split("; ");
  for (const pair of pairs) {
    const [name2, ...valueParts] = pair.split("=");
    if (name2 && valueParts.length > 0) cookies2[name2] = valueParts.join("=");
  }
  return cookies2;
}
function getChunkIndex(cookieName) {
  const parts = cookieName.split(".");
  const lastPart = parts[parts.length - 1];
  const index2 = parseInt(lastPart || "0", 10);
  return isNaN(index2) ? 0 : index2;
}
function readExistingChunks(cookieName, ctx) {
  const chunks = {};
  const cookies2 = parseCookiesFromContext(ctx);
  for (const [name2, value] of Object.entries(cookies2)) if (name2.startsWith(cookieName)) chunks[name2] = value;
  return chunks;
}
function joinChunks(chunks) {
  return Object.keys(chunks).sort((a, b) => {
    return getChunkIndex(a) - getChunkIndex(b);
  }).map((key) => chunks[key]).join("");
}
function chunkCookie(storeName, cookie, chunks, logger2) {
  const chunkCount = Math.ceil(cookie.value.length / CHUNK_SIZE);
  if (chunkCount === 1) {
    chunks[cookie.name] = cookie.value;
    return [cookie];
  }
  const cookies2 = [];
  for (let i = 0; i < chunkCount; i++) {
    const name2 = `${cookie.name}.${i}`;
    const start = i * CHUNK_SIZE;
    const value = cookie.value.substring(start, start + CHUNK_SIZE);
    cookies2.push({
      ...cookie,
      name: name2,
      value
    });
    chunks[name2] = value;
  }
  logger2.debug(`CHUNKING_${storeName.toUpperCase()}_COOKIE`, {
    message: `${storeName} cookie exceeds allowed ${ALLOWED_COOKIE_SIZE} bytes.`,
    emptyCookieSize: ESTIMATED_EMPTY_COOKIE_SIZE,
    valueSize: cookie.value.length,
    chunkCount,
    chunks: cookies2.map((c2) => c2.value.length + ESTIMATED_EMPTY_COOKIE_SIZE)
  });
  return cookies2;
}
function getCleanCookies(chunks, cookieOptions) {
  const cleanedChunks = {};
  for (const name2 in chunks) cleanedChunks[name2] = {
    name: name2,
    value: "",
    attributes: {
      ...cookieOptions,
      maxAge: 0
    }
  };
  return cleanedChunks;
}
const storeFactory = (storeName) => (cookieName, cookieOptions, ctx) => {
  const chunks = readExistingChunks(cookieName, ctx);
  const logger2 = ctx.context.logger;
  return {
    getValue() {
      return joinChunks(chunks);
    },
    hasChunks() {
      return Object.keys(chunks).length > 0;
    },
    chunk(value, options) {
      const cleanedChunks = getCleanCookies(chunks, cookieOptions);
      for (const name2 in chunks) delete chunks[name2];
      const cookies2 = cleanedChunks;
      const chunked = chunkCookie(storeName, {
        name: cookieName,
        value,
        attributes: {
          ...cookieOptions,
          ...options
        }
      }, chunks, logger2);
      for (const chunk of chunked) cookies2[chunk.name] = chunk;
      return Object.values(cookies2);
    },
    clean() {
      const cleanedChunks = getCleanCookies(chunks, cookieOptions);
      for (const name2 in chunks) delete chunks[name2];
      return Object.values(cleanedChunks);
    },
    setCookies(cookies2) {
      for (const cookie of cookies2) ctx.setCookie(cookie.name, cookie.value, cookie.attributes);
    }
  };
};
const createSessionStore = storeFactory("Session");
const createAccountStore = storeFactory("Account");
function getChunkedCookie(ctx, cookieName) {
  const value = ctx.getCookie(cookieName);
  if (value) return value;
  const chunks = [];
  const cookieHeader = ctx.headers?.get("cookie");
  if (!cookieHeader) return null;
  const cookies2 = {};
  const pairs = cookieHeader.split("; ");
  for (const pair of pairs) {
    const [name2, ...valueParts] = pair.split("=");
    if (name2 && valueParts.length > 0) cookies2[name2] = valueParts.join("=");
  }
  for (const [name2, val] of Object.entries(cookies2)) if (name2.startsWith(cookieName + ".")) {
    const indexStr = name2.split(".").at(-1);
    const index2 = parseInt(indexStr || "0", 10);
    if (!isNaN(index2)) chunks.push({
      index: index2,
      value: val
    });
  }
  if (chunks.length > 0) {
    chunks.sort((a, b) => a.index - b.index);
    return chunks.map((c2) => c2.value).join("");
  }
  return null;
}
async function setAccountCookie(c2, accountData) {
  const accountDataCookie = c2.context.authCookies.accountData;
  const options = {
    maxAge: 300,
    ...accountDataCookie.attributes
  };
  const data = await symmetricEncodeJWT(accountData, c2.context.secret, "better-auth-account", options.maxAge);
  if (data.length > ALLOWED_COOKIE_SIZE) {
    const accountStore = createAccountStore(accountDataCookie.name, options, c2);
    const cookies2 = accountStore.chunk(data, options);
    accountStore.setCookies(cookies2);
  } else {
    const accountStore = createAccountStore(accountDataCookie.name, options, c2);
    if (accountStore.hasChunks()) {
      const cleanCookies = accountStore.clean();
      accountStore.setCookies(cleanCookies);
    }
    c2.setCookie(accountDataCookie.name, data, options);
  }
}
async function getAccountCookie(c2) {
  const accountCookie = getChunkedCookie(c2, c2.context.authCookies.accountData.name);
  if (accountCookie) {
    const accountData = safeJSONParse(await symmetricDecodeJWT(accountCookie, c2.context.secret, "better-auth-account"));
    if (accountData) return accountData;
  }
  return null;
}
const getSessionQuerySchema = z.optional(z.object({
  disableCookieCache: z.coerce.boolean().meta({ description: "Disable cookie cache and fetch session from database" }).optional(),
  disableRefresh: z.coerce.boolean().meta({ description: "Disable session refresh. Useful for checking session status, without updating the session" }).optional()
}));
function isPromise(obj) {
  return !!obj && (typeof obj === "object" || typeof obj === "function") && typeof obj.then === "function";
}
const SEC$1 = 1e3;
const MIN$1 = SEC$1 * 60;
const HOUR$1 = MIN$1 * 60;
const DAY$1 = HOUR$1 * 24;
const WEEK = DAY$1 * 7;
const MONTH = DAY$1 * 30;
const YEAR$1 = DAY$1 * 365.25;
const REGEX = /^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|months?|mo|years?|yrs?|y)(?: (ago|from now))?$/i;
function parse$4(value) {
  const match2 = REGEX.exec(value);
  if (!match2 || match2[4] && match2[1]) throw new TypeError(`Invalid time string format: "${value}". Use formats like "7d", "30m", "1 hour", etc.`);
  const n2 = parseFloat(match2[2]);
  const unit = match2[3].toLowerCase();
  let result2;
  switch (unit) {
    case "years":
    case "year":
    case "yrs":
    case "yr":
    case "y":
      result2 = n2 * YEAR$1;
      break;
    case "months":
    case "month":
    case "mo":
      result2 = n2 * MONTH;
      break;
    case "weeks":
    case "week":
    case "w":
      result2 = n2 * WEEK;
      break;
    case "days":
    case "day":
    case "d":
      result2 = n2 * DAY$1;
      break;
    case "hours":
    case "hour":
    case "hrs":
    case "hr":
    case "h":
      result2 = n2 * HOUR$1;
      break;
    case "minutes":
    case "minute":
    case "mins":
    case "min":
    case "m":
      result2 = n2 * MIN$1;
      break;
    case "seconds":
    case "second":
    case "secs":
    case "sec":
    case "s":
      result2 = n2 * SEC$1;
      break;
    default:
      throw new TypeError(`Unknown time unit: "${unit}"`);
  }
  if (match2[1] === "-" || match2[4] === "ago") return -result2;
  return result2;
}
function ms(value) {
  return parse$4(value);
}
function sec(value) {
  return Math.round(parse$4(value) / 1e3);
}
const SECURE_COOKIE_PREFIX = "__Secure-";
function splitSetCookieHeader(setCookie) {
  if (!setCookie) return [];
  const result2 = [];
  let current = "";
  let i = 0;
  while (i < setCookie.length) {
    const c2 = setCookie[i];
    if (c2 === ",") {
      const lower = current.toLowerCase();
      if (lower.includes("expires=") && !lower.includes("gmt")) {
        current += c2;
        i++;
      } else {
        const trimmed$1 = current.trim();
        if (trimmed$1) result2.push(trimmed$1);
        current = "";
        i++;
        if (i < setCookie.length && setCookie[i] === " ") i++;
      }
      continue;
    }
    current += c2;
    i++;
  }
  const trimmed = current.trim();
  if (trimmed) result2.push(trimmed);
  return result2;
}
function parseSetCookieHeader(setCookie) {
  const cookies2 = /* @__PURE__ */ new Map();
  splitSetCookieHeader(setCookie).forEach((cookieString) => {
    const [nameValue, ...attributes] = cookieString.split(";").map((part) => part.trim());
    const [name2, ...valueParts] = (nameValue || "").split("=");
    const value = valueParts.join("=");
    if (!name2 || value === void 0) return;
    const attrObj = { value };
    attributes.forEach((attribute) => {
      const [attrName, ...attrValueParts] = attribute.split("=");
      const attrValue = attrValueParts.join("=");
      const normalizedAttrName = attrName.trim().toLowerCase();
      switch (normalizedAttrName) {
        case "max-age":
          attrObj["max-age"] = attrValue ? parseInt(attrValue.trim(), 10) : void 0;
          break;
        case "expires":
          attrObj.expires = attrValue ? new Date(attrValue.trim()) : void 0;
          break;
        case "domain":
          attrObj.domain = attrValue ? attrValue.trim() : void 0;
          break;
        case "path":
          attrObj.path = attrValue ? attrValue.trim() : void 0;
          break;
        case "secure":
          attrObj.secure = true;
          break;
        case "httponly":
          attrObj.httponly = true;
          break;
        case "samesite":
          attrObj.samesite = attrValue ? attrValue.trim().toLowerCase() : void 0;
          break;
        default:
          attrObj[normalizedAttrName] = attrValue ? attrValue.trim() : true;
          break;
      }
    });
    cookies2.set(name2, attrObj);
  });
  return cookies2;
}
const decoders = /* @__PURE__ */ new Map();
const encoder = new TextEncoder();
const binary = {
  decode: (data, encoding = "utf-8") => {
    if (!decoders.has(encoding)) {
      decoders.set(encoding, new TextDecoder(encoding));
    }
    const decoder2 = decoders.get(encoding);
    return decoder2.decode(data);
  },
  encode: encoder.encode
};
const createHMAC = (algorithm2 = "SHA-256", encoding = "none") => {
  const hmac2 = {
    importKey: async (key, keyUsage) => {
      return getWebcryptoSubtle().importKey(
        "raw",
        typeof key === "string" ? new TextEncoder().encode(key) : key,
        { name: "HMAC", hash: { name: algorithm2 } },
        false,
        [keyUsage]
      );
    },
    sign: async (hmacKey, data) => {
      if (typeof hmacKey === "string") {
        hmacKey = await hmac2.importKey(hmacKey, "sign");
      }
      const signature = await getWebcryptoSubtle().sign(
        "HMAC",
        hmacKey,
        typeof data === "string" ? new TextEncoder().encode(data) : data
      );
      if (encoding === "hex") {
        return hex.encode(signature);
      }
      if (encoding === "base64" || encoding === "base64url" || encoding === "base64urlnopad") {
        return base64Url.encode(signature, {
          padding: encoding !== "base64urlnopad"
        });
      }
      return signature;
    },
    verify: async (hmacKey, data, signature) => {
      if (typeof hmacKey === "string") {
        hmacKey = await hmac2.importKey(hmacKey, "verify");
      }
      if (encoding === "hex") {
        signature = hex.decode(signature);
      }
      if (encoding === "base64" || encoding === "base64url" || encoding === "base64urlnopad") {
        signature = await base64$1.decode(signature);
      }
      return getWebcryptoSubtle().verify(
        "HMAC",
        hmacKey,
        typeof signature === "string" ? new TextEncoder().encode(signature) : signature,
        typeof data === "string" ? new TextEncoder().encode(data) : data
      );
    }
  };
  return hmac2;
};
function createCookieGetter(options) {
  const secureCookiePrefix = (options.advanced?.useSecureCookies !== void 0 ? options.advanced?.useSecureCookies : options.baseURL ? options.baseURL.startsWith("https://") ? true : false : isProduction) ? SECURE_COOKIE_PREFIX : "";
  const crossSubdomainEnabled = !!options.advanced?.crossSubDomainCookies?.enabled;
  const domain = crossSubdomainEnabled ? options.advanced?.crossSubDomainCookies?.domain || (options.baseURL ? new URL(options.baseURL).hostname : void 0) : void 0;
  if (crossSubdomainEnabled && !domain) throw new BetterAuthError("baseURL is required when crossSubdomainCookies are enabled");
  function createCookie(cookieName, overrideAttributes = {}) {
    const prefix = options.advanced?.cookiePrefix || "better-auth";
    const name2 = options.advanced?.cookies?.[cookieName]?.name || `${prefix}.${cookieName}`;
    const attributes = options.advanced?.cookies?.[cookieName]?.attributes;
    return {
      name: `${secureCookiePrefix}${name2}`,
      attributes: {
        secure: !!secureCookiePrefix,
        sameSite: "lax",
        path: "/",
        httpOnly: true,
        ...crossSubdomainEnabled ? { domain } : {},
        ...options.advanced?.defaultCookieAttributes,
        ...overrideAttributes,
        ...attributes
      }
    };
  }
  return createCookie;
}
function getCookies(options) {
  const createCookie = createCookieGetter(options);
  const sessionToken = createCookie("session_token", { maxAge: options.session?.expiresIn || sec("7d") });
  const sessionData = createCookie("session_data", { maxAge: options.session?.cookieCache?.maxAge || 300 });
  const accountData = createCookie("account_data", { maxAge: options.session?.cookieCache?.maxAge || 300 });
  const dontRememberToken = createCookie("dont_remember");
  return {
    sessionToken: {
      name: sessionToken.name,
      attributes: sessionToken.attributes
    },
    sessionData: {
      name: sessionData.name,
      attributes: sessionData.attributes
    },
    dontRememberToken: {
      name: dontRememberToken.name,
      attributes: dontRememberToken.attributes
    },
    accountData: {
      name: accountData.name,
      attributes: accountData.attributes
    }
  };
}
async function setCookieCache(ctx, session, dontRememberMe) {
  if (!ctx.context.options.session?.cookieCache?.enabled) return;
  const filteredSession = filterOutputFields(session.session, ctx.context.options.session?.additionalFields);
  const filteredUser = parseUserOutput(ctx.context.options, session.user);
  const versionConfig = ctx.context.options.session?.cookieCache?.version;
  let version2 = "1";
  if (versionConfig) {
    if (typeof versionConfig === "string") version2 = versionConfig;
    else if (typeof versionConfig === "function") {
      const result2 = versionConfig(session.session, session.user);
      version2 = isPromise(result2) ? await result2 : result2;
    }
  }
  const sessionData = {
    session: filteredSession,
    user: filteredUser,
    updatedAt: Date.now(),
    version: version2
  };
  const options = {
    ...ctx.context.authCookies.sessionData.attributes,
    maxAge: dontRememberMe ? void 0 : ctx.context.authCookies.sessionData.attributes.maxAge
  };
  const expiresAtDate = getDate(options.maxAge || 60, "sec").getTime();
  const strategy = ctx.context.options.session?.cookieCache?.strategy || "compact";
  let data;
  if (strategy === "jwe") data = await symmetricEncodeJWT(sessionData, ctx.context.secret, "better-auth-session", options.maxAge || 300);
  else if (strategy === "jwt") data = await signJWT(sessionData, ctx.context.secret, options.maxAge || 300);
  else data = base64Url.encode(JSON.stringify({
    session: sessionData,
    expiresAt: expiresAtDate,
    signature: await createHMAC("SHA-256", "base64urlnopad").sign(ctx.context.secret, JSON.stringify({
      ...sessionData,
      expiresAt: expiresAtDate
    }))
  }), { padding: false });
  if (data.length > 4093) {
    const sessionStore = createSessionStore(ctx.context.authCookies.sessionData.name, options, ctx);
    const cookies2 = sessionStore.chunk(data, options);
    sessionStore.setCookies(cookies2);
  } else {
    const sessionStore = createSessionStore(ctx.context.authCookies.sessionData.name, options, ctx);
    if (sessionStore.hasChunks()) {
      const cleanCookies = sessionStore.clean();
      sessionStore.setCookies(cleanCookies);
    }
    ctx.setCookie(ctx.context.authCookies.sessionData.name, data, options);
  }
  if (ctx.context.options.account?.storeAccountCookie) {
    const accountData = await getAccountCookie(ctx);
    if (accountData) await setAccountCookie(ctx, accountData);
  }
}
async function setSessionCookie(ctx, session, dontRememberMe, overrides) {
  const dontRememberMeCookie = await ctx.getSignedCookie(ctx.context.authCookies.dontRememberToken.name, ctx.context.secret);
  dontRememberMe = dontRememberMe !== void 0 ? dontRememberMe : !!dontRememberMeCookie;
  const options = ctx.context.authCookies.sessionToken.attributes;
  const maxAge = dontRememberMe ? void 0 : ctx.context.sessionConfig.expiresIn;
  await ctx.setSignedCookie(ctx.context.authCookies.sessionToken.name, session.session.token, ctx.context.secret, {
    ...options,
    maxAge,
    ...overrides
  });
  if (dontRememberMe) await ctx.setSignedCookie(ctx.context.authCookies.dontRememberToken.name, "true", ctx.context.secret, ctx.context.authCookies.dontRememberToken.attributes);
  await setCookieCache(ctx, session, dontRememberMe);
  ctx.context.setNewSession(session);
}
function expireCookie(ctx, cookie) {
  ctx.setCookie(cookie.name, "", {
    ...cookie.attributes,
    maxAge: 0
  });
}
function deleteSessionCookie(ctx, skipDontRememberMe) {
  expireCookie(ctx, ctx.context.authCookies.sessionToken);
  expireCookie(ctx, ctx.context.authCookies.sessionData);
  if (ctx.context.options.account?.storeAccountCookie) {
    expireCookie(ctx, ctx.context.authCookies.accountData);
    const accountStore = createAccountStore(ctx.context.authCookies.accountData.name, ctx.context.authCookies.accountData.attributes, ctx);
    const cleanCookies$1 = accountStore.clean();
    accountStore.setCookies(cleanCookies$1);
  }
  if (ctx.context.oauthConfig.storeStateStrategy === "cookie") expireCookie(ctx, ctx.context.createAuthCookie("oauth_state"));
  const sessionStore = createSessionStore(ctx.context.authCookies.sessionData.name, ctx.context.authCookies.sessionData.attributes, ctx);
  const cleanCookies = sessionStore.clean();
  sessionStore.setCookies(cleanCookies);
  expireCookie(ctx, ctx.context.authCookies.dontRememberToken);
}
const stateDataSchema = z.looseObject({
  callbackURL: z.string(),
  codeVerifier: z.string(),
  errorURL: z.string().optional(),
  newUserURL: z.string().optional(),
  expiresAt: z.number(),
  link: z.object({
    email: z.string(),
    userId: z.coerce.string()
  }).optional(),
  requestSignUp: z.boolean().optional()
});
var StateError = class extends BetterAuthError {
  code;
  details;
  constructor(message2, options) {
    super(message2, options);
    this.code = options.code;
    this.details = options.details;
  }
};
async function generateGenericState(c2, stateData, settings) {
  const state = generateRandomString(32);
  if (c2.context.oauthConfig.storeStateStrategy === "cookie") {
    const encryptedData = await symmetricEncrypt({
      key: c2.context.secret,
      data: JSON.stringify(stateData)
    });
    const stateCookie$1 = c2.context.createAuthCookie("oauth_state", { maxAge: 600 });
    c2.setCookie(stateCookie$1.name, encryptedData, stateCookie$1.attributes);
    return {
      state,
      codeVerifier: stateData.codeVerifier
    };
  }
  const stateCookie = c2.context.createAuthCookie("state", { maxAge: 300 });
  await c2.setSignedCookie(stateCookie.name, state, c2.context.secret, stateCookie.attributes);
  const expiresAt = /* @__PURE__ */ new Date();
  expiresAt.setMinutes(expiresAt.getMinutes() + 10);
  const verification = await c2.context.internalAdapter.createVerificationValue({
    value: JSON.stringify(stateData),
    identifier: state,
    expiresAt
  });
  if (!verification) throw new StateError("Unable to create verification. Make sure the database adapter is properly working and there is a verification table in the database", { code: "state_generation_error" });
  return {
    state: verification.identifier,
    codeVerifier: stateData.codeVerifier
  };
}
async function parseGenericState(c2, state, settings) {
  const storeStateStrategy = c2.context.oauthConfig.storeStateStrategy;
  let parsedData;
  if (storeStateStrategy === "cookie") {
    const stateCookie = c2.context.createAuthCookie("oauth_state");
    const encryptedData = c2.getCookie(stateCookie.name);
    if (!encryptedData) throw new StateError("State mismatch: auth state cookie not found", {
      code: "state_mismatch",
      details: { state }
    });
    try {
      const decryptedData = await symmetricDecrypt({
        key: c2.context.secret,
        data: encryptedData
      });
      parsedData = stateDataSchema.parse(JSON.parse(decryptedData));
    } catch (error2) {
      throw new StateError("State invalid: Failed to decrypt or parse auth state", {
        code: "state_invalid",
        details: { state },
        cause: error2
      });
    }
    expireCookie(c2, stateCookie);
  } else {
    const data = await c2.context.internalAdapter.findVerificationValue(state);
    if (!data) throw new StateError("State mismatch: verification not found", {
      code: "state_mismatch",
      details: { state }
    });
    parsedData = stateDataSchema.parse(JSON.parse(data.value));
    const stateCookie = c2.context.createAuthCookie("state");
    const stateCookieValue = await c2.getSignedCookie(stateCookie.name, c2.context.secret);
    if (!c2.context.oauthConfig.skipStateCookieCheck && (!stateCookieValue || stateCookieValue !== state)) throw new StateError("State mismatch: State not persisted correctly", {
      code: "state_security_mismatch",
      details: { state }
    });
    expireCookie(c2, stateCookie);
    await c2.context.internalAdapter.deleteVerificationValue(data.id);
  }
  if (parsedData.expiresAt < Date.now()) throw new StateError("Invalid state: request expired", {
    code: "state_mismatch",
    details: { expiresAt: parsedData.expiresAt }
  });
  return parsedData;
}
const symbol = /* @__PURE__ */ Symbol.for("better-auth:global");
let bind = null;
const __context = {};
const __betterAuthVersion = "1.4.18";
function __getBetterAuthGlobal() {
  if (!globalThis[symbol]) {
    globalThis[symbol] = {
      version: __betterAuthVersion,
      epoch: 1,
      context: __context
    };
    bind = globalThis[symbol];
  }
  bind = globalThis[symbol];
  if (bind.version !== __betterAuthVersion) {
    bind.version = __betterAuthVersion;
    bind.epoch++;
  }
  return globalThis[symbol];
}
function getBetterAuthVersion() {
  return __getBetterAuthGlobal().version;
}
const AsyncLocalStoragePromise = import(
  /* @vite-ignore */
  /* webpackIgnore: true */
  "node:async_hooks"
).then((mod) => mod.AsyncLocalStorage).catch((err2) => {
  if ("AsyncLocalStorage" in globalThis) return globalThis.AsyncLocalStorage;
  if (typeof window !== "undefined") return null;
  console.warn("[better-auth] Warning: AsyncLocalStorage is not available in this environment. Some features may not work as expected.");
  console.warn("[better-auth] Please read more about this warning at https://better-auth.com/docs/installation#mount-handler");
  console.warn("[better-auth] If you are using Cloudflare Workers, please see: https://developers.cloudflare.com/workers/configuration/compatibility-flags/#nodejs-compatibility-flag");
  throw err2;
});
async function getAsyncLocalStorage() {
  const mod = await AsyncLocalStoragePromise;
  if (mod === null) throw new Error("getAsyncLocalStorage is only available in server code");
  else return mod;
}
const ensureAsyncStorage$2 = async () => {
  const betterAuthGlobal = __getBetterAuthGlobal();
  if (!betterAuthGlobal.context.endpointContextAsyncStorage) {
    const AsyncLocalStorage$1 = await getAsyncLocalStorage();
    betterAuthGlobal.context.endpointContextAsyncStorage = new AsyncLocalStorage$1();
  }
  return betterAuthGlobal.context.endpointContextAsyncStorage;
};
async function getCurrentAuthContext() {
  const context = (await ensureAsyncStorage$2()).getStore();
  if (!context) throw new Error("No auth context found. Please make sure you are calling this function within a `runWithEndpointContext` callback.");
  return context;
}
async function runWithEndpointContext(context, fn2) {
  return (await ensureAsyncStorage$2()).run(context, fn2);
}
const ensureAsyncStorage$1 = async () => {
  const betterAuthGlobal = __getBetterAuthGlobal();
  if (!betterAuthGlobal.context.requestStateAsyncStorage) {
    const AsyncLocalStorage$1 = await getAsyncLocalStorage();
    betterAuthGlobal.context.requestStateAsyncStorage = new AsyncLocalStorage$1();
  }
  return betterAuthGlobal.context.requestStateAsyncStorage;
};
async function hasRequestState() {
  return (await ensureAsyncStorage$1()).getStore() !== void 0;
}
async function getCurrentRequestState() {
  const store = (await ensureAsyncStorage$1()).getStore();
  if (!store) throw new Error("No request state found. Please make sure you are calling this function within a `runWithRequestState` callback.");
  return store;
}
async function runWithRequestState(store, fn2) {
  return (await ensureAsyncStorage$1()).run(store, fn2);
}
function defineRequestState(initFn) {
  const ref2 = Object.freeze({});
  return {
    get ref() {
      return ref2;
    },
    async get() {
      const store = await getCurrentRequestState();
      if (!store.has(ref2)) {
        const initialValue = await initFn();
        store.set(ref2, initialValue);
        return initialValue;
      }
      return store.get(ref2);
    },
    async set(value) {
      (await getCurrentRequestState()).set(ref2, value);
    }
  };
}
const ensureAsyncStorage = async () => {
  const betterAuthGlobal = __getBetterAuthGlobal();
  if (!betterAuthGlobal.context.adapterAsyncStorage) {
    const AsyncLocalStorage$1 = await getAsyncLocalStorage();
    betterAuthGlobal.context.adapterAsyncStorage = new AsyncLocalStorage$1();
  }
  return betterAuthGlobal.context.adapterAsyncStorage;
};
const getCurrentAdapter = async (fallback) => {
  return ensureAsyncStorage().then((als) => {
    return als.getStore() || fallback;
  }).catch(() => {
    return fallback;
  });
};
const runWithAdapter = async (adapter, fn2) => {
  let called = true;
  return ensureAsyncStorage().then((als) => {
    called = true;
    return als.run(adapter, fn2);
  }).catch((err2) => {
    if (!called) return fn2();
    throw err2;
  });
};
const runWithTransaction = async (adapter, fn2) => {
  let called = true;
  return ensureAsyncStorage().then((als) => {
    called = true;
    return adapter.transaction(async (trx) => {
      return als.run(trx, fn2);
    });
  }).catch((err2) => {
    if (!called) return fn2();
    throw err2;
  });
};
const { set: setOAuthState } = defineRequestState(() => null);
async function generateState(c2, link, additionalData) {
  const callbackURL = c2.body?.callbackURL || c2.context.options.baseURL;
  if (!callbackURL) throw new APIError$1("BAD_REQUEST", { message: "callbackURL is required" });
  const codeVerifier = generateRandomString(128);
  const stateData = {
    ...additionalData ? additionalData : {},
    callbackURL,
    codeVerifier,
    errorURL: c2.body?.errorCallbackURL,
    newUserURL: c2.body?.newUserCallbackURL,
    link,
    expiresAt: Date.now() + 600 * 1e3,
    requestSignUp: c2.body?.requestSignUp
  };
  await setOAuthState(stateData);
  try {
    return generateGenericState(c2, stateData);
  } catch (error2) {
    c2.context.logger.error("Failed to create verification", error2);
    throw new APIError$1("INTERNAL_SERVER_ERROR", {
      message: "Unable to create verification",
      cause: error2
    });
  }
}
async function parseState(c2) {
  const state = c2.query.state || c2.body.state;
  const errorURL = c2.context.options.onAPIError?.errorURL || `${c2.context.baseURL}/error`;
  let parsedData;
  try {
    parsedData = await parseGenericState(c2, state);
  } catch (error2) {
    c2.context.logger.error("Failed to parse state", error2);
    if (error2 instanceof StateError && error2.code === "state_security_mismatch") throw c2.redirect(`${errorURL}?error=state_mismatch`);
    throw c2.redirect(`${errorURL}?error=please_restart_the_process`);
  }
  if (!parsedData.errorURL) parsedData.errorURL = errorURL;
  if (parsedData) await setOAuthState(parsedData);
  return parsedData;
}
const HIDE_METADATA = { scope: "server" };
const LOCALHOST_IP = "127.0.0.1";
function getIp(req2, options) {
  if (options.advanced?.ipAddress?.disableIpTracking) return null;
  const headers = "headers" in req2 ? req2.headers : req2;
  const ipHeaders = options.advanced?.ipAddress?.ipAddressHeaders || ["x-forwarded-for"];
  for (const key of ipHeaders) {
    const value = "get" in headers ? headers.get(key) : headers[key];
    if (typeof value === "string") {
      const ip = value.split(",")[0].trim();
      if (isValidIP(ip)) return normalizeIP(ip, { ipv6Subnet: options.advanced?.ipAddress?.ipv6Subnet });
    }
  }
  if (isTest() || isDevelopment()) return LOCALHOST_IP;
  return null;
}
function checkHasPath(url) {
  try {
    return (new URL(url).pathname.replace(/\/+$/, "") || "/") !== "/";
  } catch {
    throw new BetterAuthError(`Invalid base URL: ${url}. Please provide a valid base URL.`);
  }
}
function assertHasProtocol(url) {
  try {
    const parsedUrl = new URL(url);
    if (parsedUrl.protocol !== "http:" && parsedUrl.protocol !== "https:") throw new BetterAuthError(`Invalid base URL: ${url}. URL must include 'http://' or 'https://'`);
  } catch (error2) {
    if (error2 instanceof BetterAuthError) throw error2;
    throw new BetterAuthError(`Invalid base URL: ${url}. Please provide a valid base URL.`, { cause: error2 });
  }
}
function withPath(url, path = "/api/auth") {
  assertHasProtocol(url);
  if (checkHasPath(url)) return url;
  const trimmedUrl = url.replace(/\/+$/, "");
  if (!path || path === "/") return trimmedUrl;
  path = path.startsWith("/") ? path : `/${path}`;
  return `${trimmedUrl}${path}`;
}
function validateProxyHeader(header, type2) {
  if (!header || header.trim() === "") return false;
  if (type2 === "proto") return header === "http" || header === "https";
  if (type2 === "host") {
    if ([
      /\.\./,
      /\0/,
      /[\s]/,
      /^[.]/,
      /[<>'"]/,
      /javascript:/i,
      /file:/i,
      /data:/i
    ].some((pattern) => pattern.test(header))) return false;
    return /^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*(:[0-9]{1,5})?$/.test(header) || /^(\d{1,3}\.){3}\d{1,3}(:[0-9]{1,5})?$/.test(header) || /^\[[0-9a-fA-F:]+\](:[0-9]{1,5})?$/.test(header) || /^localhost(:[0-9]{1,5})?$/i.test(header);
  }
  return false;
}
function getBaseURL(url, path, request, loadEnv, trustedProxyHeaders) {
  if (url) return withPath(url, path);
  {
    const fromEnv = env.BETTER_AUTH_URL || env.NEXT_PUBLIC_BETTER_AUTH_URL || env.PUBLIC_BETTER_AUTH_URL || env.NUXT_PUBLIC_BETTER_AUTH_URL || env.NUXT_PUBLIC_AUTH_URL || (env.BASE_URL !== "/" ? env.BASE_URL : void 0);
    if (fromEnv) return withPath(fromEnv, path);
  }
  const fromRequest = request?.headers.get("x-forwarded-host");
  const fromRequestProto = request?.headers.get("x-forwarded-proto");
  if (fromRequest && fromRequestProto && trustedProxyHeaders) {
    if (validateProxyHeader(fromRequestProto, "proto") && validateProxyHeader(fromRequest, "host")) try {
      return withPath(`${fromRequestProto}://${fromRequest}`, path);
    } catch (_error) {
    }
  }
  if (request) {
    const url$1 = getOrigin(request.url);
    if (!url$1) throw new BetterAuthError("Could not get origin from request. Please provide a valid base URL.");
    return withPath(url$1, path);
  }
  if (typeof window !== "undefined" && window.location) return withPath(window.location.origin, path);
}
function getOrigin(url) {
  try {
    const parsedUrl = new URL(url);
    return parsedUrl.origin === "null" ? null : parsedUrl.origin;
  } catch {
    return null;
  }
}
function getProtocol(url) {
  try {
    return new URL(url).protocol;
  } catch {
    return null;
  }
}
function getHost(url) {
  try {
    return new URL(url).host;
  } catch {
    return null;
  }
}
function escapeRegExpChar(char2) {
  if (char2 === "-" || char2 === "^" || char2 === "$" || char2 === "+" || char2 === "." || char2 === "(" || char2 === ")" || char2 === "|" || char2 === "[" || char2 === "]" || char2 === "{" || char2 === "}" || char2 === "*" || char2 === "?" || char2 === "\\") return `\\${char2}`;
  else return char2;
}
function escapeRegExpString(str) {
  let result2 = "";
  for (let i = 0; i < str.length; i++) result2 += escapeRegExpChar(str[i]);
  return result2;
}
function transform(pattern, separator = true) {
  if (Array.isArray(pattern)) return `(?:${pattern.map((p) => `^${transform(p, separator)}$`).join("|")})`;
  let separatorSplitter = "";
  let separatorMatcher = "";
  let wildcard = ".";
  if (separator === true) {
    separatorSplitter = "/";
    separatorMatcher = "[/\\\\]";
    wildcard = "[^/\\\\]";
  } else if (separator) {
    separatorSplitter = separator;
    separatorMatcher = escapeRegExpString(separatorSplitter);
    if (separatorMatcher.length > 1) {
      separatorMatcher = `(?:${separatorMatcher})`;
      wildcard = `((?!${separatorMatcher}).)`;
    } else wildcard = `[^${separatorMatcher}]`;
  }
  const requiredSeparator = separator ? `${separatorMatcher}+?` : "";
  const optionalSeparator = separator ? `${separatorMatcher}*?` : "";
  const segments = separator ? pattern.split(separatorSplitter) : [pattern];
  let result2 = "";
  for (let s2 = 0; s2 < segments.length; s2++) {
    const segment = segments[s2];
    const nextSegment = segments[s2 + 1];
    let currentSeparator = "";
    if (!segment && s2 > 0) continue;
    if (separator) if (s2 === segments.length - 1) currentSeparator = optionalSeparator;
    else if (nextSegment !== "**") currentSeparator = requiredSeparator;
    else currentSeparator = "";
    if (separator && segment === "**") {
      if (currentSeparator) {
        result2 += s2 === 0 ? "" : currentSeparator;
        result2 += `(?:${wildcard}*?${currentSeparator})*?`;
      }
      continue;
    }
    for (let c2 = 0; c2 < segment.length; c2++) {
      const char2 = segment[c2];
      if (char2 === "\\") {
        if (c2 < segment.length - 1) {
          result2 += escapeRegExpChar(segment[c2 + 1]);
          c2++;
        }
      } else if (char2 === "?") result2 += wildcard;
      else if (char2 === "*") result2 += `${wildcard}*?`;
      else result2 += escapeRegExpChar(char2);
    }
    result2 += currentSeparator;
  }
  return result2;
}
function isMatch(regexp, sample) {
  if (typeof sample !== "string") throw new TypeError(`Sample must be a string, but ${typeof sample} given`);
  return regexp.test(sample);
}
function wildcardMatch(pattern, options) {
  if (typeof pattern !== "string" && !Array.isArray(pattern)) throw new TypeError(`The first argument must be a single pattern string or an array of patterns, but ${typeof pattern} given`);
  if (typeof options === "string" || typeof options === "boolean") options = { separator: options };
  if (arguments.length === 2 && !(typeof options === "undefined" || typeof options === "object" && options !== null && !Array.isArray(options))) throw new TypeError(`The second argument must be an options object or a string/boolean separator, but ${typeof options} given`);
  options = options || {};
  if (options.separator === "\\") throw new Error("\\ is not a valid separator because it is used for escaping. Try setting the separator to `true` instead");
  const regexpPattern = transform(pattern, options.separator);
  const regexp = new RegExp(`^${regexpPattern}$`, options.flags);
  const fn2 = isMatch.bind(null, regexp);
  fn2.options = options;
  fn2.pattern = pattern;
  fn2.regexp = regexp;
  return fn2;
}
const matchesOriginPattern = (url, pattern, settings) => {
  if (url.startsWith("/")) {
    if (settings?.allowRelativePaths) return url.startsWith("/") && /^\/(?!\/|\\|%2f|%5c)[\w\-.\+/@]*(?:\?[\w\-.\+/=&%@]*)?$/.test(url);
    return false;
  }
  if (pattern.includes("*") || pattern.includes("?")) {
    if (pattern.includes("://")) return wildcardMatch(pattern)(getOrigin(url) || url);
    const host = getHost(url);
    if (!host) return false;
    return wildcardMatch(pattern)(host);
  }
  const protocol2 = getProtocol(url);
  return protocol2 === "http:" || protocol2 === "https:" || !protocol2 ? pattern === getOrigin(url) : url.startsWith(pattern);
};
function isErrorStackTraceLimitWritable() {
  const desc2 = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
  if (desc2 === void 0) return Object.isExtensible(Error);
  return Object.prototype.hasOwnProperty.call(desc2, "writable") ? desc2.writable : desc2.set !== void 0;
}
function hideInternalStackFrames(stack) {
  const lines = stack.split("\n    at ");
  if (lines.length <= 1) return stack;
  lines.splice(1, 1);
  return lines.join("\n    at ");
}
function makeErrorForHideStackFrame(Base, clazz) {
  class HideStackFramesError extends Base {
    #hiddenStack;
    constructor(...args) {
      if (isErrorStackTraceLimitWritable()) {
        const limit = Error.stackTraceLimit;
        Error.stackTraceLimit = 0;
        super(...args);
        Error.stackTraceLimit = limit;
      } else super(...args);
      const stack = (/* @__PURE__ */ new Error()).stack;
      if (stack) this.#hiddenStack = hideInternalStackFrames(stack.replace(/^Error/, this.name));
    }
    get errorStack() {
      return this.#hiddenStack;
    }
  }
  Object.defineProperty(HideStackFramesError.prototype, "constructor", {
    get() {
      return clazz;
    },
    enumerable: false,
    configurable: true
  });
  return HideStackFramesError;
}
const statusCodes = {
  OK: 200,
  CREATED: 201,
  ACCEPTED: 202,
  NO_CONTENT: 204,
  MULTIPLE_CHOICES: 300,
  MOVED_PERMANENTLY: 301,
  FOUND: 302,
  SEE_OTHER: 303,
  NOT_MODIFIED: 304,
  TEMPORARY_REDIRECT: 307,
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  PAYMENT_REQUIRED: 402,
  FORBIDDEN: 403,
  NOT_FOUND: 404,
  METHOD_NOT_ALLOWED: 405,
  NOT_ACCEPTABLE: 406,
  PROXY_AUTHENTICATION_REQUIRED: 407,
  REQUEST_TIMEOUT: 408,
  CONFLICT: 409,
  GONE: 410,
  LENGTH_REQUIRED: 411,
  PRECONDITION_FAILED: 412,
  PAYLOAD_TOO_LARGE: 413,
  URI_TOO_LONG: 414,
  UNSUPPORTED_MEDIA_TYPE: 415,
  RANGE_NOT_SATISFIABLE: 416,
  EXPECTATION_FAILED: 417,
  "I'M_A_TEAPOT": 418,
  MISDIRECTED_REQUEST: 421,
  UNPROCESSABLE_ENTITY: 422,
  LOCKED: 423,
  FAILED_DEPENDENCY: 424,
  TOO_EARLY: 425,
  UPGRADE_REQUIRED: 426,
  PRECONDITION_REQUIRED: 428,
  TOO_MANY_REQUESTS: 429,
  REQUEST_HEADER_FIELDS_TOO_LARGE: 431,
  UNAVAILABLE_FOR_LEGAL_REASONS: 451,
  INTERNAL_SERVER_ERROR: 500,
  NOT_IMPLEMENTED: 501,
  BAD_GATEWAY: 502,
  SERVICE_UNAVAILABLE: 503,
  GATEWAY_TIMEOUT: 504,
  HTTP_VERSION_NOT_SUPPORTED: 505,
  VARIANT_ALSO_NEGOTIATES: 506,
  INSUFFICIENT_STORAGE: 507,
  LOOP_DETECTED: 508,
  NOT_EXTENDED: 510,
  NETWORK_AUTHENTICATION_REQUIRED: 511
};
var InternalAPIError2 = class extends Error {
  constructor(status = "INTERNAL_SERVER_ERROR", body = void 0, headers = {}, statusCode = typeof status === "number" ? status : statusCodes[status]) {
    super(body?.message, body?.cause ? { cause: body.cause } : void 0);
    this.status = status;
    this.body = body;
    this.headers = headers;
    this.statusCode = statusCode;
    this.name = "APIError";
    this.status = status;
    this.headers = headers;
    this.statusCode = statusCode;
    this.body = body ? {
      code: body?.message?.toUpperCase().replace(/ /g, "_").replace(/[^A-Z0-9_]/g, ""),
      ...body
    } : void 0;
  }
};
var ValidationError$1 = class ValidationError2 extends InternalAPIError2 {
  constructor(message2, issues) {
    super(400, {
      message: message2,
      code: "VALIDATION_ERROR"
    });
    this.message = message2;
    this.issues = issues;
    this.issues = issues;
  }
};
var BetterCallError2 = class extends Error {
  constructor(message2) {
    super(message2);
    this.name = "BetterCallError";
  }
};
const APIError = makeErrorForHideStackFrame(InternalAPIError2, Error);
function isAPIError(error2) {
  return error2 instanceof APIError || error2?.name === "APIError";
}
function tryDecode(str) {
  try {
    return str.includes("%") ? decodeURIComponent(str) : str;
  } catch {
    return str;
  }
}
async function tryCatch(promise) {
  try {
    return {
      data: await promise,
      error: null
    };
  } catch (error2) {
    return {
      data: null,
      error: error2
    };
  }
}
function isRequest(obj) {
  return obj instanceof Request || Object.prototype.toString.call(obj) === "[object Request]";
}
function isJSONSerializable$1(value) {
  if (value === void 0) return false;
  const t2 = typeof value;
  if (t2 === "string" || t2 === "number" || t2 === "boolean" || t2 === null) return true;
  if (t2 !== "object") return false;
  if (Array.isArray(value)) return true;
  if (value.buffer) return false;
  return value.constructor && value.constructor.name === "Object" || typeof value.toJSON === "function";
}
function safeStringify(obj, replacer, space) {
  let id = 0;
  const seen = /* @__PURE__ */ new WeakMap();
  const safeReplacer = (key, value) => {
    if (typeof value === "bigint") return value.toString();
    if (typeof value === "object" && value !== null) {
      if (seen.has(value)) return `[Circular ref-${seen.get(value)}]`;
      seen.set(value, id++);
    }
    return value;
  };
  return JSON.stringify(obj, safeReplacer, space);
}
function isJSONResponse(value) {
  if (!value || typeof value !== "object") return false;
  return "_flag" in value && value._flag === "json";
}
function toResponse(data, init2) {
  if (data instanceof Response) {
    if (init2?.headers instanceof Headers) init2.headers.forEach((value, key) => {
      data.headers.set(key, value);
    });
    return data;
  }
  if (isJSONResponse(data)) {
    const body$1 = data.body;
    const routerResponse = data.routerResponse;
    if (routerResponse instanceof Response) return routerResponse;
    const headers$1 = new Headers();
    if (routerResponse?.headers) {
      const headers$2 = new Headers(routerResponse.headers);
      for (const [key, value] of headers$2.entries()) headers$2.set(key, value);
    }
    if (data.headers) for (const [key, value] of new Headers(data.headers).entries()) headers$1.set(key, value);
    if (init2?.headers) for (const [key, value] of new Headers(init2.headers).entries()) headers$1.set(key, value);
    headers$1.set("Content-Type", "application/json");
    return new Response(JSON.stringify(body$1), {
      ...routerResponse,
      headers: headers$1,
      status: data.status ?? init2?.status ?? routerResponse?.status,
      statusText: init2?.statusText ?? routerResponse?.statusText
    });
  }
  if (isAPIError(data)) return toResponse(data.body, {
    status: init2?.status ?? data.statusCode,
    statusText: data.status.toString(),
    headers: init2?.headers || data.headers
  });
  let body = data;
  let headers = new Headers(init2?.headers);
  if (!data) {
    if (data === null) body = JSON.stringify(null);
    headers.set("content-type", "application/json");
  } else if (typeof data === "string") {
    body = data;
    headers.set("Content-Type", "text/plain");
  } else if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {
    body = data;
    headers.set("Content-Type", "application/octet-stream");
  } else if (data instanceof Blob) {
    body = data;
    headers.set("Content-Type", data.type || "application/octet-stream");
  } else if (data instanceof FormData) body = data;
  else if (data instanceof URLSearchParams) {
    body = data;
    headers.set("Content-Type", "application/x-www-form-urlencoded");
  } else if (data instanceof ReadableStream) {
    body = data;
    headers.set("Content-Type", "application/octet-stream");
  } else if (isJSONSerializable$1(data)) {
    body = safeStringify(data);
    headers.set("Content-Type", "application/json");
  }
  return new Response(body, {
    ...init2,
    headers
  });
}
const algorithm = {
  name: "HMAC",
  hash: "SHA-256"
};
const getCryptoKey = async (secret) => {
  const secretBuf = typeof secret === "string" ? new TextEncoder().encode(secret) : secret;
  return await getWebcryptoSubtle().importKey("raw", secretBuf, algorithm, false, ["sign", "verify"]);
};
const verifySignature = async (base64Signature, value, secret) => {
  try {
    const signatureBinStr = atob(base64Signature);
    const signature = new Uint8Array(signatureBinStr.length);
    for (let i = 0, len = signatureBinStr.length; i < len; i++) signature[i] = signatureBinStr.charCodeAt(i);
    return await getWebcryptoSubtle().verify(algorithm, secret, signature, new TextEncoder().encode(value));
  } catch (e2) {
    return false;
  }
};
const makeSignature = async (value, secret) => {
  const key = await getCryptoKey(secret);
  const signature = await getWebcryptoSubtle().sign(algorithm.name, key, new TextEncoder().encode(value));
  return btoa(String.fromCharCode(...new Uint8Array(signature)));
};
const signCookieValue = async (value, secret) => {
  const signature = await makeSignature(value, secret);
  value = `${value}.${signature}`;
  value = encodeURIComponent(value);
  return value;
};
const getCookieKey = (key, prefix) => {
  let finalKey = key;
  if (prefix) if (prefix === "secure") finalKey = "__Secure-" + key;
  else if (prefix === "host") finalKey = "__Host-" + key;
  else return;
  return finalKey;
};
function parseCookies(str) {
  if (typeof str !== "string") throw new TypeError("argument str must be a string");
  const cookies2 = /* @__PURE__ */ new Map();
  let index2 = 0;
  while (index2 < str.length) {
    const eqIdx = str.indexOf("=", index2);
    if (eqIdx === -1) break;
    let endIdx = str.indexOf(";", index2);
    if (endIdx === -1) endIdx = str.length;
    else if (endIdx < eqIdx) {
      index2 = str.lastIndexOf(";", eqIdx - 1) + 1;
      continue;
    }
    const key = str.slice(index2, eqIdx).trim();
    if (!cookies2.has(key)) {
      let val = str.slice(eqIdx + 1, endIdx).trim();
      if (val.codePointAt(0) === 34) val = val.slice(1, -1);
      cookies2.set(key, tryDecode(val));
    }
    index2 = endIdx + 1;
  }
  return cookies2;
}
const _serialize = (key, value, opt = {}) => {
  let cookie;
  if (opt?.prefix === "secure") cookie = `${`__Secure-${key}`}=${value}`;
  else if (opt?.prefix === "host") cookie = `${`__Host-${key}`}=${value}`;
  else cookie = `${key}=${value}`;
  if (key.startsWith("__Secure-") && !opt.secure) opt.secure = true;
  if (key.startsWith("__Host-")) {
    if (!opt.secure) opt.secure = true;
    if (opt.path !== "/") opt.path = "/";
    if (opt.domain) opt.domain = void 0;
  }
  if (opt && typeof opt.maxAge === "number" && opt.maxAge >= 0) {
    if (opt.maxAge > 3456e4) throw new Error("Cookies Max-Age SHOULD NOT be greater than 400 days (34560000 seconds) in duration.");
    cookie += `; Max-Age=${Math.floor(opt.maxAge)}`;
  }
  if (opt.domain && opt.prefix !== "host") cookie += `; Domain=${opt.domain}`;
  if (opt.path) cookie += `; Path=${opt.path}`;
  if (opt.expires) {
    if (opt.expires.getTime() - Date.now() > 3456e7) throw new Error("Cookies Expires SHOULD NOT be greater than 400 days (34560000 seconds) in the future.");
    cookie += `; Expires=${opt.expires.toUTCString()}`;
  }
  if (opt.httpOnly) cookie += "; HttpOnly";
  if (opt.secure) cookie += "; Secure";
  if (opt.sameSite) cookie += `; SameSite=${opt.sameSite.charAt(0).toUpperCase() + opt.sameSite.slice(1)}`;
  if (opt.partitioned) {
    if (!opt.secure) opt.secure = true;
    cookie += "; Partitioned";
  }
  return cookie;
};
const serializeCookie = (key, value, opt) => {
  value = encodeURIComponent(value);
  return _serialize(key, value, opt);
};
const serializeSignedCookie = async (key, value, secret, opt) => {
  value = await signCookieValue(value, secret);
  return _serialize(key, value, opt);
};
async function runValidation(options, context = {}) {
  let request = {
    body: context.body,
    query: context.query
  };
  if (options.body) {
    const result2 = await options.body["~standard"].validate(context.body);
    if (result2.issues) return {
      data: null,
      error: fromError(result2.issues, "body")
    };
    request.body = result2.value;
  }
  if (options.query) {
    const result2 = await options.query["~standard"].validate(context.query);
    if (result2.issues) return {
      data: null,
      error: fromError(result2.issues, "query")
    };
    request.query = result2.value;
  }
  if (options.requireHeaders && !context.headers) return {
    data: null,
    error: {
      message: "Headers is required",
      issues: []
    }
  };
  if (options.requireRequest && !context.request) return {
    data: null,
    error: {
      message: "Request is required",
      issues: []
    }
  };
  return {
    data: request,
    error: null
  };
}
function fromError(error2, validating) {
  return {
    message: error2.map((e2) => {
      return `[${e2.path?.length ? `${validating}.` + e2.path.map((x) => typeof x === "object" ? x.key : x).join(".") : validating}] ${e2.message}`;
    }).join("; "),
    issues: error2
  };
}
const createInternalContext = async (context, { options, path }) => {
  const headers = new Headers();
  let responseStatus = void 0;
  const { data, error: error2 } = await runValidation(options, context);
  if (error2) throw new ValidationError$1(error2.message, error2.issues);
  const requestHeaders = "headers" in context ? context.headers instanceof Headers ? context.headers : new Headers(context.headers) : "request" in context && isRequest(context.request) ? context.request.headers : null;
  const requestCookies = requestHeaders?.get("cookie");
  const parsedCookies = requestCookies ? parseCookies(requestCookies) : void 0;
  const internalContext = {
    ...context,
    body: data.body,
    query: data.query,
    path: context.path || path || "virtual:",
    context: "context" in context && context.context ? context.context : {},
    returned: void 0,
    headers: context?.headers,
    request: context?.request,
    params: "params" in context ? context.params : void 0,
    method: context.method ?? (Array.isArray(options.method) ? options.method[0] : options.method === "*" ? "GET" : options.method),
    setHeader: (key, value) => {
      headers.set(key, value);
    },
    getHeader: (key) => {
      if (!requestHeaders) return null;
      return requestHeaders.get(key);
    },
    getCookie: (key, prefix) => {
      const finalKey = getCookieKey(key, prefix);
      if (!finalKey) return null;
      return parsedCookies?.get(finalKey) || null;
    },
    getSignedCookie: async (key, secret, prefix) => {
      const finalKey = getCookieKey(key, prefix);
      if (!finalKey) return null;
      const value = parsedCookies?.get(finalKey);
      if (!value) return null;
      const signatureStartPos = value.lastIndexOf(".");
      if (signatureStartPos < 1) return null;
      const signedValue = value.substring(0, signatureStartPos);
      const signature = value.substring(signatureStartPos + 1);
      if (signature.length !== 44 || !signature.endsWith("=")) return null;
      return await verifySignature(signature, signedValue, await getCryptoKey(secret)) ? signedValue : false;
    },
    setCookie: (key, value, options$1) => {
      const cookie = serializeCookie(key, value, options$1);
      headers.append("set-cookie", cookie);
      return cookie;
    },
    setSignedCookie: async (key, value, secret, options$1) => {
      const cookie = await serializeSignedCookie(key, value, secret, options$1);
      headers.append("set-cookie", cookie);
      return cookie;
    },
    redirect: (url) => {
      headers.set("location", url);
      return new APIError("FOUND", void 0, headers);
    },
    error: (status, body, headers$1) => {
      return new APIError(status, body, headers$1);
    },
    setStatus: (status) => {
      responseStatus = status;
    },
    json: (json2, routerResponse) => {
      if (!context.asResponse) return json2;
      return {
        body: routerResponse?.body || json2,
        routerResponse,
        _flag: "json"
      };
    },
    responseHeaders: headers,
    get responseStatus() {
      return responseStatus;
    }
  };
  for (const middleware of options.use || []) {
    const response = await middleware({
      ...internalContext,
      returnHeaders: true,
      asResponse: false
    });
    if (response.response) Object.assign(internalContext.context, response.response);
    if (response.headers) response.headers.forEach((value, key) => {
      internalContext.responseHeaders.set(key, value);
    });
  }
  return internalContext;
};
function createEndpoint(pathOrOptions, handlerOrOptions, handlerOrNever) {
  const path = typeof pathOrOptions === "string" ? pathOrOptions : void 0;
  const options = typeof handlerOrOptions === "object" ? handlerOrOptions : pathOrOptions;
  const handler2 = typeof handlerOrOptions === "function" ? handlerOrOptions : handlerOrNever;
  if ((options.method === "GET" || options.method === "HEAD") && options.body) throw new BetterCallError2("Body is not allowed with GET or HEAD methods");
  if (path && /\/{2,}/.test(path)) throw new BetterCallError2("Path cannot contain consecutive slashes");
  const internalHandler = async (...inputCtx) => {
    const context = inputCtx[0] || {};
    const { data: internalContext, error: validationError } = await tryCatch(createInternalContext(context, {
      options,
      path
    }));
    if (validationError) {
      if (!(validationError instanceof ValidationError$1)) throw validationError;
      if (options.onValidationError) await options.onValidationError({
        message: validationError.message,
        issues: validationError.issues
      });
      throw new APIError(400, {
        message: validationError.message,
        code: "VALIDATION_ERROR"
      });
    }
    const response = await handler2(internalContext).catch(async (e2) => {
      if (isAPIError(e2)) {
        const onAPIError = options.onAPIError;
        if (onAPIError) await onAPIError(e2);
        if (context.asResponse) return e2;
      }
      throw e2;
    });
    const headers = internalContext.responseHeaders;
    const status = internalContext.responseStatus;
    return context.asResponse ? toResponse(response, {
      headers,
      status
    }) : context.returnHeaders ? context.returnStatus ? {
      headers,
      response,
      status
    } : {
      headers,
      response
    } : context.returnStatus ? {
      response,
      status
    } : response;
  };
  internalHandler.options = options;
  internalHandler.path = path;
  return internalHandler;
}
createEndpoint.create = (opts) => {
  return (path, options, handler2) => {
    return createEndpoint(path, {
      ...options,
      use: [...options?.use || [], ...opts?.use || []]
    }, handler2);
  };
};
function createMiddleware(optionsOrHandler, handler2) {
  const internalHandler = async (inputCtx) => {
    const context = inputCtx;
    const _handler = typeof optionsOrHandler === "function" ? optionsOrHandler : handler2;
    const internalContext = await createInternalContext(context, {
      options: typeof optionsOrHandler === "function" ? {} : optionsOrHandler,
      path: "/"
    });
    if (!_handler) throw new Error("handler must be defined");
    const response = await _handler(internalContext);
    const headers = internalContext.responseHeaders;
    return context.returnHeaders ? {
      headers,
      response
    } : response;
  };
  internalHandler.options = typeof optionsOrHandler === "function" ? {} : optionsOrHandler;
  return internalHandler;
}
createMiddleware.create = (opts) => {
  function fn2(optionsOrHandler, handler2) {
    if (typeof optionsOrHandler === "function") return createMiddleware({
      use: opts?.use
    }, optionsOrHandler);
    if (!handler2) throw new Error("Middleware handler is required");
    return createMiddleware({
      ...optionsOrHandler,
      method: "*",
      use: [...opts?.use || [], ...optionsOrHandler.use || []]
    }, handler2);
  }
  return fn2;
};
const optionsMiddleware = createMiddleware(async () => {
  return {};
});
const createAuthMiddleware = createMiddleware.create({
  use: [optionsMiddleware, createMiddleware(async () => {
    return {};
  })]
});
const use = [optionsMiddleware];
function createAuthEndpoint(pathOrOptions, handlerOrOptions, handlerOrNever) {
  const path = typeof pathOrOptions === "string" ? pathOrOptions : void 0;
  const options = typeof handlerOrOptions === "object" ? handlerOrOptions : pathOrOptions;
  const handler2 = typeof handlerOrOptions === "function" ? handlerOrOptions : handlerOrNever;
  if (path) return createEndpoint(path, {
    ...options,
    use: [...options?.use || [], ...use]
  }, async (ctx) => runWithEndpointContext(ctx, () => handler2(ctx)));
  return createEndpoint({
    ...options,
    use: [...options?.use || [], ...use]
  }, async (ctx) => runWithEndpointContext(ctx, () => handler2(ctx)));
}
function shouldSkipCSRFForBackwardCompat(ctx) {
  return ctx.context.skipOriginCheck === true && ctx.context.options.advanced?.disableCSRFCheck === void 0;
}
const logBackwardCompatWarning = deprecate(function logBackwardCompatWarning$1() {
}, "disableOriginCheck: true currently also disables CSRF checks. In a future version, disableOriginCheck will ONLY disable URL validation. To keep CSRF disabled, add disableCSRFCheck: true to your config.");
const originCheckMiddleware = createAuthMiddleware(async (ctx) => {
  if (ctx.request?.method === "GET" || ctx.request?.method === "OPTIONS" || ctx.request?.method === "HEAD" || !ctx.request) return;
  await validateOrigin(ctx);
  if (ctx.context.skipOriginCheck) return;
  const { body, query: query2 } = ctx;
  const callbackURL = body?.callbackURL || query2?.callbackURL;
  const redirectURL = body?.redirectTo;
  const errorCallbackURL = body?.errorCallbackURL;
  const newUserCallbackURL = body?.newUserCallbackURL;
  const validateURL = (url, label) => {
    if (!url) return;
    if (!ctx.context.isTrustedOrigin(url, { allowRelativePaths: label !== "origin" })) {
      ctx.context.logger.error(`Invalid ${label}: ${url}`);
      ctx.context.logger.info(`If it's a valid URL, please add ${url} to trustedOrigins in your auth config
`, `Current list of trustedOrigins: ${ctx.context.trustedOrigins}`);
      throw new APIError$1("FORBIDDEN", { message: `Invalid ${label}` });
    }
  };
  callbackURL && validateURL(callbackURL, "callbackURL");
  redirectURL && validateURL(redirectURL, "redirectURL");
  errorCallbackURL && validateURL(errorCallbackURL, "errorCallbackURL");
  newUserCallbackURL && validateURL(newUserCallbackURL, "newUserCallbackURL");
});
const originCheck = (getValue) => createAuthMiddleware(async (ctx) => {
  if (!ctx.request) return;
  if (ctx.context.skipOriginCheck) return;
  const callbackURL = getValue(ctx);
  const validateURL = (url, label) => {
    if (!url) return;
    if (!ctx.context.isTrustedOrigin(url, { allowRelativePaths: label !== "origin" })) {
      ctx.context.logger.error(`Invalid ${label}: ${url}`);
      ctx.context.logger.info(`If it's a valid URL, please add ${url} to trustedOrigins in your auth config
`, `Current list of trustedOrigins: ${ctx.context.trustedOrigins}`);
      throw new APIError$1("FORBIDDEN", { message: `Invalid ${label}` });
    }
  };
  const callbacks = Array.isArray(callbackURL) ? callbackURL : [callbackURL];
  for (const url of callbacks) validateURL(url, "callbackURL");
});
async function validateOrigin(ctx, forceValidate = false) {
  const headers = ctx.request?.headers;
  if (!headers || !ctx.request) return;
  const originHeader = headers.get("origin") || headers.get("referer") || "";
  const useCookies = headers.has("cookie");
  if (ctx.context.skipCSRFCheck) return;
  if (shouldSkipCSRFForBackwardCompat(ctx)) {
    ctx.context.options.advanced?.disableOriginCheck === true && logBackwardCompatWarning();
    return;
  }
  const skipOriginCheck = ctx.context.skipOriginCheck;
  if (Array.isArray(skipOriginCheck)) try {
    const basePath = new URL(ctx.context.baseURL).pathname;
    const currentPath = normalizePathname(ctx.request.url, basePath);
    if (skipOriginCheck.some((skipPath) => currentPath.startsWith(skipPath))) return;
  } catch {
  }
  if (!(forceValidate || useCookies)) return;
  if (!originHeader || originHeader === "null") throw new APIError$1("FORBIDDEN", { message: BASE_ERROR_CODES.MISSING_OR_NULL_ORIGIN });
  const trustedOrigins = Array.isArray(ctx.context.options.trustedOrigins) ? ctx.context.trustedOrigins : [...ctx.context.trustedOrigins, ...(await ctx.context.options.trustedOrigins?.(ctx.request))?.filter((v) => Boolean(v)) || []];
  if (!trustedOrigins.some((origin) => matchesOriginPattern(originHeader, origin))) {
    ctx.context.logger.error(`Invalid origin: ${originHeader}`);
    ctx.context.logger.info(`If it's a valid URL, please add ${originHeader} to trustedOrigins in your auth config
`, `Current list of trustedOrigins: ${trustedOrigins}`);
    throw new APIError$1("FORBIDDEN", { message: "Invalid origin" });
  }
}
const formCsrfMiddleware = createAuthMiddleware(async (ctx) => {
  if (!ctx.request) return;
  await validateFormCsrf(ctx);
});
async function validateFormCsrf(ctx) {
  const req2 = ctx.request;
  if (!req2) return;
  if (ctx.context.skipCSRFCheck) return;
  if (shouldSkipCSRFForBackwardCompat(ctx)) return;
  const headers = req2.headers;
  if (headers.has("cookie")) return await validateOrigin(ctx);
  const site = headers.get("Sec-Fetch-Site");
  const mode = headers.get("Sec-Fetch-Mode");
  const dest = headers.get("Sec-Fetch-Dest");
  if (Boolean(site && site.trim() || mode && mode.trim() || dest && dest.trim())) {
    if (site === "cross-site" && mode === "navigate") {
      ctx.context.logger.error("Blocked cross-site navigation login attempt (CSRF protection)", {
        secFetchSite: site,
        secFetchMode: mode,
        secFetchDest: dest
      });
      throw new APIError$1("FORBIDDEN", { message: BASE_ERROR_CODES.CROSS_SITE_NAVIGATION_LOGIN_BLOCKED });
    }
    return await validateOrigin(ctx, true);
  }
}
const memory = /* @__PURE__ */ new Map();
function shouldRateLimit(max2, window2, rateLimitData) {
  const now2 = Date.now();
  const windowInMs = window2 * 1e3;
  return now2 - rateLimitData.lastRequest < windowInMs && rateLimitData.count >= max2;
}
function rateLimitResponse(retryAfter) {
  return new Response(JSON.stringify({ message: "Too many requests. Please try again later." }), {
    status: 429,
    statusText: "Too Many Requests",
    headers: { "X-Retry-After": retryAfter.toString() }
  });
}
function getRetryAfter(lastRequest, window2) {
  const now2 = Date.now();
  const windowInMs = window2 * 1e3;
  return Math.ceil((lastRequest + windowInMs - now2) / 1e3);
}
function createDatabaseStorageWrapper(ctx) {
  const model = "rateLimit";
  const db = ctx.adapter;
  return {
    get: async (key) => {
      const data = (await db.findMany({
        model,
        where: [{
          field: "key",
          value: key
        }]
      }))[0];
      if (typeof data?.lastRequest === "bigint") data.lastRequest = Number(data.lastRequest);
      return data;
    },
    set: async (key, value, _update) => {
      try {
        if (_update) await db.updateMany({
          model,
          where: [{
            field: "key",
            value: key
          }],
          update: {
            count: value.count,
            lastRequest: value.lastRequest
          }
        });
        else await db.create({
          model,
          data: {
            key,
            count: value.count,
            lastRequest: value.lastRequest
          }
        });
      } catch (e2) {
        ctx.logger.error("Error setting rate limit", e2);
      }
    }
  };
}
function getRateLimitStorage(ctx, rateLimitSettings) {
  if (ctx.options.rateLimit?.customStorage) return ctx.options.rateLimit.customStorage;
  const storage = ctx.rateLimit.storage;
  if (storage === "secondary-storage") return {
    get: async (key) => {
      const data = await ctx.options.secondaryStorage?.get(key);
      return data ? safeJSONParse(data) : null;
    },
    set: async (key, value, _update) => {
      const ttl = rateLimitSettings?.window ?? ctx.options.rateLimit?.window ?? 10;
      await ctx.options.secondaryStorage?.set?.(key, JSON.stringify(value), ttl);
    }
  };
  else if (storage === "memory") return {
    async get(key) {
      const entry = memory.get(key);
      if (!entry) return null;
      if (Date.now() >= entry.expiresAt) {
        memory.delete(key);
        return null;
      }
      return entry.data;
    },
    async set(key, value, _update) {
      const ttl = rateLimitSettings?.window ?? ctx.options.rateLimit?.window ?? 10;
      const expiresAt = Date.now() + ttl * 1e3;
      memory.set(key, {
        data: value,
        expiresAt
      });
    }
  };
  return createDatabaseStorageWrapper(ctx);
}
async function onRequestRateLimit(req2, ctx) {
  if (!ctx.rateLimit.enabled) return;
  const basePath = new URL(ctx.baseURL).pathname;
  const path = normalizePathname(req2.url, basePath);
  let currentWindow = ctx.rateLimit.window;
  let currentMax = ctx.rateLimit.max;
  const ip = getIp(req2, ctx.options);
  if (!ip) return;
  const key = createRateLimitKey(ip, path);
  const specialRule = getDefaultSpecialRules().find((rule) => rule.pathMatcher(path));
  if (specialRule) {
    currentWindow = specialRule.window;
    currentMax = specialRule.max;
  }
  for (const plugin of ctx.options.plugins || []) if (plugin.rateLimit) {
    const matchedRule = plugin.rateLimit.find((rule) => rule.pathMatcher(path));
    if (matchedRule) {
      currentWindow = matchedRule.window;
      currentMax = matchedRule.max;
      break;
    }
  }
  if (ctx.rateLimit.customRules) {
    const _path = Object.keys(ctx.rateLimit.customRules).find((p) => {
      if (p.includes("*")) return wildcardMatch(p)(path);
      return p === path;
    });
    if (_path) {
      const customRule2 = ctx.rateLimit.customRules[_path];
      const resolved = typeof customRule2 === "function" ? await customRule2(req2, {
        window: currentWindow,
        max: currentMax
      }) : customRule2;
      if (resolved) {
        currentWindow = resolved.window;
        currentMax = resolved.max;
      }
      if (resolved === false) return;
    }
  }
  const storage = getRateLimitStorage(ctx, { window: currentWindow });
  const data = await storage.get(key);
  const now2 = Date.now();
  if (!data) await storage.set(key, {
    key,
    count: 1,
    lastRequest: now2
  });
  else {
    const timeSinceLastRequest = now2 - data.lastRequest;
    if (shouldRateLimit(currentMax, currentWindow, data)) return rateLimitResponse(getRetryAfter(data.lastRequest, currentWindow));
    else if (timeSinceLastRequest > currentWindow * 1e3) await storage.set(key, {
      ...data,
      count: 1,
      lastRequest: now2
    }, true);
    else await storage.set(key, {
      ...data,
      count: data.count + 1,
      lastRequest: now2
    }, true);
  }
}
function getDefaultSpecialRules() {
  return [{
    pathMatcher(path) {
      return path.startsWith("/sign-in") || path.startsWith("/sign-up") || path.startsWith("/change-password") || path.startsWith("/change-email");
    },
    window: 10,
    max: 3
  }];
}
var __defProp$4 = Object.defineProperty;
var __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames$2 = Object.getOwnPropertyNames;
var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
var __export$1 = (all2, symbols2) => {
  let target = {};
  for (var name2 in all2) {
    __defProp$4(target, name2, {
      get: all2[name2],
      enumerable: true
    });
  }
  return target;
};
var __copyProps$2 = (to, from, except, desc2) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (var keys = __getOwnPropNames$2(from), i = 0, n2 = keys.length, key; i < n2; i++) {
      key = keys[i];
      if (!__hasOwnProp$3.call(to, key) && key !== except) {
        __defProp$4(to, key, {
          get: ((k) => from[k]).bind(null, key),
          enumerable: !(desc2 = __getOwnPropDesc$2(from, key)) || desc2.enumerable
        });
      }
    }
  }
  return to;
};
var __reExport$1 = (target, mod, secondTarget, symbols2) => {
  __copyProps$2(target, mod, "default");
};
async function getBaseAdapter(options, handleDirectDatabase) {
  let adapter;
  if (!options.database) {
    const tables = getAuthTables(options);
    const memoryDB = Object.keys(tables).reduce((acc, key) => {
      acc[key] = [];
      return acc;
    }, {});
    const { memoryAdapter } = await import("./index-KffjMoRX.js");
    adapter = memoryAdapter(memoryDB)(options);
  } else if (typeof options.database === "function") adapter = options.database(options);
  else adapter = await handleDirectDatabase(options);
  if (!adapter.transaction) {
    logger.warn("Adapter does not correctly implement transaction function, patching it automatically. Please update your adapter implementation.");
    adapter.transaction = async (cb) => {
      return cb(adapter);
    };
  }
  return adapter;
}
async function getAdapter(options) {
  return getBaseAdapter(options, async (opts) => {
    const { createKyselyAdapter: createKyselyAdapter2 } = await import("./index-Dh-UuRmK.js");
    const { kysely, databaseType, transaction } = await createKyselyAdapter2(opts);
    if (!kysely) throw new BetterAuthError("Failed to initialize database adapter");
    const { kyselyAdapter } = await import("./index-Dh-UuRmK.js");
    return kyselyAdapter(kysely, {
      type: databaseType || "sqlite",
      debugLogs: opts.database && "debugLogs" in opts.database ? opts.database.debugLogs : false,
      transaction
    })(opts);
  });
}
const createFieldAttribute = (type2, config2) => {
  return {
    type: type2,
    ...config2
  };
};
function convertToDB(fields2, values) {
  const result2 = values.id ? { id: values.id } : {};
  for (const key in fields2) {
    const field = fields2[key];
    const value = values[key];
    if (value === void 0) continue;
    result2[field.fieldName || key] = value;
  }
  return result2;
}
function convertFromDB(fields2, values) {
  if (!values) return null;
  const result2 = { id: values.id };
  for (const [key, value] of Object.entries(fields2)) result2[key] = values[value.fieldName || key];
  return result2;
}
function getWithHooks(adapter, ctx) {
  const hooks = ctx.hooks;
  async function createWithHooks(data, model, customCreateFn) {
    const context = await getCurrentAuthContext().catch(() => null);
    let actualData = data;
    for (const hook of hooks || []) {
      const toRun = hook[model]?.create?.before;
      if (toRun) {
        const result2 = await toRun(actualData, context);
        if (result2 === false) return null;
        if (typeof result2 === "object" && "data" in result2) actualData = {
          ...actualData,
          ...result2.data
        };
      }
    }
    const customCreated = customCreateFn ? await customCreateFn.fn(actualData) : null;
    const created = !customCreateFn || customCreateFn.executeMainFn ? await (await getCurrentAdapter(adapter)).create({
      model,
      data: actualData,
      forceAllowId: true
    }) : customCreated;
    for (const hook of hooks || []) {
      const toRun = hook[model]?.create?.after;
      if (toRun) await toRun(created, context);
    }
    return created;
  }
  async function updateWithHooks(data, where, model, customUpdateFn) {
    const context = await getCurrentAuthContext().catch(() => null);
    let actualData = data;
    for (const hook of hooks || []) {
      const toRun = hook[model]?.update?.before;
      if (toRun) {
        const result2 = await toRun(data, context);
        if (result2 === false) return null;
        if (typeof result2 === "object" && "data" in result2) actualData = {
          ...actualData,
          ...result2.data
        };
      }
    }
    const customUpdated = customUpdateFn ? await customUpdateFn.fn(actualData) : null;
    const updated = !customUpdateFn || customUpdateFn.executeMainFn ? await (await getCurrentAdapter(adapter)).update({
      model,
      update: actualData,
      where
    }) : customUpdated;
    for (const hook of hooks || []) {
      const toRun = hook[model]?.update?.after;
      if (toRun) await toRun(updated, context);
    }
    return updated;
  }
  async function updateManyWithHooks(data, where, model, customUpdateFn) {
    const context = await getCurrentAuthContext().catch(() => null);
    let actualData = data;
    for (const hook of hooks || []) {
      const toRun = hook[model]?.update?.before;
      if (toRun) {
        const result2 = await toRun(data, context);
        if (result2 === false) return null;
        if (typeof result2 === "object" && "data" in result2) actualData = {
          ...actualData,
          ...result2.data
        };
      }
    }
    const customUpdated = customUpdateFn ? await customUpdateFn.fn(actualData) : null;
    const updated = !customUpdateFn || customUpdateFn.executeMainFn ? await (await getCurrentAdapter(adapter)).updateMany({
      model,
      update: actualData,
      where
    }) : customUpdated;
    for (const hook of hooks || []) {
      const toRun = hook[model]?.update?.after;
      if (toRun) await toRun(updated, context);
    }
    return updated;
  }
  async function deleteWithHooks(where, model, customDeleteFn) {
    const context = await getCurrentAuthContext().catch(() => null);
    let entityToDelete = null;
    try {
      entityToDelete = (await (await getCurrentAdapter(adapter)).findMany({
        model,
        where,
        limit: 1
      }))[0] || null;
    } catch {
    }
    if (entityToDelete) for (const hook of hooks || []) {
      const toRun = hook[model]?.delete?.before;
      if (toRun) {
        if (await toRun(entityToDelete, context) === false) return null;
      }
    }
    const customDeleted = customDeleteFn ? await customDeleteFn.fn(where) : null;
    const deleted = !customDeleteFn || customDeleteFn.executeMainFn ? await (await getCurrentAdapter(adapter)).delete({
      model,
      where
    }) : customDeleted;
    if (entityToDelete) for (const hook of hooks || []) {
      const toRun = hook[model]?.delete?.after;
      if (toRun) await toRun(entityToDelete, context);
    }
    return deleted;
  }
  async function deleteManyWithHooks(where, model, customDeleteFn) {
    const context = await getCurrentAuthContext().catch(() => null);
    let entitiesToDelete = [];
    try {
      entitiesToDelete = await (await getCurrentAdapter(adapter)).findMany({
        model,
        where
      });
    } catch {
    }
    for (const entity of entitiesToDelete) for (const hook of hooks || []) {
      const toRun = hook[model]?.delete?.before;
      if (toRun) {
        if (await toRun(entity, context) === false) return null;
      }
    }
    const customDeleted = customDeleteFn ? await customDeleteFn.fn(where) : null;
    const deleted = !customDeleteFn || customDeleteFn.executeMainFn ? await (await getCurrentAdapter(adapter)).deleteMany({
      model,
      where
    }) : customDeleted;
    for (const entity of entitiesToDelete) for (const hook of hooks || []) {
      const toRun = hook[model]?.delete?.after;
      if (toRun) await toRun(entity, context);
    }
    return deleted;
  }
  return {
    createWithHooks,
    updateWithHooks,
    updateManyWithHooks,
    deleteWithHooks,
    deleteManyWithHooks
  };
}
const createInternalAdapter = (adapter, ctx) => {
  const logger2 = ctx.logger;
  const options = ctx.options;
  const secondaryStorage = options.secondaryStorage;
  const sessionExpiration = options.session?.expiresIn || 3600 * 24 * 7;
  const { createWithHooks, updateWithHooks, updateManyWithHooks, deleteWithHooks, deleteManyWithHooks } = getWithHooks(adapter, ctx);
  async function refreshUserSessions(user) {
    if (!secondaryStorage) return;
    const listRaw = await secondaryStorage.get(`active-sessions-${user.id}`);
    if (!listRaw) return;
    const now2 = Date.now();
    const validSessions = (safeJSONParse(listRaw) || []).filter((s2) => s2.expiresAt > now2);
    await Promise.all(validSessions.map(async ({ token: token2 }) => {
      const cached = await secondaryStorage.get(token2);
      if (!cached) return;
      const parsed = safeJSONParse(cached);
      if (!parsed) return;
      const sessionTTL = Math.max(Math.floor(new Date(parsed.session.expiresAt).getTime() - now2) / 1e3, 0);
      await secondaryStorage.set(token2, JSON.stringify({
        session: parsed.session,
        user
      }), Math.floor(sessionTTL));
    }));
  }
  return {
    createOAuthUser: async (user, account) => {
      return runWithTransaction(adapter, async () => {
        const createdUser = await createWithHooks({
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date(),
          ...user
        }, "user", void 0);
        return {
          user: createdUser,
          account: await createWithHooks({
            ...account,
            userId: createdUser.id,
            createdAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          }, "account", void 0)
        };
      });
    },
    createUser: async (user) => {
      return await createWithHooks({
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date(),
        ...user,
        email: user.email?.toLowerCase()
      }, "user", void 0);
    },
    createAccount: async (account) => {
      return await createWithHooks({
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date(),
        ...account
      }, "account", void 0);
    },
    listSessions: async (userId) => {
      if (secondaryStorage) {
        const currentList = await secondaryStorage.get(`active-sessions-${userId}`);
        if (!currentList) return [];
        const list = safeJSONParse(currentList) || [];
        const now2 = Date.now();
        const seenTokens = /* @__PURE__ */ new Set();
        const sessions = [];
        for (const { token: token2, expiresAt } of list) {
          if (expiresAt <= now2 || seenTokens.has(token2)) continue;
          seenTokens.add(token2);
          const data = await secondaryStorage.get(token2);
          if (!data) continue;
          try {
            const parsed = typeof data === "string" ? JSON.parse(data) : data;
            if (!parsed?.session) continue;
            sessions.push(parseSessionOutput(ctx.options, {
              ...parsed.session,
              expiresAt: new Date(parsed.session.expiresAt)
            }));
          } catch {
            continue;
          }
        }
        return sessions;
      }
      return await (await getCurrentAdapter(adapter)).findMany({
        model: "session",
        where: [{
          field: "userId",
          value: userId
        }]
      });
    },
    listUsers: async (limit, offset2, sortBy, where) => {
      return await (await getCurrentAdapter(adapter)).findMany({
        model: "user",
        limit,
        offset: offset2,
        sortBy,
        where
      });
    },
    countTotalUsers: async (where) => {
      const total = await (await getCurrentAdapter(adapter)).count({
        model: "user",
        where
      });
      if (typeof total === "string") return parseInt(total);
      return total;
    },
    deleteUser: async (userId) => {
      if (!secondaryStorage || options.session?.storeSessionInDatabase) await deleteManyWithHooks([{
        field: "userId",
        value: userId
      }], "session", void 0);
      await deleteManyWithHooks([{
        field: "userId",
        value: userId
      }], "account", void 0);
      await deleteWithHooks([{
        field: "id",
        value: userId
      }], "user", void 0);
    },
    createSession: async (userId, dontRememberMe, override, overrideAll) => {
      const ctx$1 = await getCurrentAuthContext().catch(() => null);
      const headers = ctx$1?.headers || ctx$1?.request?.headers;
      const { id: _, ...rest } = override || {};
      const defaultAdditionalFields = parseSessionInput(ctx$1?.context.options ?? options, {});
      const data = {
        ipAddress: ctx$1?.request || ctx$1?.headers ? getIp(ctx$1?.request || ctx$1?.headers, ctx$1?.context.options) || "" : "",
        userAgent: headers?.get("user-agent") || "",
        ...rest,
        expiresAt: dontRememberMe ? getDate(3600 * 24, "sec") : getDate(sessionExpiration, "sec"),
        userId,
        token: generateId$1(32),
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date(),
        ...defaultAdditionalFields,
        ...overrideAll ? rest : {}
      };
      return await createWithHooks(data, "session", secondaryStorage ? {
        fn: async (sessionData) => {
          const currentList = await secondaryStorage.get(`active-sessions-${userId}`);
          let list = [];
          const now2 = Date.now();
          if (currentList) {
            list = safeJSONParse(currentList) || [];
            list = list.filter((session) => session.expiresAt > now2 && session.token !== data.token);
          }
          const sorted = [...list, {
            token: data.token,
            expiresAt: data.expiresAt.getTime()
          }].sort((a, b) => a.expiresAt - b.expiresAt);
          const furthestSessionExp = sorted.at(-1)?.expiresAt ?? data.expiresAt.getTime();
          const furthestSessionTTL = Math.max(Math.floor((furthestSessionExp - now2) / 1e3), 0);
          if (furthestSessionTTL > 0) await secondaryStorage.set(`active-sessions-${userId}`, JSON.stringify(sorted), furthestSessionTTL);
          const user = await adapter.findOne({
            model: "user",
            where: [{
              field: "id",
              value: userId
            }]
          });
          const sessionTTL = Math.max(Math.floor((data.expiresAt.getTime() - now2) / 1e3), 0);
          if (sessionTTL > 0) await secondaryStorage.set(data.token, JSON.stringify({
            session: sessionData,
            user
          }), sessionTTL);
          return sessionData;
        },
        executeMainFn: options.session?.storeSessionInDatabase
      } : void 0);
    },
    findSession: async (token2) => {
      if (secondaryStorage) {
        const sessionStringified = await secondaryStorage.get(token2);
        if (!sessionStringified && !options.session?.storeSessionInDatabase) return null;
        if (sessionStringified) {
          const s2 = safeJSONParse(sessionStringified);
          if (!s2) return null;
          return {
            session: parseSessionOutput(ctx.options, {
              ...s2.session,
              expiresAt: new Date(s2.session.expiresAt),
              createdAt: new Date(s2.session.createdAt),
              updatedAt: new Date(s2.session.updatedAt)
            }),
            user: parseUserOutput(ctx.options, {
              ...s2.user,
              createdAt: new Date(s2.user.createdAt),
              updatedAt: new Date(s2.user.updatedAt)
            })
          };
        }
      }
      const result2 = await (await getCurrentAdapter(adapter)).findOne({
        model: "session",
        where: [{
          value: token2,
          field: "token"
        }],
        join: { user: true }
      });
      if (!result2) return null;
      const { user, ...session } = result2;
      if (!user) return null;
      return {
        session: parseSessionOutput(ctx.options, session),
        user: parseUserOutput(ctx.options, user)
      };
    },
    findSessions: async (sessionTokens) => {
      if (secondaryStorage) {
        const sessions$1 = [];
        for (const sessionToken of sessionTokens) {
          const sessionStringified = await secondaryStorage.get(sessionToken);
          if (sessionStringified) try {
            const s2 = typeof sessionStringified === "string" ? JSON.parse(sessionStringified) : sessionStringified;
            if (!s2?.session) continue;
            const session = {
              session: {
                ...s2.session,
                expiresAt: new Date(s2.session.expiresAt)
              },
              user: {
                ...s2.user,
                createdAt: new Date(s2.user.createdAt),
                updatedAt: new Date(s2.user.updatedAt)
              }
            };
            sessions$1.push(session);
          } catch {
            continue;
          }
        }
        return sessions$1;
      }
      const sessions = await (await getCurrentAdapter(adapter)).findMany({
        model: "session",
        where: [{
          field: "token",
          value: sessionTokens,
          operator: "in"
        }],
        join: { user: true }
      });
      if (!sessions.length) return [];
      if (sessions.some((session) => !session.user)) return [];
      return sessions.map((_session) => {
        const { user, ...session } = _session;
        return {
          session,
          user
        };
      });
    },
    updateSession: async (sessionToken, session) => {
      return await updateWithHooks(session, [{
        field: "token",
        value: sessionToken
      }], "session", secondaryStorage ? {
        async fn(data) {
          const currentSession = await secondaryStorage.get(sessionToken);
          if (!currentSession) return null;
          const parsedSession = safeJSONParse(currentSession);
          if (!parsedSession) return null;
          const mergedSession = {
            ...parsedSession.session,
            ...data,
            expiresAt: new Date(data.expiresAt ?? parsedSession.session.expiresAt),
            createdAt: new Date(parsedSession.session.createdAt),
            updatedAt: new Date(data.updatedAt ?? parsedSession.session.updatedAt)
          };
          const updatedSession = parseSessionOutput(ctx.options, mergedSession);
          const now2 = Date.now();
          const expiresMs = new Date(updatedSession.expiresAt).getTime();
          const sessionTTL = Math.max(Math.floor((expiresMs - now2) / 1e3), 0);
          if (sessionTTL > 0) {
            await secondaryStorage.set(sessionToken, JSON.stringify({
              session: updatedSession,
              user: parsedSession.user
            }), sessionTTL);
            const listKey = `active-sessions-${updatedSession.userId}`;
            const listRaw = await secondaryStorage.get(listKey);
            const sorted = (listRaw ? safeJSONParse(listRaw) || [] : []).filter((s2) => s2.token !== sessionToken && s2.expiresAt > now2).concat([{
              token: sessionToken,
              expiresAt: expiresMs
            }]).sort((a, b) => a.expiresAt - b.expiresAt);
            const furthestSessionExp = sorted.at(-1)?.expiresAt;
            if (furthestSessionExp && furthestSessionExp > now2) await secondaryStorage.set(listKey, JSON.stringify(sorted), Math.floor((furthestSessionExp - now2) / 1e3));
            else await secondaryStorage.delete(listKey);
          }
          return updatedSession;
        },
        executeMainFn: options.session?.storeSessionInDatabase
      } : void 0);
    },
    deleteSession: async (token2) => {
      if (secondaryStorage) {
        const data = await secondaryStorage.get(token2);
        if (data) {
          const { session } = safeJSONParse(data) ?? {};
          if (!session) {
            logger2.error("Session not found in secondary storage");
            return;
          }
          const userId = session.userId;
          const currentList = await secondaryStorage.get(`active-sessions-${userId}`);
          if (currentList) {
            const list = safeJSONParse(currentList) || [];
            const now2 = Date.now();
            const filtered = list.filter((session$1) => session$1.expiresAt > now2 && session$1.token !== token2);
            const furthestSessionExp = filtered.sort((a, b) => a.expiresAt - b.expiresAt).at(-1)?.expiresAt;
            if (filtered.length > 0 && furthestSessionExp && furthestSessionExp > Date.now()) await secondaryStorage.set(`active-sessions-${userId}`, JSON.stringify(filtered), Math.floor((furthestSessionExp - now2) / 1e3));
            else await secondaryStorage.delete(`active-sessions-${userId}`);
          } else logger2.error("Active sessions list not found in secondary storage");
        }
        await secondaryStorage.delete(token2);
        if (!options.session?.storeSessionInDatabase || ctx.options.session?.preserveSessionInDatabase) return;
      }
      await deleteWithHooks([{
        field: "token",
        value: token2
      }], "session", void 0);
    },
    deleteAccounts: async (userId) => {
      await deleteManyWithHooks([{
        field: "userId",
        value: userId
      }], "account", void 0);
    },
    deleteAccount: async (accountId) => {
      await deleteWithHooks([{
        field: "id",
        value: accountId
      }], "account", void 0);
    },
    deleteSessions: async (userIdOrSessionTokens) => {
      if (secondaryStorage) {
        if (typeof userIdOrSessionTokens === "string") {
          const activeSession = await secondaryStorage.get(`active-sessions-${userIdOrSessionTokens}`);
          const sessions = activeSession ? safeJSONParse(activeSession) : [];
          if (!sessions) return;
          for (const session of sessions) await secondaryStorage.delete(session.token);
          await secondaryStorage.delete(`active-sessions-${userIdOrSessionTokens}`);
        } else for (const sessionToken of userIdOrSessionTokens) if (await secondaryStorage.get(sessionToken)) await secondaryStorage.delete(sessionToken);
        if (!options.session?.storeSessionInDatabase || ctx.options.session?.preserveSessionInDatabase) return;
      }
      await deleteManyWithHooks([{
        field: Array.isArray(userIdOrSessionTokens) ? "token" : "userId",
        value: userIdOrSessionTokens,
        operator: Array.isArray(userIdOrSessionTokens) ? "in" : void 0
      }], "session", void 0);
    },
    findOAuthUser: async (email, accountId, providerId) => {
      const account = await (await getCurrentAdapter(adapter)).findOne({
        model: "account",
        where: [{
          value: accountId,
          field: "accountId"
        }, {
          value: providerId,
          field: "providerId"
        }],
        join: { user: true }
      });
      if (account) if (account.user) return {
        user: account.user,
        linkedAccount: account,
        accounts: [account]
      };
      else {
        const user = await (await getCurrentAdapter(adapter)).findOne({
          model: "user",
          where: [{
            value: email.toLowerCase(),
            field: "email"
          }]
        });
        if (user) return {
          user,
          linkedAccount: account,
          accounts: [account]
        };
        return null;
      }
      else {
        const user = await (await getCurrentAdapter(adapter)).findOne({
          model: "user",
          where: [{
            value: email.toLowerCase(),
            field: "email"
          }]
        });
        if (user) return {
          user,
          linkedAccount: null,
          accounts: await (await getCurrentAdapter(adapter)).findMany({
            model: "account",
            where: [{
              value: user.id,
              field: "userId"
            }]
          }) || []
        };
        else return null;
      }
    },
    findUserByEmail: async (email, options$1) => {
      const result2 = await (await getCurrentAdapter(adapter)).findOne({
        model: "user",
        where: [{
          value: email.toLowerCase(),
          field: "email"
        }],
        join: { ...options$1?.includeAccounts ? { account: true } : {} }
      });
      if (!result2) return null;
      const { account: accounts, ...user } = result2;
      return {
        user,
        accounts: accounts ?? []
      };
    },
    findUserById: async (userId) => {
      if (!userId) return null;
      return await (await getCurrentAdapter(adapter)).findOne({
        model: "user",
        where: [{
          field: "id",
          value: userId
        }]
      });
    },
    linkAccount: async (account) => {
      return await createWithHooks({
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date(),
        ...account
      }, "account", void 0);
    },
    updateUser: async (userId, data) => {
      const user = await updateWithHooks(data, [{
        field: "id",
        value: userId
      }], "user", void 0);
      await refreshUserSessions(user);
      return user;
    },
    updateUserByEmail: async (email, data) => {
      const user = await updateWithHooks(data, [{
        field: "email",
        value: email.toLowerCase()
      }], "user", void 0);
      await refreshUserSessions(user);
      return user;
    },
    updatePassword: async (userId, password) => {
      await updateManyWithHooks({ password }, [{
        field: "userId",
        value: userId
      }, {
        field: "providerId",
        value: "credential"
      }], "account", void 0);
    },
    findAccounts: async (userId) => {
      return await (await getCurrentAdapter(adapter)).findMany({
        model: "account",
        where: [{
          field: "userId",
          value: userId
        }]
      });
    },
    findAccount: async (accountId) => {
      return await (await getCurrentAdapter(adapter)).findOne({
        model: "account",
        where: [{
          field: "accountId",
          value: accountId
        }]
      });
    },
    findAccountByProviderId: async (accountId, providerId) => {
      return await (await getCurrentAdapter(adapter)).findOne({
        model: "account",
        where: [{
          field: "accountId",
          value: accountId
        }, {
          field: "providerId",
          value: providerId
        }]
      });
    },
    findAccountByUserId: async (userId) => {
      return await (await getCurrentAdapter(adapter)).findMany({
        model: "account",
        where: [{
          field: "userId",
          value: userId
        }]
      });
    },
    updateAccount: async (id, data) => {
      return await updateWithHooks(data, [{
        field: "id",
        value: id
      }], "account", void 0);
    },
    createVerificationValue: async (data) => {
      return await createWithHooks({
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date(),
        ...data
      }, "verification", void 0);
    },
    findVerificationValue: async (identifier) => {
      const verification = await (await getCurrentAdapter(adapter)).findMany({
        model: "verification",
        where: [{
          field: "identifier",
          value: identifier
        }],
        sortBy: {
          field: "createdAt",
          direction: "desc"
        },
        limit: 1
      });
      if (!options.verification?.disableCleanup) await deleteManyWithHooks([{
        field: "expiresAt",
        value: /* @__PURE__ */ new Date(),
        operator: "lt"
      }], "verification", void 0);
      return verification[0];
    },
    deleteVerificationValue: async (id) => {
      await deleteWithHooks([{
        field: "id",
        value: id
      }], "verification", void 0);
    },
    deleteVerificationByIdentifier: async (identifier) => {
      await deleteWithHooks([{
        field: "identifier",
        value: identifier
      }], "verification", void 0);
    },
    updateVerificationValue: async (id, data) => {
      return await updateWithHooks(data, [{
        field: "id",
        value: id
      }], "verification", void 0);
    }
  };
};
function toZodSchema({ fields: fields2, isClientSide }) {
  const zodFields = Object.keys(fields2).reduce((acc, key) => {
    const field = fields2[key];
    if (!field) return acc;
    if (isClientSide && field.input === false) return acc;
    let schema2;
    if (field.type === "json") schema2 = z.json ? z.json() : z.any();
    else if (field.type === "string[]" || field.type === "number[]") schema2 = z.array(field.type === "string[]" ? z.string() : z.number());
    else if (Array.isArray(field.type)) schema2 = z.any();
    else schema2 = z[field.type]();
    if (field?.required === false) schema2 = schema2.optional();
    if (!isClientSide && field?.returned === false) return acc;
    return {
      ...acc,
      [key]: schema2
    };
  }, {});
  return z.object(zodFields);
}
function getSchema(config2) {
  const tables = (0, db_exports.getAuthTables)(config2);
  const schema2 = {};
  for (const key in tables) {
    const table = tables[key];
    const fields2 = table.fields;
    const actualFields = {};
    Object.entries(fields2).forEach(([key$1, field]) => {
      actualFields[field.fieldName || key$1] = field;
      if (field.references) {
        const refTable = tables[field.references.model];
        if (refTable) actualFields[field.fieldName || key$1].references = {
          ...field.references,
          model: refTable.modelName,
          field: field.references.field
        };
      }
    });
    if (schema2[table.modelName]) {
      schema2[table.modelName].fields = {
        ...schema2[table.modelName].fields,
        ...actualFields
      };
      continue;
    }
    schema2[table.modelName] = {
      fields: actualFields,
      order: table.order || Infinity
    };
  }
  return schema2;
}
function isUndefined$1(obj) {
  return typeof obj === "undefined" || obj === void 0;
}
function isString$1(obj) {
  return typeof obj === "string";
}
function isNumber$3(obj) {
  return typeof obj === "number";
}
function isBoolean(obj) {
  return typeof obj === "boolean";
}
function isNull(obj) {
  return obj === null;
}
function isDate$1(obj) {
  return obj instanceof Date;
}
function isBigInt(obj) {
  return typeof obj === "bigint";
}
function isBuffer(obj) {
  return typeof Buffer !== "undefined" && Buffer.isBuffer(obj);
}
function isFunction$1(obj) {
  return typeof obj === "function";
}
function isObject(obj) {
  return typeof obj === "object" && obj !== null;
}
function freeze(obj) {
  return Object.freeze(obj);
}
function asArray(arg) {
  if (isReadonlyArray(arg)) {
    return arg;
  } else {
    return [arg];
  }
}
function isReadonlyArray(arg) {
  return Array.isArray(arg);
}
function noop$1(obj) {
  return obj;
}
const AlterTableNode = freeze({
  is(node) {
    return node.kind === "AlterTableNode";
  },
  create(table) {
    return freeze({
      kind: "AlterTableNode",
      table
    });
  },
  cloneWithTableProps(node, props) {
    return freeze({
      ...node,
      ...props
    });
  },
  cloneWithColumnAlteration(node, columnAlteration) {
    return freeze({
      ...node,
      columnAlterations: node.columnAlterations ? [...node.columnAlterations, columnAlteration] : [columnAlteration]
    });
  }
});
const IdentifierNode = freeze({
  is(node) {
    return node.kind === "IdentifierNode";
  },
  create(name2) {
    return freeze({
      kind: "IdentifierNode",
      name: name2
    });
  }
});
const CreateIndexNode = freeze({
  is(node) {
    return node.kind === "CreateIndexNode";
  },
  create(name2) {
    return freeze({
      kind: "CreateIndexNode",
      name: IdentifierNode.create(name2)
    });
  },
  cloneWith(node, props) {
    return freeze({
      ...node,
      ...props
    });
  },
  cloneWithColumns(node, columns) {
    return freeze({
      ...node,
      columns: [...node.columns || [], ...columns]
    });
  }
});
const CreateSchemaNode = freeze({
  is(node) {
    return node.kind === "CreateSchemaNode";
  },
  create(schema2, params) {
    return freeze({
      kind: "CreateSchemaNode",
      schema: IdentifierNode.create(schema2),
      ...params
    });
  },
  cloneWith(createSchema2, params) {
    return freeze({
      ...createSchema2,
      ...params
    });
  }
});
const ON_COMMIT_ACTIONS = ["preserve rows", "delete rows", "drop"];
const CreateTableNode = freeze({
  is(node) {
    return node.kind === "CreateTableNode";
  },
  create(table) {
    return freeze({
      kind: "CreateTableNode",
      table,
      columns: freeze([])
    });
  },
  cloneWithColumn(createTable, column) {
    return freeze({
      ...createTable,
      columns: freeze([...createTable.columns, column])
    });
  },
  cloneWithConstraint(createTable, constraint) {
    return freeze({
      ...createTable,
      constraints: createTable.constraints ? freeze([...createTable.constraints, constraint]) : freeze([constraint])
    });
  },
  cloneWithFrontModifier(createTable, modifier) {
    return freeze({
      ...createTable,
      frontModifiers: createTable.frontModifiers ? freeze([...createTable.frontModifiers, modifier]) : freeze([modifier])
    });
  },
  cloneWithEndModifier(createTable, modifier) {
    return freeze({
      ...createTable,
      endModifiers: createTable.endModifiers ? freeze([...createTable.endModifiers, modifier]) : freeze([modifier])
    });
  },
  cloneWith(createTable, params) {
    return freeze({
      ...createTable,
      ...params
    });
  }
});
const SchemableIdentifierNode = freeze({
  is(node) {
    return node.kind === "SchemableIdentifierNode";
  },
  create(identifier) {
    return freeze({
      kind: "SchemableIdentifierNode",
      identifier: IdentifierNode.create(identifier)
    });
  },
  createWithSchema(schema2, identifier) {
    return freeze({
      kind: "SchemableIdentifierNode",
      schema: IdentifierNode.create(schema2),
      identifier: IdentifierNode.create(identifier)
    });
  }
});
const DropIndexNode = freeze({
  is(node) {
    return node.kind === "DropIndexNode";
  },
  create(name2, params) {
    return freeze({
      kind: "DropIndexNode",
      name: SchemableIdentifierNode.create(name2),
      ...params
    });
  },
  cloneWith(dropIndex, props) {
    return freeze({
      ...dropIndex,
      ...props
    });
  }
});
const DropSchemaNode = freeze({
  is(node) {
    return node.kind === "DropSchemaNode";
  },
  create(schema2, params) {
    return freeze({
      kind: "DropSchemaNode",
      schema: IdentifierNode.create(schema2),
      ...params
    });
  },
  cloneWith(dropSchema, params) {
    return freeze({
      ...dropSchema,
      ...params
    });
  }
});
const DropTableNode = freeze({
  is(node) {
    return node.kind === "DropTableNode";
  },
  create(table, params) {
    return freeze({
      kind: "DropTableNode",
      table,
      ...params
    });
  },
  cloneWith(dropIndex, params) {
    return freeze({
      ...dropIndex,
      ...params
    });
  }
});
const AliasNode = freeze({
  is(node) {
    return node.kind === "AliasNode";
  },
  create(node, alias2) {
    return freeze({
      kind: "AliasNode",
      node,
      alias: alias2
    });
  }
});
const TableNode = freeze({
  is(node) {
    return node.kind === "TableNode";
  },
  create(table) {
    return freeze({
      kind: "TableNode",
      table: SchemableIdentifierNode.create(table)
    });
  },
  createWithSchema(schema2, table) {
    return freeze({
      kind: "TableNode",
      table: SchemableIdentifierNode.createWithSchema(schema2, table)
    });
  }
});
function isOperationNodeSource(obj) {
  return isObject(obj) && isFunction$1(obj.toOperationNode);
}
function isExpression(obj) {
  return isObject(obj) && "expressionType" in obj && isOperationNodeSource(obj);
}
function isAliasedExpression(obj) {
  return isObject(obj) && "expression" in obj && isString$1(obj.alias) && isOperationNodeSource(obj);
}
const SelectModifierNode = freeze({
  is(node) {
    return node.kind === "SelectModifierNode";
  },
  create(modifier, of) {
    return freeze({
      kind: "SelectModifierNode",
      modifier,
      of
    });
  },
  createWithExpression(modifier) {
    return freeze({
      kind: "SelectModifierNode",
      rawModifier: modifier
    });
  }
});
const AndNode = freeze({
  is(node) {
    return node.kind === "AndNode";
  },
  create(left2, right2) {
    return freeze({
      kind: "AndNode",
      left: left2,
      right: right2
    });
  }
});
const OrNode = freeze({
  is(node) {
    return node.kind === "OrNode";
  },
  create(left2, right2) {
    return freeze({
      kind: "OrNode",
      left: left2,
      right: right2
    });
  }
});
const OnNode = freeze({
  is(node) {
    return node.kind === "OnNode";
  },
  create(filter) {
    return freeze({
      kind: "OnNode",
      on: filter
    });
  },
  cloneWithOperation(onNode, operator2, operation) {
    return freeze({
      ...onNode,
      on: operator2 === "And" ? AndNode.create(onNode.on, operation) : OrNode.create(onNode.on, operation)
    });
  }
});
const JoinNode = freeze({
  is(node) {
    return node.kind === "JoinNode";
  },
  create(joinType, table) {
    return freeze({
      kind: "JoinNode",
      joinType,
      table,
      on: void 0
    });
  },
  createWithOn(joinType, table, on) {
    return freeze({
      kind: "JoinNode",
      joinType,
      table,
      on: OnNode.create(on)
    });
  },
  cloneWithOn(joinNode, operation) {
    return freeze({
      ...joinNode,
      on: joinNode.on ? OnNode.cloneWithOperation(joinNode.on, "And", operation) : OnNode.create(operation)
    });
  }
});
const BinaryOperationNode = freeze({
  is(node) {
    return node.kind === "BinaryOperationNode";
  },
  create(leftOperand, operator2, rightOperand) {
    return freeze({
      kind: "BinaryOperationNode",
      leftOperand,
      operator: operator2,
      rightOperand
    });
  }
});
const COMPARISON_OPERATORS = [
  "=",
  "==",
  "!=",
  "<>",
  ">",
  ">=",
  "<",
  "<=",
  "in",
  "not in",
  "is",
  "is not",
  "like",
  "not like",
  "match",
  "ilike",
  "not ilike",
  "@>",
  "<@",
  "^@",
  "&&",
  "?",
  "?&",
  "?|",
  "!<",
  "!>",
  "<=>",
  "!~",
  "~",
  "~*",
  "!~*",
  "@@",
  "@@@",
  "!!",
  "<->",
  "regexp",
  "is distinct from",
  "is not distinct from"
];
const ARITHMETIC_OPERATORS = [
  "+",
  "-",
  "*",
  "/",
  "%",
  "^",
  "&",
  "|",
  "#",
  "<<",
  ">>"
];
const JSON_OPERATORS = ["->", "->>"];
const BINARY_OPERATORS = [
  ...COMPARISON_OPERATORS,
  ...ARITHMETIC_OPERATORS,
  "&&",
  "||"
];
const UNARY_FILTER_OPERATORS = ["exists", "not exists"];
const UNARY_OPERATORS = ["not", "-", ...UNARY_FILTER_OPERATORS];
const OPERATORS = [
  ...BINARY_OPERATORS,
  ...JSON_OPERATORS,
  ...UNARY_OPERATORS,
  "between",
  "between symmetric"
];
const OperatorNode = freeze({
  is(node) {
    return node.kind === "OperatorNode";
  },
  create(operator2) {
    return freeze({
      kind: "OperatorNode",
      operator: operator2
    });
  }
});
function isJSONOperator(op) {
  return isString$1(op) && JSON_OPERATORS.includes(op);
}
const ColumnNode = freeze({
  is(node) {
    return node.kind === "ColumnNode";
  },
  create(column) {
    return freeze({
      kind: "ColumnNode",
      column: IdentifierNode.create(column)
    });
  }
});
const SelectAllNode = freeze({
  is(node) {
    return node.kind === "SelectAllNode";
  },
  create() {
    return freeze({
      kind: "SelectAllNode"
    });
  }
});
const ReferenceNode = freeze({
  is(node) {
    return node.kind === "ReferenceNode";
  },
  create(column, table) {
    return freeze({
      kind: "ReferenceNode",
      table,
      column
    });
  },
  createSelectAll(table) {
    return freeze({
      kind: "ReferenceNode",
      table,
      column: SelectAllNode.create()
    });
  }
});
class DynamicReferenceBuilder {
  #dynamicReference;
  get dynamicReference() {
    return this.#dynamicReference;
  }
  /**
   * @private
   *
   * This needs to be here just so that the typings work. Without this
   * the generated .d.ts file contains no reference to the type param R
   * which causes this type to be equal to DynamicReferenceBuilder with
   * any R.
   */
  get refType() {
    return void 0;
  }
  constructor(reference) {
    this.#dynamicReference = reference;
  }
  toOperationNode() {
    return parseSimpleReferenceExpression(this.#dynamicReference);
  }
}
function isDynamicReferenceBuilder(obj) {
  return isObject(obj) && isOperationNodeSource(obj) && isString$1(obj.dynamicReference);
}
const OrderByItemNode = freeze({
  is(node) {
    return node.kind === "OrderByItemNode";
  },
  create(orderBy, direction) {
    return freeze({
      kind: "OrderByItemNode",
      orderBy,
      direction
    });
  },
  cloneWith(node, props) {
    return freeze({
      ...node,
      ...props
    });
  }
});
const RawNode = freeze({
  is(node) {
    return node.kind === "RawNode";
  },
  create(sqlFragments, parameters) {
    return freeze({
      kind: "RawNode",
      sqlFragments: freeze(sqlFragments),
      parameters: freeze(parameters)
    });
  },
  createWithSql(sql2) {
    return RawNode.create([sql2], []);
  },
  createWithChild(child) {
    return RawNode.create(["", ""], [child]);
  },
  createWithChildren(children) {
    return RawNode.create(new Array(children.length + 1).fill(""), children);
  }
});
const CollateNode = freeze({
  is(node) {
    return node.kind === "CollateNode";
  },
  create(collation) {
    return freeze({
      kind: "CollateNode",
      collation: IdentifierNode.create(collation)
    });
  }
});
class OrderByItemBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * Adds `desc` to the `order by` item.
   *
   * See {@link asc} for the opposite.
   */
  desc() {
    return new OrderByItemBuilder({
      node: OrderByItemNode.cloneWith(this.#props.node, {
        direction: RawNode.createWithSql("desc")
      })
    });
  }
  /**
   * Adds `asc` to the `order by` item.
   *
   * See {@link desc} for the opposite.
   */
  asc() {
    return new OrderByItemBuilder({
      node: OrderByItemNode.cloneWith(this.#props.node, {
        direction: RawNode.createWithSql("asc")
      })
    });
  }
  /**
   * Adds `nulls last` to the `order by` item.
   *
   * This is only supported by some dialects like PostgreSQL and SQLite.
   *
   * See {@link nullsFirst} for the opposite.
   */
  nullsLast() {
    return new OrderByItemBuilder({
      node: OrderByItemNode.cloneWith(this.#props.node, { nulls: "last" })
    });
  }
  /**
   * Adds `nulls first` to the `order by` item.
   *
   * This is only supported by some dialects like PostgreSQL and SQLite.
   *
   * See {@link nullsLast} for the opposite.
   */
  nullsFirst() {
    return new OrderByItemBuilder({
      node: OrderByItemNode.cloneWith(this.#props.node, { nulls: "first" })
    });
  }
  /**
   * Adds `collate <collationName>` to the `order by` item.
   */
  collate(collation) {
    return new OrderByItemBuilder({
      node: OrderByItemNode.cloneWith(this.#props.node, {
        collation: CollateNode.create(collation)
      })
    });
  }
  toOperationNode() {
    return this.#props.node;
  }
}
const LOGGED_MESSAGES = /* @__PURE__ */ new Set();
function logOnce(message2) {
  if (LOGGED_MESSAGES.has(message2)) {
    return;
  }
  LOGGED_MESSAGES.add(message2);
  console.log(message2);
}
function isOrderByDirection(thing) {
  return thing === "asc" || thing === "desc";
}
function parseOrderBy(args) {
  if (args.length === 2) {
    return [parseOrderByItem(args[0], args[1])];
  }
  if (args.length === 1) {
    const [orderBy] = args;
    if (Array.isArray(orderBy)) {
      logOnce("orderBy(array) is deprecated, use multiple orderBy calls instead.");
      return orderBy.map((item) => parseOrderByItem(item));
    }
    return [parseOrderByItem(orderBy)];
  }
  throw new Error(`Invalid number of arguments at order by! expected 1-2, received ${args.length}`);
}
function parseOrderByItem(expr, modifiers) {
  const parsedRef = parseOrderByExpression(expr);
  if (OrderByItemNode.is(parsedRef)) {
    if (modifiers) {
      throw new Error("Cannot specify direction twice!");
    }
    return parsedRef;
  }
  return parseOrderByWithModifiers(parsedRef, modifiers);
}
function parseOrderByExpression(expr) {
  if (isExpressionOrFactory(expr)) {
    return parseExpression(expr);
  }
  if (isDynamicReferenceBuilder(expr)) {
    return expr.toOperationNode();
  }
  const [ref2, direction] = expr.split(" ");
  if (direction) {
    logOnce("`orderBy('column asc')` is deprecated. Use `orderBy('column', 'asc')` instead.");
    return parseOrderByWithModifiers(parseStringReference(ref2), direction);
  }
  return parseStringReference(expr);
}
function parseOrderByWithModifiers(expr, modifiers) {
  if (typeof modifiers === "string") {
    if (!isOrderByDirection(modifiers)) {
      throw new Error(`Invalid order by direction: ${modifiers}`);
    }
    return OrderByItemNode.create(expr, RawNode.createWithSql(modifiers));
  }
  if (isExpression(modifiers)) {
    logOnce("`orderBy(..., expr)` is deprecated. Use `orderBy(..., 'asc')` or `orderBy(..., (ob) => ...)` instead.");
    return OrderByItemNode.create(expr, modifiers.toOperationNode());
  }
  const node = OrderByItemNode.create(expr);
  if (!modifiers) {
    return node;
  }
  return modifiers(new OrderByItemBuilder({ node })).toOperationNode();
}
const JSONReferenceNode = freeze({
  is(node) {
    return node.kind === "JSONReferenceNode";
  },
  create(reference, traversal) {
    return freeze({
      kind: "JSONReferenceNode",
      reference,
      traversal
    });
  },
  cloneWithTraversal(node, traversal) {
    return freeze({
      ...node,
      traversal
    });
  }
});
const JSONOperatorChainNode = freeze({
  is(node) {
    return node.kind === "JSONOperatorChainNode";
  },
  create(operator2) {
    return freeze({
      kind: "JSONOperatorChainNode",
      operator: operator2,
      values: freeze([])
    });
  },
  cloneWithValue(node, value) {
    return freeze({
      ...node,
      values: freeze([...node.values, value])
    });
  }
});
const JSONPathNode = freeze({
  is(node) {
    return node.kind === "JSONPathNode";
  },
  create(inOperator) {
    return freeze({
      kind: "JSONPathNode",
      inOperator,
      pathLegs: freeze([])
    });
  },
  cloneWithLeg(jsonPathNode, pathLeg) {
    return freeze({
      ...jsonPathNode,
      pathLegs: freeze([...jsonPathNode.pathLegs, pathLeg])
    });
  }
});
function parseSimpleReferenceExpression(exp) {
  if (isString$1(exp)) {
    return parseStringReference(exp);
  }
  return exp.toOperationNode();
}
function parseReferenceExpressionOrList(arg) {
  if (isReadonlyArray(arg)) {
    return arg.map((it) => parseReferenceExpression(it));
  } else {
    return [parseReferenceExpression(arg)];
  }
}
function parseReferenceExpression(exp) {
  if (isExpressionOrFactory(exp)) {
    return parseExpression(exp);
  }
  return parseSimpleReferenceExpression(exp);
}
function parseJSONReference(ref2, op) {
  const referenceNode = parseStringReference(ref2);
  if (isJSONOperator(op)) {
    return JSONReferenceNode.create(referenceNode, JSONOperatorChainNode.create(OperatorNode.create(op)));
  }
  const opWithoutLastChar = op.slice(0, -1);
  if (isJSONOperator(opWithoutLastChar)) {
    return JSONReferenceNode.create(referenceNode, JSONPathNode.create(OperatorNode.create(opWithoutLastChar)));
  }
  throw new Error(`Invalid JSON operator: ${op}`);
}
function parseStringReference(ref2) {
  const COLUMN_SEPARATOR = ".";
  if (!ref2.includes(COLUMN_SEPARATOR)) {
    return ReferenceNode.create(ColumnNode.create(ref2));
  }
  const parts = ref2.split(COLUMN_SEPARATOR).map(trim$2);
  if (parts.length === 3) {
    return parseStringReferenceWithTableAndSchema(parts);
  }
  if (parts.length === 2) {
    return parseStringReferenceWithTable(parts);
  }
  throw new Error(`invalid column reference ${ref2}`);
}
function parseAliasedStringReference(ref2) {
  const ALIAS_SEPARATOR = " as ";
  if (ref2.includes(ALIAS_SEPARATOR)) {
    const [columnRef, alias2] = ref2.split(ALIAS_SEPARATOR).map(trim$2);
    return AliasNode.create(parseStringReference(columnRef), IdentifierNode.create(alias2));
  } else {
    return parseStringReference(ref2);
  }
}
function parseColumnName(column) {
  return ColumnNode.create(column);
}
function parseOrderedColumnName(column) {
  const ORDER_SEPARATOR = " ";
  if (column.includes(ORDER_SEPARATOR)) {
    const [columnName, order] = column.split(ORDER_SEPARATOR).map(trim$2);
    if (!isOrderByDirection(order)) {
      throw new Error(`invalid order direction "${order}" next to "${columnName}"`);
    }
    return parseOrderBy([columnName, order])[0];
  } else {
    return parseColumnName(column);
  }
}
function parseStringReferenceWithTableAndSchema(parts) {
  const [schema2, table, column] = parts;
  return ReferenceNode.create(ColumnNode.create(column), TableNode.createWithSchema(schema2, table));
}
function parseStringReferenceWithTable(parts) {
  const [table, column] = parts;
  return ReferenceNode.create(ColumnNode.create(column), TableNode.create(table));
}
function trim$2(str) {
  return str.trim();
}
const PrimitiveValueListNode = freeze({
  is(node) {
    return node.kind === "PrimitiveValueListNode";
  },
  create(values) {
    return freeze({
      kind: "PrimitiveValueListNode",
      values: freeze([...values])
    });
  }
});
const ValueListNode = freeze({
  is(node) {
    return node.kind === "ValueListNode";
  },
  create(values) {
    return freeze({
      kind: "ValueListNode",
      values: freeze(values)
    });
  }
});
const ValueNode = freeze({
  is(node) {
    return node.kind === "ValueNode";
  },
  create(value) {
    return freeze({
      kind: "ValueNode",
      value
    });
  },
  createImmediate(value) {
    return freeze({
      kind: "ValueNode",
      value,
      immediate: true
    });
  }
});
function parseValueExpressionOrList(arg) {
  if (isReadonlyArray(arg)) {
    return parseValueExpressionList(arg);
  }
  return parseValueExpression(arg);
}
function parseValueExpression(exp) {
  if (isExpressionOrFactory(exp)) {
    return parseExpression(exp);
  }
  return ValueNode.create(exp);
}
function isSafeImmediateValue(value) {
  return isNumber$3(value) || isBoolean(value) || isNull(value);
}
function parseSafeImmediateValue(value) {
  if (!isSafeImmediateValue(value)) {
    throw new Error(`unsafe immediate value ${JSON.stringify(value)}`);
  }
  return ValueNode.createImmediate(value);
}
function parseValueExpressionList(arg) {
  if (arg.some(isExpressionOrFactory)) {
    return ValueListNode.create(arg.map((it) => parseValueExpression(it)));
  }
  return PrimitiveValueListNode.create(arg);
}
const ParensNode = freeze({
  is(node) {
    return node.kind === "ParensNode";
  },
  create(node) {
    return freeze({
      kind: "ParensNode",
      node
    });
  }
});
function parseValueBinaryOperationOrExpression(args) {
  if (args.length === 3) {
    return parseValueBinaryOperation(args[0], args[1], args[2]);
  } else if (args.length === 1) {
    return parseValueExpression(args[0]);
  }
  throw new Error(`invalid arguments: ${JSON.stringify(args)}`);
}
function parseValueBinaryOperation(left2, operator2, right2) {
  if (isIsOperator(operator2) && needsIsOperator(right2)) {
    return BinaryOperationNode.create(parseReferenceExpression(left2), parseOperator(operator2), ValueNode.createImmediate(right2));
  }
  return BinaryOperationNode.create(parseReferenceExpression(left2), parseOperator(operator2), parseValueExpressionOrList(right2));
}
function parseReferentialBinaryOperation(left2, operator2, right2) {
  return BinaryOperationNode.create(parseReferenceExpression(left2), parseOperator(operator2), parseReferenceExpression(right2));
}
function parseFilterObject(obj, combinator) {
  return parseFilterList(Object.entries(obj).filter(([, v]) => !isUndefined$1(v)).map(([k, v]) => parseValueBinaryOperation(k, needsIsOperator(v) ? "is" : "=", v)), combinator);
}
function parseFilterList(list, combinator, withParens = true) {
  const combine = combinator === "and" ? AndNode.create : OrNode.create;
  if (list.length === 0) {
    return BinaryOperationNode.create(ValueNode.createImmediate(1), OperatorNode.create("="), ValueNode.createImmediate(combinator === "and" ? 1 : 0));
  }
  let node = toOperationNode(list[0]);
  for (let i = 1; i < list.length; ++i) {
    node = combine(node, toOperationNode(list[i]));
  }
  if (list.length > 1 && withParens) {
    return ParensNode.create(node);
  }
  return node;
}
function isIsOperator(operator2) {
  return operator2 === "is" || operator2 === "is not";
}
function needsIsOperator(value) {
  return isNull(value) || isBoolean(value);
}
function parseOperator(operator2) {
  if (isString$1(operator2) && OPERATORS.includes(operator2)) {
    return OperatorNode.create(operator2);
  }
  if (isOperationNodeSource(operator2)) {
    return operator2.toOperationNode();
  }
  throw new Error(`invalid operator ${JSON.stringify(operator2)}`);
}
function toOperationNode(nodeOrSource) {
  return isOperationNodeSource(nodeOrSource) ? nodeOrSource.toOperationNode() : nodeOrSource;
}
const OrderByNode = freeze({
  is(node) {
    return node.kind === "OrderByNode";
  },
  create(items) {
    return freeze({
      kind: "OrderByNode",
      items: freeze([...items])
    });
  },
  cloneWithItems(orderBy, items) {
    return freeze({
      ...orderBy,
      items: freeze([...orderBy.items, ...items])
    });
  }
});
const PartitionByNode = freeze({
  is(node) {
    return node.kind === "PartitionByNode";
  },
  create(items) {
    return freeze({
      kind: "PartitionByNode",
      items: freeze(items)
    });
  },
  cloneWithItems(partitionBy, items) {
    return freeze({
      ...partitionBy,
      items: freeze([...partitionBy.items, ...items])
    });
  }
});
const OverNode = freeze({
  is(node) {
    return node.kind === "OverNode";
  },
  create() {
    return freeze({
      kind: "OverNode"
    });
  },
  cloneWithOrderByItems(overNode, items) {
    return freeze({
      ...overNode,
      orderBy: overNode.orderBy ? OrderByNode.cloneWithItems(overNode.orderBy, items) : OrderByNode.create(items)
    });
  },
  cloneWithPartitionByItems(overNode, items) {
    return freeze({
      ...overNode,
      partitionBy: overNode.partitionBy ? PartitionByNode.cloneWithItems(overNode.partitionBy, items) : PartitionByNode.create(items)
    });
  }
});
const FromNode = freeze({
  is(node) {
    return node.kind === "FromNode";
  },
  create(froms) {
    return freeze({
      kind: "FromNode",
      froms: freeze(froms)
    });
  },
  cloneWithFroms(from, froms) {
    return freeze({
      ...from,
      froms: freeze([...from.froms, ...froms])
    });
  }
});
const GroupByNode = freeze({
  is(node) {
    return node.kind === "GroupByNode";
  },
  create(items) {
    return freeze({
      kind: "GroupByNode",
      items: freeze(items)
    });
  },
  cloneWithItems(groupBy, items) {
    return freeze({
      ...groupBy,
      items: freeze([...groupBy.items, ...items])
    });
  }
});
const HavingNode = freeze({
  is(node) {
    return node.kind === "HavingNode";
  },
  create(filter) {
    return freeze({
      kind: "HavingNode",
      having: filter
    });
  },
  cloneWithOperation(havingNode, operator2, operation) {
    return freeze({
      ...havingNode,
      having: operator2 === "And" ? AndNode.create(havingNode.having, operation) : OrNode.create(havingNode.having, operation)
    });
  }
});
const InsertQueryNode = freeze({
  is(node) {
    return node.kind === "InsertQueryNode";
  },
  create(into, withNode, replace) {
    return freeze({
      kind: "InsertQueryNode",
      into,
      ...withNode && { with: withNode },
      replace
    });
  },
  createWithoutInto() {
    return freeze({
      kind: "InsertQueryNode"
    });
  },
  cloneWith(insertQuery, props) {
    return freeze({
      ...insertQuery,
      ...props
    });
  }
});
const ListNode = freeze({
  is(node) {
    return node.kind === "ListNode";
  },
  create(items) {
    return freeze({
      kind: "ListNode",
      items: freeze(items)
    });
  }
});
const UpdateQueryNode = freeze({
  is(node) {
    return node.kind === "UpdateQueryNode";
  },
  create(tables, withNode) {
    return freeze({
      kind: "UpdateQueryNode",
      // For backwards compatibility, use the raw table node when there's only one table
      // and don't rename the property to something like `tables`.
      table: tables.length === 1 ? tables[0] : ListNode.create(tables),
      ...withNode && { with: withNode }
    });
  },
  createWithoutTable() {
    return freeze({
      kind: "UpdateQueryNode"
    });
  },
  cloneWithFromItems(updateQuery, fromItems) {
    return freeze({
      ...updateQuery,
      from: updateQuery.from ? FromNode.cloneWithFroms(updateQuery.from, fromItems) : FromNode.create(fromItems)
    });
  },
  cloneWithUpdates(updateQuery, updates) {
    return freeze({
      ...updateQuery,
      updates: updateQuery.updates ? freeze([...updateQuery.updates, ...updates]) : updates
    });
  },
  cloneWithLimit(updateQuery, limit) {
    return freeze({
      ...updateQuery,
      limit
    });
  }
});
const UsingNode = freeze({
  is(node) {
    return node.kind === "UsingNode";
  },
  create(tables) {
    return freeze({
      kind: "UsingNode",
      tables: freeze(tables)
    });
  },
  cloneWithTables(using, tables) {
    return freeze({
      ...using,
      tables: freeze([...using.tables, ...tables])
    });
  }
});
const DeleteQueryNode = freeze({
  is(node) {
    return node.kind === "DeleteQueryNode";
  },
  create(fromItems, withNode) {
    return freeze({
      kind: "DeleteQueryNode",
      from: FromNode.create(fromItems),
      ...withNode && { with: withNode }
    });
  },
  // TODO: remove in v0.29
  /**
   * @deprecated Use `QueryNode.cloneWithoutOrderBy` instead.
   */
  cloneWithOrderByItems: (node, items) => QueryNode.cloneWithOrderByItems(node, items),
  // TODO: remove in v0.29
  /**
   * @deprecated Use `QueryNode.cloneWithoutOrderBy` instead.
   */
  cloneWithoutOrderBy: (node) => QueryNode.cloneWithoutOrderBy(node),
  cloneWithLimit(deleteNode, limit) {
    return freeze({
      ...deleteNode,
      limit
    });
  },
  cloneWithoutLimit(deleteNode) {
    return freeze({
      ...deleteNode,
      limit: void 0
    });
  },
  cloneWithUsing(deleteNode, tables) {
    return freeze({
      ...deleteNode,
      using: deleteNode.using !== void 0 ? UsingNode.cloneWithTables(deleteNode.using, tables) : UsingNode.create(tables)
    });
  }
});
const WhereNode = freeze({
  is(node) {
    return node.kind === "WhereNode";
  },
  create(filter) {
    return freeze({
      kind: "WhereNode",
      where: filter
    });
  },
  cloneWithOperation(whereNode, operator2, operation) {
    return freeze({
      ...whereNode,
      where: operator2 === "And" ? AndNode.create(whereNode.where, operation) : OrNode.create(whereNode.where, operation)
    });
  }
});
const ReturningNode = freeze({
  is(node) {
    return node.kind === "ReturningNode";
  },
  create(selections) {
    return freeze({
      kind: "ReturningNode",
      selections: freeze(selections)
    });
  },
  cloneWithSelections(returning, selections) {
    return freeze({
      ...returning,
      selections: returning.selections ? freeze([...returning.selections, ...selections]) : freeze(selections)
    });
  }
});
const ExplainNode = freeze({
  is(node) {
    return node.kind === "ExplainNode";
  },
  create(format2, options) {
    return freeze({
      kind: "ExplainNode",
      format: format2,
      options
    });
  }
});
const WhenNode = freeze({
  is(node) {
    return node.kind === "WhenNode";
  },
  create(condition) {
    return freeze({
      kind: "WhenNode",
      condition
    });
  },
  cloneWithResult(whenNode, result2) {
    return freeze({
      ...whenNode,
      result: result2
    });
  }
});
const MergeQueryNode = freeze({
  is(node) {
    return node.kind === "MergeQueryNode";
  },
  create(into, withNode) {
    return freeze({
      kind: "MergeQueryNode",
      into,
      ...withNode && { with: withNode }
    });
  },
  cloneWithUsing(mergeNode, using) {
    return freeze({
      ...mergeNode,
      using
    });
  },
  cloneWithWhen(mergeNode, when) {
    return freeze({
      ...mergeNode,
      whens: mergeNode.whens ? freeze([...mergeNode.whens, when]) : freeze([when])
    });
  },
  cloneWithThen(mergeNode, then) {
    return freeze({
      ...mergeNode,
      whens: mergeNode.whens ? freeze([
        ...mergeNode.whens.slice(0, -1),
        WhenNode.cloneWithResult(mergeNode.whens[mergeNode.whens.length - 1], then)
      ]) : void 0
    });
  }
});
const OutputNode = freeze({
  is(node) {
    return node.kind === "OutputNode";
  },
  create(selections) {
    return freeze({
      kind: "OutputNode",
      selections: freeze(selections)
    });
  },
  cloneWithSelections(output, selections) {
    return freeze({
      ...output,
      selections: output.selections ? freeze([...output.selections, ...selections]) : freeze(selections)
    });
  }
});
const QueryNode = freeze({
  is(node) {
    return SelectQueryNode.is(node) || InsertQueryNode.is(node) || UpdateQueryNode.is(node) || DeleteQueryNode.is(node) || MergeQueryNode.is(node);
  },
  cloneWithEndModifier(node, modifier) {
    return freeze({
      ...node,
      endModifiers: node.endModifiers ? freeze([...node.endModifiers, modifier]) : freeze([modifier])
    });
  },
  cloneWithWhere(node, operation) {
    return freeze({
      ...node,
      where: node.where ? WhereNode.cloneWithOperation(node.where, "And", operation) : WhereNode.create(operation)
    });
  },
  cloneWithJoin(node, join2) {
    return freeze({
      ...node,
      joins: node.joins ? freeze([...node.joins, join2]) : freeze([join2])
    });
  },
  cloneWithReturning(node, selections) {
    return freeze({
      ...node,
      returning: node.returning ? ReturningNode.cloneWithSelections(node.returning, selections) : ReturningNode.create(selections)
    });
  },
  cloneWithoutReturning(node) {
    return freeze({
      ...node,
      returning: void 0
    });
  },
  cloneWithoutWhere(node) {
    return freeze({
      ...node,
      where: void 0
    });
  },
  cloneWithExplain(node, format2, options) {
    return freeze({
      ...node,
      explain: ExplainNode.create(format2, options?.toOperationNode())
    });
  },
  cloneWithTop(node, top) {
    return freeze({
      ...node,
      top
    });
  },
  cloneWithOutput(node, selections) {
    return freeze({
      ...node,
      output: node.output ? OutputNode.cloneWithSelections(node.output, selections) : OutputNode.create(selections)
    });
  },
  cloneWithOrderByItems(node, items) {
    return freeze({
      ...node,
      orderBy: node.orderBy ? OrderByNode.cloneWithItems(node.orderBy, items) : OrderByNode.create(items)
    });
  },
  cloneWithoutOrderBy(node) {
    return freeze({
      ...node,
      orderBy: void 0
    });
  }
});
const SelectQueryNode = freeze({
  is(node) {
    return node.kind === "SelectQueryNode";
  },
  create(withNode) {
    return freeze({
      kind: "SelectQueryNode",
      ...withNode && { with: withNode }
    });
  },
  createFrom(fromItems, withNode) {
    return freeze({
      kind: "SelectQueryNode",
      from: FromNode.create(fromItems),
      ...withNode && { with: withNode }
    });
  },
  cloneWithSelections(select, selections) {
    return freeze({
      ...select,
      selections: select.selections ? freeze([...select.selections, ...selections]) : freeze(selections)
    });
  },
  cloneWithDistinctOn(select, expressions) {
    return freeze({
      ...select,
      distinctOn: select.distinctOn ? freeze([...select.distinctOn, ...expressions]) : freeze(expressions)
    });
  },
  cloneWithFrontModifier(select, modifier) {
    return freeze({
      ...select,
      frontModifiers: select.frontModifiers ? freeze([...select.frontModifiers, modifier]) : freeze([modifier])
    });
  },
  // TODO: remove in v0.29
  /**
   * @deprecated Use `QueryNode.cloneWithoutOrderBy` instead.
   */
  cloneWithOrderByItems: (node, items) => QueryNode.cloneWithOrderByItems(node, items),
  cloneWithGroupByItems(selectNode, items) {
    return freeze({
      ...selectNode,
      groupBy: selectNode.groupBy ? GroupByNode.cloneWithItems(selectNode.groupBy, items) : GroupByNode.create(items)
    });
  },
  cloneWithLimit(selectNode, limit) {
    return freeze({
      ...selectNode,
      limit
    });
  },
  cloneWithOffset(selectNode, offset2) {
    return freeze({
      ...selectNode,
      offset: offset2
    });
  },
  cloneWithFetch(selectNode, fetch2) {
    return freeze({
      ...selectNode,
      fetch: fetch2
    });
  },
  cloneWithHaving(selectNode, operation) {
    return freeze({
      ...selectNode,
      having: selectNode.having ? HavingNode.cloneWithOperation(selectNode.having, "And", operation) : HavingNode.create(operation)
    });
  },
  cloneWithSetOperations(selectNode, setOperations) {
    return freeze({
      ...selectNode,
      setOperations: selectNode.setOperations ? freeze([...selectNode.setOperations, ...setOperations]) : freeze([...setOperations])
    });
  },
  cloneWithoutSelections(select) {
    return freeze({
      ...select,
      selections: []
    });
  },
  cloneWithoutLimit(select) {
    return freeze({
      ...select,
      limit: void 0
    });
  },
  cloneWithoutOffset(select) {
    return freeze({
      ...select,
      offset: void 0
    });
  },
  // TODO: remove in v0.29
  /**
   * @deprecated Use `QueryNode.cloneWithoutOrderBy` instead.
   */
  cloneWithoutOrderBy: (node) => QueryNode.cloneWithoutOrderBy(node),
  cloneWithoutGroupBy(select) {
    return freeze({
      ...select,
      groupBy: void 0
    });
  }
});
class JoinBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  on(...args) {
    return new JoinBuilder({
      ...this.#props,
      joinNode: JoinNode.cloneWithOn(this.#props.joinNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  /**
   * Just like {@link WhereInterface.whereRef} but adds an item to the join's
   * `on` clause instead.
   *
   * See {@link WhereInterface.whereRef} for documentation and examples.
   */
  onRef(lhs, op, rhs) {
    return new JoinBuilder({
      ...this.#props,
      joinNode: JoinNode.cloneWithOn(this.#props.joinNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  /**
   * Adds `on true`.
   */
  onTrue() {
    return new JoinBuilder({
      ...this.#props,
      joinNode: JoinNode.cloneWithOn(this.#props.joinNode, RawNode.createWithSql("true"))
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.joinNode;
  }
}
const PartitionByItemNode = freeze({
  is(node) {
    return node.kind === "PartitionByItemNode";
  },
  create(partitionBy) {
    return freeze({
      kind: "PartitionByItemNode",
      partitionBy
    });
  }
});
function parsePartitionBy(partitionBy) {
  return parseReferenceExpressionOrList(partitionBy).map(PartitionByItemNode.create);
}
class OverBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  orderBy(...args) {
    return new OverBuilder({
      overNode: OverNode.cloneWithOrderByItems(this.#props.overNode, parseOrderBy(args))
    });
  }
  clearOrderBy() {
    return new OverBuilder({
      overNode: QueryNode.cloneWithoutOrderBy(this.#props.overNode)
    });
  }
  partitionBy(partitionBy) {
    return new OverBuilder({
      overNode: OverNode.cloneWithPartitionByItems(this.#props.overNode, parsePartitionBy(partitionBy))
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.overNode;
  }
}
const SelectionNode = freeze({
  is(node) {
    return node.kind === "SelectionNode";
  },
  create(selection) {
    return freeze({
      kind: "SelectionNode",
      selection
    });
  },
  createSelectAll() {
    return freeze({
      kind: "SelectionNode",
      selection: SelectAllNode.create()
    });
  },
  createSelectAllFromTable(table) {
    return freeze({
      kind: "SelectionNode",
      selection: ReferenceNode.createSelectAll(table)
    });
  }
});
function parseSelectArg(selection) {
  if (isFunction$1(selection)) {
    return parseSelectArg(selection(expressionBuilder()));
  } else if (isReadonlyArray(selection)) {
    return selection.map((it) => parseSelectExpression(it));
  } else {
    return [parseSelectExpression(selection)];
  }
}
function parseSelectExpression(selection) {
  if (isString$1(selection)) {
    return SelectionNode.create(parseAliasedStringReference(selection));
  } else if (isDynamicReferenceBuilder(selection)) {
    return SelectionNode.create(selection.toOperationNode());
  } else {
    return SelectionNode.create(parseAliasedExpression(selection));
  }
}
function parseSelectAll(table) {
  if (!table) {
    return [SelectionNode.createSelectAll()];
  } else if (Array.isArray(table)) {
    return table.map(parseSelectAllArg);
  } else {
    return [parseSelectAllArg(table)];
  }
}
function parseSelectAllArg(table) {
  if (isString$1(table)) {
    return SelectionNode.createSelectAllFromTable(parseTable(table));
  }
  throw new Error(`invalid value selectAll expression: ${JSON.stringify(table)}`);
}
const ValuesNode = freeze({
  is(node) {
    return node.kind === "ValuesNode";
  },
  create(values) {
    return freeze({
      kind: "ValuesNode",
      values: freeze(values)
    });
  }
});
const DefaultInsertValueNode = freeze({
  is(node) {
    return node.kind === "DefaultInsertValueNode";
  },
  create() {
    return freeze({
      kind: "DefaultInsertValueNode"
    });
  }
});
function parseInsertExpression(arg) {
  const objectOrList = isFunction$1(arg) ? arg(expressionBuilder()) : arg;
  const list = isReadonlyArray(objectOrList) ? objectOrList : freeze([objectOrList]);
  return parseInsertColumnsAndValues(list);
}
function parseInsertColumnsAndValues(rows) {
  const columns = parseColumnNamesAndIndexes(rows);
  return [
    freeze([...columns.keys()].map(ColumnNode.create)),
    ValuesNode.create(rows.map((row) => parseRowValues(row, columns)))
  ];
}
function parseColumnNamesAndIndexes(rows) {
  const columns = /* @__PURE__ */ new Map();
  for (const row of rows) {
    const cols = Object.keys(row);
    for (const col of cols) {
      if (!columns.has(col) && row[col] !== void 0) {
        columns.set(col, columns.size);
      }
    }
  }
  return columns;
}
function parseRowValues(row, columns) {
  const rowColumns = Object.keys(row);
  const rowValues = Array.from({
    length: columns.size
  });
  let hasUndefinedOrComplexColumns = false;
  let indexedRowColumns = rowColumns.length;
  for (const col of rowColumns) {
    const columnIdx = columns.get(col);
    if (isUndefined$1(columnIdx)) {
      indexedRowColumns--;
      continue;
    }
    const value = row[col];
    if (isUndefined$1(value) || isExpressionOrFactory(value)) {
      hasUndefinedOrComplexColumns = true;
    }
    rowValues[columnIdx] = value;
  }
  const hasMissingColumns = indexedRowColumns < columns.size;
  if (hasMissingColumns || hasUndefinedOrComplexColumns) {
    const defaultValue = DefaultInsertValueNode.create();
    return ValueListNode.create(rowValues.map((it) => isUndefined$1(it) ? defaultValue : parseValueExpression(it)));
  }
  return PrimitiveValueListNode.create(rowValues);
}
const ColumnUpdateNode = freeze({
  is(node) {
    return node.kind === "ColumnUpdateNode";
  },
  create(column, value) {
    return freeze({
      kind: "ColumnUpdateNode",
      column,
      value
    });
  }
});
function parseUpdate(...args) {
  if (args.length === 2) {
    return [
      ColumnUpdateNode.create(parseReferenceExpression(args[0]), parseValueExpression(args[1]))
    ];
  }
  return parseUpdateObjectExpression(args[0]);
}
function parseUpdateObjectExpression(update) {
  const updateObj = isFunction$1(update) ? update(expressionBuilder()) : update;
  return Object.entries(updateObj).filter(([_, value]) => value !== void 0).map(([key, value]) => {
    return ColumnUpdateNode.create(ColumnNode.create(key), parseValueExpression(value));
  });
}
const OnDuplicateKeyNode = freeze({
  is(node) {
    return node.kind === "OnDuplicateKeyNode";
  },
  create(updates) {
    return freeze({
      kind: "OnDuplicateKeyNode",
      updates
    });
  }
});
class InsertResult {
  /**
   * The auto incrementing primary key of the inserted row.
   *
   * This property can be undefined when the query contains an `on conflict`
   * clause that makes the query succeed even when nothing gets inserted.
   *
   * This property is always undefined on dialects like PostgreSQL that
   * don't return the inserted id by default. On those dialects you need
   * to use the {@link ReturningInterface.returning | returning} method.
   */
  insertId;
  /**
   * Affected rows count.
   */
  numInsertedOrUpdatedRows;
  constructor(insertId, numInsertedOrUpdatedRows) {
    this.insertId = insertId;
    this.numInsertedOrUpdatedRows = numInsertedOrUpdatedRows;
  }
}
class NoResultError extends Error {
  /**
   * The operation node tree of the query that was executed.
   */
  node;
  constructor(node) {
    super("no result");
    this.node = node;
  }
}
function isNoResultErrorConstructor(fn2) {
  return Object.prototype.hasOwnProperty.call(fn2, "prototype");
}
const OnConflictNode = freeze({
  is(node) {
    return node.kind === "OnConflictNode";
  },
  create() {
    return freeze({
      kind: "OnConflictNode"
    });
  },
  cloneWith(node, props) {
    return freeze({
      ...node,
      ...props
    });
  },
  cloneWithIndexWhere(node, operation) {
    return freeze({
      ...node,
      indexWhere: node.indexWhere ? WhereNode.cloneWithOperation(node.indexWhere, "And", operation) : WhereNode.create(operation)
    });
  },
  cloneWithIndexOrWhere(node, operation) {
    return freeze({
      ...node,
      indexWhere: node.indexWhere ? WhereNode.cloneWithOperation(node.indexWhere, "Or", operation) : WhereNode.create(operation)
    });
  },
  cloneWithUpdateWhere(node, operation) {
    return freeze({
      ...node,
      updateWhere: node.updateWhere ? WhereNode.cloneWithOperation(node.updateWhere, "And", operation) : WhereNode.create(operation)
    });
  },
  cloneWithUpdateOrWhere(node, operation) {
    return freeze({
      ...node,
      updateWhere: node.updateWhere ? WhereNode.cloneWithOperation(node.updateWhere, "Or", operation) : WhereNode.create(operation)
    });
  },
  cloneWithoutIndexWhere(node) {
    return freeze({
      ...node,
      indexWhere: void 0
    });
  },
  cloneWithoutUpdateWhere(node) {
    return freeze({
      ...node,
      updateWhere: void 0
    });
  }
});
class OnConflictBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * Specify a single column as the conflict target.
   *
   * Also see the {@link columns}, {@link constraint} and {@link expression}
   * methods for alternative ways to specify the conflict target.
   */
  column(column) {
    const columnNode = ColumnNode.create(column);
    return new OnConflictBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {
        columns: this.#props.onConflictNode.columns ? freeze([...this.#props.onConflictNode.columns, columnNode]) : freeze([columnNode])
      })
    });
  }
  /**
   * Specify a list of columns as the conflict target.
   *
   * Also see the {@link column}, {@link constraint} and {@link expression}
   * methods for alternative ways to specify the conflict target.
   */
  columns(columns) {
    const columnNodes = columns.map(ColumnNode.create);
    return new OnConflictBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {
        columns: this.#props.onConflictNode.columns ? freeze([...this.#props.onConflictNode.columns, ...columnNodes]) : freeze(columnNodes)
      })
    });
  }
  /**
   * Specify a specific constraint by name as the conflict target.
   *
   * Also see the {@link column}, {@link columns} and {@link expression}
   * methods for alternative ways to specify the conflict target.
   */
  constraint(constraintName) {
    return new OnConflictBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {
        constraint: IdentifierNode.create(constraintName)
      })
    });
  }
  /**
   * Specify an expression as the conflict target.
   *
   * This can be used if the unique index is an expression index.
   *
   * Also see the {@link column}, {@link columns} and {@link constraint}
   * methods for alternative ways to specify the conflict target.
   */
  expression(expression) {
    return new OnConflictBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {
        indexExpression: expression.toOperationNode()
      })
    });
  }
  where(...args) {
    return new OnConflictBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWithIndexWhere(this.#props.onConflictNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  whereRef(lhs, op, rhs) {
    return new OnConflictBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWithIndexWhere(this.#props.onConflictNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  clearWhere() {
    return new OnConflictBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWithoutIndexWhere(this.#props.onConflictNode)
    });
  }
  /**
   * Adds the "do nothing" conflict action.
   *
   * ### Examples
   *
   * ```ts
   * const id = 1
   * const first_name = 'John'
   *
   * await db
   *   .insertInto('person')
   *   .values({first_name, id })
   *   .onConflict((oc) => oc
   *     .column('id')
   *     .doNothing()
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "person" ("first_name", "id")
   * values ($1, $2)
   * on conflict ("id") do nothing
   * ```
   */
  doNothing() {
    return new OnConflictDoNothingBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {
        doNothing: true
      })
    });
  }
  /**
   * Adds the "do update set" conflict action.
   *
   * ### Examples
   *
   * ```ts
   * const id = 1
   * const first_name = 'John'
   *
   * await db
   *   .insertInto('person')
   *   .values({first_name, id })
   *   .onConflict((oc) => oc
   *     .column('id')
   *     .doUpdateSet({ first_name })
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "person" ("first_name", "id")
   * values ($1, $2)
   * on conflict ("id")
   * do update set "first_name" = $3
   * ```
   *
   * In the next example we use the `ref` method to reference
   * columns of the virtual table `excluded` in a type-safe way
   * to create an upsert operation:
   *
   * ```ts
   * import type { NewPerson } from 'type-editor' // imaginary module
   *
   * async function upsertPerson(person: NewPerson): Promise<void> {
   *   await db.insertInto('person')
   *     .values(person)
   *     .onConflict((oc) => oc
   *       .column('id')
   *       .doUpdateSet((eb) => ({
   *         first_name: eb.ref('excluded.first_name'),
   *         last_name: eb.ref('excluded.last_name')
   *       })
   *     )
   *   )
   *   .execute()
   * }
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "person" ("first_name", "last_name")
   * values ($1, $2)
   * on conflict ("id")
   * do update set
   *  "first_name" = excluded."first_name",
   *  "last_name" = excluded."last_name"
   * ```
   */
  doUpdateSet(update) {
    return new OnConflictUpdateBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {
        updates: parseUpdateObjectExpression(update)
      })
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
}
class OnConflictDoNothingBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  toOperationNode() {
    return this.#props.onConflictNode;
  }
}
class OnConflictUpdateBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  where(...args) {
    return new OnConflictUpdateBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWithUpdateWhere(this.#props.onConflictNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  /**
   * Specify a where condition for the update operation.
   *
   * See {@link WhereInterface.whereRef} for more info.
   */
  whereRef(lhs, op, rhs) {
    return new OnConflictUpdateBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWithUpdateWhere(this.#props.onConflictNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  clearWhere() {
    return new OnConflictUpdateBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWithoutUpdateWhere(this.#props.onConflictNode)
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.onConflictNode;
  }
}
const TopNode = freeze({
  is(node) {
    return node.kind === "TopNode";
  },
  create(expression, modifiers) {
    return freeze({
      kind: "TopNode",
      expression,
      modifiers
    });
  }
});
function parseTop(expression, modifiers) {
  if (!isNumber$3(expression) && !isBigInt(expression)) {
    throw new Error(`Invalid top expression: ${expression}`);
  }
  if (!isUndefined$1(modifiers) && !isTopModifiers(modifiers)) {
    throw new Error(`Invalid top modifiers: ${modifiers}`);
  }
  return TopNode.create(expression, modifiers);
}
function isTopModifiers(modifiers) {
  return modifiers === "percent" || modifiers === "with ties" || modifiers === "percent with ties";
}
const OrActionNode = freeze({
  is(node) {
    return node.kind === "OrActionNode";
  },
  create(action) {
    return freeze({
      kind: "OrActionNode",
      action
    });
  }
});
class InsertQueryBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * Sets the values to insert for an {@link Kysely.insertInto | insert} query.
   *
   * This method takes an object whose keys are column names and values are
   * values to insert. In addition to the column's type, the values can be
   * raw {@link sql} snippets or select queries.
   *
   * You must provide all fields you haven't explicitly marked as nullable
   * or optional using {@link Generated} or {@link ColumnType}.
   *
   * The return value of an `insert` query is an instance of {@link InsertResult}. The
   * {@link InsertResult.insertId | insertId} field holds the auto incremented primary
   * key if the database returned one.
   *
   * On PostgreSQL and some other dialects, you need to call `returning` to get
   * something out of the query.
   *
   * Also see the {@link expression} method for inserting the result of a select
   * query or any other expression.
   *
   * ### Examples
   *
   * <!-- siteExample("insert", "Single row", 10) -->
   *
   * Insert a single row:
   *
   * ```ts
   * const result = await db
   *   .insertInto('person')
   *   .values({
   *     first_name: 'Jennifer',
   *     last_name: 'Aniston',
   *     age: 40
   *   })
   *   .executeTakeFirst()
   *
   * // `insertId` is only available on dialects that
   * // automatically return the id of the inserted row
   * // such as MySQL and SQLite. On PostgreSQL, for example,
   * // you need to add a `returning` clause to the query to
   * // get anything out. See the "returning data" example.
   * console.log(result.insertId)
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * insert into `person` (`first_name`, `last_name`, `age`) values (?, ?, ?)
   * ```
   *
   * <!-- siteExample("insert", "Multiple rows", 20) -->
   *
   * On dialects that support it (for example PostgreSQL) you can insert multiple
   * rows by providing an array. Note that the return value is once again very
   * dialect-specific. Some databases may only return the id of the *last* inserted
   * row and some return nothing at all unless you call `returning`.
   *
   * ```ts
   * await db
   *   .insertInto('person')
   *   .values([{
   *     first_name: 'Jennifer',
   *     last_name: 'Aniston',
   *     age: 40,
   *   }, {
   *     first_name: 'Arnold',
   *     last_name: 'Schwarzenegger',
   *     age: 70,
   *   }])
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "person" ("first_name", "last_name", "age") values (($1, $2, $3), ($4, $5, $6))
   * ```
   *
   * <!-- siteExample("insert", "Returning data", 30) -->
   *
   * On supported dialects like PostgreSQL you need to chain `returning` to the query to get
   * the inserted row's columns (or any other expression) as the return value. `returning`
   * works just like `select`. Refer to `select` method's examples and documentation for
   * more info.
   *
   * ```ts
   * const result = await db
   *   .insertInto('person')
   *   .values({
   *     first_name: 'Jennifer',
   *     last_name: 'Aniston',
   *     age: 40,
   *   })
   *   .returning(['id', 'first_name as name'])
   *   .executeTakeFirstOrThrow()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "person" ("first_name", "last_name", "age") values ($1, $2, $3) returning "id", "first_name" as "name"
   * ```
   *
   * <!-- siteExample("insert", "Complex values", 40) -->
   *
   * In addition to primitives, the values can also be arbitrary expressions.
   * You can build the expressions by using a callback and calling the methods
   * on the expression builder passed to it:
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * const ani = "Ani"
   * const ston = "ston"
   *
   * const result = await db
   *   .insertInto('person')
   *   .values(({ ref, selectFrom, fn }) => ({
   *     first_name: 'Jennifer',
   *     last_name: sql<string>`concat(${ani}, ${ston})`,
   *     middle_name: ref('first_name'),
   *     age: selectFrom('person')
   *       .select(fn.avg<number>('age').as('avg_age')),
   *   }))
   *   .executeTakeFirst()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "person" (
   *   "first_name",
   *   "last_name",
   *   "middle_name",
   *   "age"
   * )
   * values (
   *   $1,
   *   concat($2, $3),
   *   "first_name",
   *   (select avg("age") as "avg_age" from "person")
   * )
   * ```
   *
   * You can also use the callback version of subqueries or raw expressions:
   *
   * ```ts
   * await db.with('jennifer', (db) => db
   *   .selectFrom('person')
   *   .where('first_name', '=', 'Jennifer')
   *   .select(['id', 'first_name', 'gender'])
   *   .limit(1)
   * ).insertInto('pet').values((eb) => ({
   *   owner_id: eb.selectFrom('jennifer').select('id'),
   *   name: eb.selectFrom('jennifer').select('first_name'),
   *   species: 'cat',
   * }))
   * .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * with "jennifer" as (
   *   select "id", "first_name", "gender"
   *   from "person"
   *   where "first_name" = $1
   *   limit $2
   * )
   * insert into "pet" ("owner_id", "name", "species")
   * values (
   *  (select "id" from "jennifer"),
   *  (select "first_name" from "jennifer"),
   *  $3
   * )
   * ```
   */
  values(insert) {
    const [columns, values] = parseInsertExpression(insert);
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        columns,
        values
      })
    });
  }
  /**
   * Sets the columns to insert.
   *
   * The {@link values} method sets both the columns and the values and this method
   * is not needed. But if you are using the {@link expression} method, you can use
   * this method to set the columns to insert.
   *
   * ### Examples
   *
   * ```ts
   * await db.insertInto('person')
   *   .columns(['first_name'])
   *   .expression((eb) => eb.selectFrom('pet').select('pet.name'))
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "person" ("first_name")
   * select "pet"."name" from "pet"
   * ```
   */
  columns(columns) {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        columns: freeze(columns.map(ColumnNode.create))
      })
    });
  }
  /**
   * Insert an arbitrary expression. For example the result of a select query.
   *
   * ### Examples
   *
   * <!-- siteExample("insert", "Insert subquery", 50) -->
   *
   * You can create an `INSERT INTO SELECT FROM` query using the `expression` method.
   * This API doesn't follow our WYSIWYG principles and might be a bit difficult to
   * remember. The reasons for this design stem from implementation difficulties.
   *
   * ```ts
   * const result = await db.insertInto('person')
   *   .columns(['first_name', 'last_name', 'age'])
   *   .expression((eb) => eb
   *     .selectFrom('pet')
   *     .select((eb) => [
   *       'pet.name',
   *       eb.val('Petson').as('last_name'),
   *       eb.lit(7).as('age'),
   *     ])
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "person" ("first_name", "last_name", "age")
   * select "pet"."name", $1 as "last_name", 7 as "age from "pet"
   * ```
   */
  expression(expression) {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        values: parseExpression(expression)
      })
    });
  }
  /**
   * Creates an `insert into "person" default values` query.
   *
   * ### Examples
   *
   * ```ts
   * await db.insertInto('person')
   *   .defaultValues()
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "person" default values
   * ```
   */
  defaultValues() {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        defaultValues: true
      })
    });
  }
  /**
   * This can be used to add any additional SQL to the end of the query.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.insertInto('person')
   *   .values({
   *     first_name: 'John',
   *     last_name: 'Doe',
   *     gender: 'male',
   *   })
   *   .modifyEnd(sql`-- This is a comment`)
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * insert into `person` ("first_name", "last_name", "gender")
   * values (?, ?, ?) -- This is a comment
   * ```
   */
  modifyEnd(modifier) {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, modifier.toOperationNode())
    });
  }
  /**
   * Changes an `insert into` query to an `insert ignore into` query.
   *
   * This is only supported by some dialects like MySQL.
   *
   * To avoid a footgun, when invoked with the SQLite dialect, this method will
   * be handled like {@link orIgnore}. See also, {@link orAbort}, {@link orFail},
   * {@link orReplace}, and {@link orRollback}.
   *
   * If you use the ignore modifier, ignorable errors that occur while executing the
   * insert statement are ignored. For example, without ignore, a row that duplicates
   * an existing unique index or primary key value in the table causes a duplicate-key
   * error and the statement is aborted. With ignore, the row is discarded and no error
   * occurs.
   *
   * ### Examples
   *
   * ```ts
   * await db.insertInto('person')
   *   .ignore()
   *   .values({
   *     first_name: 'John',
   *     last_name: 'Doe',
   *     gender: 'female',
   *   })
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * insert ignore into `person` (`first_name`, `last_name`, `gender`) values (?, ?, ?)
   * ```
   *
   * The generated SQL (SQLite):
   *
   * ```sql
   * insert or ignore into "person" ("first_name", "last_name", "gender") values (?, ?, ?)
   * ```
   */
  ignore() {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        orAction: OrActionNode.create("ignore")
      })
    });
  }
  /**
   * Changes an `insert into` query to an `insert or ignore into` query.
   *
   * This is only supported by some dialects like SQLite.
   *
   * To avoid a footgun, when invoked with the MySQL dialect, this method will
   * be handled like {@link ignore}.
   *
   * See also, {@link orAbort}, {@link orFail}, {@link orReplace}, and {@link orRollback}.
   *
   * ### Examples
   *
   * ```ts
   * await db.insertInto('person')
   *   .orIgnore()
   *   .values({
   *     first_name: 'John',
   *     last_name: 'Doe',
   *     gender: 'female',
   *   })
   *   .execute()
   * ```
   *
   * The generated SQL (SQLite):
   *
   * ```sql
   * insert or ignore into "person" ("first_name", "last_name", "gender") values (?, ?, ?)
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * insert ignore into `person` (`first_name`, `last_name`, `gender`) values (?, ?, ?)
   * ```
   */
  orIgnore() {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        orAction: OrActionNode.create("ignore")
      })
    });
  }
  /**
   * Changes an `insert into` query to an `insert or abort into` query.
   *
   * This is only supported by some dialects like SQLite.
   *
   * See also, {@link orIgnore}, {@link orFail}, {@link orReplace}, and {@link orRollback}.
   *
   * ### Examples
   *
   * ```ts
   * await db.insertInto('person')
   *   .orAbort()
   *   .values({
   *     first_name: 'John',
   *     last_name: 'Doe',
   *     gender: 'female',
   *   })
   *   .execute()
   * ```
   *
   * The generated SQL (SQLite):
   *
   * ```sql
   * insert or abort into "person" ("first_name", "last_name", "gender") values (?, ?, ?)
   * ```
   */
  orAbort() {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        orAction: OrActionNode.create("abort")
      })
    });
  }
  /**
   * Changes an `insert into` query to an `insert or fail into` query.
   *
   * This is only supported by some dialects like SQLite.
   *
   * See also, {@link orIgnore}, {@link orAbort}, {@link orReplace}, and {@link orRollback}.
   *
   * ### Examples
   *
   * ```ts
   * await db.insertInto('person')
   *   .orFail()
   *   .values({
   *     first_name: 'John',
   *     last_name: 'Doe',
   *     gender: 'female',
   *   })
   *   .execute()
   * ```
   *
   * The generated SQL (SQLite):
   *
   * ```sql
   * insert or fail into "person" ("first_name", "last_name", "gender") values (?, ?, ?)
   * ```
   */
  orFail() {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        orAction: OrActionNode.create("fail")
      })
    });
  }
  /**
   * Changes an `insert into` query to an `insert or replace into` query.
   *
   * This is only supported by some dialects like SQLite.
   *
   * You can also use {@link Kysely.replaceInto} to achieve the same result.
   *
   * See also, {@link orIgnore}, {@link orAbort}, {@link orFail}, and {@link orRollback}.
   *
   * ### Examples
   *
   * ```ts
   * await db.insertInto('person')
   *   .orReplace()
   *   .values({
   *     first_name: 'John',
   *     last_name: 'Doe',
   *     gender: 'female',
   *   })
   *   .execute()
   * ```
   *
   * The generated SQL (SQLite):
   *
   * ```sql
   * insert or replace into "person" ("first_name", "last_name", "gender") values (?, ?, ?)
   * ```
   */
  orReplace() {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        orAction: OrActionNode.create("replace")
      })
    });
  }
  /**
   * Changes an `insert into` query to an `insert or rollback into` query.
   *
   * This is only supported by some dialects like SQLite.
   *
   * See also, {@link orIgnore}, {@link orAbort}, {@link orFail}, and {@link orReplace}.
   *
   * ### Examples
   *
   * ```ts
   * await db.insertInto('person')
   *   .orRollback()
   *   .values({
   *     first_name: 'John',
   *     last_name: 'Doe',
   *     gender: 'female',
   *   })
   *   .execute()
   * ```
   *
   * The generated SQL (SQLite):
   *
   * ```sql
   * insert or rollback into "person" ("first_name", "last_name", "gender") values (?, ?, ?)
   * ```
   */
  orRollback() {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        orAction: OrActionNode.create("rollback")
      })
    });
  }
  /**
   * Changes an `insert into` query to an `insert top into` query.
   *
   * `top` clause is only supported by some dialects like MS SQL Server.
   *
   * ### Examples
   *
   * Insert the first 5 rows:
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.insertInto('person')
   *   .top(5)
   *   .columns(['first_name', 'gender'])
   *   .expression(
   *     (eb) => eb.selectFrom('pet').select(['name', sql.lit('other').as('gender')])
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (MS SQL Server):
   *
   * ```sql
   * insert top(5) into "person" ("first_name", "gender") select "name", 'other' as "gender" from "pet"
   * ```
   *
   * Insert the first 50 percent of rows:
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.insertInto('person')
   *   .top(50, 'percent')
   *   .columns(['first_name', 'gender'])
   *   .expression(
   *     (eb) => eb.selectFrom('pet').select(['name', sql.lit('other').as('gender')])
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (MS SQL Server):
   *
   * ```sql
   * insert top(50) percent into "person" ("first_name", "gender") select "name", 'other' as "gender" from "pet"
   * ```
   */
  top(expression, modifiers) {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers))
    });
  }
  /**
   * Adds an `on conflict` clause to the query.
   *
   * `on conflict` is only supported by some dialects like PostgreSQL and SQLite. On MySQL
   * you can use {@link ignore} and {@link onDuplicateKeyUpdate} to achieve similar results.
   *
   * ### Examples
   *
   * ```ts
   * await db
   *   .insertInto('pet')
   *   .values({
   *     name: 'Catto',
   *     species: 'cat',
   *     owner_id: 3,
   *   })
   *   .onConflict((oc) => oc
   *     .column('name')
   *     .doUpdateSet({ species: 'hamster' })
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "pet" ("name", "species", "owner_id")
   * values ($1, $2, $3)
   * on conflict ("name")
   * do update set "species" = $4
   * ```
   *
   * You can provide the name of the constraint instead of a column name:
   *
   * ```ts
   * await db
   *   .insertInto('pet')
   *   .values({
   *     name: 'Catto',
   *     species: 'cat',
   *     owner_id: 3,
   *   })
   *   .onConflict((oc) => oc
   *     .constraint('pet_name_key')
   *     .doUpdateSet({ species: 'hamster' })
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "pet" ("name", "species", "owner_id")
   * values ($1, $2, $3)
   * on conflict on constraint "pet_name_key"
   * do update set "species" = $4
   * ```
   *
   * You can also specify an expression as the conflict target in case
   * the unique index is an expression index:
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db
   *   .insertInto('pet')
   *   .values({
   *     name: 'Catto',
   *     species: 'cat',
   *     owner_id: 3,
   *   })
   *   .onConflict((oc) => oc
   *     .expression(sql<string>`lower(name)`)
   *     .doUpdateSet({ species: 'hamster' })
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "pet" ("name", "species", "owner_id")
   * values ($1, $2, $3)
   * on conflict (lower(name))
   * do update set "species" = $4
   * ```
   *
   * You can add a filter for the update statement like this:
   *
   * ```ts
   * await db
   *   .insertInto('pet')
   *   .values({
   *     name: 'Catto',
   *     species: 'cat',
   *     owner_id: 3,
   *   })
   *   .onConflict((oc) => oc
   *     .column('name')
   *     .doUpdateSet({ species: 'hamster' })
   *     .where('excluded.name', '!=', 'Catto')
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "pet" ("name", "species", "owner_id")
   * values ($1, $2, $3)
   * on conflict ("name")
   * do update set "species" = $4
   * where "excluded"."name" != $5
   * ```
   *
   * You can create an `on conflict do nothing` clauses like this:
   *
   * ```ts
   * await db
   *   .insertInto('pet')
   *   .values({
   *     name: 'Catto',
   *     species: 'cat',
   *     owner_id: 3,
   *   })
   *   .onConflict((oc) => oc
   *     .column('name')
   *     .doNothing()
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "pet" ("name", "species", "owner_id")
   * values ($1, $2, $3)
   * on conflict ("name") do nothing
   * ```
   *
   * You can refer to the columns of the virtual `excluded` table
   * in a type-safe way using a callback and the `ref` method of
   * `ExpressionBuilder`:
   *
   * ```ts
   * await db.insertInto('person')
   *   .values({
   *     id: 1,
   *     first_name: 'John',
   *     last_name: 'Doe',
   *     gender: 'male',
   *   })
   *   .onConflict(oc => oc
   *     .column('id')
   *     .doUpdateSet({
   *       first_name: (eb) => eb.ref('excluded.first_name'),
   *       last_name: (eb) => eb.ref('excluded.last_name')
   *     })
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * insert into "person" ("id", "first_name", "last_name", "gender")
   * values ($1, $2, $3, $4)
   * on conflict ("id")
   * do update set
   *  "first_name" = "excluded"."first_name",
   *  "last_name" = "excluded"."last_name"
   * ```
   */
  onConflict(callback) {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        onConflict: callback(new OnConflictBuilder({
          onConflictNode: OnConflictNode.create()
        })).toOperationNode()
      })
    });
  }
  /**
   * Adds `on duplicate key update` to the query.
   *
   * If you specify `on duplicate key update`, and a row is inserted that would cause
   * a duplicate value in a unique index or primary key, an update of the old row occurs.
   *
   * This is only implemented by some dialects like MySQL. On most dialects you should
   * use {@link onConflict} instead.
   *
   * ### Examples
   *
   * ```ts
   * await db
   *   .insertInto('person')
   *   .values({
   *     id: 1,
   *     first_name: 'John',
   *     last_name: 'Doe',
   *     gender: 'male',
   *   })
   *   .onDuplicateKeyUpdate({ updated_at: new Date().toISOString() })
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * insert into `person` (`id`, `first_name`, `last_name`, `gender`)
   * values (?, ?, ?, ?)
   * on duplicate key update `updated_at` = ?
   * ```
   */
  onDuplicateKeyUpdate(update) {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        onDuplicateKey: OnDuplicateKeyNode.create(parseUpdateObjectExpression(update))
      })
    });
  }
  returning(selection) {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectArg(selection))
    });
  }
  returningAll() {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectAll())
    });
  }
  output(args) {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectArg(args))
    });
  }
  outputAll(table) {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectAll(table))
    });
  }
  /**
   * Clears all `returning` clauses from the query.
   *
   * ### Examples
   *
   * ```ts
   * await db.insertInto('person')
   *   .values({ first_name: 'James', last_name: 'Smith', gender: 'male' })
   *   .returning(['first_name'])
   *   .clearReturning()
   *   .execute()
   * ```
   *
   * The generated SQL(PostgreSQL):
   *
   * ```sql
   * insert into "person" ("first_name", "last_name", "gender") values ($1, $2, $3)
   * ```
   */
  clearReturning() {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithoutReturning(this.#props.queryNode)
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   *
   * If you want to conditionally call a method on `this`, see
   * the {@link $if} method.
   *
   * ### Examples
   *
   * The next example uses a helper function `log` to log a query:
   *
   * ```ts
   * import type { Compilable } from 'kysely'
   *
   * function log<T extends Compilable>(qb: T): T {
   *   console.log(qb.compile())
   *   return qb
   * }
   *
   * await db.insertInto('person')
   *   .values({ first_name: 'John', last_name: 'Doe', gender: 'male' })
   *   .$call(log)
   *   .execute()
   * ```
   */
  $call(func) {
    return func(this);
  }
  /**
   * Call `func(this)` if `condition` is true.
   *
   * This method is especially handy with optional selects. Any `returning` or `returningAll`
   * method calls add columns as optional fields to the output type when called inside
   * the `func` callback. This is because we can't know if those selections were actually
   * made before running the code.
   *
   * You can also call any other methods inside the callback.
   *
   * ### Examples
   *
   * ```ts
   * import type { NewPerson } from 'type-editor' // imaginary module
   *
   * async function insertPerson(values: NewPerson, returnLastName: boolean) {
   *   return await db
   *     .insertInto('person')
   *     .values(values)
   *     .returning(['id', 'first_name'])
   *     .$if(returnLastName, (qb) => qb.returning('last_name'))
   *     .executeTakeFirstOrThrow()
   * }
   * ```
   *
   * Any selections added inside the `if` callback will be added as optional fields to the
   * output type since we can't know if the selections were actually made before running
   * the code. In the example above the return type of the `insertPerson` function is:
   *
   * ```ts
   * Promise<{
   *   id: number
   *   first_name: string
   *   last_name?: string
   * }>
   * ```
   */
  $if(condition, func) {
    if (condition) {
      return func(this);
    }
    return new InsertQueryBuilder({
      ...this.#props
    });
  }
  /**
   * Change the output type of the query.
   *
   * This method call doesn't change the SQL in any way. This methods simply
   * returns a copy of this `InsertQueryBuilder` with a new output type.
   */
  $castTo() {
    return new InsertQueryBuilder(this.#props);
  }
  /**
   * Narrows (parts of) the output type of the query.
   *
   * Kysely tries to be as type-safe as possible, but in some cases we have to make
   * compromises for better maintainability and compilation performance. At present,
   * Kysely doesn't narrow the output type of the query based on {@link values} input
   * when using {@link returning} or {@link returningAll}.
   *
   * This utility method is very useful for these situations, as it removes unncessary
   * runtime assertion/guard code. Its input type is limited to the output type
   * of the query, so you can't add a column that doesn't exist, or change a column's
   * type to something that doesn't exist in its union type.
   *
   * ### Examples
   *
   * Turn this code:
   *
   * ```ts
   * import type { Person } from 'type-editor' // imaginary module
   *
   * const person = await db.insertInto('person')
   *   .values({
   *     first_name: 'John',
   *     last_name: 'Doe',
   *     gender: 'male',
   *     nullable_column: 'hell yeah!'
   *   })
   *   .returningAll()
   *   .executeTakeFirstOrThrow()
   *
   * if (isWithNoNullValue(person)) {
   *   functionThatExpectsPersonWithNonNullValue(person)
   * }
   *
   * function isWithNoNullValue(person: Person): person is Person & { nullable_column: string } {
   *   return person.nullable_column != null
   * }
   * ```
   *
   * Into this:
   *
   * ```ts
   * import type { NotNull } from 'kysely'
   *
   * const person = await db.insertInto('person')
   *   .values({
   *     first_name: 'John',
   *     last_name: 'Doe',
   *     gender: 'male',
   *     nullable_column: 'hell yeah!'
   *   })
   *   .returningAll()
   *   .$narrowType<{ nullable_column: NotNull }>()
   *   .executeTakeFirstOrThrow()
   *
   * functionThatExpectsPersonWithNonNullValue(person)
   * ```
   */
  $narrowType() {
    return new InsertQueryBuilder(this.#props);
  }
  /**
   * Asserts that query's output row type equals the given type `T`.
   *
   * This method can be used to simplify excessively complex types to make TypeScript happy
   * and much faster.
   *
   * Kysely uses complex type magic to achieve its type safety. This complexity is sometimes too much
   * for TypeScript and you get errors like this:
   *
   * ```
   * error TS2589: Type instantiation is excessively deep and possibly infinite.
   * ```
   *
   * In these case you can often use this method to help TypeScript a little bit. When you use this
   * method to assert the output type of a query, Kysely can drop the complex output type that
   * consists of multiple nested helper types and replace it with the simple asserted type.
   *
   * Using this method doesn't reduce type safety at all. You have to pass in a type that is
   * structurally equal to the current type.
   *
   * ### Examples
   *
   * ```ts
   * import type { NewPerson, NewPet, Species } from 'type-editor' // imaginary module
   *
   * async function insertPersonAndPet(person: NewPerson, pet: Omit<NewPet, 'owner_id'>) {
   *   return await db
   *     .with('new_person', (qb) => qb
   *       .insertInto('person')
   *       .values(person)
   *       .returning('id')
   *       .$assertType<{ id: number }>()
   *     )
   *     .with('new_pet', (qb) => qb
   *       .insertInto('pet')
   *       .values((eb) => ({
   *         owner_id: eb.selectFrom('new_person').select('id'),
   *         ...pet
   *       }))
   *       .returning(['name as pet_name', 'species'])
   *       .$assertType<{ pet_name: string, species: Species }>()
   *     )
   *     .selectFrom(['new_person', 'new_pet'])
   *     .selectAll()
   *     .executeTakeFirstOrThrow()
   * }
   * ```
   */
  $assertType() {
    return new InsertQueryBuilder(this.#props);
  }
  /**
   * Returns a copy of this InsertQueryBuilder instance with the given plugin installed.
   */
  withPlugin(plugin) {
    return new InsertQueryBuilder({
      ...this.#props,
      executor: this.#props.executor.withPlugin(plugin)
    });
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.queryNode, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  /**
   * Executes the query and returns an array of rows.
   *
   * Also see the {@link executeTakeFirst} and {@link executeTakeFirstOrThrow} methods.
   */
  async execute() {
    const compiledQuery = this.compile();
    const result2 = await this.#props.executor.executeQuery(compiledQuery);
    const { adapter } = this.#props.executor;
    const query2 = compiledQuery.query;
    if (query2.returning && adapter.supportsReturning || query2.output && adapter.supportsOutput) {
      return result2.rows;
    }
    return [
      new InsertResult(result2.insertId, result2.numAffectedRows ?? BigInt(0))
    ];
  }
  /**
   * Executes the query and returns the first result or undefined if
   * the query returned no result.
   */
  async executeTakeFirst() {
    const [result2] = await this.execute();
    return result2;
  }
  /**
   * Executes the query and returns the first result or throws if
   * the query returned no result.
   *
   * By default an instance of {@link NoResultError} is thrown, but you can
   * provide a custom error class, or callback as the only argument to throw a different
   * error.
   */
  async executeTakeFirstOrThrow(errorConstructor = NoResultError) {
    const result2 = await this.executeTakeFirst();
    if (result2 === void 0) {
      const error2 = isNoResultErrorConstructor(errorConstructor) ? new errorConstructor(this.toOperationNode()) : errorConstructor(this.toOperationNode());
      throw error2;
    }
    return result2;
  }
  async *stream(chunkSize = 100) {
    const compiledQuery = this.compile();
    const stream2 = this.#props.executor.stream(compiledQuery, chunkSize);
    for await (const item of stream2) {
      yield* item.rows;
    }
  }
  async explain(format2, options) {
    const builder = new InsertQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithExplain(this.#props.queryNode, format2, options)
    });
    return await builder.execute();
  }
}
class DeleteResult {
  numDeletedRows;
  constructor(numDeletedRows) {
    this.numDeletedRows = numDeletedRows;
  }
}
const LimitNode = freeze({
  is(node) {
    return node.kind === "LimitNode";
  },
  create(limit) {
    return freeze({
      kind: "LimitNode",
      limit
    });
  }
});
class DeleteQueryBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  where(...args) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  whereRef(lhs, op, rhs) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  clearWhere() {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithoutWhere(this.#props.queryNode)
    });
  }
  /**
   * Changes a `delete from` query into a `delete top from` query.
   *
   * `top` clause is only supported by some dialects like MS SQL Server.
   *
   * ### Examples
   *
   * Delete the first 5 rows:
   *
   * ```ts
   * await db
   *   .deleteFrom('person')
   *   .top(5)
   *   .where('age', '>', 18)
   *   .executeTakeFirstOrThrow()
   * ```
   *
   * The generated SQL (MS SQL Server):
   *
   * ```sql
   * delete top(5) from "person" where "age" > @1
   * ```
   *
   * Delete the first 50% of rows:
   *
   * ```ts
   * await db
   *   .deleteFrom('person')
   *   .top(50, 'percent')
   *   .where('age', '>', 18)
   *   .executeTakeFirstOrThrow()
   * ```
   *
   * The generated SQL (MS SQL Server):
   *
   * ```sql
   * delete top(50) percent from "person" where "age" > @1
   * ```
   */
  top(expression, modifiers) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers))
    });
  }
  using(tables) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: DeleteQueryNode.cloneWithUsing(this.#props.queryNode, parseTableExpressionOrList(tables))
    });
  }
  innerJoin(...args) {
    return this.#join("InnerJoin", args);
  }
  leftJoin(...args) {
    return this.#join("LeftJoin", args);
  }
  rightJoin(...args) {
    return this.#join("RightJoin", args);
  }
  fullJoin(...args) {
    return this.#join("FullJoin", args);
  }
  #join(joinType, args) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin(joinType, args))
    });
  }
  returning(selection) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectArg(selection))
    });
  }
  returningAll(table) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectAll(table))
    });
  }
  output(args) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectArg(args))
    });
  }
  outputAll(table) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectAll(table))
    });
  }
  /**
   * Clears all `returning` clauses from the query.
   *
   * ### Examples
   *
   * ```ts
   * await db.deleteFrom('pet')
   *   .returningAll()
   *   .where('name', '=', 'Max')
   *   .clearReturning()
   *   .execute()
   * ```
   *
   * The generated SQL(PostgreSQL):
   *
   * ```sql
   * delete from "pet" where "name" = "Max"
   * ```
   */
  clearReturning() {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithoutReturning(this.#props.queryNode)
    });
  }
  /**
   * Clears the `limit` clause from the query.
   *
   * ### Examples
   *
   * ```ts
   * await db.deleteFrom('pet')
   *   .returningAll()
   *   .where('name', '=', 'Max')
   *   .limit(5)
   *   .clearLimit()
   *   .execute()
   * ```
   *
   * The generated SQL(PostgreSQL):
   *
   * ```sql
   * delete from "pet" where "name" = "Max" returning *
   * ```
   */
  clearLimit() {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: DeleteQueryNode.cloneWithoutLimit(this.#props.queryNode)
    });
  }
  orderBy(...args) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOrderByItems(this.#props.queryNode, parseOrderBy(args))
    });
  }
  clearOrderBy() {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithoutOrderBy(this.#props.queryNode)
    });
  }
  /**
   * Adds a limit clause to the query.
   *
   * A limit clause in a delete query is only supported by some dialects
   * like MySQL.
   *
   * ### Examples
   *
   * Delete 5 oldest items in a table:
   *
   * ```ts
   * await db
   *   .deleteFrom('pet')
   *   .orderBy('created_at')
   *   .limit(5)
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * delete from `pet` order by `created_at` limit ?
   * ```
   */
  limit(limit) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: DeleteQueryNode.cloneWithLimit(this.#props.queryNode, LimitNode.create(parseValueExpression(limit)))
    });
  }
  /**
   * This can be used to add any additional SQL to the end of the query.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.deleteFrom('person')
   *   .where('first_name', '=', 'John')
   *   .modifyEnd(sql`-- This is a comment`)
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * delete from `person`
   * where `first_name` = "John" -- This is a comment
   * ```
   */
  modifyEnd(modifier) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, modifier.toOperationNode())
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   *
   * If you want to conditionally call a method on `this`, see
   * the {@link $if} method.
   *
   * ### Examples
   *
   * The next example uses a helper function `log` to log a query:
   *
   * ```ts
   * import type { Compilable } from 'kysely'
   *
   * function log<T extends Compilable>(qb: T): T {
   *   console.log(qb.compile())
   *   return qb
   * }
   *
   * await db.deleteFrom('person')
   *   .$call(log)
   *   .execute()
   * ```
   */
  $call(func) {
    return func(this);
  }
  /**
   * Call `func(this)` if `condition` is true.
   *
   * This method is especially handy with optional selects. Any `returning` or `returningAll`
   * method calls add columns as optional fields to the output type when called inside
   * the `func` callback. This is because we can't know if those selections were actually
   * made before running the code.
   *
   * You can also call any other methods inside the callback.
   *
   * ### Examples
   *
   * ```ts
   * async function deletePerson(id: number, returnLastName: boolean) {
   *   return await db
   *     .deleteFrom('person')
   *     .where('id', '=', id)
   *     .returning(['id', 'first_name'])
   *     .$if(returnLastName, (qb) => qb.returning('last_name'))
   *     .executeTakeFirstOrThrow()
   * }
   * ```
   *
   * Any selections added inside the `if` callback will be added as optional fields to the
   * output type since we can't know if the selections were actually made before running
   * the code. In the example above the return type of the `deletePerson` function is:
   *
   * ```ts
   * Promise<{
   *   id: number
   *   first_name: string
   *   last_name?: string
   * }>
   * ```
   */
  $if(condition, func) {
    if (condition) {
      return func(this);
    }
    return new DeleteQueryBuilder({
      ...this.#props
    });
  }
  /**
   * Change the output type of the query.
   *
   * This method call doesn't change the SQL in any way. This methods simply
   * returns a copy of this `DeleteQueryBuilder` with a new output type.
   */
  $castTo() {
    return new DeleteQueryBuilder(this.#props);
  }
  /**
   * Narrows (parts of) the output type of the query.
   *
   * Kysely tries to be as type-safe as possible, but in some cases we have to make
   * compromises for better maintainability and compilation performance. At present,
   * Kysely doesn't narrow the output type of the query when using {@link where} and {@link returning} or {@link returningAll}.
   *
   * This utility method is very useful for these situations, as it removes unncessary
   * runtime assertion/guard code. Its input type is limited to the output type
   * of the query, so you can't add a column that doesn't exist, or change a column's
   * type to something that doesn't exist in its union type.
   *
   * ### Examples
   *
   * Turn this code:
   *
   * ```ts
   * import type { Person } from 'type-editor' // imaginary module
   *
   * const person = await db.deleteFrom('person')
   *   .where('id', '=', 3)
   *   .where('nullable_column', 'is not', null)
   *   .returningAll()
   *   .executeTakeFirstOrThrow()
   *
   * if (isWithNoNullValue(person)) {
   *   functionThatExpectsPersonWithNonNullValue(person)
   * }
   *
   * function isWithNoNullValue(person: Person): person is Person & { nullable_column: string } {
   *   return person.nullable_column != null
   * }
   * ```
   *
   * Into this:
   *
   * ```ts
   * import type { NotNull } from 'kysely'
   *
   * const person = await db.deleteFrom('person')
   *   .where('id', '=', 3)
   *   .where('nullable_column', 'is not', null)
   *   .returningAll()
   *   .$narrowType<{ nullable_column: NotNull }>()
   *   .executeTakeFirstOrThrow()
   *
   * functionThatExpectsPersonWithNonNullValue(person)
   * ```
   */
  $narrowType() {
    return new DeleteQueryBuilder(this.#props);
  }
  /**
   * Asserts that query's output row type equals the given type `T`.
   *
   * This method can be used to simplify excessively complex types to make TypeScript happy
   * and much faster.
   *
   * Kysely uses complex type magic to achieve its type safety. This complexity is sometimes too much
   * for TypeScript and you get errors like this:
   *
   * ```
   * error TS2589: Type instantiation is excessively deep and possibly infinite.
   * ```
   *
   * In these case you can often use this method to help TypeScript a little bit. When you use this
   * method to assert the output type of a query, Kysely can drop the complex output type that
   * consists of multiple nested helper types and replace it with the simple asserted type.
   *
   * Using this method doesn't reduce type safety at all. You have to pass in a type that is
   * structurally equal to the current type.
   *
   * ### Examples
   *
   * ```ts
   * import type { Species } from 'type-editor' // imaginary module
   *
   * async function deletePersonAndPets(personId: number) {
   *   return await db
   *     .with('deleted_person', (qb) => qb
   *        .deleteFrom('person')
   *        .where('id', '=', personId)
   *        .returning('first_name')
   *        .$assertType<{ first_name: string }>()
   *     )
   *     .with('deleted_pets', (qb) => qb
   *       .deleteFrom('pet')
   *       .where('owner_id', '=', personId)
   *       .returning(['name as pet_name', 'species'])
   *       .$assertType<{ pet_name: string, species: Species }>()
   *     )
   *     .selectFrom(['deleted_person', 'deleted_pets'])
   *     .selectAll()
   *     .execute()
   * }
   * ```
   */
  $assertType() {
    return new DeleteQueryBuilder(this.#props);
  }
  /**
   * Returns a copy of this DeleteQueryBuilder instance with the given plugin installed.
   */
  withPlugin(plugin) {
    return new DeleteQueryBuilder({
      ...this.#props,
      executor: this.#props.executor.withPlugin(plugin)
    });
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.queryNode, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  /**
   * Executes the query and returns an array of rows.
   *
   * Also see the {@link executeTakeFirst} and {@link executeTakeFirstOrThrow} methods.
   */
  async execute() {
    const compiledQuery = this.compile();
    const result2 = await this.#props.executor.executeQuery(compiledQuery);
    const { adapter } = this.#props.executor;
    const query2 = compiledQuery.query;
    if (query2.returning && adapter.supportsReturning || query2.output && adapter.supportsOutput) {
      return result2.rows;
    }
    return [new DeleteResult(result2.numAffectedRows ?? BigInt(0))];
  }
  /**
   * Executes the query and returns the first result or undefined if
   * the query returned no result.
   */
  async executeTakeFirst() {
    const [result2] = await this.execute();
    return result2;
  }
  /**
   * Executes the query and returns the first result or throws if
   * the query returned no result.
   *
   * By default an instance of {@link NoResultError} is thrown, but you can
   * provide a custom error class, or callback as the only argument to throw a different
   * error.
   */
  async executeTakeFirstOrThrow(errorConstructor = NoResultError) {
    const result2 = await this.executeTakeFirst();
    if (result2 === void 0) {
      const error2 = isNoResultErrorConstructor(errorConstructor) ? new errorConstructor(this.toOperationNode()) : errorConstructor(this.toOperationNode());
      throw error2;
    }
    return result2;
  }
  async *stream(chunkSize = 100) {
    const compiledQuery = this.compile();
    const stream2 = this.#props.executor.stream(compiledQuery, chunkSize);
    for await (const item of stream2) {
      yield* item.rows;
    }
  }
  async explain(format2, options) {
    const builder = new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithExplain(this.#props.queryNode, format2, options)
    });
    return await builder.execute();
  }
}
class UpdateResult {
  /**
   * The number of rows the update query updated (even if not changed).
   */
  numUpdatedRows;
  /**
   * The number of rows the update query changed.
   *
   * This is **optional** and only supported in dialects such as MySQL.
   * You would probably use {@link numUpdatedRows} in most cases.
   */
  numChangedRows;
  constructor(numUpdatedRows, numChangedRows) {
    this.numUpdatedRows = numUpdatedRows;
    this.numChangedRows = numChangedRows;
  }
}
class UpdateQueryBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  where(...args) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  whereRef(lhs, op, rhs) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  clearWhere() {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithoutWhere(this.#props.queryNode)
    });
  }
  /**
   * Changes an `update` query into a `update top` query.
   *
   * `top` clause is only supported by some dialects like MS SQL Server.
   *
   * ### Examples
   *
   * Update the first row:
   *
   * ```ts
   * await db.updateTable('person')
   *   .top(1)
   *   .set({ first_name: 'Foo' })
   *   .where('age', '>', 18)
   *   .executeTakeFirstOrThrow()
   * ```
   *
   * The generated SQL (MS SQL Server):
   *
   * ```sql
   * update top(1) "person" set "first_name" = @1 where "age" > @2
   * ```
   *
   * Update the 50% first rows:
   *
   * ```ts
   * await db.updateTable('person')
   *   .top(50, 'percent')
   *   .set({ first_name: 'Foo' })
   *   .where('age', '>', 18)
   *   .executeTakeFirstOrThrow()
   * ```
   *
   * The generated SQL (MS SQL Server):
   *
   * ```sql
   * update top(50) percent "person" set "first_name" = @1 where "age" > @2
   * ```
   */
  top(expression, modifiers) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers))
    });
  }
  from(from) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: UpdateQueryNode.cloneWithFromItems(this.#props.queryNode, parseTableExpressionOrList(from))
    });
  }
  innerJoin(...args) {
    return this.#join("InnerJoin", args);
  }
  leftJoin(...args) {
    return this.#join("LeftJoin", args);
  }
  rightJoin(...args) {
    return this.#join("RightJoin", args);
  }
  fullJoin(...args) {
    return this.#join("FullJoin", args);
  }
  #join(joinType, args) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin(joinType, args))
    });
  }
  orderBy(...args) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOrderByItems(this.#props.queryNode, parseOrderBy(args))
    });
  }
  clearOrderBy() {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithoutOrderBy(this.#props.queryNode)
    });
  }
  /**
   * Adds a limit clause to the update query for supported databases, such as MySQL.
   *
   * ### Examples
   *
   * Update the first 2 rows in the 'person' table:
   *
   * ```ts
   * await db
   *   .updateTable('person')
   *   .set({ first_name: 'Foo' })
   *   .limit(2)
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * update `person` set `first_name` = ? limit ?
   * ```
   */
  limit(limit) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: UpdateQueryNode.cloneWithLimit(this.#props.queryNode, LimitNode.create(parseValueExpression(limit)))
    });
  }
  set(...args) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: UpdateQueryNode.cloneWithUpdates(this.#props.queryNode, parseUpdate(...args))
    });
  }
  returning(selection) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectArg(selection))
    });
  }
  returningAll(table) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectAll(table))
    });
  }
  output(args) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectArg(args))
    });
  }
  outputAll(table) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectAll(table))
    });
  }
  /**
   * This can be used to add any additional SQL to the end of the query.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.updateTable('person')
   *   .set({ age: 39 })
   *   .where('first_name', '=', 'John')
   *   .modifyEnd(sql.raw('-- This is a comment'))
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * update `person`
   * set `age` = 39
   * where `first_name` = "John" -- This is a comment
   * ```
   */
  modifyEnd(modifier) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, modifier.toOperationNode())
    });
  }
  /**
   * Clears all `returning` clauses from the query.
   *
   * ### Examples
   *
   * ```ts
   * db.updateTable('person')
   *   .returningAll()
   *   .set({ age: 39 })
   *   .where('first_name', '=', 'John')
   *   .clearReturning()
   * ```
   *
   * The generated SQL(PostgreSQL):
   *
   * ```sql
   * update "person" set "age" = 39 where "first_name" = "John"
   * ```
   */
  clearReturning() {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithoutReturning(this.#props.queryNode)
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   *
   * If you want to conditionally call a method on `this`, see
   * the {@link $if} method.
   *
   * ### Examples
   *
   * The next example uses a helper function `log` to log a query:
   *
   * ```ts
   * import type { Compilable } from 'kysely'
   * import type { PersonUpdate } from 'type-editor' // imaginary module
   *
   * function log<T extends Compilable>(qb: T): T {
   *   console.log(qb.compile())
   *   return qb
   * }
   *
   * const values = {
   *   first_name: 'John',
   * } satisfies PersonUpdate
   *
   * db.updateTable('person')
   *   .set(values)
   *   .$call(log)
   *   .execute()
   * ```
   */
  $call(func) {
    return func(this);
  }
  /**
   * Call `func(this)` if `condition` is true.
   *
   * This method is especially handy with optional selects. Any `returning` or `returningAll`
   * method calls add columns as optional fields to the output type when called inside
   * the `func` callback. This is because we can't know if those selections were actually
   * made before running the code.
   *
   * You can also call any other methods inside the callback.
   *
   * ### Examples
   *
   * ```ts
   * import type { PersonUpdate } from 'type-editor' // imaginary module
   *
   * async function updatePerson(id: number, updates: PersonUpdate, returnLastName: boolean) {
   *   return await db
   *     .updateTable('person')
   *     .set(updates)
   *     .where('id', '=', id)
   *     .returning(['id', 'first_name'])
   *     .$if(returnLastName, (qb) => qb.returning('last_name'))
   *     .executeTakeFirstOrThrow()
   * }
   * ```
   *
   * Any selections added inside the `if` callback will be added as optional fields to the
   * output type since we can't know if the selections were actually made before running
   * the code. In the example above the return type of the `updatePerson` function is:
   *
   * ```ts
   * Promise<{
   *   id: number
   *   first_name: string
   *   last_name?: string
   * }>
   * ```
   */
  $if(condition, func) {
    if (condition) {
      return func(this);
    }
    return new UpdateQueryBuilder({
      ...this.#props
    });
  }
  /**
   * Change the output type of the query.
   *
   * This method call doesn't change the SQL in any way. This methods simply
   * returns a copy of this `UpdateQueryBuilder` with a new output type.
   */
  $castTo() {
    return new UpdateQueryBuilder(this.#props);
  }
  /**
   * Narrows (parts of) the output type of the query.
   *
   * Kysely tries to be as type-safe as possible, but in some cases we have to make
   * compromises for better maintainability and compilation performance. At present,
   * Kysely doesn't narrow the output type of the query based on {@link set} input
   * when using {@link where} and/or {@link returning} or {@link returningAll}.
   *
   * This utility method is very useful for these situations, as it removes unncessary
   * runtime assertion/guard code. Its input type is limited to the output type
   * of the query, so you can't add a column that doesn't exist, or change a column's
   * type to something that doesn't exist in its union type.
   *
   * ### Examples
   *
   * Turn this code:
   *
   * ```ts
   * import type { Person } from 'type-editor' // imaginary module
   *
   * const id = 1
   * const now = new Date().toISOString()
   *
   * const person = await db.updateTable('person')
   *   .set({ deleted_at: now })
   *   .where('id', '=', id)
   *   .where('nullable_column', 'is not', null)
   *   .returningAll()
   *   .executeTakeFirstOrThrow()
   *
   * if (isWithNoNullValue(person)) {
   *   functionThatExpectsPersonWithNonNullValue(person)
   * }
   *
   * function isWithNoNullValue(person: Person): person is Person & { nullable_column: string } {
   *   return person.nullable_column != null
   * }
   * ```
   *
   * Into this:
   *
   * ```ts
   * import type { NotNull } from 'kysely'
   *
   * const id = 1
   * const now = new Date().toISOString()
   *
   * const person = await db.updateTable('person')
   *   .set({ deleted_at: now })
   *   .where('id', '=', id)
   *   .where('nullable_column', 'is not', null)
   *   .returningAll()
   *   .$narrowType<{ deleted_at: Date; nullable_column: NotNull }>()
   *   .executeTakeFirstOrThrow()
   *
   * functionThatExpectsPersonWithNonNullValue(person)
   * ```
   */
  $narrowType() {
    return new UpdateQueryBuilder(this.#props);
  }
  /**
   * Asserts that query's output row type equals the given type `T`.
   *
   * This method can be used to simplify excessively complex types to make TypeScript happy
   * and much faster.
   *
   * Kysely uses complex type magic to achieve its type safety. This complexity is sometimes too much
   * for TypeScript and you get errors like this:
   *
   * ```
   * error TS2589: Type instantiation is excessively deep and possibly infinite.
   * ```
   *
   * In these case you can often use this method to help TypeScript a little bit. When you use this
   * method to assert the output type of a query, Kysely can drop the complex output type that
   * consists of multiple nested helper types and replace it with the simple asserted type.
   *
   * Using this method doesn't reduce type safety at all. You have to pass in a type that is
   * structurally equal to the current type.
   *
   * ### Examples
   *
   * ```ts
   * import type { PersonUpdate, PetUpdate, Species } from 'type-editor' // imaginary module
   *
   * const person = {
   *   id: 1,
   *   gender: 'other',
   * } satisfies PersonUpdate
   *
   * const pet = {
   *   name: 'Fluffy',
   * } satisfies PetUpdate
   *
   * const result = await db
   *   .with('updated_person', (qb) => qb
   *     .updateTable('person')
   *     .set(person)
   *     .where('id', '=', person.id)
   *     .returning('first_name')
   *     .$assertType<{ first_name: string }>()
   *   )
   *   .with('updated_pet', (qb) => qb
   *     .updateTable('pet')
   *     .set(pet)
   *     .where('owner_id', '=', person.id)
   *     .returning(['name as pet_name', 'species'])
   *     .$assertType<{ pet_name: string, species: Species }>()
   *   )
   *   .selectFrom(['updated_person', 'updated_pet'])
   *   .selectAll()
   *   .executeTakeFirstOrThrow()
   * ```
   */
  $assertType() {
    return new UpdateQueryBuilder(this.#props);
  }
  /**
   * Returns a copy of this UpdateQueryBuilder instance with the given plugin installed.
   */
  withPlugin(plugin) {
    return new UpdateQueryBuilder({
      ...this.#props,
      executor: this.#props.executor.withPlugin(plugin)
    });
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.queryNode, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  /**
   * Executes the query and returns an array of rows.
   *
   * Also see the {@link executeTakeFirst} and {@link executeTakeFirstOrThrow} methods.
   */
  async execute() {
    const compiledQuery = this.compile();
    const result2 = await this.#props.executor.executeQuery(compiledQuery);
    const { adapter } = this.#props.executor;
    const query2 = compiledQuery.query;
    if (query2.returning && adapter.supportsReturning || query2.output && adapter.supportsOutput) {
      return result2.rows;
    }
    return [
      new UpdateResult(result2.numAffectedRows ?? BigInt(0), result2.numChangedRows)
    ];
  }
  /**
   * Executes the query and returns the first result or undefined if
   * the query returned no result.
   */
  async executeTakeFirst() {
    const [result2] = await this.execute();
    return result2;
  }
  /**
   * Executes the query and returns the first result or throws if
   * the query returned no result.
   *
   * By default an instance of {@link NoResultError} is thrown, but you can
   * provide a custom error class, or callback as the only argument to throw a different
   * error.
   */
  async executeTakeFirstOrThrow(errorConstructor = NoResultError) {
    const result2 = await this.executeTakeFirst();
    if (result2 === void 0) {
      const error2 = isNoResultErrorConstructor(errorConstructor) ? new errorConstructor(this.toOperationNode()) : errorConstructor(this.toOperationNode());
      throw error2;
    }
    return result2;
  }
  async *stream(chunkSize = 100) {
    const compiledQuery = this.compile();
    const stream2 = this.#props.executor.stream(compiledQuery, chunkSize);
    for await (const item of stream2) {
      yield* item.rows;
    }
  }
  async explain(format2, options) {
    const builder = new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithExplain(this.#props.queryNode, format2, options)
    });
    return await builder.execute();
  }
}
const CommonTableExpressionNameNode = freeze({
  is(node) {
    return node.kind === "CommonTableExpressionNameNode";
  },
  create(tableName, columnNames) {
    return freeze({
      kind: "CommonTableExpressionNameNode",
      table: TableNode.create(tableName),
      columns: columnNames ? freeze(columnNames.map(ColumnNode.create)) : void 0
    });
  }
});
const CommonTableExpressionNode = freeze({
  is(node) {
    return node.kind === "CommonTableExpressionNode";
  },
  create(name2, expression) {
    return freeze({
      kind: "CommonTableExpressionNode",
      name: name2,
      expression
    });
  },
  cloneWith(node, props) {
    return freeze({
      ...node,
      ...props
    });
  }
});
class CTEBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * Makes the common table expression materialized.
   */
  materialized() {
    return new CTEBuilder({
      ...this.#props,
      node: CommonTableExpressionNode.cloneWith(this.#props.node, {
        materialized: true
      })
    });
  }
  /**
   * Makes the common table expression not materialized.
   */
  notMaterialized() {
    return new CTEBuilder({
      ...this.#props,
      node: CommonTableExpressionNode.cloneWith(this.#props.node, {
        materialized: false
      })
    });
  }
  toOperationNode() {
    return this.#props.node;
  }
}
function parseCommonTableExpression(nameOrBuilderCallback, expression) {
  const expressionNode = expression(createQueryCreator()).toOperationNode();
  if (isFunction$1(nameOrBuilderCallback)) {
    return nameOrBuilderCallback(cteBuilderFactory(expressionNode)).toOperationNode();
  }
  return CommonTableExpressionNode.create(parseCommonTableExpressionName(nameOrBuilderCallback), expressionNode);
}
function cteBuilderFactory(expressionNode) {
  return (name2) => {
    return new CTEBuilder({
      node: CommonTableExpressionNode.create(parseCommonTableExpressionName(name2), expressionNode)
    });
  };
}
function parseCommonTableExpressionName(name2) {
  if (name2.includes("(")) {
    const parts = name2.split(/[\(\)]/);
    const table = parts[0];
    const columns = parts[1].split(",").map((it) => it.trim());
    return CommonTableExpressionNameNode.create(table, columns);
  } else {
    return CommonTableExpressionNameNode.create(name2);
  }
}
const WithNode = freeze({
  is(node) {
    return node.kind === "WithNode";
  },
  create(expression, params) {
    return freeze({
      kind: "WithNode",
      expressions: freeze([expression]),
      ...params
    });
  },
  cloneWithExpression(withNode, expression) {
    return freeze({
      ...withNode,
      expressions: freeze([...withNode.expressions, expression])
    });
  }
});
const CHARS = [
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9"
];
function randomString(length) {
  let chars = "";
  for (let i = 0; i < length; ++i) {
    chars += randomChar();
  }
  return chars;
}
function randomChar() {
  return CHARS[~~(Math.random() * CHARS.length)];
}
function createQueryId() {
  return new LazyQueryId();
}
class LazyQueryId {
  #queryId;
  get queryId() {
    if (this.#queryId === void 0) {
      this.#queryId = randomString(8);
    }
    return this.#queryId;
  }
}
function requireAllProps(obj) {
  return obj;
}
class OperationNodeTransformer {
  nodeStack = [];
  #transformers = freeze({
    AliasNode: this.transformAlias.bind(this),
    ColumnNode: this.transformColumn.bind(this),
    IdentifierNode: this.transformIdentifier.bind(this),
    SchemableIdentifierNode: this.transformSchemableIdentifier.bind(this),
    RawNode: this.transformRaw.bind(this),
    ReferenceNode: this.transformReference.bind(this),
    SelectQueryNode: this.transformSelectQuery.bind(this),
    SelectionNode: this.transformSelection.bind(this),
    TableNode: this.transformTable.bind(this),
    FromNode: this.transformFrom.bind(this),
    SelectAllNode: this.transformSelectAll.bind(this),
    AndNode: this.transformAnd.bind(this),
    OrNode: this.transformOr.bind(this),
    ValueNode: this.transformValue.bind(this),
    ValueListNode: this.transformValueList.bind(this),
    PrimitiveValueListNode: this.transformPrimitiveValueList.bind(this),
    ParensNode: this.transformParens.bind(this),
    JoinNode: this.transformJoin.bind(this),
    OperatorNode: this.transformOperator.bind(this),
    WhereNode: this.transformWhere.bind(this),
    InsertQueryNode: this.transformInsertQuery.bind(this),
    DeleteQueryNode: this.transformDeleteQuery.bind(this),
    ReturningNode: this.transformReturning.bind(this),
    CreateTableNode: this.transformCreateTable.bind(this),
    AddColumnNode: this.transformAddColumn.bind(this),
    ColumnDefinitionNode: this.transformColumnDefinition.bind(this),
    DropTableNode: this.transformDropTable.bind(this),
    DataTypeNode: this.transformDataType.bind(this),
    OrderByNode: this.transformOrderBy.bind(this),
    OrderByItemNode: this.transformOrderByItem.bind(this),
    GroupByNode: this.transformGroupBy.bind(this),
    GroupByItemNode: this.transformGroupByItem.bind(this),
    UpdateQueryNode: this.transformUpdateQuery.bind(this),
    ColumnUpdateNode: this.transformColumnUpdate.bind(this),
    LimitNode: this.transformLimit.bind(this),
    OffsetNode: this.transformOffset.bind(this),
    OnConflictNode: this.transformOnConflict.bind(this),
    OnDuplicateKeyNode: this.transformOnDuplicateKey.bind(this),
    CreateIndexNode: this.transformCreateIndex.bind(this),
    DropIndexNode: this.transformDropIndex.bind(this),
    ListNode: this.transformList.bind(this),
    PrimaryKeyConstraintNode: this.transformPrimaryKeyConstraint.bind(this),
    UniqueConstraintNode: this.transformUniqueConstraint.bind(this),
    ReferencesNode: this.transformReferences.bind(this),
    CheckConstraintNode: this.transformCheckConstraint.bind(this),
    WithNode: this.transformWith.bind(this),
    CommonTableExpressionNode: this.transformCommonTableExpression.bind(this),
    CommonTableExpressionNameNode: this.transformCommonTableExpressionName.bind(this),
    HavingNode: this.transformHaving.bind(this),
    CreateSchemaNode: this.transformCreateSchema.bind(this),
    DropSchemaNode: this.transformDropSchema.bind(this),
    AlterTableNode: this.transformAlterTable.bind(this),
    DropColumnNode: this.transformDropColumn.bind(this),
    RenameColumnNode: this.transformRenameColumn.bind(this),
    AlterColumnNode: this.transformAlterColumn.bind(this),
    ModifyColumnNode: this.transformModifyColumn.bind(this),
    AddConstraintNode: this.transformAddConstraint.bind(this),
    DropConstraintNode: this.transformDropConstraint.bind(this),
    RenameConstraintNode: this.transformRenameConstraint.bind(this),
    ForeignKeyConstraintNode: this.transformForeignKeyConstraint.bind(this),
    CreateViewNode: this.transformCreateView.bind(this),
    RefreshMaterializedViewNode: this.transformRefreshMaterializedView.bind(this),
    DropViewNode: this.transformDropView.bind(this),
    GeneratedNode: this.transformGenerated.bind(this),
    DefaultValueNode: this.transformDefaultValue.bind(this),
    OnNode: this.transformOn.bind(this),
    ValuesNode: this.transformValues.bind(this),
    SelectModifierNode: this.transformSelectModifier.bind(this),
    CreateTypeNode: this.transformCreateType.bind(this),
    DropTypeNode: this.transformDropType.bind(this),
    ExplainNode: this.transformExplain.bind(this),
    DefaultInsertValueNode: this.transformDefaultInsertValue.bind(this),
    AggregateFunctionNode: this.transformAggregateFunction.bind(this),
    OverNode: this.transformOver.bind(this),
    PartitionByNode: this.transformPartitionBy.bind(this),
    PartitionByItemNode: this.transformPartitionByItem.bind(this),
    SetOperationNode: this.transformSetOperation.bind(this),
    BinaryOperationNode: this.transformBinaryOperation.bind(this),
    UnaryOperationNode: this.transformUnaryOperation.bind(this),
    UsingNode: this.transformUsing.bind(this),
    FunctionNode: this.transformFunction.bind(this),
    CaseNode: this.transformCase.bind(this),
    WhenNode: this.transformWhen.bind(this),
    JSONReferenceNode: this.transformJSONReference.bind(this),
    JSONPathNode: this.transformJSONPath.bind(this),
    JSONPathLegNode: this.transformJSONPathLeg.bind(this),
    JSONOperatorChainNode: this.transformJSONOperatorChain.bind(this),
    TupleNode: this.transformTuple.bind(this),
    MergeQueryNode: this.transformMergeQuery.bind(this),
    MatchedNode: this.transformMatched.bind(this),
    AddIndexNode: this.transformAddIndex.bind(this),
    CastNode: this.transformCast.bind(this),
    FetchNode: this.transformFetch.bind(this),
    TopNode: this.transformTop.bind(this),
    OutputNode: this.transformOutput.bind(this),
    OrActionNode: this.transformOrAction.bind(this),
    CollateNode: this.transformCollate.bind(this)
  });
  transformNode(node, queryId) {
    if (!node) {
      return node;
    }
    this.nodeStack.push(node);
    const out = this.transformNodeImpl(node, queryId);
    this.nodeStack.pop();
    return freeze(out);
  }
  transformNodeImpl(node, queryId) {
    return this.#transformers[node.kind](node, queryId);
  }
  transformNodeList(list, queryId) {
    if (!list) {
      return list;
    }
    return freeze(list.map((node) => this.transformNode(node, queryId)));
  }
  transformSelectQuery(node, queryId) {
    return requireAllProps({
      kind: "SelectQueryNode",
      from: this.transformNode(node.from, queryId),
      selections: this.transformNodeList(node.selections, queryId),
      distinctOn: this.transformNodeList(node.distinctOn, queryId),
      joins: this.transformNodeList(node.joins, queryId),
      groupBy: this.transformNode(node.groupBy, queryId),
      orderBy: this.transformNode(node.orderBy, queryId),
      where: this.transformNode(node.where, queryId),
      frontModifiers: this.transformNodeList(node.frontModifiers, queryId),
      endModifiers: this.transformNodeList(node.endModifiers, queryId),
      limit: this.transformNode(node.limit, queryId),
      offset: this.transformNode(node.offset, queryId),
      with: this.transformNode(node.with, queryId),
      having: this.transformNode(node.having, queryId),
      explain: this.transformNode(node.explain, queryId),
      setOperations: this.transformNodeList(node.setOperations, queryId),
      fetch: this.transformNode(node.fetch, queryId),
      top: this.transformNode(node.top, queryId)
    });
  }
  transformSelection(node, queryId) {
    return requireAllProps({
      kind: "SelectionNode",
      selection: this.transformNode(node.selection, queryId)
    });
  }
  transformColumn(node, queryId) {
    return requireAllProps({
      kind: "ColumnNode",
      column: this.transformNode(node.column, queryId)
    });
  }
  transformAlias(node, queryId) {
    return requireAllProps({
      kind: "AliasNode",
      node: this.transformNode(node.node, queryId),
      alias: this.transformNode(node.alias, queryId)
    });
  }
  transformTable(node, queryId) {
    return requireAllProps({
      kind: "TableNode",
      table: this.transformNode(node.table, queryId)
    });
  }
  transformFrom(node, queryId) {
    return requireAllProps({
      kind: "FromNode",
      froms: this.transformNodeList(node.froms, queryId)
    });
  }
  transformReference(node, queryId) {
    return requireAllProps({
      kind: "ReferenceNode",
      column: this.transformNode(node.column, queryId),
      table: this.transformNode(node.table, queryId)
    });
  }
  transformAnd(node, queryId) {
    return requireAllProps({
      kind: "AndNode",
      left: this.transformNode(node.left, queryId),
      right: this.transformNode(node.right, queryId)
    });
  }
  transformOr(node, queryId) {
    return requireAllProps({
      kind: "OrNode",
      left: this.transformNode(node.left, queryId),
      right: this.transformNode(node.right, queryId)
    });
  }
  transformValueList(node, queryId) {
    return requireAllProps({
      kind: "ValueListNode",
      values: this.transformNodeList(node.values, queryId)
    });
  }
  transformParens(node, queryId) {
    return requireAllProps({
      kind: "ParensNode",
      node: this.transformNode(node.node, queryId)
    });
  }
  transformJoin(node, queryId) {
    return requireAllProps({
      kind: "JoinNode",
      joinType: node.joinType,
      table: this.transformNode(node.table, queryId),
      on: this.transformNode(node.on, queryId)
    });
  }
  transformRaw(node, queryId) {
    return requireAllProps({
      kind: "RawNode",
      sqlFragments: freeze([...node.sqlFragments]),
      parameters: this.transformNodeList(node.parameters, queryId)
    });
  }
  transformWhere(node, queryId) {
    return requireAllProps({
      kind: "WhereNode",
      where: this.transformNode(node.where, queryId)
    });
  }
  transformInsertQuery(node, queryId) {
    return requireAllProps({
      kind: "InsertQueryNode",
      into: this.transformNode(node.into, queryId),
      columns: this.transformNodeList(node.columns, queryId),
      values: this.transformNode(node.values, queryId),
      returning: this.transformNode(node.returning, queryId),
      onConflict: this.transformNode(node.onConflict, queryId),
      onDuplicateKey: this.transformNode(node.onDuplicateKey, queryId),
      endModifiers: this.transformNodeList(node.endModifiers, queryId),
      with: this.transformNode(node.with, queryId),
      ignore: node.ignore,
      orAction: this.transformNode(node.orAction, queryId),
      replace: node.replace,
      explain: this.transformNode(node.explain, queryId),
      defaultValues: node.defaultValues,
      top: this.transformNode(node.top, queryId),
      output: this.transformNode(node.output, queryId)
    });
  }
  transformValues(node, queryId) {
    return requireAllProps({
      kind: "ValuesNode",
      values: this.transformNodeList(node.values, queryId)
    });
  }
  transformDeleteQuery(node, queryId) {
    return requireAllProps({
      kind: "DeleteQueryNode",
      from: this.transformNode(node.from, queryId),
      using: this.transformNode(node.using, queryId),
      joins: this.transformNodeList(node.joins, queryId),
      where: this.transformNode(node.where, queryId),
      returning: this.transformNode(node.returning, queryId),
      endModifiers: this.transformNodeList(node.endModifiers, queryId),
      with: this.transformNode(node.with, queryId),
      orderBy: this.transformNode(node.orderBy, queryId),
      limit: this.transformNode(node.limit, queryId),
      explain: this.transformNode(node.explain, queryId),
      top: this.transformNode(node.top, queryId),
      output: this.transformNode(node.output, queryId)
    });
  }
  transformReturning(node, queryId) {
    return requireAllProps({
      kind: "ReturningNode",
      selections: this.transformNodeList(node.selections, queryId)
    });
  }
  transformCreateTable(node, queryId) {
    return requireAllProps({
      kind: "CreateTableNode",
      table: this.transformNode(node.table, queryId),
      columns: this.transformNodeList(node.columns, queryId),
      constraints: this.transformNodeList(node.constraints, queryId),
      temporary: node.temporary,
      ifNotExists: node.ifNotExists,
      onCommit: node.onCommit,
      frontModifiers: this.transformNodeList(node.frontModifiers, queryId),
      endModifiers: this.transformNodeList(node.endModifiers, queryId),
      selectQuery: this.transformNode(node.selectQuery, queryId)
    });
  }
  transformColumnDefinition(node, queryId) {
    return requireAllProps({
      kind: "ColumnDefinitionNode",
      column: this.transformNode(node.column, queryId),
      dataType: this.transformNode(node.dataType, queryId),
      references: this.transformNode(node.references, queryId),
      primaryKey: node.primaryKey,
      autoIncrement: node.autoIncrement,
      unique: node.unique,
      notNull: node.notNull,
      unsigned: node.unsigned,
      defaultTo: this.transformNode(node.defaultTo, queryId),
      check: this.transformNode(node.check, queryId),
      generated: this.transformNode(node.generated, queryId),
      frontModifiers: this.transformNodeList(node.frontModifiers, queryId),
      endModifiers: this.transformNodeList(node.endModifiers, queryId),
      nullsNotDistinct: node.nullsNotDistinct,
      identity: node.identity,
      ifNotExists: node.ifNotExists
    });
  }
  transformAddColumn(node, queryId) {
    return requireAllProps({
      kind: "AddColumnNode",
      column: this.transformNode(node.column, queryId)
    });
  }
  transformDropTable(node, queryId) {
    return requireAllProps({
      kind: "DropTableNode",
      table: this.transformNode(node.table, queryId),
      ifExists: node.ifExists,
      cascade: node.cascade
    });
  }
  transformOrderBy(node, queryId) {
    return requireAllProps({
      kind: "OrderByNode",
      items: this.transformNodeList(node.items, queryId)
    });
  }
  transformOrderByItem(node, queryId) {
    return requireAllProps({
      kind: "OrderByItemNode",
      orderBy: this.transformNode(node.orderBy, queryId),
      direction: this.transformNode(node.direction, queryId),
      collation: this.transformNode(node.collation, queryId),
      nulls: node.nulls
    });
  }
  transformGroupBy(node, queryId) {
    return requireAllProps({
      kind: "GroupByNode",
      items: this.transformNodeList(node.items, queryId)
    });
  }
  transformGroupByItem(node, queryId) {
    return requireAllProps({
      kind: "GroupByItemNode",
      groupBy: this.transformNode(node.groupBy, queryId)
    });
  }
  transformUpdateQuery(node, queryId) {
    return requireAllProps({
      kind: "UpdateQueryNode",
      table: this.transformNode(node.table, queryId),
      from: this.transformNode(node.from, queryId),
      joins: this.transformNodeList(node.joins, queryId),
      where: this.transformNode(node.where, queryId),
      updates: this.transformNodeList(node.updates, queryId),
      returning: this.transformNode(node.returning, queryId),
      endModifiers: this.transformNodeList(node.endModifiers, queryId),
      with: this.transformNode(node.with, queryId),
      explain: this.transformNode(node.explain, queryId),
      limit: this.transformNode(node.limit, queryId),
      top: this.transformNode(node.top, queryId),
      output: this.transformNode(node.output, queryId),
      orderBy: this.transformNode(node.orderBy, queryId)
    });
  }
  transformColumnUpdate(node, queryId) {
    return requireAllProps({
      kind: "ColumnUpdateNode",
      column: this.transformNode(node.column, queryId),
      value: this.transformNode(node.value, queryId)
    });
  }
  transformLimit(node, queryId) {
    return requireAllProps({
      kind: "LimitNode",
      limit: this.transformNode(node.limit, queryId)
    });
  }
  transformOffset(node, queryId) {
    return requireAllProps({
      kind: "OffsetNode",
      offset: this.transformNode(node.offset, queryId)
    });
  }
  transformOnConflict(node, queryId) {
    return requireAllProps({
      kind: "OnConflictNode",
      columns: this.transformNodeList(node.columns, queryId),
      constraint: this.transformNode(node.constraint, queryId),
      indexExpression: this.transformNode(node.indexExpression, queryId),
      indexWhere: this.transformNode(node.indexWhere, queryId),
      updates: this.transformNodeList(node.updates, queryId),
      updateWhere: this.transformNode(node.updateWhere, queryId),
      doNothing: node.doNothing
    });
  }
  transformOnDuplicateKey(node, queryId) {
    return requireAllProps({
      kind: "OnDuplicateKeyNode",
      updates: this.transformNodeList(node.updates, queryId)
    });
  }
  transformCreateIndex(node, queryId) {
    return requireAllProps({
      kind: "CreateIndexNode",
      name: this.transformNode(node.name, queryId),
      table: this.transformNode(node.table, queryId),
      columns: this.transformNodeList(node.columns, queryId),
      unique: node.unique,
      using: this.transformNode(node.using, queryId),
      ifNotExists: node.ifNotExists,
      where: this.transformNode(node.where, queryId),
      nullsNotDistinct: node.nullsNotDistinct
    });
  }
  transformList(node, queryId) {
    return requireAllProps({
      kind: "ListNode",
      items: this.transformNodeList(node.items, queryId)
    });
  }
  transformDropIndex(node, queryId) {
    return requireAllProps({
      kind: "DropIndexNode",
      name: this.transformNode(node.name, queryId),
      table: this.transformNode(node.table, queryId),
      ifExists: node.ifExists,
      cascade: node.cascade
    });
  }
  transformPrimaryKeyConstraint(node, queryId) {
    return requireAllProps({
      kind: "PrimaryKeyConstraintNode",
      columns: this.transformNodeList(node.columns, queryId),
      name: this.transformNode(node.name, queryId),
      deferrable: node.deferrable,
      initiallyDeferred: node.initiallyDeferred
    });
  }
  transformUniqueConstraint(node, queryId) {
    return requireAllProps({
      kind: "UniqueConstraintNode",
      columns: this.transformNodeList(node.columns, queryId),
      name: this.transformNode(node.name, queryId),
      nullsNotDistinct: node.nullsNotDistinct,
      deferrable: node.deferrable,
      initiallyDeferred: node.initiallyDeferred
    });
  }
  transformForeignKeyConstraint(node, queryId) {
    return requireAllProps({
      kind: "ForeignKeyConstraintNode",
      columns: this.transformNodeList(node.columns, queryId),
      references: this.transformNode(node.references, queryId),
      name: this.transformNode(node.name, queryId),
      onDelete: node.onDelete,
      onUpdate: node.onUpdate,
      deferrable: node.deferrable,
      initiallyDeferred: node.initiallyDeferred
    });
  }
  transformSetOperation(node, queryId) {
    return requireAllProps({
      kind: "SetOperationNode",
      operator: node.operator,
      expression: this.transformNode(node.expression, queryId),
      all: node.all
    });
  }
  transformReferences(node, queryId) {
    return requireAllProps({
      kind: "ReferencesNode",
      table: this.transformNode(node.table, queryId),
      columns: this.transformNodeList(node.columns, queryId),
      onDelete: node.onDelete,
      onUpdate: node.onUpdate
    });
  }
  transformCheckConstraint(node, queryId) {
    return requireAllProps({
      kind: "CheckConstraintNode",
      expression: this.transformNode(node.expression, queryId),
      name: this.transformNode(node.name, queryId)
    });
  }
  transformWith(node, queryId) {
    return requireAllProps({
      kind: "WithNode",
      expressions: this.transformNodeList(node.expressions, queryId),
      recursive: node.recursive
    });
  }
  transformCommonTableExpression(node, queryId) {
    return requireAllProps({
      kind: "CommonTableExpressionNode",
      name: this.transformNode(node.name, queryId),
      materialized: node.materialized,
      expression: this.transformNode(node.expression, queryId)
    });
  }
  transformCommonTableExpressionName(node, queryId) {
    return requireAllProps({
      kind: "CommonTableExpressionNameNode",
      table: this.transformNode(node.table, queryId),
      columns: this.transformNodeList(node.columns, queryId)
    });
  }
  transformHaving(node, queryId) {
    return requireAllProps({
      kind: "HavingNode",
      having: this.transformNode(node.having, queryId)
    });
  }
  transformCreateSchema(node, queryId) {
    return requireAllProps({
      kind: "CreateSchemaNode",
      schema: this.transformNode(node.schema, queryId),
      ifNotExists: node.ifNotExists
    });
  }
  transformDropSchema(node, queryId) {
    return requireAllProps({
      kind: "DropSchemaNode",
      schema: this.transformNode(node.schema, queryId),
      ifExists: node.ifExists,
      cascade: node.cascade
    });
  }
  transformAlterTable(node, queryId) {
    return requireAllProps({
      kind: "AlterTableNode",
      table: this.transformNode(node.table, queryId),
      renameTo: this.transformNode(node.renameTo, queryId),
      setSchema: this.transformNode(node.setSchema, queryId),
      columnAlterations: this.transformNodeList(node.columnAlterations, queryId),
      addConstraint: this.transformNode(node.addConstraint, queryId),
      dropConstraint: this.transformNode(node.dropConstraint, queryId),
      renameConstraint: this.transformNode(node.renameConstraint, queryId),
      addIndex: this.transformNode(node.addIndex, queryId),
      dropIndex: this.transformNode(node.dropIndex, queryId)
    });
  }
  transformDropColumn(node, queryId) {
    return requireAllProps({
      kind: "DropColumnNode",
      column: this.transformNode(node.column, queryId)
    });
  }
  transformRenameColumn(node, queryId) {
    return requireAllProps({
      kind: "RenameColumnNode",
      column: this.transformNode(node.column, queryId),
      renameTo: this.transformNode(node.renameTo, queryId)
    });
  }
  transformAlterColumn(node, queryId) {
    return requireAllProps({
      kind: "AlterColumnNode",
      column: this.transformNode(node.column, queryId),
      dataType: this.transformNode(node.dataType, queryId),
      dataTypeExpression: this.transformNode(node.dataTypeExpression, queryId),
      setDefault: this.transformNode(node.setDefault, queryId),
      dropDefault: node.dropDefault,
      setNotNull: node.setNotNull,
      dropNotNull: node.dropNotNull
    });
  }
  transformModifyColumn(node, queryId) {
    return requireAllProps({
      kind: "ModifyColumnNode",
      column: this.transformNode(node.column, queryId)
    });
  }
  transformAddConstraint(node, queryId) {
    return requireAllProps({
      kind: "AddConstraintNode",
      constraint: this.transformNode(node.constraint, queryId)
    });
  }
  transformDropConstraint(node, queryId) {
    return requireAllProps({
      kind: "DropConstraintNode",
      constraintName: this.transformNode(node.constraintName, queryId),
      ifExists: node.ifExists,
      modifier: node.modifier
    });
  }
  transformRenameConstraint(node, queryId) {
    return requireAllProps({
      kind: "RenameConstraintNode",
      oldName: this.transformNode(node.oldName, queryId),
      newName: this.transformNode(node.newName, queryId)
    });
  }
  transformCreateView(node, queryId) {
    return requireAllProps({
      kind: "CreateViewNode",
      name: this.transformNode(node.name, queryId),
      temporary: node.temporary,
      orReplace: node.orReplace,
      ifNotExists: node.ifNotExists,
      materialized: node.materialized,
      columns: this.transformNodeList(node.columns, queryId),
      as: this.transformNode(node.as, queryId)
    });
  }
  transformRefreshMaterializedView(node, queryId) {
    return requireAllProps({
      kind: "RefreshMaterializedViewNode",
      name: this.transformNode(node.name, queryId),
      concurrently: node.concurrently,
      withNoData: node.withNoData
    });
  }
  transformDropView(node, queryId) {
    return requireAllProps({
      kind: "DropViewNode",
      name: this.transformNode(node.name, queryId),
      ifExists: node.ifExists,
      materialized: node.materialized,
      cascade: node.cascade
    });
  }
  transformGenerated(node, queryId) {
    return requireAllProps({
      kind: "GeneratedNode",
      byDefault: node.byDefault,
      always: node.always,
      identity: node.identity,
      stored: node.stored,
      expression: this.transformNode(node.expression, queryId)
    });
  }
  transformDefaultValue(node, queryId) {
    return requireAllProps({
      kind: "DefaultValueNode",
      defaultValue: this.transformNode(node.defaultValue, queryId)
    });
  }
  transformOn(node, queryId) {
    return requireAllProps({
      kind: "OnNode",
      on: this.transformNode(node.on, queryId)
    });
  }
  transformSelectModifier(node, queryId) {
    return requireAllProps({
      kind: "SelectModifierNode",
      modifier: node.modifier,
      rawModifier: this.transformNode(node.rawModifier, queryId),
      of: this.transformNodeList(node.of, queryId)
    });
  }
  transformCreateType(node, queryId) {
    return requireAllProps({
      kind: "CreateTypeNode",
      name: this.transformNode(node.name, queryId),
      enum: this.transformNode(node.enum, queryId)
    });
  }
  transformDropType(node, queryId) {
    return requireAllProps({
      kind: "DropTypeNode",
      name: this.transformNode(node.name, queryId),
      ifExists: node.ifExists
    });
  }
  transformExplain(node, queryId) {
    return requireAllProps({
      kind: "ExplainNode",
      format: node.format,
      options: this.transformNode(node.options, queryId)
    });
  }
  transformSchemableIdentifier(node, queryId) {
    return requireAllProps({
      kind: "SchemableIdentifierNode",
      schema: this.transformNode(node.schema, queryId),
      identifier: this.transformNode(node.identifier, queryId)
    });
  }
  transformAggregateFunction(node, queryId) {
    return requireAllProps({
      kind: "AggregateFunctionNode",
      func: node.func,
      aggregated: this.transformNodeList(node.aggregated, queryId),
      distinct: node.distinct,
      orderBy: this.transformNode(node.orderBy, queryId),
      withinGroup: this.transformNode(node.withinGroup, queryId),
      filter: this.transformNode(node.filter, queryId),
      over: this.transformNode(node.over, queryId)
    });
  }
  transformOver(node, queryId) {
    return requireAllProps({
      kind: "OverNode",
      orderBy: this.transformNode(node.orderBy, queryId),
      partitionBy: this.transformNode(node.partitionBy, queryId)
    });
  }
  transformPartitionBy(node, queryId) {
    return requireAllProps({
      kind: "PartitionByNode",
      items: this.transformNodeList(node.items, queryId)
    });
  }
  transformPartitionByItem(node, queryId) {
    return requireAllProps({
      kind: "PartitionByItemNode",
      partitionBy: this.transformNode(node.partitionBy, queryId)
    });
  }
  transformBinaryOperation(node, queryId) {
    return requireAllProps({
      kind: "BinaryOperationNode",
      leftOperand: this.transformNode(node.leftOperand, queryId),
      operator: this.transformNode(node.operator, queryId),
      rightOperand: this.transformNode(node.rightOperand, queryId)
    });
  }
  transformUnaryOperation(node, queryId) {
    return requireAllProps({
      kind: "UnaryOperationNode",
      operator: this.transformNode(node.operator, queryId),
      operand: this.transformNode(node.operand, queryId)
    });
  }
  transformUsing(node, queryId) {
    return requireAllProps({
      kind: "UsingNode",
      tables: this.transformNodeList(node.tables, queryId)
    });
  }
  transformFunction(node, queryId) {
    return requireAllProps({
      kind: "FunctionNode",
      func: node.func,
      arguments: this.transformNodeList(node.arguments, queryId)
    });
  }
  transformCase(node, queryId) {
    return requireAllProps({
      kind: "CaseNode",
      value: this.transformNode(node.value, queryId),
      when: this.transformNodeList(node.when, queryId),
      else: this.transformNode(node.else, queryId),
      isStatement: node.isStatement
    });
  }
  transformWhen(node, queryId) {
    return requireAllProps({
      kind: "WhenNode",
      condition: this.transformNode(node.condition, queryId),
      result: this.transformNode(node.result, queryId)
    });
  }
  transformJSONReference(node, queryId) {
    return requireAllProps({
      kind: "JSONReferenceNode",
      reference: this.transformNode(node.reference, queryId),
      traversal: this.transformNode(node.traversal, queryId)
    });
  }
  transformJSONPath(node, queryId) {
    return requireAllProps({
      kind: "JSONPathNode",
      inOperator: this.transformNode(node.inOperator, queryId),
      pathLegs: this.transformNodeList(node.pathLegs, queryId)
    });
  }
  transformJSONPathLeg(node, _queryId) {
    return requireAllProps({
      kind: "JSONPathLegNode",
      type: node.type,
      value: node.value
    });
  }
  transformJSONOperatorChain(node, queryId) {
    return requireAllProps({
      kind: "JSONOperatorChainNode",
      operator: this.transformNode(node.operator, queryId),
      values: this.transformNodeList(node.values, queryId)
    });
  }
  transformTuple(node, queryId) {
    return requireAllProps({
      kind: "TupleNode",
      values: this.transformNodeList(node.values, queryId)
    });
  }
  transformMergeQuery(node, queryId) {
    return requireAllProps({
      kind: "MergeQueryNode",
      into: this.transformNode(node.into, queryId),
      using: this.transformNode(node.using, queryId),
      whens: this.transformNodeList(node.whens, queryId),
      with: this.transformNode(node.with, queryId),
      top: this.transformNode(node.top, queryId),
      endModifiers: this.transformNodeList(node.endModifiers, queryId),
      output: this.transformNode(node.output, queryId),
      returning: this.transformNode(node.returning, queryId)
    });
  }
  transformMatched(node, _queryId) {
    return requireAllProps({
      kind: "MatchedNode",
      not: node.not,
      bySource: node.bySource
    });
  }
  transformAddIndex(node, queryId) {
    return requireAllProps({
      kind: "AddIndexNode",
      name: this.transformNode(node.name, queryId),
      columns: this.transformNodeList(node.columns, queryId),
      unique: node.unique,
      using: this.transformNode(node.using, queryId),
      ifNotExists: node.ifNotExists
    });
  }
  transformCast(node, queryId) {
    return requireAllProps({
      kind: "CastNode",
      expression: this.transformNode(node.expression, queryId),
      dataType: this.transformNode(node.dataType, queryId)
    });
  }
  transformFetch(node, queryId) {
    return requireAllProps({
      kind: "FetchNode",
      rowCount: this.transformNode(node.rowCount, queryId),
      modifier: node.modifier
    });
  }
  transformTop(node, _queryId) {
    return requireAllProps({
      kind: "TopNode",
      expression: node.expression,
      modifiers: node.modifiers
    });
  }
  transformOutput(node, queryId) {
    return requireAllProps({
      kind: "OutputNode",
      selections: this.transformNodeList(node.selections, queryId)
    });
  }
  transformDataType(node, _queryId) {
    return node;
  }
  transformSelectAll(node, _queryId) {
    return node;
  }
  transformIdentifier(node, _queryId) {
    return node;
  }
  transformValue(node, _queryId) {
    return node;
  }
  transformPrimitiveValueList(node, _queryId) {
    return node;
  }
  transformOperator(node, _queryId) {
    return node;
  }
  transformDefaultInsertValue(node, _queryId) {
    return node;
  }
  transformOrAction(node, _queryId) {
    return node;
  }
  transformCollate(node, _queryId) {
    return node;
  }
}
const ROOT_OPERATION_NODES = freeze({
  AlterTableNode: true,
  CreateIndexNode: true,
  CreateSchemaNode: true,
  CreateTableNode: true,
  CreateTypeNode: true,
  CreateViewNode: true,
  RefreshMaterializedViewNode: true,
  DeleteQueryNode: true,
  DropIndexNode: true,
  DropSchemaNode: true,
  DropTableNode: true,
  DropTypeNode: true,
  DropViewNode: true,
  InsertQueryNode: true,
  RawNode: true,
  SelectQueryNode: true,
  UpdateQueryNode: true,
  MergeQueryNode: true
});
const SCHEMALESS_FUNCTIONS = {
  json_agg: true,
  to_json: true
};
class WithSchemaTransformer extends OperationNodeTransformer {
  #schema;
  #schemableIds = /* @__PURE__ */ new Set();
  #ctes = /* @__PURE__ */ new Set();
  constructor(schema2) {
    super();
    this.#schema = schema2;
  }
  transformNodeImpl(node, queryId) {
    if (!this.#isRootOperationNode(node)) {
      return super.transformNodeImpl(node, queryId);
    }
    const ctes = this.#collectCTEs(node);
    for (const cte of ctes) {
      this.#ctes.add(cte);
    }
    const tables = this.#collectSchemableIds(node);
    for (const table of tables) {
      this.#schemableIds.add(table);
    }
    const transformed = super.transformNodeImpl(node, queryId);
    for (const table of tables) {
      this.#schemableIds.delete(table);
    }
    for (const cte of ctes) {
      this.#ctes.delete(cte);
    }
    return transformed;
  }
  transformSchemableIdentifier(node, queryId) {
    const transformed = super.transformSchemableIdentifier(node, queryId);
    if (transformed.schema || !this.#schemableIds.has(node.identifier.name)) {
      return transformed;
    }
    return {
      ...transformed,
      schema: IdentifierNode.create(this.#schema)
    };
  }
  transformReferences(node, queryId) {
    const transformed = super.transformReferences(node, queryId);
    if (transformed.table.table.schema) {
      return transformed;
    }
    return {
      ...transformed,
      table: TableNode.createWithSchema(this.#schema, transformed.table.table.identifier.name)
    };
  }
  transformAggregateFunction(node, queryId) {
    return {
      ...super.transformAggregateFunction({ ...node, aggregated: [] }, queryId),
      aggregated: this.#transformTableArgsWithoutSchemas(node, queryId, "aggregated")
    };
  }
  transformFunction(node, queryId) {
    return {
      ...super.transformFunction({ ...node, arguments: [] }, queryId),
      arguments: this.#transformTableArgsWithoutSchemas(node, queryId, "arguments")
    };
  }
  transformSelectModifier(node, queryId) {
    return {
      ...super.transformSelectModifier({ ...node, of: void 0 }, queryId),
      of: node.of?.map((item) => TableNode.is(item) && !item.table.schema ? {
        ...item,
        table: this.transformIdentifier(item.table.identifier, queryId)
      } : this.transformNode(item, queryId))
    };
  }
  #transformTableArgsWithoutSchemas(node, queryId, argsKey) {
    return SCHEMALESS_FUNCTIONS[node.func] ? node[argsKey].map((arg) => !TableNode.is(arg) || arg.table.schema ? this.transformNode(arg, queryId) : {
      ...arg,
      table: this.transformIdentifier(arg.table.identifier, queryId)
    }) : this.transformNodeList(node[argsKey], queryId);
  }
  #isRootOperationNode(node) {
    return node.kind in ROOT_OPERATION_NODES;
  }
  #collectSchemableIds(node) {
    const schemableIds = /* @__PURE__ */ new Set();
    if ("name" in node && node.name && SchemableIdentifierNode.is(node.name)) {
      this.#collectSchemableId(node.name, schemableIds);
    }
    if ("from" in node && node.from) {
      for (const from of node.from.froms) {
        this.#collectSchemableIdsFromTableExpr(from, schemableIds);
      }
    }
    if ("into" in node && node.into) {
      this.#collectSchemableIdsFromTableExpr(node.into, schemableIds);
    }
    if ("table" in node && node.table) {
      this.#collectSchemableIdsFromTableExpr(node.table, schemableIds);
    }
    if ("joins" in node && node.joins) {
      for (const join2 of node.joins) {
        this.#collectSchemableIdsFromTableExpr(join2.table, schemableIds);
      }
    }
    if ("using" in node && node.using) {
      if (JoinNode.is(node.using)) {
        this.#collectSchemableIdsFromTableExpr(node.using.table, schemableIds);
      } else {
        this.#collectSchemableIdsFromTableExpr(node.using, schemableIds);
      }
    }
    return schemableIds;
  }
  #collectCTEs(node) {
    const ctes = /* @__PURE__ */ new Set();
    if ("with" in node && node.with) {
      this.#collectCTEIds(node.with, ctes);
    }
    return ctes;
  }
  #collectSchemableIdsFromTableExpr(node, schemableIds) {
    if (TableNode.is(node)) {
      return this.#collectSchemableId(node.table, schemableIds);
    }
    if (AliasNode.is(node) && TableNode.is(node.node)) {
      return this.#collectSchemableId(node.node.table, schemableIds);
    }
    if (ListNode.is(node)) {
      for (const table of node.items) {
        this.#collectSchemableIdsFromTableExpr(table, schemableIds);
      }
      return;
    }
    if (UsingNode.is(node)) {
      for (const table of node.tables) {
        this.#collectSchemableIdsFromTableExpr(table, schemableIds);
      }
      return;
    }
  }
  #collectSchemableId(node, schemableIds) {
    const id = node.identifier.name;
    if (!this.#schemableIds.has(id) && !this.#ctes.has(id)) {
      schemableIds.add(id);
    }
  }
  #collectCTEIds(node, ctes) {
    for (const expr of node.expressions) {
      const cteId = expr.name.table.table.identifier.name;
      if (!this.#ctes.has(cteId)) {
        ctes.add(cteId);
      }
    }
  }
}
class WithSchemaPlugin {
  #transformer;
  constructor(schema2) {
    this.#transformer = new WithSchemaTransformer(schema2);
  }
  transformQuery(args) {
    return this.#transformer.transformNode(args.node, args.queryId);
  }
  async transformResult(args) {
    return args.result;
  }
}
const MatchedNode = freeze({
  is(node) {
    return node.kind === "MatchedNode";
  },
  create(not2, bySource = false) {
    return freeze({
      kind: "MatchedNode",
      not: not2,
      bySource
    });
  }
});
function parseMergeWhen(type2, args, refRight) {
  return WhenNode.create(parseFilterList([
    MatchedNode.create(!type2.isMatched, type2.bySource),
    ...args && args.length > 0 ? [
      args.length === 3 && refRight ? parseReferentialBinaryOperation(args[0], args[1], args[2]) : parseValueBinaryOperationOrExpression(args)
    ] : []
  ], "and", false));
}
function parseMergeThen(result2) {
  if (isString$1(result2)) {
    return RawNode.create([result2], []);
  }
  if (isOperationNodeSource(result2)) {
    return result2.toOperationNode();
  }
  return result2;
}
class Deferred {
  #promise;
  #resolve;
  #reject;
  constructor() {
    this.#promise = new Promise((resolve2, reject) => {
      this.#reject = reject;
      this.#resolve = resolve2;
    });
  }
  get promise() {
    return this.#promise;
  }
  resolve = (value) => {
    if (this.#resolve) {
      this.#resolve(value);
    }
  };
  reject = (reason) => {
    if (this.#reject) {
      this.#reject(reason);
    }
  };
}
async function provideControlledConnection(connectionProvider) {
  const connectionDefer = new Deferred();
  const connectionReleaseDefer = new Deferred();
  connectionProvider.provideConnection(async (connection2) => {
    connectionDefer.resolve(connection2);
    return await connectionReleaseDefer.promise;
  }).catch((ex) => connectionDefer.reject(ex));
  return freeze({
    connection: await connectionDefer.promise,
    release: connectionReleaseDefer.resolve
  });
}
const NO_PLUGINS = freeze([]);
class QueryExecutorBase {
  #plugins;
  constructor(plugins = NO_PLUGINS) {
    this.#plugins = plugins;
  }
  get plugins() {
    return this.#plugins;
  }
  transformQuery(node, queryId) {
    for (const plugin of this.#plugins) {
      const transformedNode = plugin.transformQuery({ node, queryId });
      if (transformedNode.kind === node.kind) {
        node = transformedNode;
      } else {
        throw new Error([
          `KyselyPlugin.transformQuery must return a node`,
          `of the same kind that was given to it.`,
          `The plugin was given a ${node.kind}`,
          `but it returned a ${transformedNode.kind}`
        ].join(" "));
      }
    }
    return node;
  }
  async executeQuery(compiledQuery) {
    return await this.provideConnection(async (connection2) => {
      const result2 = await connection2.executeQuery(compiledQuery);
      if ("numUpdatedOrDeletedRows" in result2) {
        logOnce("kysely:warning: outdated driver/plugin detected! `QueryResult.numUpdatedOrDeletedRows` has been replaced with `QueryResult.numAffectedRows`.");
      }
      return await this.#transformResult(result2, compiledQuery.queryId);
    });
  }
  async *stream(compiledQuery, chunkSize) {
    const { connection: connection2, release } = await provideControlledConnection(this);
    try {
      for await (const result2 of connection2.streamQuery(compiledQuery, chunkSize)) {
        yield await this.#transformResult(result2, compiledQuery.queryId);
      }
    } finally {
      release();
    }
  }
  async #transformResult(result2, queryId) {
    for (const plugin of this.#plugins) {
      result2 = await plugin.transformResult({ result: result2, queryId });
    }
    return result2;
  }
}
class NoopQueryExecutor extends QueryExecutorBase {
  get adapter() {
    throw new Error("this query cannot be compiled to SQL");
  }
  compileQuery() {
    throw new Error("this query cannot be compiled to SQL");
  }
  provideConnection() {
    throw new Error("this query cannot be executed");
  }
  withConnectionProvider() {
    throw new Error("this query cannot have a connection provider");
  }
  withPlugin(plugin) {
    return new NoopQueryExecutor([...this.plugins, plugin]);
  }
  withPlugins(plugins) {
    return new NoopQueryExecutor([...this.plugins, ...plugins]);
  }
  withPluginAtFront(plugin) {
    return new NoopQueryExecutor([plugin, ...this.plugins]);
  }
  withoutPlugins() {
    return new NoopQueryExecutor([]);
  }
}
const NOOP_QUERY_EXECUTOR = new NoopQueryExecutor();
class MergeResult {
  numChangedRows;
  constructor(numChangedRows) {
    this.numChangedRows = numChangedRows;
  }
}
class MergeQueryBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * This can be used to add any additional SQL to the end of the query.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db
   *   .mergeInto('person')
   *   .using('pet', 'pet.owner_id', 'person.id')
   *   .whenMatched()
   *   .thenDelete()
   *   .modifyEnd(sql.raw('-- this is a comment'))
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * merge into "person" using "pet" on "pet"."owner_id" = "person"."id" when matched then delete -- this is a comment
   * ```
   */
  modifyEnd(modifier) {
    return new MergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, modifier.toOperationNode())
    });
  }
  /**
   * Changes a `merge into` query to an `merge top into` query.
   *
   * `top` clause is only supported by some dialects like MS SQL Server.
   *
   * ### Examples
   *
   * Affect 5 matched rows at most:
   *
   * ```ts
   * await db.mergeInto('person')
   *   .top(5)
   *   .using('pet', 'person.id', 'pet.owner_id')
   *   .whenMatched()
   *   .thenDelete()
   *   .execute()
   * ```
   *
   * The generated SQL (MS SQL Server):
   *
   * ```sql
   * merge top(5) into "person"
   * using "pet" on "person"."id" = "pet"."owner_id"
   * when matched then
   *   delete
   * ```
   *
   * Affect 50% of matched rows:
   *
   * ```ts
   * await db.mergeInto('person')
   *   .top(50, 'percent')
   *   .using('pet', 'person.id', 'pet.owner_id')
   *   .whenMatched()
   *   .thenDelete()
   *   .execute()
   * ```
   *
   * The generated SQL (MS SQL Server):
   *
   * ```sql
   * merge top(50) percent into "person"
   * using "pet" on "person"."id" = "pet"."owner_id"
   * when matched then
   *   delete
   * ```
   */
  top(expression, modifiers) {
    return new MergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers))
    });
  }
  using(...args) {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: MergeQueryNode.cloneWithUsing(this.#props.queryNode, parseJoin("Using", args))
    });
  }
  returning(args) {
    return new MergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectArg(args))
    });
  }
  returningAll(table) {
    return new MergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectAll(table))
    });
  }
  output(args) {
    return new MergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectArg(args))
    });
  }
  outputAll(table) {
    return new MergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectAll(table))
    });
  }
}
class WheneableMergeQueryBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * This can be used to add any additional SQL to the end of the query.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db
   *   .mergeInto('person')
   *   .using('pet', 'pet.owner_id', 'person.id')
   *   .whenMatched()
   *   .thenDelete()
   *   .modifyEnd(sql.raw('-- this is a comment'))
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * merge into "person" using "pet" on "pet"."owner_id" = "person"."id" when matched then delete -- this is a comment
   * ```
   */
  modifyEnd(modifier) {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, modifier.toOperationNode())
    });
  }
  /**
   * See {@link MergeQueryBuilder.top}.
   */
  top(expression, modifiers) {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers))
    });
  }
  /**
   * Adds a simple `when matched` clause to the query.
   *
   * For a `when matched` clause with an `and` condition, see {@link whenMatchedAnd}.
   *
   * For a simple `when not matched` clause, see {@link whenNotMatched}.
   *
   * For a `when not matched` clause with an `and` condition, see {@link whenNotMatchedAnd}.
   *
   * ### Examples
   *
   * ```ts
   * const result = await db.mergeInto('person')
   *   .using('pet', 'person.id', 'pet.owner_id')
   *   .whenMatched()
   *   .thenDelete()
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * merge into "person"
   * using "pet" on "person"."id" = "pet"."owner_id"
   * when matched then
   *   delete
   * ```
   */
  whenMatched() {
    return this.#whenMatched([]);
  }
  whenMatchedAnd(...args) {
    return this.#whenMatched(args);
  }
  /**
   * Adds the `when matched` clause to the query with an `and` condition. But unlike
   * {@link whenMatchedAnd}, this method accepts a column reference as the 3rd argument.
   *
   * This method is similar to {@link SelectQueryBuilder.whereRef}, so see the documentation
   * for that method for more examples.
   */
  whenMatchedAndRef(lhs, op, rhs) {
    return this.#whenMatched([lhs, op, rhs], true);
  }
  #whenMatched(args, refRight) {
    return new MatchedThenableMergeQueryBuilder({
      ...this.#props,
      queryNode: MergeQueryNode.cloneWithWhen(this.#props.queryNode, parseMergeWhen({ isMatched: true }, args, refRight))
    });
  }
  /**
   * Adds a simple `when not matched` clause to the query.
   *
   * For a `when not matched` clause with an `and` condition, see {@link whenNotMatchedAnd}.
   *
   * For a simple `when matched` clause, see {@link whenMatched}.
   *
   * For a `when matched` clause with an `and` condition, see {@link whenMatchedAnd}.
   *
   * ### Examples
   *
   * ```ts
   * const result = await db.mergeInto('person')
   *   .using('pet', 'person.id', 'pet.owner_id')
   *   .whenNotMatched()
   *   .thenInsertValues({
   *     first_name: 'John',
   *     last_name: 'Doe',
   *   })
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * merge into "person"
   * using "pet" on "person"."id" = "pet"."owner_id"
   * when not matched then
   *   insert ("first_name", "last_name") values ($1, $2)
   * ```
   */
  whenNotMatched() {
    return this.#whenNotMatched([]);
  }
  whenNotMatchedAnd(...args) {
    return this.#whenNotMatched(args);
  }
  /**
   * Adds the `when not matched` clause to the query with an `and` condition. But unlike
   * {@link whenNotMatchedAnd}, this method accepts a column reference as the 3rd argument.
   *
   * Unlike {@link whenMatchedAndRef}, you cannot reference columns from the target table.
   *
   * This method is similar to {@link SelectQueryBuilder.whereRef}, so see the documentation
   * for that method for more examples.
   */
  whenNotMatchedAndRef(lhs, op, rhs) {
    return this.#whenNotMatched([lhs, op, rhs], true);
  }
  /**
   * Adds a simple `when not matched by source` clause to the query.
   *
   * Supported in MS SQL Server.
   *
   * Similar to {@link whenNotMatched}, but returns a {@link MatchedThenableMergeQueryBuilder}.
   */
  whenNotMatchedBySource() {
    return this.#whenNotMatched([], false, true);
  }
  whenNotMatchedBySourceAnd(...args) {
    return this.#whenNotMatched(args, false, true);
  }
  /**
   * Adds the `when not matched by source` clause to the query with an `and` condition.
   *
   * Similar to {@link whenNotMatchedAndRef}, but you can reference columns from
   * the target table, and not from source table and returns a {@link MatchedThenableMergeQueryBuilder}.
   */
  whenNotMatchedBySourceAndRef(lhs, op, rhs) {
    return this.#whenNotMatched([lhs, op, rhs], true, true);
  }
  returning(args) {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectArg(args))
    });
  }
  returningAll(table) {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectAll(table))
    });
  }
  output(args) {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectArg(args))
    });
  }
  outputAll(table) {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectAll(table))
    });
  }
  #whenNotMatched(args, refRight = false, bySource = false) {
    const props = {
      ...this.#props,
      queryNode: MergeQueryNode.cloneWithWhen(this.#props.queryNode, parseMergeWhen({ isMatched: false, bySource }, args, refRight))
    };
    const Builder = bySource ? MatchedThenableMergeQueryBuilder : NotMatchedThenableMergeQueryBuilder;
    return new Builder(props);
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   *
   * If you want to conditionally call a method on `this`, see
   * the {@link $if} method.
   *
   * ### Examples
   *
   * The next example uses a helper function `log` to log a query:
   *
   * ```ts
   * import type { Compilable } from 'kysely'
   *
   * function log<T extends Compilable>(qb: T): T {
   *   console.log(qb.compile())
   *   return qb
   * }
   *
   * await db.updateTable('person')
   *   .set({ first_name: 'John' })
   *   .$call(log)
   *   .execute()
   * ```
   */
  $call(func) {
    return func(this);
  }
  /**
   * Call `func(this)` if `condition` is true.
   *
   * This method is especially handy with optional selects. Any `returning` or `returningAll`
   * method calls add columns as optional fields to the output type when called inside
   * the `func` callback. This is because we can't know if those selections were actually
   * made before running the code.
   *
   * You can also call any other methods inside the callback.
   *
   * ### Examples
   *
   * ```ts
   * import type { PersonUpdate } from 'type-editor' // imaginary module
   *
   * async function updatePerson(id: number, updates: PersonUpdate, returnLastName: boolean) {
   *   return await db
   *     .updateTable('person')
   *     .set(updates)
   *     .where('id', '=', id)
   *     .returning(['id', 'first_name'])
   *     .$if(returnLastName, (qb) => qb.returning('last_name'))
   *     .executeTakeFirstOrThrow()
   * }
   * ```
   *
   * Any selections added inside the `if` callback will be added as optional fields to the
   * output type since we can't know if the selections were actually made before running
   * the code. In the example above the return type of the `updatePerson` function is:
   *
   * ```ts
   * Promise<{
   *   id: number
   *   first_name: string
   *   last_name?: string
   * }>
   * ```
   */
  $if(condition, func) {
    if (condition) {
      return func(this);
    }
    return new WheneableMergeQueryBuilder({
      ...this.#props
    });
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.queryNode, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  /**
   * Executes the query and returns an array of rows.
   *
   * Also see the {@link executeTakeFirst} and {@link executeTakeFirstOrThrow} methods.
   */
  async execute() {
    const compiledQuery = this.compile();
    const result2 = await this.#props.executor.executeQuery(compiledQuery);
    const { adapter } = this.#props.executor;
    const query2 = compiledQuery.query;
    if (query2.returning && adapter.supportsReturning || query2.output && adapter.supportsOutput) {
      return result2.rows;
    }
    return [new MergeResult(result2.numAffectedRows)];
  }
  /**
   * Executes the query and returns the first result or undefined if
   * the query returned no result.
   */
  async executeTakeFirst() {
    const [result2] = await this.execute();
    return result2;
  }
  /**
   * Executes the query and returns the first result or throws if
   * the query returned no result.
   *
   * By default an instance of {@link NoResultError} is thrown, but you can
   * provide a custom error class, or callback as the only argument to throw a different
   * error.
   */
  async executeTakeFirstOrThrow(errorConstructor = NoResultError) {
    const result2 = await this.executeTakeFirst();
    if (result2 === void 0) {
      const error2 = isNoResultErrorConstructor(errorConstructor) ? new errorConstructor(this.toOperationNode()) : errorConstructor(this.toOperationNode());
      throw error2;
    }
    return result2;
  }
}
class MatchedThenableMergeQueryBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * Performs the `delete` action.
   *
   * To perform the `do nothing` action, see {@link thenDoNothing}.
   *
   * To perform the `update` action, see {@link thenUpdate} or {@link thenUpdateSet}.
   *
   * ### Examples
   *
   * ```ts
   * const result = await db.mergeInto('person')
   *   .using('pet', 'person.id', 'pet.owner_id')
   *   .whenMatched()
   *   .thenDelete()
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * merge into "person"
   * using "pet" on "person"."id" = "pet"."owner_id"
   * when matched then
   *   delete
   * ```
   */
  thenDelete() {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: MergeQueryNode.cloneWithThen(this.#props.queryNode, parseMergeThen("delete"))
    });
  }
  /**
   * Performs the `do nothing` action.
   *
   * This is supported in PostgreSQL.
   *
   * To perform the `delete` action, see {@link thenDelete}.
   *
   * To perform the `update` action, see {@link thenUpdate} or {@link thenUpdateSet}.
   *
   * ### Examples
   *
   * ```ts
   * const result = await db.mergeInto('person')
   *   .using('pet', 'person.id', 'pet.owner_id')
   *   .whenMatched()
   *   .thenDoNothing()
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * merge into "person"
   * using "pet" on "person"."id" = "pet"."owner_id"
   * when matched then
   *   do nothing
   * ```
   */
  thenDoNothing() {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: MergeQueryNode.cloneWithThen(this.#props.queryNode, parseMergeThen("do nothing"))
    });
  }
  /**
   * Perform an `update` operation with a full-fledged {@link UpdateQueryBuilder}.
   * This is handy when multiple `set` invocations are needed.
   *
   * For a shorthand version of this method, see {@link thenUpdateSet}.
   *
   * To perform the `delete` action, see {@link thenDelete}.
   *
   * To perform the `do nothing` action, see {@link thenDoNothing}.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * const result = await db.mergeInto('person')
   *   .using('pet', 'person.id', 'pet.owner_id')
   *   .whenMatched()
   *   .thenUpdate((ub) => ub
   *     .set(sql`metadata['has_pets']`, 'Y')
   *     .set({
   *       updated_at: new Date().toISOString(),
   *     })
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * merge into "person"
   * using "pet" on "person"."id" = "pet"."owner_id"
   * when matched then
   *   update set metadata['has_pets'] = $1, "updated_at" = $2
   * ```
   */
  thenUpdate(set) {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: MergeQueryNode.cloneWithThen(this.#props.queryNode, parseMergeThen(set(new UpdateQueryBuilder({
        queryId: this.#props.queryId,
        executor: NOOP_QUERY_EXECUTOR,
        queryNode: UpdateQueryNode.createWithoutTable()
      }))))
    });
  }
  thenUpdateSet(...args) {
    return this.thenUpdate((ub) => ub.set(...args));
  }
}
class NotMatchedThenableMergeQueryBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * Performs the `do nothing` action.
   *
   * This is supported in PostgreSQL.
   *
   * To perform the `insert` action, see {@link thenInsertValues}.
   *
   * ### Examples
   *
   * ```ts
   * const result = await db.mergeInto('person')
   *   .using('pet', 'person.id', 'pet.owner_id')
   *   .whenNotMatched()
   *   .thenDoNothing()
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * merge into "person"
   * using "pet" on "person"."id" = "pet"."owner_id"
   * when not matched then
   *   do nothing
   * ```
   */
  thenDoNothing() {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: MergeQueryNode.cloneWithThen(this.#props.queryNode, parseMergeThen("do nothing"))
    });
  }
  thenInsertValues(insert) {
    const [columns, values] = parseInsertExpression(insert);
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: MergeQueryNode.cloneWithThen(this.#props.queryNode, parseMergeThen(InsertQueryNode.cloneWith(InsertQueryNode.createWithoutInto(), {
        columns,
        values
      })))
    });
  }
}
class QueryCreator {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * Creates a `select` query builder for the given table or tables.
   *
   * The tables passed to this method are built as the query's `from` clause.
   *
   * ### Examples
   *
   * Create a select query for one table:
   *
   * ```ts
   * db.selectFrom('person').selectAll()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select * from "person"
   * ```
   *
   * Create a select query for one table with an alias:
   *
   * ```ts
   * const persons = await db.selectFrom('person as p')
   *   .select(['p.id', 'first_name'])
   *   .execute()
   *
   * console.log(persons[0].id)
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select "p"."id", "first_name" from "person" as "p"
   * ```
   *
   * Create a select query from a subquery:
   *
   * ```ts
   * const persons = await db.selectFrom(
   *     (eb) => eb.selectFrom('person').select('person.id as identifier').as('p')
   *   )
   *   .select('p.identifier')
   *   .execute()
   *
   * console.log(persons[0].identifier)
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select "p"."identifier",
   * from (
   *   select "person"."id" as "identifier" from "person"
   * ) as p
   * ```
   *
   * Create a select query from raw sql:
   *
   * ```ts
   * import {sql } from 'kysely'
   *
   * const items = await db
   *   .selectFrom(sql<{ one: number }>`(select 1 as one)`.as('q'))
   *   .select('q.one')
   *   .execute()
   *
   * console.log(items[0].one)
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select "q"."one",
   * from (
   *   select 1 as one
   * ) as q
   * ```
   *
   * When you use the `sql` tag you need to also provide the result type of the
   * raw snippet / query so that Kysely can figure out what columns are
   * available for the rest of the query.
   *
   * The `selectFrom` method also accepts an array for multiple tables. All
   * the above examples can also be used in an array.
   *
   * ```ts
   * import {sql } from 'kysely'
   *
   * const items = await db.selectFrom([
   *     'person as p',
   *     db.selectFrom('pet').select('pet.species').as('a'),
   *     sql<{ one: number }>`(select 1 as one)`.as('q')
   *   ])
   *   .select(['p.id', 'a.species', 'q.one'])
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select "p".id, "a"."species", "q"."one"
   * from
   *   "person" as "p",
   *   (select "pet"."species" from "pet") as a,
   *   (select 1 as one) as "q"
   * ```
   */
  selectFrom(from) {
    return createSelectQueryBuilder({
      queryId: createQueryId(),
      executor: this.#props.executor,
      queryNode: SelectQueryNode.createFrom(parseTableExpressionOrList(from), this.#props.withNode)
    });
  }
  selectNoFrom(selection) {
    return createSelectQueryBuilder({
      queryId: createQueryId(),
      executor: this.#props.executor,
      queryNode: SelectQueryNode.cloneWithSelections(SelectQueryNode.create(this.#props.withNode), parseSelectArg(selection))
    });
  }
  /**
   * Creates an insert query.
   *
   * The return value of this query is an instance of {@link InsertResult}. {@link InsertResult}
   * has the {@link InsertResult.insertId | insertId} field that holds the auto incremented id of
   * the inserted row if the db returned one.
   *
   * See the {@link InsertQueryBuilder.values | values} method for more info and examples. Also see
   * the {@link ReturningInterface.returning | returning} method for a way to return columns
   * on supported databases like PostgreSQL.
   *
   * ### Examples
   *
   * ```ts
   * const result = await db
   *   .insertInto('person')
   *   .values({
   *     first_name: 'Jennifer',
   *     last_name: 'Aniston'
   *   })
   *   .executeTakeFirst()
   *
   * console.log(result.insertId)
   * ```
   *
   * Some databases like PostgreSQL support the `returning` method:
   *
   * ```ts
   * const { id } = await db
   *   .insertInto('person')
   *   .values({
   *     first_name: 'Jennifer',
   *     last_name: 'Aniston'
   *   })
   *   .returning('id')
   *   .executeTakeFirstOrThrow()
   * ```
   */
  insertInto(table) {
    return new InsertQueryBuilder({
      queryId: createQueryId(),
      executor: this.#props.executor,
      queryNode: InsertQueryNode.create(parseTable(table), this.#props.withNode)
    });
  }
  /**
   * Creates a "replace into" query.
   *
   * This is only supported by some dialects like MySQL or SQLite.
   *
   * Similar to MySQL's {@link InsertQueryBuilder.onDuplicateKeyUpdate} that deletes
   * and inserts values on collision instead of updating existing rows.
   *
   * An alias of SQLite's {@link InsertQueryBuilder.orReplace}.
   *
   * The return value of this query is an instance of {@link InsertResult}. {@link InsertResult}
   * has the {@link InsertResult.insertId | insertId} field that holds the auto incremented id of
   * the inserted row if the db returned one.
   *
   * See the {@link InsertQueryBuilder.values | values} method for more info and examples.
   *
   * ### Examples
   *
   * ```ts
   * const result = await db
   *   .replaceInto('person')
   *   .values({
   *     first_name: 'Jennifer',
   *     last_name: 'Aniston'
   *   })
   *   .executeTakeFirstOrThrow()
   *
   * console.log(result.insertId)
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * replace into `person` (`first_name`, `last_name`) values (?, ?)
   * ```
   */
  replaceInto(table) {
    return new InsertQueryBuilder({
      queryId: createQueryId(),
      executor: this.#props.executor,
      queryNode: InsertQueryNode.create(parseTable(table), this.#props.withNode, true)
    });
  }
  /**
   * Creates a delete query.
   *
   * See the {@link DeleteQueryBuilder.where} method for examples on how to specify
   * a where clause for the delete operation.
   *
   * The return value of the query is an instance of {@link DeleteResult}.
   *
   * ### Examples
   *
   * <!-- siteExample("delete", "Single row", 10) -->
   *
   * Delete a single row:
   *
   * ```ts
   * const result = await db
   *   .deleteFrom('person')
   *   .where('person.id', '=', 1)
   *   .executeTakeFirst()
   *
   * console.log(result.numDeletedRows)
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * delete from "person" where "person"."id" = $1
   * ```
   *
   * Some databases such as MySQL support deleting from multiple tables:
   *
   * ```ts
   * const result = await db
   *   .deleteFrom(['person', 'pet'])
   *   .using('person')
   *   .innerJoin('pet', 'pet.owner_id', 'person.id')
   *   .where('person.id', '=', 1)
   *   .executeTakeFirst()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * delete from `person`, `pet`
   * using `person`
   * inner join `pet` on `pet`.`owner_id` = `person`.`id`
   * where `person`.`id` = ?
   * ```
   */
  deleteFrom(from) {
    return new DeleteQueryBuilder({
      queryId: createQueryId(),
      executor: this.#props.executor,
      queryNode: DeleteQueryNode.create(parseTableExpressionOrList(from), this.#props.withNode)
    });
  }
  /**
   * Creates an update query.
   *
   * See the {@link UpdateQueryBuilder.where} method for examples on how to specify
   * a where clause for the update operation.
   *
   * See the {@link UpdateQueryBuilder.set} method for examples on how to
   * specify the updates.
   *
   * The return value of the query is an {@link UpdateResult}.
   *
   * ### Examples
   *
   * ```ts
   * const result = await db
   *   .updateTable('person')
   *   .set({ first_name: 'Jennifer' })
   *   .where('person.id', '=', 1)
   *   .executeTakeFirst()
   *
   * console.log(result.numUpdatedRows)
   * ```
   */
  updateTable(tables) {
    return new UpdateQueryBuilder({
      queryId: createQueryId(),
      executor: this.#props.executor,
      queryNode: UpdateQueryNode.create(parseTableExpressionOrList(tables), this.#props.withNode)
    });
  }
  /**
   * Creates a merge query.
   *
   * The return value of the query is a {@link MergeResult}.
   *
   * See the {@link MergeQueryBuilder.using} method for examples on how to specify
   * the other table.
   *
   * ### Examples
   *
   * <!-- siteExample("merge", "Source row existence", 10) -->
   *
   * Update a target column based on the existence of a source row:
   *
   * ```ts
   * const result = await db
   *   .mergeInto('person as target')
   *   .using('pet as source', 'source.owner_id', 'target.id')
   *   .whenMatchedAnd('target.has_pets', '!=', 'Y')
   *   .thenUpdateSet({ has_pets: 'Y' })
   *   .whenNotMatchedBySourceAnd('target.has_pets', '=', 'Y')
   *   .thenUpdateSet({ has_pets: 'N' })
   *   .executeTakeFirstOrThrow()
   *
   * console.log(result.numChangedRows)
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * merge into "person"
   * using "pet"
   * on "pet"."owner_id" = "person"."id"
   * when matched and "has_pets" != $1
   * then update set "has_pets" = $2
   * when not matched by source and "has_pets" = $3
   * then update set "has_pets" = $4
   * ```
   *
   * <!-- siteExample("merge", "Temporary changes table", 20) -->
   *
   * Merge new entries from a temporary changes table:
   *
   * ```ts
   * const result = await db
   *   .mergeInto('wine as target')
   *   .using(
   *     'wine_stock_change as source',
   *     'source.wine_name',
   *     'target.name',
   *   )
   *   .whenNotMatchedAnd('source.stock_delta', '>', 0)
   *   .thenInsertValues(({ ref }) => ({
   *     name: ref('source.wine_name'),
   *     stock: ref('source.stock_delta'),
   *   }))
   *   .whenMatchedAnd(
   *     (eb) => eb('target.stock', '+', eb.ref('source.stock_delta')),
   *     '>',
   *     0,
   *   )
   *   .thenUpdateSet('stock', (eb) =>
   *     eb('target.stock', '+', eb.ref('source.stock_delta')),
   *   )
   *   .whenMatched()
   *   .thenDelete()
   *   .executeTakeFirstOrThrow()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * merge into "wine" as "target"
   * using "wine_stock_change" as "source"
   * on "source"."wine_name" = "target"."name"
   * when not matched and "source"."stock_delta" > $1
   * then insert ("name", "stock") values ("source"."wine_name", "source"."stock_delta")
   * when matched and "target"."stock" + "source"."stock_delta" > $2
   * then update set "stock" = "target"."stock" + "source"."stock_delta"
   * when matched
   * then delete
   * ```
   */
  mergeInto(targetTable) {
    return new MergeQueryBuilder({
      queryId: createQueryId(),
      executor: this.#props.executor,
      queryNode: MergeQueryNode.create(parseAliasedTable(targetTable), this.#props.withNode)
    });
  }
  /**
   * Creates a `with` query (Common Table Expression).
   *
   * ### Examples
   *
   * <!-- siteExample("cte", "Simple selects", 10) -->
   *
   * Common table expressions (CTE) are a great way to modularize complex queries.
   * Essentially they allow you to run multiple separate queries within a
   * single roundtrip to the DB.
   *
   * Since CTEs are a part of the main query, query optimizers inside DB
   * engines are able to optimize the overall query. For example, postgres
   * is able to inline the CTEs inside the using queries if it decides it's
   * faster.
   *
   * ```ts
   * const result = await db
   *   // Create a CTE called `jennifers` that selects all
   *   // persons named 'Jennifer'.
   *   .with('jennifers', (db) => db
   *     .selectFrom('person')
   *     .where('first_name', '=', 'Jennifer')
   *     .select(['id', 'age'])
   *   )
   *   // Select all rows from the `jennifers` CTE and
   *   // further filter it.
   *   .with('adult_jennifers', (db) => db
   *     .selectFrom('jennifers')
   *     .where('age', '>', 18)
   *     .select(['id', 'age'])
   *   )
   *   // Finally select all adult jennifers that are
   *   // also younger than 60.
   *   .selectFrom('adult_jennifers')
   *   .where('age', '<', 60)
   *   .selectAll()
   *   .execute()
   * ```
   *
   * <!-- siteExample("cte", "Inserts, updates and deletions", 20) -->
   *
   * Some databases like postgres also allow you to run other queries than selects
   * in CTEs. On these databases CTEs are extremely powerful:
   *
   * ```ts
   * const result = await db
   *   .with('new_person', (db) => db
   *     .insertInto('person')
   *     .values({
   *       first_name: 'Jennifer',
   *       age: 35,
   *     })
   *     .returning('id')
   *   )
   *   .with('new_pet', (db) => db
   *     .insertInto('pet')
   *     .values({
   *       name: 'Doggo',
   *       species: 'dog',
   *       is_favorite: true,
   *       // Use the id of the person we just inserted.
   *       owner_id: db
   *         .selectFrom('new_person')
   *         .select('id')
   *     })
   *     .returning('id')
   *   )
   *   .selectFrom(['new_person', 'new_pet'])
   *   .select([
   *     'new_person.id as person_id',
   *     'new_pet.id as pet_id'
   *   ])
   *   .execute()
   * ```
   *
   * The CTE name can optionally specify column names in addition to
   * a name. In that case Kysely requires the expression to retun
   * rows with the same columns.
   *
   * ```ts
   * await db
   *   .with('jennifers(id, age)', (db) => db
   *     .selectFrom('person')
   *     .where('first_name', '=', 'Jennifer')
   *     // This is ok since we return columns with the same
   *     // names as specified by `jennifers(id, age)`.
   *     .select(['id', 'age'])
   *   )
   *   .selectFrom('jennifers')
   *   .selectAll()
   *   .execute()
   * ```
   *
   * The first argument can also be a callback. The callback is passed
   * a `CTEBuilder` instance that can be used to configure the CTE:
   *
   * ```ts
   * await db
   *   .with(
   *     (cte) => cte('jennifers').materialized(),
   *     (db) => db
   *       .selectFrom('person')
   *       .where('first_name', '=', 'Jennifer')
   *       .select(['id', 'age'])
   *   )
   *   .selectFrom('jennifers')
   *   .selectAll()
   *   .execute()
   * ```
   */
  with(nameOrBuilder, expression) {
    const cte = parseCommonTableExpression(nameOrBuilder, expression);
    return new QueryCreator({
      ...this.#props,
      withNode: this.#props.withNode ? WithNode.cloneWithExpression(this.#props.withNode, cte) : WithNode.create(cte)
    });
  }
  /**
   * Creates a recursive `with` query (Common Table Expression).
   *
   * Note that recursiveness is a property of the whole `with` statement.
   * You cannot have recursive and non-recursive CTEs in a same `with` statement.
   * Therefore the recursiveness is determined by the **first** `with` or
   * `withRecusive` call you make.
   *
   * See the {@link with} method for examples and more documentation.
   */
  withRecursive(nameOrBuilder, expression) {
    const cte = parseCommonTableExpression(nameOrBuilder, expression);
    return new QueryCreator({
      ...this.#props,
      withNode: this.#props.withNode ? WithNode.cloneWithExpression(this.#props.withNode, cte) : WithNode.create(cte, { recursive: true })
    });
  }
  /**
   * Returns a copy of this query creator instance with the given plugin installed.
   */
  withPlugin(plugin) {
    return new QueryCreator({
      ...this.#props,
      executor: this.#props.executor.withPlugin(plugin)
    });
  }
  /**
   * Returns a copy of this query creator instance without any plugins.
   */
  withoutPlugins() {
    return new QueryCreator({
      ...this.#props,
      executor: this.#props.executor.withoutPlugins()
    });
  }
  /**
   * Sets the schema to be used for all table references that don't explicitly
   * specify a schema.
   *
   * This only affects the query created through the builder returned from
   * this method and doesn't modify the `db` instance.
   *
   * See [this recipe](https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0007-schemas.md)
   * for a more detailed explanation.
   *
   * ### Examples
   *
   * ```
   * await db
   *   .withSchema('mammals')
   *   .selectFrom('pet')
   *   .selectAll()
   *   .innerJoin('public.person', 'public.person.id', 'pet.owner_id')
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select * from "mammals"."pet"
   * inner join "public"."person"
   * on "public"."person"."id" = "mammals"."pet"."owner_id"
   * ```
   *
   * `withSchema` is smart enough to not add schema for aliases,
   * common table expressions or other places where the schema
   * doesn't belong to:
   *
   * ```
   * await db
   *   .withSchema('mammals')
   *   .selectFrom('pet as p')
   *   .select('p.name')
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select "p"."name" from "mammals"."pet" as "p"
   * ```
   */
  withSchema(schema2) {
    return new QueryCreator({
      ...this.#props,
      executor: this.#props.executor.withPluginAtFront(new WithSchemaPlugin(schema2))
    });
  }
}
function createQueryCreator() {
  return new QueryCreator({
    executor: NOOP_QUERY_EXECUTOR
  });
}
function createJoinBuilder(joinType, table) {
  return new JoinBuilder({
    joinNode: JoinNode.create(joinType, parseTableExpression(table))
  });
}
function createOverBuilder() {
  return new OverBuilder({
    overNode: OverNode.create()
  });
}
function parseJoin(joinType, args) {
  if (args.length === 3) {
    return parseSingleOnJoin(joinType, args[0], args[1], args[2]);
  } else if (args.length === 2) {
    return parseCallbackJoin(joinType, args[0], args[1]);
  } else if (args.length === 1) {
    return parseOnlessJoin(joinType, args[0]);
  } else {
    throw new Error("not implemented");
  }
}
function parseCallbackJoin(joinType, from, callback) {
  return callback(createJoinBuilder(joinType, from)).toOperationNode();
}
function parseSingleOnJoin(joinType, from, lhsColumn, rhsColumn) {
  return JoinNode.createWithOn(joinType, parseTableExpression(from), parseReferentialBinaryOperation(lhsColumn, "=", rhsColumn));
}
function parseOnlessJoin(joinType, from) {
  return JoinNode.create(joinType, parseTableExpression(from));
}
const OffsetNode = freeze({
  is(node) {
    return node.kind === "OffsetNode";
  },
  create(offset2) {
    return freeze({
      kind: "OffsetNode",
      offset: offset2
    });
  }
});
const GroupByItemNode = freeze({
  is(node) {
    return node.kind === "GroupByItemNode";
  },
  create(groupBy) {
    return freeze({
      kind: "GroupByItemNode",
      groupBy
    });
  }
});
function parseGroupBy(groupBy) {
  groupBy = isFunction$1(groupBy) ? groupBy(expressionBuilder()) : groupBy;
  return parseReferenceExpressionOrList(groupBy).map(GroupByItemNode.create);
}
const SetOperationNode = freeze({
  is(node) {
    return node.kind === "SetOperationNode";
  },
  create(operator2, expression, all2) {
    return freeze({
      kind: "SetOperationNode",
      operator: operator2,
      expression,
      all: all2
    });
  }
});
function parseSetOperations(operator2, expression, all2) {
  if (isFunction$1(expression)) {
    expression = expression(createExpressionBuilder());
  }
  if (!isReadonlyArray(expression)) {
    expression = [expression];
  }
  return expression.map((expr) => SetOperationNode.create(operator2, parseExpression(expr), all2));
}
class ExpressionWrapper {
  #node;
  constructor(node) {
    this.#node = node;
  }
  /** @private */
  get expressionType() {
    return void 0;
  }
  as(alias2) {
    return new AliasedExpressionWrapper(this, alias2);
  }
  or(...args) {
    return new OrWrapper(OrNode.create(this.#node, parseValueBinaryOperationOrExpression(args)));
  }
  and(...args) {
    return new AndWrapper(AndNode.create(this.#node, parseValueBinaryOperationOrExpression(args)));
  }
  /**
   * Change the output type of the expression.
   *
   * This method call doesn't change the SQL in any way. This methods simply
   * returns a copy of this `ExpressionWrapper` with a new output type.
   */
  $castTo() {
    return new ExpressionWrapper(this.#node);
  }
  /**
   * Omit null from the expression's type.
   *
   * This function can be useful in cases where you know an expression can't be
   * null, but Kysely is unable to infer it.
   *
   * This method call doesn't change the SQL in any way. This methods simply
   * returns a copy of `this` with a new output type.
   */
  $notNull() {
    return new ExpressionWrapper(this.#node);
  }
  toOperationNode() {
    return this.#node;
  }
}
class AliasedExpressionWrapper {
  #expr;
  #alias;
  constructor(expr, alias2) {
    this.#expr = expr;
    this.#alias = alias2;
  }
  /** @private */
  get expression() {
    return this.#expr;
  }
  /** @private */
  get alias() {
    return this.#alias;
  }
  toOperationNode() {
    return AliasNode.create(this.#expr.toOperationNode(), isOperationNodeSource(this.#alias) ? this.#alias.toOperationNode() : IdentifierNode.create(this.#alias));
  }
}
class OrWrapper {
  #node;
  constructor(node) {
    this.#node = node;
  }
  /** @private */
  get expressionType() {
    return void 0;
  }
  as(alias2) {
    return new AliasedExpressionWrapper(this, alias2);
  }
  or(...args) {
    return new OrWrapper(OrNode.create(this.#node, parseValueBinaryOperationOrExpression(args)));
  }
  /**
   * Change the output type of the expression.
   *
   * This method call doesn't change the SQL in any way. This methods simply
   * returns a copy of this `OrWrapper` with a new output type.
   */
  $castTo() {
    return new OrWrapper(this.#node);
  }
  toOperationNode() {
    return ParensNode.create(this.#node);
  }
}
class AndWrapper {
  #node;
  constructor(node) {
    this.#node = node;
  }
  /** @private */
  get expressionType() {
    return void 0;
  }
  as(alias2) {
    return new AliasedExpressionWrapper(this, alias2);
  }
  and(...args) {
    return new AndWrapper(AndNode.create(this.#node, parseValueBinaryOperationOrExpression(args)));
  }
  /**
   * Change the output type of the expression.
   *
   * This method call doesn't change the SQL in any way. This methods simply
   * returns a copy of this `AndWrapper` with a new output type.
   */
  $castTo() {
    return new AndWrapper(this.#node);
  }
  toOperationNode() {
    return ParensNode.create(this.#node);
  }
}
const FetchNode = freeze({
  is(node) {
    return node.kind === "FetchNode";
  },
  create(rowCount, modifier) {
    return {
      kind: "FetchNode",
      rowCount: ValueNode.create(rowCount),
      modifier
    };
  }
});
function parseFetch(rowCount, modifier) {
  if (!isNumber$3(rowCount) && !isBigInt(rowCount)) {
    throw new Error(`Invalid fetch row count: ${rowCount}`);
  }
  if (!isFetchModifier(modifier)) {
    throw new Error(`Invalid fetch modifier: ${modifier}`);
  }
  return FetchNode.create(rowCount, modifier);
}
function isFetchModifier(value) {
  return value === "only" || value === "with ties";
}
class SelectQueryBuilderImpl {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  get expressionType() {
    return void 0;
  }
  get isSelectQueryBuilder() {
    return true;
  }
  where(...args) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  whereRef(lhs, op, rhs) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  having(...args) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithHaving(this.#props.queryNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  havingRef(lhs, op, rhs) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithHaving(this.#props.queryNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  select(selection) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithSelections(this.#props.queryNode, parseSelectArg(selection))
    });
  }
  distinctOn(selection) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithDistinctOn(this.#props.queryNode, parseReferenceExpressionOrList(selection))
    });
  }
  modifyFront(modifier) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithFrontModifier(this.#props.queryNode, SelectModifierNode.createWithExpression(modifier.toOperationNode()))
    });
  }
  modifyEnd(modifier) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.createWithExpression(modifier.toOperationNode()))
    });
  }
  distinct() {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithFrontModifier(this.#props.queryNode, SelectModifierNode.create("Distinct"))
    });
  }
  forUpdate(of) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create("ForUpdate", of ? asArray(of).map(parseTable) : void 0))
    });
  }
  forShare(of) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create("ForShare", of ? asArray(of).map(parseTable) : void 0))
    });
  }
  forKeyShare(of) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create("ForKeyShare", of ? asArray(of).map(parseTable) : void 0))
    });
  }
  forNoKeyUpdate(of) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create("ForNoKeyUpdate", of ? asArray(of).map(parseTable) : void 0))
    });
  }
  skipLocked() {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create("SkipLocked"))
    });
  }
  noWait() {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create("NoWait"))
    });
  }
  selectAll(table) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithSelections(this.#props.queryNode, parseSelectAll(table))
    });
  }
  innerJoin(...args) {
    return this.#join("InnerJoin", args);
  }
  leftJoin(...args) {
    return this.#join("LeftJoin", args);
  }
  rightJoin(...args) {
    return this.#join("RightJoin", args);
  }
  fullJoin(...args) {
    return this.#join("FullJoin", args);
  }
  crossJoin(...args) {
    return this.#join("CrossJoin", args);
  }
  innerJoinLateral(...args) {
    return this.#join("LateralInnerJoin", args);
  }
  leftJoinLateral(...args) {
    return this.#join("LateralLeftJoin", args);
  }
  crossJoinLateral(...args) {
    return this.#join("LateralCrossJoin", args);
  }
  crossApply(...args) {
    return this.#join("CrossApply", args);
  }
  outerApply(...args) {
    return this.#join("OuterApply", args);
  }
  #join(joinType, args) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin(joinType, args))
    });
  }
  orderBy(...args) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithOrderByItems(this.#props.queryNode, parseOrderBy(args))
    });
  }
  groupBy(groupBy) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithGroupByItems(this.#props.queryNode, parseGroupBy(groupBy))
    });
  }
  limit(limit) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithLimit(this.#props.queryNode, LimitNode.create(parseValueExpression(limit)))
    });
  }
  offset(offset2) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithOffset(this.#props.queryNode, OffsetNode.create(parseValueExpression(offset2)))
    });
  }
  fetch(rowCount, modifier = "only") {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithFetch(this.#props.queryNode, parseFetch(rowCount, modifier))
    });
  }
  top(expression, modifiers) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers))
    });
  }
  union(expression) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations("union", expression, false))
    });
  }
  unionAll(expression) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations("union", expression, true))
    });
  }
  intersect(expression) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations("intersect", expression, false))
    });
  }
  intersectAll(expression) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations("intersect", expression, true))
    });
  }
  except(expression) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations("except", expression, false))
    });
  }
  exceptAll(expression) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations("except", expression, true))
    });
  }
  as(alias2) {
    return new AliasedSelectQueryBuilderImpl(this, alias2);
  }
  clearSelect() {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithoutSelections(this.#props.queryNode)
    });
  }
  clearWhere() {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithoutWhere(this.#props.queryNode)
    });
  }
  clearLimit() {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithoutLimit(this.#props.queryNode)
    });
  }
  clearOffset() {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithoutOffset(this.#props.queryNode)
    });
  }
  clearOrderBy() {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithoutOrderBy(this.#props.queryNode)
    });
  }
  clearGroupBy() {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithoutGroupBy(this.#props.queryNode)
    });
  }
  $call(func) {
    return func(this);
  }
  $if(condition, func) {
    if (condition) {
      return func(this);
    }
    return new SelectQueryBuilderImpl({
      ...this.#props
    });
  }
  $castTo() {
    return new SelectQueryBuilderImpl(this.#props);
  }
  $narrowType() {
    return new SelectQueryBuilderImpl(this.#props);
  }
  $assertType() {
    return new SelectQueryBuilderImpl(this.#props);
  }
  $asTuple() {
    return new ExpressionWrapper(this.toOperationNode());
  }
  $asScalar() {
    return new ExpressionWrapper(this.toOperationNode());
  }
  withPlugin(plugin) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      executor: this.#props.executor.withPlugin(plugin)
    });
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.queryNode, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    const compiledQuery = this.compile();
    const result2 = await this.#props.executor.executeQuery(compiledQuery);
    return result2.rows;
  }
  async executeTakeFirst() {
    const [result2] = await this.execute();
    return result2;
  }
  async executeTakeFirstOrThrow(errorConstructor = NoResultError) {
    const result2 = await this.executeTakeFirst();
    if (result2 === void 0) {
      const error2 = isNoResultErrorConstructor(errorConstructor) ? new errorConstructor(this.toOperationNode()) : errorConstructor(this.toOperationNode());
      throw error2;
    }
    return result2;
  }
  async *stream(chunkSize = 100) {
    const compiledQuery = this.compile();
    const stream2 = this.#props.executor.stream(compiledQuery, chunkSize);
    for await (const item of stream2) {
      yield* item.rows;
    }
  }
  async explain(format2, options) {
    const builder = new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithExplain(this.#props.queryNode, format2, options)
    });
    return await builder.execute();
  }
}
function createSelectQueryBuilder(props) {
  return new SelectQueryBuilderImpl(props);
}
class AliasedSelectQueryBuilderImpl {
  #queryBuilder;
  #alias;
  constructor(queryBuilder, alias2) {
    this.#queryBuilder = queryBuilder;
    this.#alias = alias2;
  }
  get expression() {
    return this.#queryBuilder;
  }
  get alias() {
    return this.#alias;
  }
  get isAliasedSelectQueryBuilder() {
    return true;
  }
  toOperationNode() {
    return AliasNode.create(this.#queryBuilder.toOperationNode(), IdentifierNode.create(this.#alias));
  }
}
const AggregateFunctionNode = freeze({
  is(node) {
    return node.kind === "AggregateFunctionNode";
  },
  create(aggregateFunction, aggregated = []) {
    return freeze({
      kind: "AggregateFunctionNode",
      func: aggregateFunction,
      aggregated
    });
  },
  cloneWithDistinct(aggregateFunctionNode) {
    return freeze({
      ...aggregateFunctionNode,
      distinct: true
    });
  },
  cloneWithOrderBy(aggregateFunctionNode, orderItems, withinGroup = false) {
    const prop = withinGroup ? "withinGroup" : "orderBy";
    return freeze({
      ...aggregateFunctionNode,
      [prop]: aggregateFunctionNode[prop] ? OrderByNode.cloneWithItems(aggregateFunctionNode[prop], orderItems) : OrderByNode.create(orderItems)
    });
  },
  cloneWithFilter(aggregateFunctionNode, filter) {
    return freeze({
      ...aggregateFunctionNode,
      filter: aggregateFunctionNode.filter ? WhereNode.cloneWithOperation(aggregateFunctionNode.filter, "And", filter) : WhereNode.create(filter)
    });
  },
  cloneWithOrFilter(aggregateFunctionNode, filter) {
    return freeze({
      ...aggregateFunctionNode,
      filter: aggregateFunctionNode.filter ? WhereNode.cloneWithOperation(aggregateFunctionNode.filter, "Or", filter) : WhereNode.create(filter)
    });
  },
  cloneWithOver(aggregateFunctionNode, over) {
    return freeze({
      ...aggregateFunctionNode,
      over
    });
  }
});
const FunctionNode = freeze({
  is(node) {
    return node.kind === "FunctionNode";
  },
  create(func, args) {
    return freeze({
      kind: "FunctionNode",
      func,
      arguments: args
    });
  }
});
class AggregateFunctionBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /** @private */
  get expressionType() {
    return void 0;
  }
  /**
   * Returns an aliased version of the function.
   *
   * In addition to slapping `as "the_alias"` to the end of the SQL,
   * this method also provides strict typing:
   *
   * ```ts
   * const result = await db
   *   .selectFrom('person')
   *   .select(
   *     (eb) => eb.fn.count<number>('id').as('person_count')
   *   )
   *   .executeTakeFirstOrThrow()
   *
   * // `person_count: number` field exists in the result type.
   * console.log(result.person_count)
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select count("id") as "person_count"
   * from "person"
   * ```
   */
  as(alias2) {
    return new AliasedAggregateFunctionBuilder(this, alias2);
  }
  /**
   * Adds a `distinct` clause inside the function.
   *
   * ### Examples
   *
   * ```ts
   * const result = await db
   *   .selectFrom('person')
   *   .select((eb) =>
   *     eb.fn.count<number>('first_name').distinct().as('first_name_count')
   *   )
   *   .executeTakeFirstOrThrow()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select count(distinct "first_name") as "first_name_count"
   * from "person"
   * ```
   */
  distinct() {
    return new AggregateFunctionBuilder({
      ...this.#props,
      aggregateFunctionNode: AggregateFunctionNode.cloneWithDistinct(this.#props.aggregateFunctionNode)
    });
  }
  orderBy(...args) {
    return new AggregateFunctionBuilder({
      ...this.#props,
      aggregateFunctionNode: QueryNode.cloneWithOrderByItems(this.#props.aggregateFunctionNode, parseOrderBy(args))
    });
  }
  clearOrderBy() {
    return new AggregateFunctionBuilder({
      ...this.#props,
      aggregateFunctionNode: QueryNode.cloneWithoutOrderBy(this.#props.aggregateFunctionNode)
    });
  }
  withinGroupOrderBy(...args) {
    return new AggregateFunctionBuilder({
      ...this.#props,
      aggregateFunctionNode: AggregateFunctionNode.cloneWithOrderBy(this.#props.aggregateFunctionNode, parseOrderBy(args), true)
    });
  }
  filterWhere(...args) {
    return new AggregateFunctionBuilder({
      ...this.#props,
      aggregateFunctionNode: AggregateFunctionNode.cloneWithFilter(this.#props.aggregateFunctionNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  /**
   * Adds a `filter` clause with a nested `where` clause after the function, where
   * both sides of the operator are references to columns.
   *
   * Similar to {@link WhereInterface}'s `whereRef` method.
   *
   * ### Examples
   *
   * Count people with same first and last names versus general public:
   *
   * ```ts
   * const result = await db
   *   .selectFrom('person')
   *   .select((eb) => [
   *     eb.fn
   *       .count<number>('id')
   *       .filterWhereRef('first_name', '=', 'last_name')
   *       .as('repeat_name_count'),
   *     eb.fn.count<number>('id').as('total_count'),
   *   ])
   *   .executeTakeFirstOrThrow()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select
   *   count("id") filter(where "first_name" = "last_name") as "repeat_name_count",
   *   count("id") as "total_count"
   * from "person"
   * ```
   */
  filterWhereRef(lhs, op, rhs) {
    return new AggregateFunctionBuilder({
      ...this.#props,
      aggregateFunctionNode: AggregateFunctionNode.cloneWithFilter(this.#props.aggregateFunctionNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  /**
   * Adds an `over` clause (window functions) after the function.
   *
   * ### Examples
   *
   * ```ts
   * const result = await db
   *   .selectFrom('person')
   *   .select(
   *     (eb) => eb.fn.avg<number>('age').over().as('average_age')
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select avg("age") over() as "average_age"
   * from "person"
   * ```
   *
   * Also supports passing a callback that returns an over builder,
   * allowing to add partition by and sort by clauses inside over.
   *
   * ```ts
   * const result = await db
   *   .selectFrom('person')
   *   .select(
   *     (eb) => eb.fn.avg<number>('age').over(
   *       ob => ob.partitionBy('last_name').orderBy('first_name', 'asc')
   *     ).as('average_age')
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select avg("age") over(partition by "last_name" order by "first_name" asc) as "average_age"
   * from "person"
   * ```
   */
  over(over) {
    const builder = createOverBuilder();
    return new AggregateFunctionBuilder({
      ...this.#props,
      aggregateFunctionNode: AggregateFunctionNode.cloneWithOver(this.#props.aggregateFunctionNode, (over ? over(builder) : builder).toOperationNode())
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  /**
   * Casts the expression to the given type.
   *
   * This method call doesn't change the SQL in any way. This methods simply
   * returns a copy of this `AggregateFunctionBuilder` with a new output type.
   */
  $castTo() {
    return new AggregateFunctionBuilder(this.#props);
  }
  /**
   * Omit null from the expression's type.
   *
   * This function can be useful in cases where you know an expression can't be
   * null, but Kysely is unable to infer it.
   *
   * This method call doesn't change the SQL in any way. This methods simply
   * returns a copy of `this` with a new output type.
   */
  $notNull() {
    return new AggregateFunctionBuilder(this.#props);
  }
  toOperationNode() {
    return this.#props.aggregateFunctionNode;
  }
}
class AliasedAggregateFunctionBuilder {
  #aggregateFunctionBuilder;
  #alias;
  constructor(aggregateFunctionBuilder, alias2) {
    this.#aggregateFunctionBuilder = aggregateFunctionBuilder;
    this.#alias = alias2;
  }
  /** @private */
  get expression() {
    return this.#aggregateFunctionBuilder;
  }
  /** @private */
  get alias() {
    return this.#alias;
  }
  toOperationNode() {
    return AliasNode.create(this.#aggregateFunctionBuilder.toOperationNode(), IdentifierNode.create(this.#alias));
  }
}
function createFunctionModule() {
  const fn2 = (name2, args) => {
    return new ExpressionWrapper(FunctionNode.create(name2, parseReferenceExpressionOrList(args ?? [])));
  };
  const agg = (name2, args) => {
    return new AggregateFunctionBuilder({
      aggregateFunctionNode: AggregateFunctionNode.create(name2, args ? parseReferenceExpressionOrList(args) : void 0)
    });
  };
  return Object.assign(fn2, {
    agg,
    avg(column) {
      return agg("avg", [column]);
    },
    coalesce(...values) {
      return fn2("coalesce", values);
    },
    count(column) {
      return agg("count", [column]);
    },
    countAll(table) {
      return new AggregateFunctionBuilder({
        aggregateFunctionNode: AggregateFunctionNode.create("count", parseSelectAll(table))
      });
    },
    max(column) {
      return agg("max", [column]);
    },
    min(column) {
      return agg("min", [column]);
    },
    sum(column) {
      return agg("sum", [column]);
    },
    any(column) {
      return fn2("any", [column]);
    },
    jsonAgg(table) {
      return new AggregateFunctionBuilder({
        aggregateFunctionNode: AggregateFunctionNode.create("json_agg", [
          isString$1(table) ? parseTable(table) : table.toOperationNode()
        ])
      });
    },
    toJson(table) {
      return new ExpressionWrapper(FunctionNode.create("to_json", [
        isString$1(table) ? parseTable(table) : table.toOperationNode()
      ]));
    }
  });
}
const UnaryOperationNode = freeze({
  is(node) {
    return node.kind === "UnaryOperationNode";
  },
  create(operator2, operand) {
    return freeze({
      kind: "UnaryOperationNode",
      operator: operator2,
      operand
    });
  }
});
function parseUnaryOperation(operator2, operand) {
  return UnaryOperationNode.create(OperatorNode.create(operator2), parseReferenceExpression(operand));
}
const CaseNode = freeze({
  is(node) {
    return node.kind === "CaseNode";
  },
  create(value) {
    return freeze({
      kind: "CaseNode",
      value
    });
  },
  cloneWithWhen(caseNode, when) {
    return freeze({
      ...caseNode,
      when: freeze(caseNode.when ? [...caseNode.when, when] : [when])
    });
  },
  cloneWithThen(caseNode, then) {
    return freeze({
      ...caseNode,
      when: caseNode.when ? freeze([
        ...caseNode.when.slice(0, -1),
        WhenNode.cloneWithResult(caseNode.when[caseNode.when.length - 1], then)
      ]) : void 0
    });
  },
  cloneWith(caseNode, props) {
    return freeze({
      ...caseNode,
      ...props
    });
  }
});
class CaseBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  when(...args) {
    return new CaseThenBuilder({
      ...this.#props,
      node: CaseNode.cloneWithWhen(this.#props.node, WhenNode.create(parseValueBinaryOperationOrExpression(args)))
    });
  }
}
class CaseThenBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  then(valueExpression) {
    return new CaseWhenBuilder({
      ...this.#props,
      node: CaseNode.cloneWithThen(this.#props.node, isSafeImmediateValue(valueExpression) ? parseSafeImmediateValue(valueExpression) : parseValueExpression(valueExpression))
    });
  }
}
class CaseWhenBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  when(...args) {
    return new CaseThenBuilder({
      ...this.#props,
      node: CaseNode.cloneWithWhen(this.#props.node, WhenNode.create(parseValueBinaryOperationOrExpression(args)))
    });
  }
  else(valueExpression) {
    return new CaseEndBuilder({
      ...this.#props,
      node: CaseNode.cloneWith(this.#props.node, {
        else: isSafeImmediateValue(valueExpression) ? parseSafeImmediateValue(valueExpression) : parseValueExpression(valueExpression)
      })
    });
  }
  end() {
    return new ExpressionWrapper(CaseNode.cloneWith(this.#props.node, { isStatement: false }));
  }
  endCase() {
    return new ExpressionWrapper(CaseNode.cloneWith(this.#props.node, { isStatement: true }));
  }
}
class CaseEndBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  end() {
    return new ExpressionWrapper(CaseNode.cloneWith(this.#props.node, { isStatement: false }));
  }
  endCase() {
    return new ExpressionWrapper(CaseNode.cloneWith(this.#props.node, { isStatement: true }));
  }
}
const JSONPathLegNode = freeze({
  is(node) {
    return node.kind === "JSONPathLegNode";
  },
  create(type2, value) {
    return freeze({
      kind: "JSONPathLegNode",
      type: type2,
      value
    });
  }
});
class JSONPathBuilder {
  #node;
  constructor(node) {
    this.#node = node;
  }
  /**
   * Access an element of a JSON array in a specific location.
   *
   * Since there's no guarantee an element exists in the given array location, the
   * resulting type is always nullable. If you're sure the element exists, you
   * should use {@link SelectQueryBuilder.$assertType} to narrow the type safely.
   *
   * See also {@link key} to access properties of JSON objects.
   *
   * ### Examples
   *
   * ```ts
   * await db.selectFrom('person')
   *   .select(eb =>
   *     eb.ref('nicknames', '->').at(0).as('primary_nickname')
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select "nicknames"->0 as "primary_nickname" from "person"
   *```
   *
   * Combined with {@link key}:
   *
   * ```ts
   * db.selectFrom('person').select(eb =>
   *   eb.ref('experience', '->').at(0).key('role').as('first_role')
   * )
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select "experience"->0->'role' as "first_role" from "person"
   * ```
   *
   * You can use `'last'` to access the last element of the array in MySQL:
   *
   * ```ts
   * db.selectFrom('person').select(eb =>
   *   eb.ref('nicknames', '->$').at('last').as('last_nickname')
   * )
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * select `nicknames`->'$[last]' as `last_nickname` from `person`
   * ```
   *
   * Or `'#-1'` in SQLite:
   *
   * ```ts
   * db.selectFrom('person').select(eb =>
   *   eb.ref('nicknames', '->>$').at('#-1').as('last_nickname')
   * )
   * ```
   *
   * The generated SQL (SQLite):
   *
   * ```sql
   * select "nicknames"->>'$[#-1]' as `last_nickname` from `person`
   * ```
   */
  at(index2) {
    return this.#createBuilderWithPathLeg("ArrayLocation", index2);
  }
  /**
   * Access a property of a JSON object.
   *
   * If a field is optional, the resulting type will be nullable.
   *
   * See also {@link at} to access elements of JSON arrays.
   *
   * ### Examples
   *
   * ```ts
   * db.selectFrom('person').select(eb =>
   *   eb.ref('address', '->').key('city').as('city')
   * )
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select "address"->'city' as "city" from "person"
   * ```
   *
   * Going deeper:
   *
   * ```ts
   * db.selectFrom('person').select(eb =>
   *   eb.ref('profile', '->$').key('website').key('url').as('website_url')
   * )
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * select `profile`->'$.website.url' as `website_url` from `person`
   * ```
   *
   * Combined with {@link at}:
   *
   * ```ts
   * db.selectFrom('person').select(eb =>
   *   eb.ref('profile', '->').key('addresses').at(0).key('city').as('city')
   * )
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select "profile"->'addresses'->0->'city' as "city" from "person"
   * ```
   */
  key(key) {
    return this.#createBuilderWithPathLeg("Member", key);
  }
  #createBuilderWithPathLeg(legType, value) {
    if (JSONReferenceNode.is(this.#node)) {
      return new TraversedJSONPathBuilder(JSONReferenceNode.cloneWithTraversal(this.#node, JSONPathNode.is(this.#node.traversal) ? JSONPathNode.cloneWithLeg(this.#node.traversal, JSONPathLegNode.create(legType, value)) : JSONOperatorChainNode.cloneWithValue(this.#node.traversal, ValueNode.createImmediate(value))));
    }
    return new TraversedJSONPathBuilder(JSONPathNode.cloneWithLeg(this.#node, JSONPathLegNode.create(legType, value)));
  }
}
class TraversedJSONPathBuilder extends JSONPathBuilder {
  #node;
  constructor(node) {
    super(node);
    this.#node = node;
  }
  /** @private */
  get expressionType() {
    return void 0;
  }
  as(alias2) {
    return new AliasedJSONPathBuilder(this, alias2);
  }
  /**
   * Change the output type of the json path.
   *
   * This method call doesn't change the SQL in any way. This methods simply
   * returns a copy of this `JSONPathBuilder` with a new output type.
   */
  $castTo() {
    return new TraversedJSONPathBuilder(this.#node);
  }
  $notNull() {
    return new TraversedJSONPathBuilder(this.#node);
  }
  toOperationNode() {
    return this.#node;
  }
}
class AliasedJSONPathBuilder {
  #jsonPath;
  #alias;
  constructor(jsonPath, alias2) {
    this.#jsonPath = jsonPath;
    this.#alias = alias2;
  }
  /** @private */
  get expression() {
    return this.#jsonPath;
  }
  /** @private */
  get alias() {
    return this.#alias;
  }
  toOperationNode() {
    return AliasNode.create(this.#jsonPath.toOperationNode(), isOperationNodeSource(this.#alias) ? this.#alias.toOperationNode() : IdentifierNode.create(this.#alias));
  }
}
const TupleNode = freeze({
  is(node) {
    return node.kind === "TupleNode";
  },
  create(values) {
    return freeze({
      kind: "TupleNode",
      values: freeze(values)
    });
  }
});
const SIMPLE_COLUMN_DATA_TYPES = [
  "varchar",
  "char",
  "text",
  "integer",
  "int2",
  "int4",
  "int8",
  "smallint",
  "bigint",
  "boolean",
  "real",
  "double precision",
  "float4",
  "float8",
  "decimal",
  "numeric",
  "binary",
  "bytea",
  "date",
  "datetime",
  "time",
  "timetz",
  "timestamp",
  "timestamptz",
  "serial",
  "bigserial",
  "uuid",
  "json",
  "jsonb",
  "blob",
  "varbinary",
  "int4range",
  "int4multirange",
  "int8range",
  "int8multirange",
  "numrange",
  "nummultirange",
  "tsrange",
  "tsmultirange",
  "tstzrange",
  "tstzmultirange",
  "daterange",
  "datemultirange"
];
const COLUMN_DATA_TYPE_REGEX = [
  /^varchar\(\d+\)$/,
  /^char\(\d+\)$/,
  /^decimal\(\d+, \d+\)$/,
  /^numeric\(\d+, \d+\)$/,
  /^binary\(\d+\)$/,
  /^datetime\(\d+\)$/,
  /^time\(\d+\)$/,
  /^timetz\(\d+\)$/,
  /^timestamp\(\d+\)$/,
  /^timestamptz\(\d+\)$/,
  /^varbinary\(\d+\)$/
];
const DataTypeNode = freeze({
  is(node) {
    return node.kind === "DataTypeNode";
  },
  create(dataType) {
    return freeze({
      kind: "DataTypeNode",
      dataType
    });
  }
});
function isColumnDataType(dataType) {
  if (SIMPLE_COLUMN_DATA_TYPES.includes(dataType)) {
    return true;
  }
  if (COLUMN_DATA_TYPE_REGEX.some((r2) => r2.test(dataType))) {
    return true;
  }
  return false;
}
function parseDataTypeExpression(dataType) {
  if (isOperationNodeSource(dataType)) {
    return dataType.toOperationNode();
  }
  if (isColumnDataType(dataType)) {
    return DataTypeNode.create(dataType);
  }
  throw new Error(`invalid column data type ${JSON.stringify(dataType)}`);
}
const CastNode = freeze({
  is(node) {
    return node.kind === "CastNode";
  },
  create(expression, dataType) {
    return freeze({
      kind: "CastNode",
      expression,
      dataType
    });
  }
});
function createExpressionBuilder(executor = NOOP_QUERY_EXECUTOR) {
  function binary2(lhs, op, rhs) {
    return new ExpressionWrapper(parseValueBinaryOperation(lhs, op, rhs));
  }
  function unary(op, expr) {
    return new ExpressionWrapper(parseUnaryOperation(op, expr));
  }
  const eb = Object.assign(binary2, {
    fn: void 0,
    eb: void 0,
    selectFrom(table) {
      return createSelectQueryBuilder({
        queryId: createQueryId(),
        executor,
        queryNode: SelectQueryNode.createFrom(parseTableExpressionOrList(table))
      });
    },
    case(reference) {
      return new CaseBuilder({
        node: CaseNode.create(isUndefined$1(reference) ? void 0 : parseReferenceExpression(reference))
      });
    },
    ref(reference, op) {
      if (isUndefined$1(op)) {
        return new ExpressionWrapper(parseStringReference(reference));
      }
      return new JSONPathBuilder(parseJSONReference(reference, op));
    },
    jsonPath() {
      return new JSONPathBuilder(JSONPathNode.create());
    },
    table(table) {
      return new ExpressionWrapper(parseTable(table));
    },
    val(value) {
      return new ExpressionWrapper(parseValueExpression(value));
    },
    refTuple(...values) {
      return new ExpressionWrapper(TupleNode.create(values.map(parseReferenceExpression)));
    },
    tuple(...values) {
      return new ExpressionWrapper(TupleNode.create(values.map(parseValueExpression)));
    },
    lit(value) {
      return new ExpressionWrapper(parseSafeImmediateValue(value));
    },
    unary,
    not(expr) {
      return unary("not", expr);
    },
    exists(expr) {
      return unary("exists", expr);
    },
    neg(expr) {
      return unary("-", expr);
    },
    between(expr, start, end) {
      return new ExpressionWrapper(BinaryOperationNode.create(parseReferenceExpression(expr), OperatorNode.create("between"), AndNode.create(parseValueExpression(start), parseValueExpression(end))));
    },
    betweenSymmetric(expr, start, end) {
      return new ExpressionWrapper(BinaryOperationNode.create(parseReferenceExpression(expr), OperatorNode.create("between symmetric"), AndNode.create(parseValueExpression(start), parseValueExpression(end))));
    },
    and(exprs) {
      if (isReadonlyArray(exprs)) {
        return new ExpressionWrapper(parseFilterList(exprs, "and"));
      }
      return new ExpressionWrapper(parseFilterObject(exprs, "and"));
    },
    or(exprs) {
      if (isReadonlyArray(exprs)) {
        return new ExpressionWrapper(parseFilterList(exprs, "or"));
      }
      return new ExpressionWrapper(parseFilterObject(exprs, "or"));
    },
    parens(...args) {
      const node = parseValueBinaryOperationOrExpression(args);
      if (ParensNode.is(node)) {
        return new ExpressionWrapper(node);
      } else {
        return new ExpressionWrapper(ParensNode.create(node));
      }
    },
    cast(expr, dataType) {
      return new ExpressionWrapper(CastNode.create(parseReferenceExpression(expr), parseDataTypeExpression(dataType)));
    },
    withSchema(schema2) {
      return createExpressionBuilder(executor.withPluginAtFront(new WithSchemaPlugin(schema2)));
    }
  });
  eb.fn = createFunctionModule();
  eb.eb = eb;
  return eb;
}
function expressionBuilder(_) {
  return createExpressionBuilder();
}
function parseExpression(exp) {
  if (isOperationNodeSource(exp)) {
    return exp.toOperationNode();
  } else if (isFunction$1(exp)) {
    return exp(expressionBuilder()).toOperationNode();
  }
  throw new Error(`invalid expression: ${JSON.stringify(exp)}`);
}
function parseAliasedExpression(exp) {
  if (isOperationNodeSource(exp)) {
    return exp.toOperationNode();
  } else if (isFunction$1(exp)) {
    return exp(expressionBuilder()).toOperationNode();
  }
  throw new Error(`invalid aliased expression: ${JSON.stringify(exp)}`);
}
function isExpressionOrFactory(obj) {
  return isExpression(obj) || isAliasedExpression(obj) || isFunction$1(obj);
}
class DynamicTableBuilder {
  #table;
  get table() {
    return this.#table;
  }
  constructor(table) {
    this.#table = table;
  }
  as(alias2) {
    return new AliasedDynamicTableBuilder(this.#table, alias2);
  }
}
class AliasedDynamicTableBuilder {
  #table;
  #alias;
  get table() {
    return this.#table;
  }
  get alias() {
    return this.#alias;
  }
  constructor(table, alias2) {
    this.#table = table;
    this.#alias = alias2;
  }
  toOperationNode() {
    return AliasNode.create(parseTable(this.#table), IdentifierNode.create(this.#alias));
  }
}
function isAliasedDynamicTableBuilder(obj) {
  return isObject(obj) && isOperationNodeSource(obj) && isString$1(obj.table) && isString$1(obj.alias);
}
function parseTableExpressionOrList(table) {
  if (isReadonlyArray(table)) {
    return table.map((it) => parseTableExpression(it));
  } else {
    return [parseTableExpression(table)];
  }
}
function parseTableExpression(table) {
  if (isString$1(table)) {
    return parseAliasedTable(table);
  } else if (isAliasedDynamicTableBuilder(table)) {
    return table.toOperationNode();
  } else {
    return parseAliasedExpression(table);
  }
}
function parseAliasedTable(from) {
  const ALIAS_SEPARATOR = " as ";
  if (from.includes(ALIAS_SEPARATOR)) {
    const [table, alias2] = from.split(ALIAS_SEPARATOR).map(trim$1);
    return AliasNode.create(parseTable(table), IdentifierNode.create(alias2));
  } else {
    return parseTable(from);
  }
}
function parseTable(from) {
  const SCHEMA_SEPARATOR = ".";
  if (from.includes(SCHEMA_SEPARATOR)) {
    const [schema2, table] = from.split(SCHEMA_SEPARATOR).map(trim$1);
    return TableNode.createWithSchema(schema2, table);
  } else {
    return TableNode.create(from);
  }
}
function trim$1(str) {
  return str.trim();
}
const AddColumnNode = freeze({
  is(node) {
    return node.kind === "AddColumnNode";
  },
  create(column) {
    return freeze({
      kind: "AddColumnNode",
      column
    });
  }
});
const ColumnDefinitionNode = freeze({
  is(node) {
    return node.kind === "ColumnDefinitionNode";
  },
  create(column, dataType) {
    return freeze({
      kind: "ColumnDefinitionNode",
      column: ColumnNode.create(column),
      dataType
    });
  },
  cloneWithFrontModifier(node, modifier) {
    return freeze({
      ...node,
      frontModifiers: node.frontModifiers ? freeze([...node.frontModifiers, modifier]) : [modifier]
    });
  },
  cloneWithEndModifier(node, modifier) {
    return freeze({
      ...node,
      endModifiers: node.endModifiers ? freeze([...node.endModifiers, modifier]) : [modifier]
    });
  },
  cloneWith(node, props) {
    return freeze({
      ...node,
      ...props
    });
  }
});
const DropColumnNode = freeze({
  is(node) {
    return node.kind === "DropColumnNode";
  },
  create(column) {
    return freeze({
      kind: "DropColumnNode",
      column: ColumnNode.create(column)
    });
  }
});
const RenameColumnNode = freeze({
  is(node) {
    return node.kind === "RenameColumnNode";
  },
  create(column, newColumn) {
    return freeze({
      kind: "RenameColumnNode",
      column: ColumnNode.create(column),
      renameTo: ColumnNode.create(newColumn)
    });
  }
});
const CheckConstraintNode = freeze({
  is(node) {
    return node.kind === "CheckConstraintNode";
  },
  create(expression, constraintName) {
    return freeze({
      kind: "CheckConstraintNode",
      expression,
      name: constraintName ? IdentifierNode.create(constraintName) : void 0
    });
  }
});
const ON_MODIFY_FOREIGN_ACTIONS = [
  "no action",
  "restrict",
  "cascade",
  "set null",
  "set default"
];
const ReferencesNode = freeze({
  is(node) {
    return node.kind === "ReferencesNode";
  },
  create(table, columns) {
    return freeze({
      kind: "ReferencesNode",
      table,
      columns: freeze([...columns])
    });
  },
  cloneWithOnDelete(references, onDelete) {
    return freeze({
      ...references,
      onDelete
    });
  },
  cloneWithOnUpdate(references, onUpdate) {
    return freeze({
      ...references,
      onUpdate
    });
  }
});
function parseDefaultValueExpression(value) {
  return isOperationNodeSource(value) ? value.toOperationNode() : ValueNode.createImmediate(value);
}
const GeneratedNode = freeze({
  is(node) {
    return node.kind === "GeneratedNode";
  },
  create(params) {
    return freeze({
      kind: "GeneratedNode",
      ...params
    });
  },
  createWithExpression(expression) {
    return freeze({
      kind: "GeneratedNode",
      always: true,
      expression
    });
  },
  cloneWith(node, params) {
    return freeze({
      ...node,
      ...params
    });
  }
});
const DefaultValueNode = freeze({
  is(node) {
    return node.kind === "DefaultValueNode";
  },
  create(defaultValue) {
    return freeze({
      kind: "DefaultValueNode",
      defaultValue
    });
  }
});
function parseOnModifyForeignAction(action) {
  if (ON_MODIFY_FOREIGN_ACTIONS.includes(action)) {
    return action;
  }
  throw new Error(`invalid OnModifyForeignAction ${action}`);
}
class ColumnDefinitionBuilder {
  #node;
  constructor(node) {
    this.#node = node;
  }
  /**
   * Adds `auto_increment` or `autoincrement` to the column definition
   * depending on the dialect.
   *
   * Some dialects like PostgreSQL don't support this. On PostgreSQL
   * you can use the `serial` or `bigserial` data type instead.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('id', 'integer', col => col.autoIncrement().primaryKey())
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * create table `person` (
   *   `id` integer primary key auto_increment
   * )
   * ```
   */
  autoIncrement() {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { autoIncrement: true }));
  }
  /**
   * Makes the column an identity column.
   *
   * This only works on some dialects like MS SQL Server (MSSQL).
   *
   * For PostgreSQL's `generated always as identity` use {@link generatedAlwaysAsIdentity}.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('id', 'integer', col => col.identity().primaryKey())
   *   .execute()
   * ```
   *
   * The generated SQL (MSSQL):
   *
   * ```sql
   * create table "person" (
   *   "id" integer identity primary key
   * )
   * ```
   */
  identity() {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { identity: true }));
  }
  /**
   * Makes the column the primary key.
   *
   * If you want to specify a composite primary key use the
   * {@link CreateTableBuilder.addPrimaryKeyConstraint} method.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('id', 'integer', col => col.primaryKey())
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * create table `person` (
   *   `id` integer primary key
   * )
   */
  primaryKey() {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { primaryKey: true }));
  }
  /**
   * Adds a foreign key constraint for the column.
   *
   * If your database engine doesn't support foreign key constraints in the
   * column definition (like MySQL 5) you need to call the table level
   * {@link CreateTableBuilder.addForeignKeyConstraint} method instead.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('pet')
   *   .addColumn('owner_id', 'integer', (col) => col.references('person.id'))
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * create table "pet" (
   *   "owner_id" integer references "person" ("id")
   * )
   * ```
   */
  references(ref2) {
    const references = parseStringReference(ref2);
    if (!references.table || SelectAllNode.is(references.column)) {
      throw new Error(`invalid call references('${ref2}'). The reference must have format table.column or schema.table.column`);
    }
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      references: ReferencesNode.create(references.table, [
        references.column
      ])
    }));
  }
  /**
   * Adds an `on delete` constraint for the foreign key column.
   *
   * If your database engine doesn't support foreign key constraints in the
   * column definition (like MySQL 5) you need to call the table level
   * {@link CreateTableBuilder.addForeignKeyConstraint} method instead.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('pet')
   *   .addColumn(
   *     'owner_id',
   *     'integer',
   *     (col) => col.references('person.id').onDelete('cascade')
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * create table "pet" (
   *   "owner_id" integer references "person" ("id") on delete cascade
   * )
   * ```
   */
  onDelete(onDelete) {
    if (!this.#node.references) {
      throw new Error("on delete constraint can only be added for foreign keys");
    }
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      references: ReferencesNode.cloneWithOnDelete(this.#node.references, parseOnModifyForeignAction(onDelete))
    }));
  }
  /**
   * Adds an `on update` constraint for the foreign key column.
   *
   * If your database engine doesn't support foreign key constraints in the
   * column definition (like MySQL 5) you need to call the table level
   * {@link CreateTableBuilder.addForeignKeyConstraint} method instead.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('pet')
   *   .addColumn(
   *     'owner_id',
   *     'integer',
   *     (col) => col.references('person.id').onUpdate('cascade')
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * create table "pet" (
   *   "owner_id" integer references "person" ("id") on update cascade
   * )
   * ```
   */
  onUpdate(onUpdate) {
    if (!this.#node.references) {
      throw new Error("on update constraint can only be added for foreign keys");
    }
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      references: ReferencesNode.cloneWithOnUpdate(this.#node.references, parseOnModifyForeignAction(onUpdate))
    }));
  }
  /**
   * Adds a unique constraint for the column.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('email', 'varchar(255)', col => col.unique())
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * create table `person` (
   *   `email` varchar(255) unique
   * )
   * ```
   */
  unique() {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { unique: true }));
  }
  /**
   * Adds a `not null` constraint for the column.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('first_name', 'varchar(255)', col => col.notNull())
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * create table `person` (
   *   `first_name` varchar(255) not null
   * )
   * ```
   */
  notNull() {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { notNull: true }));
  }
  /**
   * Adds a `unsigned` modifier for the column.
   *
   * This only works on some dialects like MySQL.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('age', 'integer', col => col.unsigned())
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * create table `person` (
   *   `age` integer unsigned
   * )
   * ```
   */
  unsigned() {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { unsigned: true }));
  }
  /**
   * Adds a default value constraint for the column.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('pet')
   *   .addColumn('number_of_legs', 'integer', (col) => col.defaultTo(4))
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * create table `pet` (
   *   `number_of_legs` integer default 4
   * )
   * ```
   *
   * Values passed to `defaultTo` are interpreted as value literals by default. You can define
   * an arbitrary SQL expression using the {@link sql} template tag:
   *
   * ```ts
   * import {sql } from 'kysely'
   *
   * await db.schema
   *   .createTable('pet')
   *   .addColumn(
   *     'created_at',
   *     'timestamp',
   *     (col) => col.defaultTo(sql`CURRENT_TIMESTAMP`)
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * create table `pet` (
   *   `created_at` timestamp default CURRENT_TIMESTAMP
   * )
   * ```
   */
  defaultTo(value) {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      defaultTo: DefaultValueNode.create(parseDefaultValueExpression(value))
    }));
  }
  /**
   * Adds a check constraint for the column.
   *
   * ### Examples
   *
   * ```ts
   * import {sql } from 'kysely'
   *
   * await db.schema
   *   .createTable('pet')
   *   .addColumn('number_of_legs', 'integer', (col) =>
   *     col.check(sql`number_of_legs < 5`)
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * create table `pet` (
   *   `number_of_legs` integer check (number_of_legs < 5)
   * )
   * ```
   */
  check(expression) {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      check: CheckConstraintNode.create(expression.toOperationNode())
    }));
  }
  /**
   * Makes the column a generated column using a `generated always as` statement.
   *
   * ### Examples
   *
   * ```ts
   * import {sql } from 'kysely'
   *
   * await db.schema
   *   .createTable('person')
   *   .addColumn('full_name', 'varchar(255)',
   *     (col) => col.generatedAlwaysAs(sql`concat(first_name, ' ', last_name)`)
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * create table `person` (
   *   `full_name` varchar(255) generated always as (concat(first_name, ' ', last_name))
   * )
   * ```
   */
  generatedAlwaysAs(expression) {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      generated: GeneratedNode.createWithExpression(expression.toOperationNode())
    }));
  }
  /**
   * Adds the `generated always as identity` specifier.
   *
   * This only works on some dialects like PostgreSQL.
   *
   * For MS SQL Server (MSSQL)'s identity column use {@link identity}.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('id', 'integer', col => col.generatedAlwaysAsIdentity().primaryKey())
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * create table "person" (
   *   "id" integer generated always as identity primary key
   * )
   * ```
   */
  generatedAlwaysAsIdentity() {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      generated: GeneratedNode.create({ identity: true, always: true })
    }));
  }
  /**
   * Adds the `generated by default as identity` specifier on supported dialects.
   *
   * This only works on some dialects like PostgreSQL.
   *
   * For MS SQL Server (MSSQL)'s identity column use {@link identity}.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('id', 'integer', col => col.generatedByDefaultAsIdentity().primaryKey())
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * create table "person" (
   *   "id" integer generated by default as identity primary key
   * )
   * ```
   */
  generatedByDefaultAsIdentity() {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      generated: GeneratedNode.create({ identity: true, byDefault: true })
    }));
  }
  /**
   * Makes a generated column stored instead of virtual. This method can only
   * be used with {@link generatedAlwaysAs}
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.schema
   *   .createTable('person')
   *   .addColumn('full_name', 'varchar(255)', (col) => col
   *     .generatedAlwaysAs(sql`concat(first_name, ' ', last_name)`)
   *     .stored()
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * create table `person` (
   *   `full_name` varchar(255) generated always as (concat(first_name, ' ', last_name)) stored
   * )
   * ```
   */
  stored() {
    if (!this.#node.generated) {
      throw new Error("stored() can only be called after generatedAlwaysAs");
    }
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      generated: GeneratedNode.cloneWith(this.#node.generated, {
        stored: true
      })
    }));
  }
  /**
   * This can be used to add any additional SQL right after the column's data type.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.schema
   *   .createTable('person')
   *   .addColumn('id', 'integer', col => col.primaryKey())
   *   .addColumn(
   *     'first_name',
   *     'varchar(36)',
   *     (col) => col.modifyFront(sql`collate utf8mb4_general_ci`).notNull()
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * create table `person` (
   *   `id` integer primary key,
   *   `first_name` varchar(36) collate utf8mb4_general_ci not null
   * )
   * ```
   */
  modifyFront(modifier) {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWithFrontModifier(this.#node, modifier.toOperationNode()));
  }
  /**
   * Adds `nulls not distinct` specifier.
   * Should be used with `unique` constraint.
   *
   * This only works on some dialects like PostgreSQL.
   *
   * ### Examples
   *
   * ```ts
   * db.schema
   *   .createTable('person')
   *   .addColumn('id', 'integer', col => col.primaryKey())
   *   .addColumn('first_name', 'varchar(30)', col => col.unique().nullsNotDistinct())
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * create table "person" (
   *   "id" integer primary key,
   *   "first_name" varchar(30) unique nulls not distinct
   * )
   * ```
   */
  nullsNotDistinct() {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { nullsNotDistinct: true }));
  }
  /**
   * Adds `if not exists` specifier. This only works for PostgreSQL.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .alterTable('person')
   *   .addColumn('email', 'varchar(255)', col => col.unique().ifNotExists())
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * alter table "person" add column if not exists "email" varchar(255) unique
   * ```
   */
  ifNotExists() {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { ifNotExists: true }));
  }
  /**
   * This can be used to add any additional SQL to the end of the column definition.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.schema
   *   .createTable('person')
   *   .addColumn('id', 'integer', col => col.primaryKey())
   *   .addColumn(
   *     'age',
   *     'integer',
   *     col => col.unsigned()
   *       .notNull()
   *       .modifyEnd(sql`comment ${sql.lit('it is not polite to ask a woman her age')}`)
   *   )
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * create table `person` (
   *   `id` integer primary key,
   *   `age` integer unsigned not null comment 'it is not polite to ask a woman her age'
   * )
   * ```
   */
  modifyEnd(modifier) {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWithEndModifier(this.#node, modifier.toOperationNode()));
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#node;
  }
}
const ModifyColumnNode = freeze({
  is(node) {
    return node.kind === "ModifyColumnNode";
  },
  create(column) {
    return freeze({
      kind: "ModifyColumnNode",
      column
    });
  }
});
const ForeignKeyConstraintNode = freeze({
  is(node) {
    return node.kind === "ForeignKeyConstraintNode";
  },
  create(sourceColumns, targetTable, targetColumns, constraintName) {
    return freeze({
      kind: "ForeignKeyConstraintNode",
      columns: sourceColumns,
      references: ReferencesNode.create(targetTable, targetColumns),
      name: constraintName ? IdentifierNode.create(constraintName) : void 0
    });
  },
  cloneWith(node, props) {
    return freeze({
      ...node,
      ...props
    });
  }
});
class ForeignKeyConstraintBuilder {
  #node;
  constructor(node) {
    this.#node = node;
  }
  onDelete(onDelete) {
    return new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.cloneWith(this.#node, {
      onDelete: parseOnModifyForeignAction(onDelete)
    }));
  }
  onUpdate(onUpdate) {
    return new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.cloneWith(this.#node, {
      onUpdate: parseOnModifyForeignAction(onUpdate)
    }));
  }
  deferrable() {
    return new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.cloneWith(this.#node, { deferrable: true }));
  }
  notDeferrable() {
    return new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.cloneWith(this.#node, { deferrable: false }));
  }
  initiallyDeferred() {
    return new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.cloneWith(this.#node, {
      initiallyDeferred: true
    }));
  }
  initiallyImmediate() {
    return new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.cloneWith(this.#node, {
      initiallyDeferred: false
    }));
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#node;
  }
}
const AddConstraintNode = freeze({
  is(node) {
    return node.kind === "AddConstraintNode";
  },
  create(constraint) {
    return freeze({
      kind: "AddConstraintNode",
      constraint
    });
  }
});
const UniqueConstraintNode = freeze({
  is(node) {
    return node.kind === "UniqueConstraintNode";
  },
  create(columns, constraintName, nullsNotDistinct) {
    return freeze({
      kind: "UniqueConstraintNode",
      columns: freeze(columns.map(ColumnNode.create)),
      name: constraintName ? IdentifierNode.create(constraintName) : void 0,
      nullsNotDistinct
    });
  },
  cloneWith(node, props) {
    return freeze({
      ...node,
      ...props
    });
  }
});
const DropConstraintNode = freeze({
  is(node) {
    return node.kind === "DropConstraintNode";
  },
  create(constraintName) {
    return freeze({
      kind: "DropConstraintNode",
      constraintName: IdentifierNode.create(constraintName)
    });
  },
  cloneWith(dropConstraint, props) {
    return freeze({
      ...dropConstraint,
      ...props
    });
  }
});
const AlterColumnNode = freeze({
  is(node) {
    return node.kind === "AlterColumnNode";
  },
  create(column, prop, value) {
    return freeze({
      kind: "AlterColumnNode",
      column: ColumnNode.create(column),
      [prop]: value
    });
  }
});
class AlterColumnBuilder {
  #column;
  constructor(column) {
    this.#column = column;
  }
  setDataType(dataType) {
    return new AlteredColumnBuilder(AlterColumnNode.create(this.#column, "dataType", parseDataTypeExpression(dataType)));
  }
  setDefault(value) {
    return new AlteredColumnBuilder(AlterColumnNode.create(this.#column, "setDefault", parseDefaultValueExpression(value)));
  }
  dropDefault() {
    return new AlteredColumnBuilder(AlterColumnNode.create(this.#column, "dropDefault", true));
  }
  setNotNull() {
    return new AlteredColumnBuilder(AlterColumnNode.create(this.#column, "setNotNull", true));
  }
  dropNotNull() {
    return new AlteredColumnBuilder(AlterColumnNode.create(this.#column, "dropNotNull", true));
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
}
class AlteredColumnBuilder {
  #alterColumnNode;
  constructor(alterColumnNode) {
    this.#alterColumnNode = alterColumnNode;
  }
  toOperationNode() {
    return this.#alterColumnNode;
  }
}
class AlterTableExecutor {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile());
  }
}
class AlterTableAddForeignKeyConstraintBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  onDelete(onDelete) {
    return new AlterTableAddForeignKeyConstraintBuilder({
      ...this.#props,
      constraintBuilder: this.#props.constraintBuilder.onDelete(onDelete)
    });
  }
  onUpdate(onUpdate) {
    return new AlterTableAddForeignKeyConstraintBuilder({
      ...this.#props,
      constraintBuilder: this.#props.constraintBuilder.onUpdate(onUpdate)
    });
  }
  deferrable() {
    return new AlterTableAddForeignKeyConstraintBuilder({
      ...this.#props,
      constraintBuilder: this.#props.constraintBuilder.deferrable()
    });
  }
  notDeferrable() {
    return new AlterTableAddForeignKeyConstraintBuilder({
      ...this.#props,
      constraintBuilder: this.#props.constraintBuilder.notDeferrable()
    });
  }
  initiallyDeferred() {
    return new AlterTableAddForeignKeyConstraintBuilder({
      ...this.#props,
      constraintBuilder: this.#props.constraintBuilder.initiallyDeferred()
    });
  }
  initiallyImmediate() {
    return new AlterTableAddForeignKeyConstraintBuilder({
      ...this.#props,
      constraintBuilder: this.#props.constraintBuilder.initiallyImmediate()
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(AlterTableNode.cloneWithTableProps(this.#props.node, {
      addConstraint: AddConstraintNode.create(this.#props.constraintBuilder.toOperationNode())
    }), this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile());
  }
}
class AlterTableDropConstraintBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  ifExists() {
    return new AlterTableDropConstraintBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        dropConstraint: DropConstraintNode.cloneWith(this.#props.node.dropConstraint, {
          ifExists: true
        })
      })
    });
  }
  cascade() {
    return new AlterTableDropConstraintBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        dropConstraint: DropConstraintNode.cloneWith(this.#props.node.dropConstraint, {
          modifier: "cascade"
        })
      })
    });
  }
  restrict() {
    return new AlterTableDropConstraintBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        dropConstraint: DropConstraintNode.cloneWith(this.#props.node.dropConstraint, {
          modifier: "restrict"
        })
      })
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile());
  }
}
const PrimaryKeyConstraintNode = freeze({
  is(node) {
    return node.kind === "PrimaryKeyConstraintNode";
  },
  create(columns, constraintName) {
    return freeze({
      kind: "PrimaryKeyConstraintNode",
      columns: freeze(columns.map(ColumnNode.create)),
      name: constraintName ? IdentifierNode.create(constraintName) : void 0
    });
  },
  cloneWith(node, props) {
    return freeze({ ...node, ...props });
  }
});
const AddIndexNode = freeze({
  is(node) {
    return node.kind === "AddIndexNode";
  },
  create(name2) {
    return freeze({
      kind: "AddIndexNode",
      name: IdentifierNode.create(name2)
    });
  },
  cloneWith(node, props) {
    return freeze({
      ...node,
      ...props
    });
  },
  cloneWithColumns(node, columns) {
    return freeze({
      ...node,
      columns: [...node.columns || [], ...columns]
    });
  }
});
class AlterTableAddIndexBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * Makes the index unique.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .alterTable('person')
   *   .addIndex('person_first_name_index')
   *   .unique()
   *   .column('email')
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * alter table `person` add unique index `person_first_name_index` (`email`)
   * ```
   */
  unique() {
    return new AlterTableAddIndexBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addIndex: AddIndexNode.cloneWith(this.#props.node.addIndex, {
          unique: true
        })
      })
    });
  }
  /**
   * Adds a column to the index.
   *
   * Also see {@link columns} for adding multiple columns at once or {@link expression}
   * for specifying an arbitrary expression.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .alterTable('person')
   *   .addIndex('person_first_name_and_age_index')
   *   .column('first_name')
   *   .column('age desc')
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * alter table `person` add index `person_first_name_and_age_index` (`first_name`, `age` desc)
   * ```
   */
  column(column) {
    return new AlterTableAddIndexBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addIndex: AddIndexNode.cloneWithColumns(this.#props.node.addIndex, [
          parseOrderedColumnName(column)
        ])
      })
    });
  }
  /**
   * Specifies a list of columns for the index.
   *
   * Also see {@link column} for adding a single column or {@link expression} for
   * specifying an arbitrary expression.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .alterTable('person')
   *   .addIndex('person_first_name_and_age_index')
   *   .columns(['first_name', 'age desc'])
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * alter table `person` add index `person_first_name_and_age_index` (`first_name`, `age` desc)
   * ```
   */
  columns(columns) {
    return new AlterTableAddIndexBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addIndex: AddIndexNode.cloneWithColumns(this.#props.node.addIndex, columns.map(parseOrderedColumnName))
      })
    });
  }
  /**
   * Specifies an arbitrary expression for the index.
   *
   * ### Examples
   *
   * ```ts
   * import {sql } from 'kysely'
   *
   * await db.schema
   *   .alterTable('person')
   *   .addIndex('person_first_name_index')
   *   .expression(sql<boolean>`(first_name < 'Sami')`)
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * alter table `person` add index `person_first_name_index` ((first_name < 'Sami'))
   * ```
   */
  expression(expression) {
    return new AlterTableAddIndexBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addIndex: AddIndexNode.cloneWithColumns(this.#props.node.addIndex, [
          expression.toOperationNode()
        ])
      })
    });
  }
  using(indexType) {
    return new AlterTableAddIndexBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addIndex: AddIndexNode.cloneWith(this.#props.node.addIndex, {
          using: RawNode.createWithSql(indexType)
        })
      })
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile());
  }
}
class UniqueConstraintNodeBuilder {
  #node;
  constructor(node) {
    this.#node = node;
  }
  /**
   * Adds `nulls not distinct` to the unique constraint definition
   *
   * Supported by PostgreSQL dialect only
   */
  nullsNotDistinct() {
    return new UniqueConstraintNodeBuilder(UniqueConstraintNode.cloneWith(this.#node, { nullsNotDistinct: true }));
  }
  deferrable() {
    return new UniqueConstraintNodeBuilder(UniqueConstraintNode.cloneWith(this.#node, { deferrable: true }));
  }
  notDeferrable() {
    return new UniqueConstraintNodeBuilder(UniqueConstraintNode.cloneWith(this.#node, { deferrable: false }));
  }
  initiallyDeferred() {
    return new UniqueConstraintNodeBuilder(UniqueConstraintNode.cloneWith(this.#node, {
      initiallyDeferred: true
    }));
  }
  initiallyImmediate() {
    return new UniqueConstraintNodeBuilder(UniqueConstraintNode.cloneWith(this.#node, {
      initiallyDeferred: false
    }));
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#node;
  }
}
class PrimaryKeyConstraintBuilder {
  #node;
  constructor(node) {
    this.#node = node;
  }
  deferrable() {
    return new PrimaryKeyConstraintBuilder(PrimaryKeyConstraintNode.cloneWith(this.#node, { deferrable: true }));
  }
  notDeferrable() {
    return new PrimaryKeyConstraintBuilder(PrimaryKeyConstraintNode.cloneWith(this.#node, { deferrable: false }));
  }
  initiallyDeferred() {
    return new PrimaryKeyConstraintBuilder(PrimaryKeyConstraintNode.cloneWith(this.#node, {
      initiallyDeferred: true
    }));
  }
  initiallyImmediate() {
    return new PrimaryKeyConstraintBuilder(PrimaryKeyConstraintNode.cloneWith(this.#node, {
      initiallyDeferred: false
    }));
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#node;
  }
}
class CheckConstraintBuilder {
  #node;
  constructor(node) {
    this.#node = node;
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#node;
  }
}
const RenameConstraintNode = freeze({
  is(node) {
    return node.kind === "RenameConstraintNode";
  },
  create(oldName, newName) {
    return freeze({
      kind: "RenameConstraintNode",
      oldName: IdentifierNode.create(oldName),
      newName: IdentifierNode.create(newName)
    });
  }
});
class AlterTableBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  renameTo(newTableName) {
    return new AlterTableExecutor({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        renameTo: parseTable(newTableName)
      })
    });
  }
  setSchema(newSchema) {
    return new AlterTableExecutor({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        setSchema: IdentifierNode.create(newSchema)
      })
    });
  }
  alterColumn(column, alteration) {
    const builder = alteration(new AlterColumnBuilder(column));
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, builder.toOperationNode())
    });
  }
  dropColumn(column) {
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, DropColumnNode.create(column))
    });
  }
  renameColumn(column, newColumn) {
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, RenameColumnNode.create(column, newColumn))
    });
  }
  addColumn(columnName, dataType, build = noop$1) {
    const builder = build(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType))));
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, AddColumnNode.create(builder.toOperationNode()))
    });
  }
  modifyColumn(columnName, dataType, build = noop$1) {
    const builder = build(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType))));
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, ModifyColumnNode.create(builder.toOperationNode()))
    });
  }
  /**
   * See {@link CreateTableBuilder.addUniqueConstraint}
   */
  addUniqueConstraint(constraintName, columns, build = noop$1) {
    const uniqueConstraintBuilder = build(new UniqueConstraintNodeBuilder(UniqueConstraintNode.create(columns, constraintName)));
    return new AlterTableExecutor({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addConstraint: AddConstraintNode.create(uniqueConstraintBuilder.toOperationNode())
      })
    });
  }
  /**
   * See {@link CreateTableBuilder.addCheckConstraint}
   */
  addCheckConstraint(constraintName, checkExpression, build = noop$1) {
    const constraintBuilder = build(new CheckConstraintBuilder(CheckConstraintNode.create(checkExpression.toOperationNode(), constraintName)));
    return new AlterTableExecutor({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addConstraint: AddConstraintNode.create(constraintBuilder.toOperationNode())
      })
    });
  }
  /**
   * See {@link CreateTableBuilder.addForeignKeyConstraint}
   *
   * Unlike {@link CreateTableBuilder.addForeignKeyConstraint} this method returns
   * the constraint builder and doesn't take a callback as the last argument. This
   * is because you can only add one column per `ALTER TABLE` query.
   */
  addForeignKeyConstraint(constraintName, columns, targetTable, targetColumns, build = noop$1) {
    const constraintBuilder = build(new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.create(columns.map(ColumnNode.create), parseTable(targetTable), targetColumns.map(ColumnNode.create), constraintName)));
    return new AlterTableAddForeignKeyConstraintBuilder({
      ...this.#props,
      constraintBuilder
    });
  }
  /**
   * See {@link CreateTableBuilder.addPrimaryKeyConstraint}
   */
  addPrimaryKeyConstraint(constraintName, columns, build = noop$1) {
    const constraintBuilder = build(new PrimaryKeyConstraintBuilder(PrimaryKeyConstraintNode.create(columns, constraintName)));
    return new AlterTableExecutor({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addConstraint: AddConstraintNode.create(constraintBuilder.toOperationNode())
      })
    });
  }
  dropConstraint(constraintName) {
    return new AlterTableDropConstraintBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        dropConstraint: DropConstraintNode.create(constraintName)
      })
    });
  }
  renameConstraint(oldName, newName) {
    return new AlterTableDropConstraintBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        renameConstraint: RenameConstraintNode.create(oldName, newName)
      })
    });
  }
  /**
   * This can be used to add index to table.
   *
   *  ### Examples
   *
   * ```ts
   * db.schema.alterTable('person')
   *   .addIndex('person_email_index')
   *   .column('email')
   *   .unique()
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * alter table `person` add unique index `person_email_index` (`email`)
   * ```
   */
  addIndex(indexName) {
    return new AlterTableAddIndexBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addIndex: AddIndexNode.create(indexName)
      })
    });
  }
  /**
   * This can be used to drop index from table.
   *
   * ### Examples
   *
   * ```ts
   * db.schema.alterTable('person')
   *   .dropIndex('person_email_index')
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * alter table `person` drop index `test_first_name_index`
   * ```
   */
  dropIndex(indexName) {
    return new AlterTableExecutor({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        dropIndex: DropIndexNode.create(indexName)
      })
    });
  }
  /**
   * Calls the given function passing `this` as the only argument.
   *
   * See {@link CreateTableBuilder.$call}
   */
  $call(func) {
    return func(this);
  }
}
class AlterTableColumnAlteringBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  alterColumn(column, alteration) {
    const builder = alteration(new AlterColumnBuilder(column));
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, builder.toOperationNode())
    });
  }
  dropColumn(column) {
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, DropColumnNode.create(column))
    });
  }
  renameColumn(column, newColumn) {
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, RenameColumnNode.create(column, newColumn))
    });
  }
  addColumn(columnName, dataType, build = noop$1) {
    const builder = build(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType))));
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, AddColumnNode.create(builder.toOperationNode()))
    });
  }
  modifyColumn(columnName, dataType, build = noop$1) {
    const builder = build(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType))));
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, ModifyColumnNode.create(builder.toOperationNode()))
    });
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile());
  }
}
class ImmediateValueTransformer extends OperationNodeTransformer {
  transformPrimitiveValueList(node) {
    return ValueListNode.create(node.values.map(ValueNode.createImmediate));
  }
  transformValue(node) {
    return ValueNode.createImmediate(node.value);
  }
}
class CreateIndexBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * Adds the "if not exists" modifier.
   *
   * If the index already exists, no error is thrown if this method has been called.
   */
  ifNotExists() {
    return new CreateIndexBuilder({
      ...this.#props,
      node: CreateIndexNode.cloneWith(this.#props.node, {
        ifNotExists: true
      })
    });
  }
  /**
   * Makes the index unique.
   */
  unique() {
    return new CreateIndexBuilder({
      ...this.#props,
      node: CreateIndexNode.cloneWith(this.#props.node, {
        unique: true
      })
    });
  }
  /**
   * Adds `nulls not distinct` specifier to index.
   * This only works on some dialects like PostgreSQL.
   *
   * ### Examples
   *
   * ```ts
   * db.schema.createIndex('person_first_name_index')
   *  .on('person')
   *  .column('first_name')
   *  .nullsNotDistinct()
   *  .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * create index "person_first_name_index"
   * on "test" ("first_name")
   * nulls not distinct;
   * ```
   */
  nullsNotDistinct() {
    return new CreateIndexBuilder({
      ...this.#props,
      node: CreateIndexNode.cloneWith(this.#props.node, {
        nullsNotDistinct: true
      })
    });
  }
  /**
   * Specifies the table for the index.
   */
  on(table) {
    return new CreateIndexBuilder({
      ...this.#props,
      node: CreateIndexNode.cloneWith(this.#props.node, {
        table: parseTable(table)
      })
    });
  }
  /**
   * Adds a column to the index.
   *
   * Also see {@link columns} for adding multiple columns at once or {@link expression}
   * for specifying an arbitrary expression.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *         .createIndex('person_first_name_and_age_index')
   *         .on('person')
   *         .column('first_name')
   *         .column('age desc')
   *         .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * create index "person_first_name_and_age_index" on "person" ("first_name", "age" desc)
   * ```
   */
  column(column) {
    return new CreateIndexBuilder({
      ...this.#props,
      node: CreateIndexNode.cloneWithColumns(this.#props.node, [
        parseOrderedColumnName(column)
      ])
    });
  }
  /**
   * Specifies a list of columns for the index.
   *
   * Also see {@link column} for adding a single column or {@link expression} for
   * specifying an arbitrary expression.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *         .createIndex('person_first_name_and_age_index')
   *         .on('person')
   *         .columns(['first_name', 'age desc'])
   *         .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * create index "person_first_name_and_age_index" on "person" ("first_name", "age" desc)
   * ```
   */
  columns(columns) {
    return new CreateIndexBuilder({
      ...this.#props,
      node: CreateIndexNode.cloneWithColumns(this.#props.node, columns.map(parseOrderedColumnName))
    });
  }
  /**
   * Specifies an arbitrary expression for the index.
   *
   * ### Examples
   *
   * ```ts
   * import {sql } from 'kysely'
   *
   * await db.schema
   *   .createIndex('person_first_name_index')
   *   .on('person')
   *   .expression(sql`first_name COLLATE "fi_FI"`)
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * create index "person_first_name_index" on "person" (first_name COLLATE "fi_FI")
   * ```
   */
  expression(expression) {
    return new CreateIndexBuilder({
      ...this.#props,
      node: CreateIndexNode.cloneWithColumns(this.#props.node, [
        expression.toOperationNode()
      ])
    });
  }
  using(indexType) {
    return new CreateIndexBuilder({
      ...this.#props,
      node: CreateIndexNode.cloneWith(this.#props.node, {
        using: RawNode.createWithSql(indexType)
      })
    });
  }
  where(...args) {
    const transformer = new ImmediateValueTransformer();
    return new CreateIndexBuilder({
      ...this.#props,
      node: QueryNode.cloneWithWhere(this.#props.node, transformer.transformNode(parseValueBinaryOperationOrExpression(args), this.#props.queryId))
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile());
  }
}
class CreateSchemaBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  ifNotExists() {
    return new CreateSchemaBuilder({
      ...this.#props,
      node: CreateSchemaNode.cloneWith(this.#props.node, { ifNotExists: true })
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile());
  }
}
function parseOnCommitAction(action) {
  if (ON_COMMIT_ACTIONS.includes(action)) {
    return action;
  }
  throw new Error(`invalid OnCommitAction ${action}`);
}
class CreateTableBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * Adds the "temporary" modifier.
   *
   * Use this to create a temporary table.
   */
  temporary() {
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWith(this.#props.node, {
        temporary: true
      })
    });
  }
  /**
   * Adds an "on commit" statement.
   *
   * This can be used in conjunction with temporary tables on supported databases
   * like PostgreSQL.
   */
  onCommit(onCommit) {
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWith(this.#props.node, {
        onCommit: parseOnCommitAction(onCommit)
      })
    });
  }
  /**
   * Adds the "if not exists" modifier.
   *
   * If the table already exists, no error is thrown if this method has been called.
   */
  ifNotExists() {
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWith(this.#props.node, {
        ifNotExists: true
      })
    });
  }
  /**
   * Adds a column to the table.
   *
   * ### Examples
   *
   * ```ts
   * import {sql } from 'kysely'
   *
   * await db.schema
   *   .createTable('person')
   *   .addColumn('id', 'integer', (col) => col.autoIncrement().primaryKey())
   *   .addColumn('first_name', 'varchar(50)', (col) => col.notNull())
   *   .addColumn('last_name', 'varchar(255)')
   *   .addColumn('bank_balance', 'numeric(8, 2)')
   *   // You can specify any data type using the `sql` tag if the types
   *   // don't include it.
   *   .addColumn('data', sql`any_type_here`)
   *   .addColumn('parent_id', 'integer', (col) =>
   *     col.references('person.id').onDelete('cascade')
   *   )
   * ```
   *
   * With this method, it's once again good to remember that Kysely just builds the
   * query and doesn't provide the same API for all databases. For example, some
   * databases like older MySQL don't support the `references` statement in the
   * column definition. Instead foreign key constraints need to be defined in the
   * `create table` query. See the next example:
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('id', 'integer', (col) => col.primaryKey())
   *   .addColumn('parent_id', 'integer')
   *   .addForeignKeyConstraint(
   *     'person_parent_id_fk',
   *     ['parent_id'],
   *     'person',
   *     ['id'],
   *     (cb) => cb.onDelete('cascade')
   *   )
   *   .execute()
   * ```
   *
   * Another good example is that PostgreSQL doesn't support the `auto_increment`
   * keyword and you need to define an autoincrementing column for example using
   * `serial`:
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('id', 'serial', (col) => col.primaryKey())
   *   .execute()
   * ```
   */
  addColumn(columnName, dataType, build = noop$1) {
    const columnBuilder = build(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType))));
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWithColumn(this.#props.node, columnBuilder.toOperationNode())
    });
  }
  /**
   * Adds a primary key constraint for one or more columns.
   *
   * The constraint name can be anything you want, but it must be unique
   * across the whole database.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('first_name', 'varchar(64)')
   *   .addColumn('last_name', 'varchar(64)')
   *   .addPrimaryKeyConstraint('primary_key', ['first_name', 'last_name'])
   *   .execute()
   * ```
   */
  addPrimaryKeyConstraint(constraintName, columns, build = noop$1) {
    const constraintBuilder = build(new PrimaryKeyConstraintBuilder(PrimaryKeyConstraintNode.create(columns, constraintName)));
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWithConstraint(this.#props.node, constraintBuilder.toOperationNode())
    });
  }
  /**
   * Adds a unique constraint for one or more columns.
   *
   * The constraint name can be anything you want, but it must be unique
   * across the whole database.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('first_name', 'varchar(64)')
   *   .addColumn('last_name', 'varchar(64)')
   *   .addUniqueConstraint(
   *     'first_name_last_name_unique',
   *     ['first_name', 'last_name']
   *   )
   *   .execute()
   * ```
   *
   * In dialects such as PostgreSQL you can specify `nulls not distinct` as follows:
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('first_name', 'varchar(64)')
   *   .addColumn('last_name', 'varchar(64)')
   *   .addUniqueConstraint(
   *     'first_name_last_name_unique',
   *     ['first_name', 'last_name'],
   *     (cb) => cb.nullsNotDistinct()
   *   )
   *   .execute()
   * ```
   */
  addUniqueConstraint(constraintName, columns, build = noop$1) {
    const uniqueConstraintBuilder = build(new UniqueConstraintNodeBuilder(UniqueConstraintNode.create(columns, constraintName)));
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWithConstraint(this.#props.node, uniqueConstraintBuilder.toOperationNode())
    });
  }
  /**
   * Adds a check constraint.
   *
   * The constraint name can be anything you want, but it must be unique
   * across the whole database.
   *
   * ### Examples
   *
   * ```ts
   * import {sql } from 'kysely'
   *
   * await db.schema
   *   .createTable('animal')
   *   .addColumn('number_of_legs', 'integer')
   *   .addCheckConstraint('check_legs', sql`number_of_legs < 5`)
   *   .execute()
   * ```
   */
  addCheckConstraint(constraintName, checkExpression, build = noop$1) {
    const constraintBuilder = build(new CheckConstraintBuilder(CheckConstraintNode.create(checkExpression.toOperationNode(), constraintName)));
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWithConstraint(this.#props.node, constraintBuilder.toOperationNode())
    });
  }
  /**
   * Adds a foreign key constraint.
   *
   * The constraint name can be anything you want, but it must be unique
   * across the whole database.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('pet')
   *   .addColumn('owner_id', 'integer')
   *   .addForeignKeyConstraint(
   *     'owner_id_foreign',
   *     ['owner_id'],
   *     'person',
   *     ['id'],
   *   )
   *   .execute()
   * ```
   *
   * Add constraint for multiple columns:
   *
   * ```ts
   * await db.schema
   *   .createTable('pet')
   *   .addColumn('owner_id1', 'integer')
   *   .addColumn('owner_id2', 'integer')
   *   .addForeignKeyConstraint(
   *     'owner_id_foreign',
   *     ['owner_id1', 'owner_id2'],
   *     'person',
   *     ['id1', 'id2'],
   *     (cb) => cb.onDelete('cascade')
   *   )
   *   .execute()
   * ```
   */
  addForeignKeyConstraint(constraintName, columns, targetTable, targetColumns, build = noop$1) {
    const builder = build(new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.create(columns.map(ColumnNode.create), parseTable(targetTable), targetColumns.map(ColumnNode.create), constraintName)));
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWithConstraint(this.#props.node, builder.toOperationNode())
    });
  }
  /**
   * This can be used to add any additional SQL to the front of the query __after__ the `create` keyword.
   *
   * Also see {@link temporary}.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.schema
   *   .createTable('person')
   *   .modifyFront(sql`global temporary`)
   *   .addColumn('id', 'integer', col => col.primaryKey())
   *   .addColumn('first_name', 'varchar(64)', col => col.notNull())
   *   .addColumn('last_name', 'varchar(64)', col => col.notNull())
   *   .execute()
   * ```
   *
   * The generated SQL (Postgres):
   *
   * ```sql
   * create global temporary table "person" (
   *   "id" integer primary key,
   *   "first_name" varchar(64) not null,
   *   "last_name" varchar(64) not null
   * )
   * ```
   */
  modifyFront(modifier) {
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWithFrontModifier(this.#props.node, modifier.toOperationNode())
    });
  }
  /**
   * This can be used to add any additional SQL to the end of the query.
   *
   * Also see {@link onCommit}.
   *
   * ### Examples
   *
   * ```ts
   * import { sql } from 'kysely'
   *
   * await db.schema
   *   .createTable('person')
   *   .addColumn('id', 'integer', col => col.primaryKey())
   *   .addColumn('first_name', 'varchar(64)', col => col.notNull())
   *   .addColumn('last_name', 'varchar(64)', col => col.notNull())
   *   .modifyEnd(sql`collate utf8_unicode_ci`)
   *   .execute()
   * ```
   *
   * The generated SQL (MySQL):
   *
   * ```sql
   * create table `person` (
   *   `id` integer primary key,
   *   `first_name` varchar(64) not null,
   *   `last_name` varchar(64) not null
   * ) collate utf8_unicode_ci
   * ```
   */
  modifyEnd(modifier) {
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWithEndModifier(this.#props.node, modifier.toOperationNode())
    });
  }
  /**
   * Allows to create table from `select` query.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('copy')
   *   .temporary()
   *   .as(db.selectFrom('person').select(['first_name', 'last_name']))
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * create temporary table "copy" as
   * select "first_name", "last_name" from "person"
   * ```
   */
  as(expression) {
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWith(this.#props.node, {
        selectQuery: parseExpression(expression)
      })
    });
  }
  /**
   * Calls the given function passing `this` as the only argument.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createTable('test')
   *   .$call((builder) => builder.addColumn('id', 'integer'))
   *   .execute()
   * ```
   *
   * This is useful for creating reusable functions that can be called with a builder.
   *
   * ```ts
   * import { type CreateTableBuilder, sql } from 'kysely'
   *
   * const addDefaultColumns = (ctb: CreateTableBuilder<any, any>) => {
   *   return ctb
   *     .addColumn('id', 'integer', (col) => col.notNull())
   *     .addColumn('created_at', 'date', (col) =>
   *       col.notNull().defaultTo(sql`now()`)
   *     )
   *     .addColumn('updated_at', 'date', (col) =>
   *       col.notNull().defaultTo(sql`now()`)
   *     )
   * }
   *
   * await db.schema
   *   .createTable('test')
   *   .$call(addDefaultColumns)
   *   .execute()
   * ```
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile());
  }
}
class DropIndexBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * Specifies the table the index was created for. This is not needed
   * in all dialects.
   */
  on(table) {
    return new DropIndexBuilder({
      ...this.#props,
      node: DropIndexNode.cloneWith(this.#props.node, {
        table: parseTable(table)
      })
    });
  }
  ifExists() {
    return new DropIndexBuilder({
      ...this.#props,
      node: DropIndexNode.cloneWith(this.#props.node, {
        ifExists: true
      })
    });
  }
  cascade() {
    return new DropIndexBuilder({
      ...this.#props,
      node: DropIndexNode.cloneWith(this.#props.node, {
        cascade: true
      })
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile());
  }
}
class DropSchemaBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  ifExists() {
    return new DropSchemaBuilder({
      ...this.#props,
      node: DropSchemaNode.cloneWith(this.#props.node, {
        ifExists: true
      })
    });
  }
  cascade() {
    return new DropSchemaBuilder({
      ...this.#props,
      node: DropSchemaNode.cloneWith(this.#props.node, {
        cascade: true
      })
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile());
  }
}
class DropTableBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  ifExists() {
    return new DropTableBuilder({
      ...this.#props,
      node: DropTableNode.cloneWith(this.#props.node, {
        ifExists: true
      })
    });
  }
  cascade() {
    return new DropTableBuilder({
      ...this.#props,
      node: DropTableNode.cloneWith(this.#props.node, {
        cascade: true
      })
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile());
  }
}
const CreateViewNode = freeze({
  is(node) {
    return node.kind === "CreateViewNode";
  },
  create(name2) {
    return freeze({
      kind: "CreateViewNode",
      name: SchemableIdentifierNode.create(name2)
    });
  },
  cloneWith(createView2, params) {
    return freeze({
      ...createView2,
      ...params
    });
  }
});
class ImmediateValuePlugin {
  #transformer = new ImmediateValueTransformer();
  transformQuery(args) {
    return this.#transformer.transformNode(args.node, args.queryId);
  }
  transformResult(args) {
    return Promise.resolve(args.result);
  }
}
class CreateViewBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * Adds the "temporary" modifier.
   *
   * Use this to create a temporary view.
   */
  temporary() {
    return new CreateViewBuilder({
      ...this.#props,
      node: CreateViewNode.cloneWith(this.#props.node, {
        temporary: true
      })
    });
  }
  materialized() {
    return new CreateViewBuilder({
      ...this.#props,
      node: CreateViewNode.cloneWith(this.#props.node, {
        materialized: true
      })
    });
  }
  /**
   * Only implemented on some dialects like SQLite. On most dialects, use {@link orReplace}.
   */
  ifNotExists() {
    return new CreateViewBuilder({
      ...this.#props,
      node: CreateViewNode.cloneWith(this.#props.node, {
        ifNotExists: true
      })
    });
  }
  orReplace() {
    return new CreateViewBuilder({
      ...this.#props,
      node: CreateViewNode.cloneWith(this.#props.node, {
        orReplace: true
      })
    });
  }
  columns(columns) {
    return new CreateViewBuilder({
      ...this.#props,
      node: CreateViewNode.cloneWith(this.#props.node, {
        columns: columns.map(parseColumnName)
      })
    });
  }
  /**
   * Sets the select query or a `values` statement that creates the view.
   *
   * WARNING!
   * Some dialects don't support parameterized queries in DDL statements and therefore
   * the query or raw {@link sql } expression passed here is interpolated into a single
   * string opening an SQL injection vulnerability. DO NOT pass unchecked user input
   * into the query or raw expression passed to this method!
   */
  as(query2) {
    const queryNode = query2.withPlugin(new ImmediateValuePlugin()).toOperationNode();
    return new CreateViewBuilder({
      ...this.#props,
      node: CreateViewNode.cloneWith(this.#props.node, {
        as: queryNode
      })
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile());
  }
}
const DropViewNode = freeze({
  is(node) {
    return node.kind === "DropViewNode";
  },
  create(name2) {
    return freeze({
      kind: "DropViewNode",
      name: SchemableIdentifierNode.create(name2)
    });
  },
  cloneWith(dropView, params) {
    return freeze({
      ...dropView,
      ...params
    });
  }
});
class DropViewBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  materialized() {
    return new DropViewBuilder({
      ...this.#props,
      node: DropViewNode.cloneWith(this.#props.node, {
        materialized: true
      })
    });
  }
  ifExists() {
    return new DropViewBuilder({
      ...this.#props,
      node: DropViewNode.cloneWith(this.#props.node, {
        ifExists: true
      })
    });
  }
  cascade() {
    return new DropViewBuilder({
      ...this.#props,
      node: DropViewNode.cloneWith(this.#props.node, {
        cascade: true
      })
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile());
  }
}
const CreateTypeNode = freeze({
  is(node) {
    return node.kind === "CreateTypeNode";
  },
  create(name2) {
    return freeze({
      kind: "CreateTypeNode",
      name: name2
    });
  },
  cloneWithEnum(createType, values) {
    return freeze({
      ...createType,
      enum: ValueListNode.create(values.map(ValueNode.createImmediate))
    });
  }
});
class CreateTypeBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  /**
   * Creates an anum type.
   *
   * ### Examples
   *
   * ```ts
   * db.schema.createType('species').asEnum(['cat', 'dog', 'frog'])
   * ```
   */
  asEnum(values) {
    return new CreateTypeBuilder({
      ...this.#props,
      node: CreateTypeNode.cloneWithEnum(this.#props.node, values)
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile());
  }
}
const DropTypeNode = freeze({
  is(node) {
    return node.kind === "DropTypeNode";
  },
  create(name2) {
    return freeze({
      kind: "DropTypeNode",
      name: name2
    });
  },
  cloneWith(dropType, params) {
    return freeze({
      ...dropType,
      ...params
    });
  }
});
class DropTypeBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  ifExists() {
    return new DropTypeBuilder({
      ...this.#props,
      node: DropTypeNode.cloneWith(this.#props.node, {
        ifExists: true
      })
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile());
  }
}
function parseSchemableIdentifier(id) {
  const SCHEMA_SEPARATOR = ".";
  if (id.includes(SCHEMA_SEPARATOR)) {
    const parts = id.split(SCHEMA_SEPARATOR).map(trim);
    if (parts.length === 2) {
      return SchemableIdentifierNode.createWithSchema(parts[0], parts[1]);
    } else {
      throw new Error(`invalid schemable identifier ${id}`);
    }
  } else {
    return SchemableIdentifierNode.create(id);
  }
}
function trim(str) {
  return str.trim();
}
const RefreshMaterializedViewNode = freeze({
  is(node) {
    return node.kind === "RefreshMaterializedViewNode";
  },
  create(name2) {
    return freeze({
      kind: "RefreshMaterializedViewNode",
      name: SchemableIdentifierNode.create(name2)
    });
  },
  cloneWith(createView2, params) {
    return freeze({
      ...createView2,
      ...params
    });
  }
});
class RefreshMaterializedViewBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  /**
   * Adds the "concurrently" modifier.
   *
   * Use this to refresh the view without locking out concurrent selects on the materialized view.
   *
   * WARNING!
   * This cannot be used with the "with no data" modifier.
   */
  concurrently() {
    return new RefreshMaterializedViewBuilder({
      ...this.#props,
      node: RefreshMaterializedViewNode.cloneWith(this.#props.node, {
        concurrently: true,
        withNoData: false
      })
    });
  }
  /**
   * Adds the "with data" modifier.
   *
   * If specified (or defaults) the backing query is executed to provide the new data, and the materialized view is left in a scannable state
   */
  withData() {
    return new RefreshMaterializedViewBuilder({
      ...this.#props,
      node: RefreshMaterializedViewNode.cloneWith(this.#props.node, {
        withNoData: false
      })
    });
  }
  /**
   * Adds the "with no data" modifier.
   *
   * If specified, no new data is generated and the materialized view is left in an unscannable state.
   *
   * WARNING!
   * This cannot be used with the "concurrently" modifier.
   */
  withNoData() {
    return new RefreshMaterializedViewBuilder({
      ...this.#props,
      node: RefreshMaterializedViewNode.cloneWith(this.#props.node, {
        withNoData: true,
        concurrently: false
      })
    });
  }
  /**
   * Simply calls the provided function passing `this` as the only argument. `$call` returns
   * what the provided function returns.
   */
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile());
  }
}
class SchemaModule {
  #executor;
  constructor(executor) {
    this.#executor = executor;
  }
  /**
   * Create a new table.
   *
   * ### Examples
   *
   * This example creates a new table with columns `id`, `first_name`,
   * `last_name` and `gender`:
   *
   * ```ts
   * await db.schema
   *   .createTable('person')
   *   .addColumn('id', 'integer', col => col.primaryKey().autoIncrement())
   *   .addColumn('first_name', 'varchar', col => col.notNull())
   *   .addColumn('last_name', 'varchar', col => col.notNull())
   *   .addColumn('gender', 'varchar')
   *   .execute()
   * ```
   *
   * This example creates a table with a foreign key. Not all database
   * engines support column-level foreign key constraint definitions.
   * For example if you are using MySQL 5.X see the next example after
   * this one.
   *
   * ```ts
   * await db.schema
   *   .createTable('pet')
   *   .addColumn('id', 'integer', col => col.primaryKey().autoIncrement())
   *   .addColumn('owner_id', 'integer', col => col
   *     .references('person.id')
   *     .onDelete('cascade')
   *   )
   *   .execute()
   * ```
   *
   * This example adds a foreign key constraint for a columns just
   * like the previous example, but using a table-level statement.
   * On MySQL 5.X you need to define foreign key constraints like
   * this:
   *
   * ```ts
   * await db.schema
   *   .createTable('pet')
   *   .addColumn('id', 'integer', col => col.primaryKey().autoIncrement())
   *   .addColumn('owner_id', 'integer')
   *   .addForeignKeyConstraint(
   *     'pet_owner_id_foreign', ['owner_id'], 'person', ['id'],
   *     (constraint) => constraint.onDelete('cascade')
   *   )
   *   .execute()
   * ```
   */
  createTable(table) {
    return new CreateTableBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: CreateTableNode.create(parseTable(table))
    });
  }
  /**
   * Drop a table.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .dropTable('person')
   *   .execute()
   * ```
   */
  dropTable(table) {
    return new DropTableBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: DropTableNode.create(parseTable(table))
    });
  }
  /**
   * Create a new index.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createIndex('person_full_name_unique_index')
   *   .on('person')
   *   .columns(['first_name', 'last_name'])
   *   .execute()
   * ```
   */
  createIndex(indexName) {
    return new CreateIndexBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: CreateIndexNode.create(indexName)
    });
  }
  /**
   * Drop an index.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .dropIndex('person_full_name_unique_index')
   *   .execute()
   * ```
   */
  dropIndex(indexName) {
    return new DropIndexBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: DropIndexNode.create(indexName)
    });
  }
  /**
   * Create a new schema.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createSchema('some_schema')
   *   .execute()
   * ```
   */
  createSchema(schema2) {
    return new CreateSchemaBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: CreateSchemaNode.create(schema2)
    });
  }
  /**
   * Drop a schema.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .dropSchema('some_schema')
   *   .execute()
   * ```
   */
  dropSchema(schema2) {
    return new DropSchemaBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: DropSchemaNode.create(schema2)
    });
  }
  /**
   * Alter a table.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .alterTable('person')
   *   .alterColumn('first_name', (ac) => ac.setDataType('text'))
   *   .execute()
   * ```
   */
  alterTable(table) {
    return new AlterTableBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: AlterTableNode.create(parseTable(table))
    });
  }
  /**
   * Create a new view.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createView('dogs')
   *   .orReplace()
   *   .as(db.selectFrom('pet').selectAll().where('species', '=', 'dog'))
   *   .execute()
   * ```
   */
  createView(viewName) {
    return new CreateViewBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: CreateViewNode.create(viewName)
    });
  }
  /**
   * Refresh a materialized view.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .refreshMaterializedView('my_view')
   *   .concurrently()
   *   .execute()
   * ```
   */
  refreshMaterializedView(viewName) {
    return new RefreshMaterializedViewBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: RefreshMaterializedViewNode.create(viewName)
    });
  }
  /**
   * Drop a view.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .dropView('dogs')
   *   .ifExists()
   *   .execute()
   * ```
   */
  dropView(viewName) {
    return new DropViewBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: DropViewNode.create(viewName)
    });
  }
  /**
   * Create a new type.
   *
   * Only some dialects like PostgreSQL have user-defined types.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .createType('species')
   *   .asEnum(['dog', 'cat', 'frog'])
   *   .execute()
   * ```
   */
  createType(typeName) {
    return new CreateTypeBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: CreateTypeNode.create(parseSchemableIdentifier(typeName))
    });
  }
  /**
   * Drop a type.
   *
   * Only some dialects like PostgreSQL have user-defined types.
   *
   * ### Examples
   *
   * ```ts
   * await db.schema
   *   .dropType('species')
   *   .ifExists()
   *   .execute()
   * ```
   */
  dropType(typeName) {
    return new DropTypeBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: DropTypeNode.create(parseSchemableIdentifier(typeName))
    });
  }
  /**
   * Returns a copy of this schema module with the given plugin installed.
   */
  withPlugin(plugin) {
    return new SchemaModule(this.#executor.withPlugin(plugin));
  }
  /**
   * Returns a copy of this schema module  without any plugins.
   */
  withoutPlugins() {
    return new SchemaModule(this.#executor.withoutPlugins());
  }
  /**
   * See {@link QueryCreator.withSchema}
   */
  withSchema(schema2) {
    return new SchemaModule(this.#executor.withPluginAtFront(new WithSchemaPlugin(schema2)));
  }
}
class DynamicModule {
  /**
   * Creates a dynamic reference to a column that is not know at compile time.
   *
   * Kysely is built in a way that by default you can't refer to tables or columns
   * that are not actually visible in the current query and context. This is all
   * done by TypeScript at compile time, which means that you need to know the
   * columns and tables at compile time. This is not always the case of course.
   *
   * This method is meant to be used in those cases where the column names
   * come from the user input or are not otherwise known at compile time.
   *
   * WARNING! Unlike values, column names are not escaped by the database engine
   * or Kysely and if you pass in unchecked column names using this method, you
   * create an SQL injection vulnerability. Always __always__ validate the user
   * input before passing it to this method.
   *
   * There are couple of examples below for some use cases, but you can pass
   * `ref` to other methods as well. If the types allow you to pass a `ref`
   * value to some place, it should work.
   *
   * ### Examples
   *
   * Filter by a column not know at compile time:
   *
   * ```ts
   * async function someQuery(filterColumn: string, filterValue: string) {
   *   const { ref } = db.dynamic
   *
   *   return await db
   *     .selectFrom('person')
   *     .selectAll()
   *     .where(ref(filterColumn), '=', filterValue)
   *     .execute()
   * }
   *
   * someQuery('first_name', 'Arnold')
   * someQuery('person.last_name', 'Aniston')
   * ```
   *
   * Order by a column not know at compile time:
   *
   * ```ts
   * async function someQuery(orderBy: string) {
   *   const { ref } = db.dynamic
   *
   *   return await db
   *     .selectFrom('person')
   *     .select('person.first_name as fn')
   *     .orderBy(ref(orderBy))
   *     .execute()
   * }
   *
   * someQuery('fn')
   * ```
   *
   * In this example we add selections dynamically:
   *
   * ```ts
   * const { ref } = db.dynamic
   *
   * // Some column name provided by the user. Value not known at compile time.
   * const columnFromUserInput: PossibleColumns = 'birthdate';
   *
   * // A type that lists all possible values `columnFromUserInput` can have.
   * // You can use `keyof Person` if any column of an interface is allowed.
   * type PossibleColumns = 'last_name' | 'first_name' | 'birthdate'
   *
   * const [person] = await db.selectFrom('person')
   *   .select([
   *     ref<PossibleColumns>(columnFromUserInput),
   *     'id'
   *   ])
   *   .execute()
   *
   * // The resulting type contains all `PossibleColumns` as optional fields
   * // because we cannot know which field was actually selected before
   * // running the code.
   * const lastName: string | null | undefined = person?.last_name
   * const firstName: string | undefined = person?.first_name
   * const birthDate: Date | null | undefined = person?.birthdate
   *
   * // The result type also contains the compile time selection `id`.
   * person?.id
   * ```
   */
  ref(reference) {
    return new DynamicReferenceBuilder(reference);
  }
  /**
   * Creates a table reference to a table that's not fully known at compile time.
   *
   * The type `T` is allowed to be a union of multiple tables.
   *
   * <!-- siteExample("select", "Generic find query", 130) -->
   *
   * A generic type-safe helper function for finding a row by a column value:
   *
   * ```ts
   * import { SelectType } from 'kysely'
   * import { Database } from 'type-editor'
   *
   * async function getRowByColumn<
   *   T extends keyof Database,
   *   C extends keyof Database[T] & string,
   *   V extends SelectType<Database[T][C]>,
   * >(t: T, c: C, v: V) {
   *   // We need to use the dynamic module since the table name
   *   // is not known at compile time.
   *   const { table, ref } = db.dynamic
   *
   *   return await db
   *     .selectFrom(table(t).as('t'))
   *     .selectAll()
   *     .where(ref(c), '=', v)
   *     .orderBy('t.id')
   *     .executeTakeFirstOrThrow()
   * }
   *
   * const person = await getRowByColumn('person', 'first_name', 'Arnold')
   * ```
   */
  table(table) {
    return new DynamicTableBuilder(table);
  }
}
class DefaultConnectionProvider {
  #driver;
  constructor(driver) {
    this.#driver = driver;
  }
  async provideConnection(consumer) {
    const connection2 = await this.#driver.acquireConnection();
    try {
      return await consumer(connection2);
    } finally {
      await this.#driver.releaseConnection(connection2);
    }
  }
}
class DefaultQueryExecutor extends QueryExecutorBase {
  #compiler;
  #adapter;
  #connectionProvider;
  constructor(compiler, adapter, connectionProvider, plugins = []) {
    super(plugins);
    this.#compiler = compiler;
    this.#adapter = adapter;
    this.#connectionProvider = connectionProvider;
  }
  get adapter() {
    return this.#adapter;
  }
  compileQuery(node, queryId) {
    return this.#compiler.compileQuery(node, queryId);
  }
  provideConnection(consumer) {
    return this.#connectionProvider.provideConnection(consumer);
  }
  withPlugins(plugins) {
    return new DefaultQueryExecutor(this.#compiler, this.#adapter, this.#connectionProvider, [...this.plugins, ...plugins]);
  }
  withPlugin(plugin) {
    return new DefaultQueryExecutor(this.#compiler, this.#adapter, this.#connectionProvider, [...this.plugins, plugin]);
  }
  withPluginAtFront(plugin) {
    return new DefaultQueryExecutor(this.#compiler, this.#adapter, this.#connectionProvider, [plugin, ...this.plugins]);
  }
  withConnectionProvider(connectionProvider) {
    return new DefaultQueryExecutor(this.#compiler, this.#adapter, connectionProvider, [...this.plugins]);
  }
  withoutPlugins() {
    return new DefaultQueryExecutor(this.#compiler, this.#adapter, this.#connectionProvider, []);
  }
}
function performanceNow() {
  if (typeof performance !== "undefined" && isFunction$1(performance.now)) {
    return performance.now();
  } else {
    return Date.now();
  }
}
class RuntimeDriver {
  #driver;
  #log;
  #initPromise;
  #initDone;
  #destroyPromise;
  #connections = /* @__PURE__ */ new WeakSet();
  constructor(driver, log) {
    this.#initDone = false;
    this.#driver = driver;
    this.#log = log;
  }
  async init() {
    if (this.#destroyPromise) {
      throw new Error("driver has already been destroyed");
    }
    if (!this.#initPromise) {
      this.#initPromise = this.#driver.init().then(() => {
        this.#initDone = true;
      }).catch((err2) => {
        this.#initPromise = void 0;
        return Promise.reject(err2);
      });
    }
    await this.#initPromise;
  }
  async acquireConnection() {
    if (this.#destroyPromise) {
      throw new Error("driver has already been destroyed");
    }
    if (!this.#initDone) {
      await this.init();
    }
    const connection2 = await this.#driver.acquireConnection();
    if (!this.#connections.has(connection2)) {
      if (this.#needsLogging()) {
        this.#addLogging(connection2);
      }
      this.#connections.add(connection2);
    }
    return connection2;
  }
  async releaseConnection(connection2) {
    await this.#driver.releaseConnection(connection2);
  }
  beginTransaction(connection2, settings) {
    return this.#driver.beginTransaction(connection2, settings);
  }
  commitTransaction(connection2) {
    return this.#driver.commitTransaction(connection2);
  }
  rollbackTransaction(connection2) {
    return this.#driver.rollbackTransaction(connection2);
  }
  savepoint(connection2, savepointName, compileQuery) {
    if (this.#driver.savepoint) {
      return this.#driver.savepoint(connection2, savepointName, compileQuery);
    }
    throw new Error("The `savepoint` method is not supported by this driver");
  }
  rollbackToSavepoint(connection2, savepointName, compileQuery) {
    if (this.#driver.rollbackToSavepoint) {
      return this.#driver.rollbackToSavepoint(connection2, savepointName, compileQuery);
    }
    throw new Error("The `rollbackToSavepoint` method is not supported by this driver");
  }
  releaseSavepoint(connection2, savepointName, compileQuery) {
    if (this.#driver.releaseSavepoint) {
      return this.#driver.releaseSavepoint(connection2, savepointName, compileQuery);
    }
    throw new Error("The `releaseSavepoint` method is not supported by this driver");
  }
  async destroy() {
    if (!this.#initPromise) {
      return;
    }
    await this.#initPromise;
    if (!this.#destroyPromise) {
      this.#destroyPromise = this.#driver.destroy().catch((err2) => {
        this.#destroyPromise = void 0;
        return Promise.reject(err2);
      });
    }
    await this.#destroyPromise;
  }
  #needsLogging() {
    return this.#log.isLevelEnabled("query") || this.#log.isLevelEnabled("error");
  }
  // This method monkey patches the database connection's executeQuery method
  // by adding logging code around it. Monkey patching is not pretty, but it's
  // the best option in this case.
  #addLogging(connection2) {
    const executeQuery = connection2.executeQuery;
    const streamQuery = connection2.streamQuery;
    const dis = this;
    connection2.executeQuery = async (compiledQuery) => {
      let caughtError;
      const startTime = performanceNow();
      try {
        return await executeQuery.call(connection2, compiledQuery);
      } catch (error2) {
        caughtError = error2;
        await dis.#logError(error2, compiledQuery, startTime);
        throw error2;
      } finally {
        if (!caughtError) {
          await dis.#logQuery(compiledQuery, startTime);
        }
      }
    };
    connection2.streamQuery = async function* (compiledQuery, chunkSize) {
      let caughtError;
      const startTime = performanceNow();
      try {
        for await (const result2 of streamQuery.call(connection2, compiledQuery, chunkSize)) {
          yield result2;
        }
      } catch (error2) {
        caughtError = error2;
        await dis.#logError(error2, compiledQuery, startTime);
        throw error2;
      } finally {
        if (!caughtError) {
          await dis.#logQuery(compiledQuery, startTime, true);
        }
      }
    };
  }
  async #logError(error2, compiledQuery, startTime) {
    await this.#log.error(() => ({
      level: "error",
      error: error2,
      query: compiledQuery,
      queryDurationMillis: this.#calculateDurationMillis(startTime)
    }));
  }
  async #logQuery(compiledQuery, startTime, isStream = false) {
    await this.#log.query(() => ({
      level: "query",
      isStream,
      query: compiledQuery,
      queryDurationMillis: this.#calculateDurationMillis(startTime)
    }));
  }
  #calculateDurationMillis(startTime) {
    return performanceNow() - startTime;
  }
}
const ignoreError = () => {
};
class SingleConnectionProvider {
  #connection;
  #runningPromise;
  constructor(connection2) {
    this.#connection = connection2;
  }
  async provideConnection(consumer) {
    while (this.#runningPromise) {
      await this.#runningPromise.catch(ignoreError);
    }
    this.#runningPromise = this.#run(consumer).finally(() => {
      this.#runningPromise = void 0;
    });
    return this.#runningPromise;
  }
  // Run the runner in an async function to make sure it doesn't
  // throw synchronous errors.
  async #run(runner) {
    return await runner(this.#connection);
  }
}
const TRANSACTION_ACCESS_MODES = ["read only", "read write"];
const TRANSACTION_ISOLATION_LEVELS = [
  "read uncommitted",
  "read committed",
  "repeatable read",
  "serializable",
  "snapshot"
];
function validateTransactionSettings(settings) {
  if (settings.accessMode && !TRANSACTION_ACCESS_MODES.includes(settings.accessMode)) {
    throw new Error(`invalid transaction access mode ${settings.accessMode}`);
  }
  if (settings.isolationLevel && !TRANSACTION_ISOLATION_LEVELS.includes(settings.isolationLevel)) {
    throw new Error(`invalid transaction isolation level ${settings.isolationLevel}`);
  }
}
const logLevels = ["query", "error"];
freeze(logLevels);
class Log {
  #levels;
  #logger;
  constructor(config2) {
    if (isFunction$1(config2)) {
      this.#logger = config2;
      this.#levels = freeze({
        query: true,
        error: true
      });
    } else {
      this.#logger = defaultLogger$1;
      this.#levels = freeze({
        query: config2.includes("query"),
        error: config2.includes("error")
      });
    }
  }
  isLevelEnabled(level) {
    return this.#levels[level];
  }
  async query(getEvent) {
    if (this.#levels.query) {
      await this.#logger(getEvent());
    }
  }
  async error(getEvent) {
    if (this.#levels.error) {
      await this.#logger(getEvent());
    }
  }
}
function defaultLogger$1(event) {
  if (event.level === "query") {
    const prefix = `kysely:query:${event.isStream ? "stream:" : ""}`;
    console.log(`${prefix} ${event.query.sql}`);
    console.log(`${prefix} duration: ${event.queryDurationMillis.toFixed(1)}ms`);
  } else if (event.level === "error") {
    if (event.error instanceof Error) {
      console.error(`kysely:error: ${event.error.stack ?? event.error.message}`);
    } else {
      console.error(`kysely:error: ${JSON.stringify({
        error: event.error,
        query: event.query.sql,
        queryDurationMillis: event.queryDurationMillis
      })}`);
    }
  }
}
function isCompilable(value) {
  return isObject(value) && isFunction$1(value.compile);
}
Symbol.asyncDispose ??= /* @__PURE__ */ Symbol("Symbol.asyncDispose");
class Kysely extends QueryCreator {
  #props;
  constructor(args) {
    let superProps;
    let props;
    if (isKyselyProps(args)) {
      superProps = { executor: args.executor };
      props = { ...args };
    } else {
      const dialect = args.dialect;
      const driver = dialect.createDriver();
      const compiler = dialect.createQueryCompiler();
      const adapter = dialect.createAdapter();
      const log = new Log(args.log ?? []);
      const runtimeDriver = new RuntimeDriver(driver, log);
      const connectionProvider = new DefaultConnectionProvider(runtimeDriver);
      const executor = new DefaultQueryExecutor(compiler, adapter, connectionProvider, args.plugins ?? []);
      superProps = { executor };
      props = {
        config: args,
        executor,
        dialect,
        driver: runtimeDriver
      };
    }
    super(superProps);
    this.#props = freeze(props);
  }
  /**
   * Returns the {@link SchemaModule} module for building database schema.
   */
  get schema() {
    return new SchemaModule(this.#props.executor);
  }
  /**
   * Returns a the {@link DynamicModule} module.
   *
   * The {@link DynamicModule} module can be used to bypass strict typing and
   * passing in dynamic values for the queries.
   */
  get dynamic() {
    return new DynamicModule();
  }
  /**
   * Returns a {@link DatabaseIntrospector | database introspector}.
   */
  get introspection() {
    return this.#props.dialect.createIntrospector(this.withoutPlugins());
  }
  case(value) {
    return new CaseBuilder({
      node: CaseNode.create(isUndefined$1(value) ? void 0 : parseExpression(value))
    });
  }
  /**
   * Returns a {@link FunctionModule} that can be used to write somewhat type-safe function
   * calls.
   *
   * ```ts
   * const { count } = db.fn
   *
   * await db.selectFrom('person')
   *   .innerJoin('pet', 'pet.owner_id', 'person.id')
   *   .select([
   *     'id',
   *     count('pet.id').as('person_count'),
   *   ])
   *   .groupBy('person.id')
   *   .having(count('pet.id'), '>', 10)
   *   .execute()
   * ```
   *
   * The generated SQL (PostgreSQL):
   *
   * ```sql
   * select "person"."id", count("pet"."id") as "person_count"
   * from "person"
   * inner join "pet" on "pet"."owner_id" = "person"."id"
   * group by "person"."id"
   * having count("pet"."id") > $1
   * ```
   *
   * Why "somewhat" type-safe? Because the function calls are not bound to the
   * current query context. They allow you to reference columns and tables that
   * are not in the current query. E.g. remove the `innerJoin` from the previous
   * query and TypeScript won't even complain.
   *
   * If you want to make the function calls fully type-safe, you can use the
   * {@link ExpressionBuilder.fn} getter for a query context-aware, stricter {@link FunctionModule}.
   *
   * ```ts
   * await db.selectFrom('person')
   *   .innerJoin('pet', 'pet.owner_id', 'person.id')
   *   .select((eb) => [
   *     'person.id',
   *     eb.fn.count('pet.id').as('pet_count')
   *   ])
   *   .groupBy('person.id')
   *   .having((eb) => eb.fn.count('pet.id'), '>', 10)
   *   .execute()
   * ```
   */
  get fn() {
    return createFunctionModule();
  }
  /**
   * Creates a {@link TransactionBuilder} that can be used to run queries inside a transaction.
   *
   * The returned {@link TransactionBuilder} can be used to configure the transaction. The
   * {@link TransactionBuilder.execute} method can then be called to run the transaction.
   * {@link TransactionBuilder.execute} takes a function that is run inside the
   * transaction. If the function throws an exception,
   * 1. the exception is caught,
   * 2. the transaction is rolled back, and
   * 3. the exception is thrown again.
   * Otherwise the transaction is committed.
   *
   * The callback function passed to the {@link TransactionBuilder.execute | execute}
   * method gets the transaction object as its only argument. The transaction is
   * of type {@link Transaction} which inherits {@link Kysely}. Any query
   * started through the transaction object is executed inside the transaction.
   *
   * To run a controlled transaction, allowing you to commit and rollback manually,
   * use {@link startTransaction} instead.
   *
   * ### Examples
   *
   * <!-- siteExample("transactions", "Simple transaction", 10) -->
   *
   * This example inserts two rows in a transaction. If an exception is thrown inside
   * the callback passed to the `execute` method,
   * 1. the exception is caught,
   * 2. the transaction is rolled back, and
   * 3. the exception is thrown again.
   * Otherwise the transaction is committed.
   *
   * ```ts
   * const catto = await db.transaction().execute(async (trx) => {
   *   const jennifer = await trx.insertInto('person')
   *     .values({
   *       first_name: 'Jennifer',
   *       last_name: 'Aniston',
   *       age: 40,
   *     })
   *     .returning('id')
   *     .executeTakeFirstOrThrow()
   *
   *   return await trx.insertInto('pet')
   *     .values({
   *       owner_id: jennifer.id,
   *       name: 'Catto',
   *       species: 'cat',
   *       is_favorite: false,
   *     })
   *     .returningAll()
   *     .executeTakeFirst()
   * })
   * ```
   *
   * Setting the isolation level:
   *
   * ```ts
   * import type { Kysely } from 'kysely'
   *
   * await db
   *   .transaction()
   *   .setIsolationLevel('serializable')
   *   .execute(async (trx) => {
   *     await doStuff(trx)
   *   })
   *
   * async function doStuff(kysely: typeof db) {
   *   // ...
   * }
   * ```
   */
  transaction() {
    return new TransactionBuilder({ ...this.#props });
  }
  /**
   * Creates a {@link ControlledTransactionBuilder} that can be used to run queries inside a controlled transaction.
   *
   * The returned {@link ControlledTransactionBuilder} can be used to configure the transaction.
   * The {@link ControlledTransactionBuilder.execute} method can then be called
   * to start the transaction and return a {@link ControlledTransaction}.
   *
   * A {@link ControlledTransaction} allows you to commit and rollback manually,
   * execute savepoint commands. It extends {@link Transaction} which extends {@link Kysely},
   * so you can run queries inside the transaction. Once the transaction is committed,
   * or rolled back, it can't be used anymore - all queries will throw an error.
   * This is to prevent accidentally running queries outside the transaction - where
   * atomicity is not guaranteed anymore.
   *
   * ### Examples
   *
   * <!-- siteExample("transactions", "Controlled transaction", 11) -->
   *
   * A controlled transaction allows you to commit and rollback manually, execute
   * savepoint commands, and queries in general.
   *
   * In this example we start a transaction, use it to insert two rows and then commit
   * the transaction. If an error is thrown, we catch it and rollback the transaction.
   *
   * ```ts
   * const trx = await db.startTransaction().execute()
   *
   * try {
   *   const jennifer = await trx.insertInto('person')
   *     .values({
   *       first_name: 'Jennifer',
   *       last_name: 'Aniston',
   *       age: 40,
   *     })
   *     .returning('id')
   *     .executeTakeFirstOrThrow()
   *
   *   const catto = await trx.insertInto('pet')
   *     .values({
   *       owner_id: jennifer.id,
   *       name: 'Catto',
   *       species: 'cat',
   *       is_favorite: false,
   *     })
   *     .returningAll()
   *     .executeTakeFirstOrThrow()
   *
   *   await trx.commit().execute()
   *
   *   // ...
   * } catch (error) {
   *   await trx.rollback().execute()
   * }
   * ```
   *
   * <!-- siteExample("transactions", "Controlled transaction /w savepoints", 12) -->
   *
   * A controlled transaction allows you to commit and rollback manually, execute
   * savepoint commands, and queries in general.
   *
   * In this example we start a transaction, insert a person, create a savepoint,
   * try inserting a toy and a pet, and if an error is thrown, we rollback to the
   * savepoint. Eventually we release the savepoint, insert an audit record and
   * commit the transaction. If an error is thrown, we catch it and rollback the
   * transaction.
   *
   * ```ts
   * const trx = await db.startTransaction().execute()
   *
   * try {
   *   const jennifer = await trx
   *     .insertInto('person')
   *     .values({
   *       first_name: 'Jennifer',
   *       last_name: 'Aniston',
   *       age: 40,
   *     })
   *     .returning('id')
   *     .executeTakeFirstOrThrow()
   *
   *   const trxAfterJennifer = await trx.savepoint('after_jennifer').execute()
   *
   *   try {
   *     const catto = await trxAfterJennifer
   *       .insertInto('pet')
   *       .values({
   *         owner_id: jennifer.id,
   *         name: 'Catto',
   *         species: 'cat',
   *       })
   *       .returning('id')
   *       .executeTakeFirstOrThrow()
   *
   *     await trxAfterJennifer
   *       .insertInto('toy')
   *       .values({ name: 'Bone', price: 1.99, pet_id: catto.id })
   *       .execute()
   *   } catch (error) {
   *     await trxAfterJennifer.rollbackToSavepoint('after_jennifer').execute()
   *   }
   *
   *   await trxAfterJennifer.releaseSavepoint('after_jennifer').execute()
   *
   *   await trx.insertInto('audit').values({ action: 'added Jennifer' }).execute()
   *
   *   await trx.commit().execute()
   * } catch (error) {
   *   await trx.rollback().execute()
   * }
   * ```
   */
  startTransaction() {
    return new ControlledTransactionBuilder({ ...this.#props });
  }
  /**
   * Provides a kysely instance bound to a single database connection.
   *
   * ### Examples
   *
   * ```ts
   * await db
   *   .connection()
   *   .execute(async (db) => {
   *     // `db` is an instance of `Kysely` that's bound to a single
   *     // database connection. All queries executed through `db` use
   *     // the same connection.
   *     await doStuff(db)
   *   })
   *
   * async function doStuff(kysely: typeof db) {
   *   // ...
   * }
   * ```
   */
  connection() {
    return new ConnectionBuilder({ ...this.#props });
  }
  /**
   * Returns a copy of this Kysely instance with the given plugin installed.
   */
  withPlugin(plugin) {
    return new Kysely({
      ...this.#props,
      executor: this.#props.executor.withPlugin(plugin)
    });
  }
  /**
   * Returns a copy of this Kysely instance without any plugins.
   */
  withoutPlugins() {
    return new Kysely({
      ...this.#props,
      executor: this.#props.executor.withoutPlugins()
    });
  }
  /**
   * @override
   */
  withSchema(schema2) {
    return new Kysely({
      ...this.#props,
      executor: this.#props.executor.withPluginAtFront(new WithSchemaPlugin(schema2))
    });
  }
  /**
   * Returns a copy of this Kysely instance with tables added to its
   * database type.
   *
   * This method only modifies the types and doesn't affect any of the
   * executed queries in any way.
   *
   * ### Examples
   *
   * The following example adds and uses a temporary table:
   *
   * ```ts
   * await db.schema
   *   .createTable('temp_table')
   *   .temporary()
   *   .addColumn('some_column', 'integer')
   *   .execute()
   *
   * const tempDb = db.withTables<{
   *   temp_table: {
   *     some_column: number
   *   }
   * }>()
   *
   * await tempDb
   *   .insertInto('temp_table')
   *   .values({ some_column: 100 })
   *   .execute()
   * ```
   */
  withTables() {
    return new Kysely({ ...this.#props });
  }
  /**
   * Releases all resources and disconnects from the database.
   *
   * You need to call this when you are done using the `Kysely` instance.
   */
  async destroy() {
    await this.#props.driver.destroy();
  }
  /**
   * Returns true if this `Kysely` instance is a transaction.
   *
   * You can also use `db instanceof Transaction`.
   */
  get isTransaction() {
    return false;
  }
  /**
   * @internal
   * @private
   */
  getExecutor() {
    return this.#props.executor;
  }
  /**
   * Executes a given compiled query or query builder.
   *
   * See {@link https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0004-splitting-query-building-and-execution.md#execute-compiled-queries splitting build, compile and execute code recipe} for more information.
   */
  executeQuery(query2, queryId) {
    if (queryId !== void 0) {
      logOnce("Passing `queryId` in `db.executeQuery` is deprecated and will result in a compile-time error in the future.");
    }
    const compiledQuery = isCompilable(query2) ? query2.compile() : query2;
    return this.getExecutor().executeQuery(compiledQuery);
  }
  async [Symbol.asyncDispose]() {
    await this.destroy();
  }
}
class Transaction extends Kysely {
  #props;
  constructor(props) {
    super(props);
    this.#props = props;
  }
  // The return type is `true` instead of `boolean` to make Kysely<DB>
  // unassignable to Transaction<DB> while allowing assignment the
  // other way around.
  get isTransaction() {
    return true;
  }
  transaction() {
    throw new Error("calling the transaction method for a Transaction is not supported");
  }
  connection() {
    throw new Error("calling the connection method for a Transaction is not supported");
  }
  async destroy() {
    throw new Error("calling the destroy method for a Transaction is not supported");
  }
  withPlugin(plugin) {
    return new Transaction({
      ...this.#props,
      executor: this.#props.executor.withPlugin(plugin)
    });
  }
  withoutPlugins() {
    return new Transaction({
      ...this.#props,
      executor: this.#props.executor.withoutPlugins()
    });
  }
  withSchema(schema2) {
    return new Transaction({
      ...this.#props,
      executor: this.#props.executor.withPluginAtFront(new WithSchemaPlugin(schema2))
    });
  }
  withTables() {
    return new Transaction({ ...this.#props });
  }
}
function isKyselyProps(obj) {
  return isObject(obj) && isObject(obj.config) && isObject(obj.driver) && isObject(obj.executor) && isObject(obj.dialect);
}
class ConnectionBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  async execute(callback) {
    return this.#props.executor.provideConnection(async (connection2) => {
      const executor = this.#props.executor.withConnectionProvider(new SingleConnectionProvider(connection2));
      const db = new Kysely({
        ...this.#props,
        executor
      });
      return await callback(db);
    });
  }
}
class TransactionBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  setAccessMode(accessMode) {
    return new TransactionBuilder({
      ...this.#props,
      accessMode
    });
  }
  setIsolationLevel(isolationLevel) {
    return new TransactionBuilder({
      ...this.#props,
      isolationLevel
    });
  }
  async execute(callback) {
    const { isolationLevel, accessMode, ...kyselyProps } = this.#props;
    const settings = { isolationLevel, accessMode };
    validateTransactionSettings(settings);
    return this.#props.executor.provideConnection(async (connection2) => {
      const state = { isCommitted: false, isRolledBack: false };
      const executor = new NotCommittedOrRolledBackAssertingExecutor(this.#props.executor.withConnectionProvider(new SingleConnectionProvider(connection2)), state);
      const transaction = new Transaction({
        ...kyselyProps,
        executor
      });
      let transactionBegun = false;
      try {
        await this.#props.driver.beginTransaction(connection2, settings);
        transactionBegun = true;
        const result2 = await callback(transaction);
        await this.#props.driver.commitTransaction(connection2);
        state.isCommitted = true;
        return result2;
      } catch (error2) {
        if (transactionBegun) {
          await this.#props.driver.rollbackTransaction(connection2);
          state.isRolledBack = true;
        }
        throw error2;
      }
    });
  }
}
class ControlledTransactionBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  setAccessMode(accessMode) {
    return new ControlledTransactionBuilder({
      ...this.#props,
      accessMode
    });
  }
  setIsolationLevel(isolationLevel) {
    return new ControlledTransactionBuilder({
      ...this.#props,
      isolationLevel
    });
  }
  async execute() {
    const { isolationLevel, accessMode, ...props } = this.#props;
    const settings = { isolationLevel, accessMode };
    validateTransactionSettings(settings);
    const connection2 = await provideControlledConnection(this.#props.executor);
    await this.#props.driver.beginTransaction(connection2.connection, settings);
    return new ControlledTransaction({
      ...props,
      connection: connection2,
      executor: this.#props.executor.withConnectionProvider(new SingleConnectionProvider(connection2.connection))
    });
  }
}
class ControlledTransaction extends Transaction {
  #props;
  #compileQuery;
  #state;
  constructor(props) {
    const state = { isCommitted: false, isRolledBack: false };
    props = {
      ...props,
      executor: new NotCommittedOrRolledBackAssertingExecutor(props.executor, state)
    };
    const { connection: connection2, ...transactionProps } = props;
    super(transactionProps);
    this.#props = freeze(props);
    this.#state = state;
    const queryId = createQueryId();
    this.#compileQuery = (node) => props.executor.compileQuery(node, queryId);
  }
  get isCommitted() {
    return this.#state.isCommitted;
  }
  get isRolledBack() {
    return this.#state.isRolledBack;
  }
  /**
   * Commits the transaction.
   *
   * See {@link rollback}.
   *
   * ### Examples
   *
   * ```ts
   * import type { Kysely } from 'kysely'
   * import type { Database } from 'type-editor' // imaginary module
   *
   * const trx = await db.startTransaction().execute()
   *
   * try {
   *   await doSomething(trx)
   *
   *   await trx.commit().execute()
   * } catch (error) {
   *   await trx.rollback().execute()
   * }
   *
   * async function doSomething(kysely: Kysely<Database>) {}
   * ```
   */
  commit() {
    assertNotCommittedOrRolledBack(this.#state);
    return new Command(async () => {
      await this.#props.driver.commitTransaction(this.#props.connection.connection);
      this.#state.isCommitted = true;
      this.#props.connection.release();
    });
  }
  /**
   * Rolls back the transaction.
   *
   * See {@link commit} and {@link rollbackToSavepoint}.
   *
   * ### Examples
   *
   * ```ts
   * import type { Kysely } from 'kysely'
   * import type { Database } from 'type-editor' // imaginary module
   *
   * const trx = await db.startTransaction().execute()
   *
   * try {
   *   await doSomething(trx)
   *
   *   await trx.commit().execute()
   * } catch (error) {
   *   await trx.rollback().execute()
   * }
   *
   * async function doSomething(kysely: Kysely<Database>) {}
   * ```
   */
  rollback() {
    assertNotCommittedOrRolledBack(this.#state);
    return new Command(async () => {
      await this.#props.driver.rollbackTransaction(this.#props.connection.connection);
      this.#state.isRolledBack = true;
      this.#props.connection.release();
    });
  }
  /**
   * Creates a savepoint with a given name.
   *
   * See {@link rollbackToSavepoint} and {@link releaseSavepoint}.
   *
   * For a type-safe experience, you should use the returned instance from now on.
   *
   * ### Examples
   *
   * ```ts
   * import type { Kysely } from 'kysely'
   * import type { Database } from 'type-editor' // imaginary module
   *
   * const trx = await db.startTransaction().execute()
   *
   * await insertJennifer(trx)
   *
   * const trxAfterJennifer = await trx.savepoint('after_jennifer').execute()
   *
   * try {
   *   await doSomething(trxAfterJennifer)
   * } catch (error) {
   *   await trxAfterJennifer.rollbackToSavepoint('after_jennifer').execute()
   * }
   *
   * async function insertJennifer(kysely: Kysely<Database>) {}
   * async function doSomething(kysely: Kysely<Database>) {}
   * ```
   */
  savepoint(savepointName) {
    assertNotCommittedOrRolledBack(this.#state);
    return new Command(async () => {
      await this.#props.driver.savepoint?.(this.#props.connection.connection, savepointName, this.#compileQuery);
      return new ControlledTransaction({ ...this.#props });
    });
  }
  /**
   * Rolls back to a savepoint with a given name.
   *
   * See {@link savepoint} and {@link releaseSavepoint}.
   *
   * You must use the same instance returned by {@link savepoint}, or
   * escape the type-check by using `as any`.
   *
   * ### Examples
   *
   * ```ts
   * import type { Kysely } from 'kysely'
   * import type { Database } from 'type-editor' // imaginary module
   *
   * const trx = await db.startTransaction().execute()
   *
   * await insertJennifer(trx)
   *
   * const trxAfterJennifer = await trx.savepoint('after_jennifer').execute()
   *
   * try {
   *   await doSomething(trxAfterJennifer)
   * } catch (error) {
   *   await trxAfterJennifer.rollbackToSavepoint('after_jennifer').execute()
   * }
   *
   * async function insertJennifer(kysely: Kysely<Database>) {}
   * async function doSomething(kysely: Kysely<Database>) {}
   * ```
   */
  rollbackToSavepoint(savepointName) {
    assertNotCommittedOrRolledBack(this.#state);
    return new Command(async () => {
      await this.#props.driver.rollbackToSavepoint?.(this.#props.connection.connection, savepointName, this.#compileQuery);
      return new ControlledTransaction({ ...this.#props });
    });
  }
  /**
   * Releases a savepoint with a given name.
   *
   * See {@link savepoint} and {@link rollbackToSavepoint}.
   *
   * You must use the same instance returned by {@link savepoint}, or
   * escape the type-check by using `as any`.
   *
   * ### Examples
   *
   * ```ts
   * import type { Kysely } from 'kysely'
   * import type { Database } from 'type-editor' // imaginary module
   *
   * const trx = await db.startTransaction().execute()
   *
   * await insertJennifer(trx)
   *
   * const trxAfterJennifer = await trx.savepoint('after_jennifer').execute()
   *
   * try {
   *   await doSomething(trxAfterJennifer)
   * } catch (error) {
   *   await trxAfterJennifer.rollbackToSavepoint('after_jennifer').execute()
   * }
   *
   * await trxAfterJennifer.releaseSavepoint('after_jennifer').execute()
   *
   * await doSomethingElse(trx)
   *
   * async function insertJennifer(kysely: Kysely<Database>) {}
   * async function doSomething(kysely: Kysely<Database>) {}
   * async function doSomethingElse(kysely: Kysely<Database>) {}
   * ```
   */
  releaseSavepoint(savepointName) {
    assertNotCommittedOrRolledBack(this.#state);
    return new Command(async () => {
      await this.#props.driver.releaseSavepoint?.(this.#props.connection.connection, savepointName, this.#compileQuery);
      return new ControlledTransaction({ ...this.#props });
    });
  }
  withPlugin(plugin) {
    return new ControlledTransaction({
      ...this.#props,
      executor: this.#props.executor.withPlugin(plugin)
    });
  }
  withoutPlugins() {
    return new ControlledTransaction({
      ...this.#props,
      executor: this.#props.executor.withoutPlugins()
    });
  }
  withSchema(schema2) {
    return new ControlledTransaction({
      ...this.#props,
      executor: this.#props.executor.withPluginAtFront(new WithSchemaPlugin(schema2))
    });
  }
  withTables() {
    return new ControlledTransaction({ ...this.#props });
  }
}
class Command {
  #cb;
  constructor(cb) {
    this.#cb = cb;
  }
  /**
   * Executes the command.
   */
  async execute() {
    return await this.#cb();
  }
}
function assertNotCommittedOrRolledBack(state) {
  if (state.isCommitted) {
    throw new Error("Transaction is already committed");
  }
  if (state.isRolledBack) {
    throw new Error("Transaction is already rolled back");
  }
}
class NotCommittedOrRolledBackAssertingExecutor {
  #executor;
  #state;
  constructor(executor, state) {
    if (executor instanceof NotCommittedOrRolledBackAssertingExecutor) {
      this.#executor = executor.#executor;
    } else {
      this.#executor = executor;
    }
    this.#state = state;
  }
  get adapter() {
    return this.#executor.adapter;
  }
  get plugins() {
    return this.#executor.plugins;
  }
  transformQuery(node, queryId) {
    return this.#executor.transformQuery(node, queryId);
  }
  compileQuery(node, queryId) {
    return this.#executor.compileQuery(node, queryId);
  }
  provideConnection(consumer) {
    return this.#executor.provideConnection(consumer);
  }
  executeQuery(compiledQuery) {
    assertNotCommittedOrRolledBack(this.#state);
    return this.#executor.executeQuery(compiledQuery);
  }
  stream(compiledQuery, chunkSize) {
    assertNotCommittedOrRolledBack(this.#state);
    return this.#executor.stream(compiledQuery, chunkSize);
  }
  withConnectionProvider(connectionProvider) {
    return new NotCommittedOrRolledBackAssertingExecutor(this.#executor.withConnectionProvider(connectionProvider), this.#state);
  }
  withPlugin(plugin) {
    return new NotCommittedOrRolledBackAssertingExecutor(this.#executor.withPlugin(plugin), this.#state);
  }
  withPlugins(plugins) {
    return new NotCommittedOrRolledBackAssertingExecutor(this.#executor.withPlugins(plugins), this.#state);
  }
  withPluginAtFront(plugin) {
    return new NotCommittedOrRolledBackAssertingExecutor(this.#executor.withPluginAtFront(plugin), this.#state);
  }
  withoutPlugins() {
    return new NotCommittedOrRolledBackAssertingExecutor(this.#executor.withoutPlugins(), this.#state);
  }
}
class RawBuilderImpl {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  get expressionType() {
    return void 0;
  }
  get isRawBuilder() {
    return true;
  }
  as(alias2) {
    return new AliasedRawBuilderImpl(this, alias2);
  }
  $castTo() {
    return new RawBuilderImpl({ ...this.#props });
  }
  $notNull() {
    return new RawBuilderImpl(this.#props);
  }
  withPlugin(plugin) {
    return new RawBuilderImpl({
      ...this.#props,
      plugins: this.#props.plugins !== void 0 ? freeze([...this.#props.plugins, plugin]) : freeze([plugin])
    });
  }
  toOperationNode() {
    return this.#toOperationNode(this.#getExecutor());
  }
  compile(executorProvider) {
    return this.#compile(this.#getExecutor(executorProvider));
  }
  async execute(executorProvider) {
    const executor = this.#getExecutor(executorProvider);
    return executor.executeQuery(this.#compile(executor));
  }
  #getExecutor(executorProvider) {
    const executor = executorProvider !== void 0 ? executorProvider.getExecutor() : NOOP_QUERY_EXECUTOR;
    return this.#props.plugins !== void 0 ? executor.withPlugins(this.#props.plugins) : executor;
  }
  #toOperationNode(executor) {
    return executor.transformQuery(this.#props.rawNode, this.#props.queryId);
  }
  #compile(executor) {
    return executor.compileQuery(this.#toOperationNode(executor), this.#props.queryId);
  }
}
function createRawBuilder(props) {
  return new RawBuilderImpl(props);
}
class AliasedRawBuilderImpl {
  #rawBuilder;
  #alias;
  constructor(rawBuilder, alias2) {
    this.#rawBuilder = rawBuilder;
    this.#alias = alias2;
  }
  get expression() {
    return this.#rawBuilder;
  }
  get alias() {
    return this.#alias;
  }
  get rawBuilder() {
    return this.#rawBuilder;
  }
  toOperationNode() {
    return AliasNode.create(this.#rawBuilder.toOperationNode(), isOperationNodeSource(this.#alias) ? this.#alias.toOperationNode() : IdentifierNode.create(this.#alias));
  }
}
const sql = Object.assign((sqlFragments, ...parameters) => {
  return createRawBuilder({
    queryId: createQueryId(),
    rawNode: RawNode.create(sqlFragments, parameters?.map(parseParameter) ?? [])
  });
}, {
  ref(columnReference) {
    return createRawBuilder({
      queryId: createQueryId(),
      rawNode: RawNode.createWithChild(parseStringReference(columnReference))
    });
  },
  val(value) {
    return createRawBuilder({
      queryId: createQueryId(),
      rawNode: RawNode.createWithChild(parseValueExpression(value))
    });
  },
  value(value) {
    return this.val(value);
  },
  table(tableReference) {
    return createRawBuilder({
      queryId: createQueryId(),
      rawNode: RawNode.createWithChild(parseTable(tableReference))
    });
  },
  id(...ids) {
    const fragments = new Array(ids.length + 1).fill(".");
    fragments[0] = "";
    fragments[fragments.length - 1] = "";
    return createRawBuilder({
      queryId: createQueryId(),
      rawNode: RawNode.create(fragments, ids.map(IdentifierNode.create))
    });
  },
  lit(value) {
    return createRawBuilder({
      queryId: createQueryId(),
      rawNode: RawNode.createWithChild(ValueNode.createImmediate(value))
    });
  },
  literal(value) {
    return this.lit(value);
  },
  raw(sql2) {
    return createRawBuilder({
      queryId: createQueryId(),
      rawNode: RawNode.createWithSql(sql2)
    });
  },
  join(array, separator = sql`, `) {
    const nodes = new Array(Math.max(2 * array.length - 1, 0));
    const sep = separator.toOperationNode();
    for (let i = 0; i < array.length; ++i) {
      nodes[2 * i] = parseParameter(array[i]);
      if (i !== array.length - 1) {
        nodes[2 * i + 1] = sep;
      }
    }
    return createRawBuilder({
      queryId: createQueryId(),
      rawNode: RawNode.createWithChildren(nodes)
    });
  }
});
function parseParameter(param) {
  if (isOperationNodeSource(param)) {
    return param.toOperationNode();
  }
  return parseValueExpression(param);
}
class OperationNodeVisitor {
  nodeStack = [];
  get parentNode() {
    return this.nodeStack[this.nodeStack.length - 2];
  }
  #visitors = freeze({
    AliasNode: this.visitAlias.bind(this),
    ColumnNode: this.visitColumn.bind(this),
    IdentifierNode: this.visitIdentifier.bind(this),
    SchemableIdentifierNode: this.visitSchemableIdentifier.bind(this),
    RawNode: this.visitRaw.bind(this),
    ReferenceNode: this.visitReference.bind(this),
    SelectQueryNode: this.visitSelectQuery.bind(this),
    SelectionNode: this.visitSelection.bind(this),
    TableNode: this.visitTable.bind(this),
    FromNode: this.visitFrom.bind(this),
    SelectAllNode: this.visitSelectAll.bind(this),
    AndNode: this.visitAnd.bind(this),
    OrNode: this.visitOr.bind(this),
    ValueNode: this.visitValue.bind(this),
    ValueListNode: this.visitValueList.bind(this),
    PrimitiveValueListNode: this.visitPrimitiveValueList.bind(this),
    ParensNode: this.visitParens.bind(this),
    JoinNode: this.visitJoin.bind(this),
    OperatorNode: this.visitOperator.bind(this),
    WhereNode: this.visitWhere.bind(this),
    InsertQueryNode: this.visitInsertQuery.bind(this),
    DeleteQueryNode: this.visitDeleteQuery.bind(this),
    ReturningNode: this.visitReturning.bind(this),
    CreateTableNode: this.visitCreateTable.bind(this),
    AddColumnNode: this.visitAddColumn.bind(this),
    ColumnDefinitionNode: this.visitColumnDefinition.bind(this),
    DropTableNode: this.visitDropTable.bind(this),
    DataTypeNode: this.visitDataType.bind(this),
    OrderByNode: this.visitOrderBy.bind(this),
    OrderByItemNode: this.visitOrderByItem.bind(this),
    GroupByNode: this.visitGroupBy.bind(this),
    GroupByItemNode: this.visitGroupByItem.bind(this),
    UpdateQueryNode: this.visitUpdateQuery.bind(this),
    ColumnUpdateNode: this.visitColumnUpdate.bind(this),
    LimitNode: this.visitLimit.bind(this),
    OffsetNode: this.visitOffset.bind(this),
    OnConflictNode: this.visitOnConflict.bind(this),
    OnDuplicateKeyNode: this.visitOnDuplicateKey.bind(this),
    CreateIndexNode: this.visitCreateIndex.bind(this),
    DropIndexNode: this.visitDropIndex.bind(this),
    ListNode: this.visitList.bind(this),
    PrimaryKeyConstraintNode: this.visitPrimaryKeyConstraint.bind(this),
    UniqueConstraintNode: this.visitUniqueConstraint.bind(this),
    ReferencesNode: this.visitReferences.bind(this),
    CheckConstraintNode: this.visitCheckConstraint.bind(this),
    WithNode: this.visitWith.bind(this),
    CommonTableExpressionNode: this.visitCommonTableExpression.bind(this),
    CommonTableExpressionNameNode: this.visitCommonTableExpressionName.bind(this),
    HavingNode: this.visitHaving.bind(this),
    CreateSchemaNode: this.visitCreateSchema.bind(this),
    DropSchemaNode: this.visitDropSchema.bind(this),
    AlterTableNode: this.visitAlterTable.bind(this),
    DropColumnNode: this.visitDropColumn.bind(this),
    RenameColumnNode: this.visitRenameColumn.bind(this),
    AlterColumnNode: this.visitAlterColumn.bind(this),
    ModifyColumnNode: this.visitModifyColumn.bind(this),
    AddConstraintNode: this.visitAddConstraint.bind(this),
    DropConstraintNode: this.visitDropConstraint.bind(this),
    RenameConstraintNode: this.visitRenameConstraint.bind(this),
    ForeignKeyConstraintNode: this.visitForeignKeyConstraint.bind(this),
    CreateViewNode: this.visitCreateView.bind(this),
    RefreshMaterializedViewNode: this.visitRefreshMaterializedView.bind(this),
    DropViewNode: this.visitDropView.bind(this),
    GeneratedNode: this.visitGenerated.bind(this),
    DefaultValueNode: this.visitDefaultValue.bind(this),
    OnNode: this.visitOn.bind(this),
    ValuesNode: this.visitValues.bind(this),
    SelectModifierNode: this.visitSelectModifier.bind(this),
    CreateTypeNode: this.visitCreateType.bind(this),
    DropTypeNode: this.visitDropType.bind(this),
    ExplainNode: this.visitExplain.bind(this),
    DefaultInsertValueNode: this.visitDefaultInsertValue.bind(this),
    AggregateFunctionNode: this.visitAggregateFunction.bind(this),
    OverNode: this.visitOver.bind(this),
    PartitionByNode: this.visitPartitionBy.bind(this),
    PartitionByItemNode: this.visitPartitionByItem.bind(this),
    SetOperationNode: this.visitSetOperation.bind(this),
    BinaryOperationNode: this.visitBinaryOperation.bind(this),
    UnaryOperationNode: this.visitUnaryOperation.bind(this),
    UsingNode: this.visitUsing.bind(this),
    FunctionNode: this.visitFunction.bind(this),
    CaseNode: this.visitCase.bind(this),
    WhenNode: this.visitWhen.bind(this),
    JSONReferenceNode: this.visitJSONReference.bind(this),
    JSONPathNode: this.visitJSONPath.bind(this),
    JSONPathLegNode: this.visitJSONPathLeg.bind(this),
    JSONOperatorChainNode: this.visitJSONOperatorChain.bind(this),
    TupleNode: this.visitTuple.bind(this),
    MergeQueryNode: this.visitMergeQuery.bind(this),
    MatchedNode: this.visitMatched.bind(this),
    AddIndexNode: this.visitAddIndex.bind(this),
    CastNode: this.visitCast.bind(this),
    FetchNode: this.visitFetch.bind(this),
    TopNode: this.visitTop.bind(this),
    OutputNode: this.visitOutput.bind(this),
    OrActionNode: this.visitOrAction.bind(this),
    CollateNode: this.visitCollate.bind(this)
  });
  visitNode = (node) => {
    this.nodeStack.push(node);
    this.#visitors[node.kind](node);
    this.nodeStack.pop();
  };
}
const LIT_WRAP_REGEX = /'/g;
class DefaultQueryCompiler extends OperationNodeVisitor {
  #sql = "";
  #parameters = [];
  get numParameters() {
    return this.#parameters.length;
  }
  compileQuery(node, queryId) {
    this.#sql = "";
    this.#parameters = [];
    this.nodeStack.splice(0, this.nodeStack.length);
    this.visitNode(node);
    return freeze({
      query: node,
      queryId,
      sql: this.getSql(),
      parameters: [...this.#parameters]
    });
  }
  getSql() {
    return this.#sql;
  }
  visitSelectQuery(node) {
    const wrapInParens = this.parentNode !== void 0 && !ParensNode.is(this.parentNode) && !InsertQueryNode.is(this.parentNode) && !CreateTableNode.is(this.parentNode) && !CreateViewNode.is(this.parentNode) && !SetOperationNode.is(this.parentNode);
    if (this.parentNode === void 0 && node.explain) {
      this.visitNode(node.explain);
      this.append(" ");
    }
    if (wrapInParens) {
      this.append("(");
    }
    if (node.with) {
      this.visitNode(node.with);
      this.append(" ");
    }
    this.append("select");
    if (node.distinctOn) {
      this.append(" ");
      this.compileDistinctOn(node.distinctOn);
    }
    if (node.frontModifiers?.length) {
      this.append(" ");
      this.compileList(node.frontModifiers, " ");
    }
    if (node.top) {
      this.append(" ");
      this.visitNode(node.top);
    }
    if (node.selections) {
      this.append(" ");
      this.compileList(node.selections);
    }
    if (node.from) {
      this.append(" ");
      this.visitNode(node.from);
    }
    if (node.joins) {
      this.append(" ");
      this.compileList(node.joins, " ");
    }
    if (node.where) {
      this.append(" ");
      this.visitNode(node.where);
    }
    if (node.groupBy) {
      this.append(" ");
      this.visitNode(node.groupBy);
    }
    if (node.having) {
      this.append(" ");
      this.visitNode(node.having);
    }
    if (node.setOperations) {
      this.append(" ");
      this.compileList(node.setOperations, " ");
    }
    if (node.orderBy) {
      this.append(" ");
      this.visitNode(node.orderBy);
    }
    if (node.limit) {
      this.append(" ");
      this.visitNode(node.limit);
    }
    if (node.offset) {
      this.append(" ");
      this.visitNode(node.offset);
    }
    if (node.fetch) {
      this.append(" ");
      this.visitNode(node.fetch);
    }
    if (node.endModifiers?.length) {
      this.append(" ");
      this.compileList(this.sortSelectModifiers([...node.endModifiers]), " ");
    }
    if (wrapInParens) {
      this.append(")");
    }
  }
  visitFrom(node) {
    this.append("from ");
    this.compileList(node.froms);
  }
  visitSelection(node) {
    this.visitNode(node.selection);
  }
  visitColumn(node) {
    this.visitNode(node.column);
  }
  compileDistinctOn(expressions) {
    this.append("distinct on (");
    this.compileList(expressions);
    this.append(")");
  }
  compileList(nodes, separator = ", ") {
    const lastIndex = nodes.length - 1;
    for (let i = 0; i <= lastIndex; i++) {
      this.visitNode(nodes[i]);
      if (i < lastIndex) {
        this.append(separator);
      }
    }
  }
  visitWhere(node) {
    this.append("where ");
    this.visitNode(node.where);
  }
  visitHaving(node) {
    this.append("having ");
    this.visitNode(node.having);
  }
  visitInsertQuery(node) {
    const wrapInParens = this.parentNode !== void 0 && !ParensNode.is(this.parentNode) && !RawNode.is(this.parentNode) && !WhenNode.is(this.parentNode);
    if (this.parentNode === void 0 && node.explain) {
      this.visitNode(node.explain);
      this.append(" ");
    }
    if (wrapInParens) {
      this.append("(");
    }
    if (node.with) {
      this.visitNode(node.with);
      this.append(" ");
    }
    this.append(node.replace ? "replace" : "insert");
    if (node.ignore) {
      logOnce("`InsertQueryNode.ignore` is deprecated. Use `InsertQueryNode.orAction` instead.");
      this.append(" ignore");
    }
    if (node.orAction) {
      this.append(" ");
      this.visitNode(node.orAction);
    }
    if (node.top) {
      this.append(" ");
      this.visitNode(node.top);
    }
    if (node.into) {
      this.append(" into ");
      this.visitNode(node.into);
    }
    if (node.columns) {
      this.append(" (");
      this.compileList(node.columns);
      this.append(")");
    }
    if (node.output) {
      this.append(" ");
      this.visitNode(node.output);
    }
    if (node.values) {
      this.append(" ");
      this.visitNode(node.values);
    }
    if (node.defaultValues) {
      this.append(" ");
      this.append("default values");
    }
    if (node.onConflict) {
      this.append(" ");
      this.visitNode(node.onConflict);
    }
    if (node.onDuplicateKey) {
      this.append(" ");
      this.visitNode(node.onDuplicateKey);
    }
    if (node.returning) {
      this.append(" ");
      this.visitNode(node.returning);
    }
    if (wrapInParens) {
      this.append(")");
    }
    if (node.endModifiers?.length) {
      this.append(" ");
      this.compileList(node.endModifiers, " ");
    }
  }
  visitValues(node) {
    this.append("values ");
    this.compileList(node.values);
  }
  visitDeleteQuery(node) {
    const wrapInParens = this.parentNode !== void 0 && !ParensNode.is(this.parentNode) && !RawNode.is(this.parentNode);
    if (this.parentNode === void 0 && node.explain) {
      this.visitNode(node.explain);
      this.append(" ");
    }
    if (wrapInParens) {
      this.append("(");
    }
    if (node.with) {
      this.visitNode(node.with);
      this.append(" ");
    }
    this.append("delete ");
    if (node.top) {
      this.visitNode(node.top);
      this.append(" ");
    }
    this.visitNode(node.from);
    if (node.output) {
      this.append(" ");
      this.visitNode(node.output);
    }
    if (node.using) {
      this.append(" ");
      this.visitNode(node.using);
    }
    if (node.joins) {
      this.append(" ");
      this.compileList(node.joins, " ");
    }
    if (node.where) {
      this.append(" ");
      this.visitNode(node.where);
    }
    if (node.orderBy) {
      this.append(" ");
      this.visitNode(node.orderBy);
    }
    if (node.limit) {
      this.append(" ");
      this.visitNode(node.limit);
    }
    if (node.returning) {
      this.append(" ");
      this.visitNode(node.returning);
    }
    if (wrapInParens) {
      this.append(")");
    }
    if (node.endModifiers?.length) {
      this.append(" ");
      this.compileList(node.endModifiers, " ");
    }
  }
  visitReturning(node) {
    this.append("returning ");
    this.compileList(node.selections);
  }
  visitAlias(node) {
    this.visitNode(node.node);
    this.append(" as ");
    this.visitNode(node.alias);
  }
  visitReference(node) {
    if (node.table) {
      this.visitNode(node.table);
      this.append(".");
    }
    this.visitNode(node.column);
  }
  visitSelectAll(_) {
    this.append("*");
  }
  visitIdentifier(node) {
    this.append(this.getLeftIdentifierWrapper());
    this.compileUnwrappedIdentifier(node);
    this.append(this.getRightIdentifierWrapper());
  }
  compileUnwrappedIdentifier(node) {
    if (!isString$1(node.name)) {
      throw new Error("a non-string identifier was passed to compileUnwrappedIdentifier.");
    }
    this.append(this.sanitizeIdentifier(node.name));
  }
  visitAnd(node) {
    this.visitNode(node.left);
    this.append(" and ");
    this.visitNode(node.right);
  }
  visitOr(node) {
    this.visitNode(node.left);
    this.append(" or ");
    this.visitNode(node.right);
  }
  visitValue(node) {
    if (node.immediate) {
      this.appendImmediateValue(node.value);
    } else {
      this.appendValue(node.value);
    }
  }
  visitValueList(node) {
    this.append("(");
    this.compileList(node.values);
    this.append(")");
  }
  visitTuple(node) {
    this.append("(");
    this.compileList(node.values);
    this.append(")");
  }
  visitPrimitiveValueList(node) {
    this.append("(");
    const { values } = node;
    for (let i = 0; i < values.length; ++i) {
      this.appendValue(values[i]);
      if (i !== values.length - 1) {
        this.append(", ");
      }
    }
    this.append(")");
  }
  visitParens(node) {
    this.append("(");
    this.visitNode(node.node);
    this.append(")");
  }
  visitJoin(node) {
    this.append(JOIN_TYPE_SQL[node.joinType]);
    this.append(" ");
    this.visitNode(node.table);
    if (node.on) {
      this.append(" ");
      this.visitNode(node.on);
    }
  }
  visitOn(node) {
    this.append("on ");
    this.visitNode(node.on);
  }
  visitRaw(node) {
    const { sqlFragments, parameters: params } = node;
    for (let i = 0; i < sqlFragments.length; ++i) {
      this.append(sqlFragments[i]);
      if (params.length > i) {
        this.visitNode(params[i]);
      }
    }
  }
  visitOperator(node) {
    this.append(node.operator);
  }
  visitTable(node) {
    this.visitNode(node.table);
  }
  visitSchemableIdentifier(node) {
    if (node.schema) {
      this.visitNode(node.schema);
      this.append(".");
    }
    this.visitNode(node.identifier);
  }
  visitCreateTable(node) {
    this.append("create ");
    if (node.frontModifiers && node.frontModifiers.length > 0) {
      this.compileList(node.frontModifiers, " ");
      this.append(" ");
    }
    if (node.temporary) {
      this.append("temporary ");
    }
    this.append("table ");
    if (node.ifNotExists) {
      this.append("if not exists ");
    }
    this.visitNode(node.table);
    if (node.selectQuery) {
      this.append(" as ");
      this.visitNode(node.selectQuery);
    } else {
      this.append(" (");
      this.compileList([...node.columns, ...node.constraints ?? []]);
      this.append(")");
      if (node.onCommit) {
        this.append(" on commit ");
        this.append(node.onCommit);
      }
      if (node.endModifiers && node.endModifiers.length > 0) {
        this.append(" ");
        this.compileList(node.endModifiers, " ");
      }
    }
  }
  visitColumnDefinition(node) {
    if (node.ifNotExists) {
      this.append("if not exists ");
    }
    this.visitNode(node.column);
    this.append(" ");
    this.visitNode(node.dataType);
    if (node.unsigned) {
      this.append(" unsigned");
    }
    if (node.frontModifiers && node.frontModifiers.length > 0) {
      this.append(" ");
      this.compileList(node.frontModifiers, " ");
    }
    if (node.generated) {
      this.append(" ");
      this.visitNode(node.generated);
    }
    if (node.identity) {
      this.append(" identity");
    }
    if (node.defaultTo) {
      this.append(" ");
      this.visitNode(node.defaultTo);
    }
    if (node.notNull) {
      this.append(" not null");
    }
    if (node.unique) {
      this.append(" unique");
    }
    if (node.nullsNotDistinct) {
      this.append(" nulls not distinct");
    }
    if (node.primaryKey) {
      this.append(" primary key");
    }
    if (node.autoIncrement) {
      this.append(" ");
      this.append(this.getAutoIncrement());
    }
    if (node.references) {
      this.append(" ");
      this.visitNode(node.references);
    }
    if (node.check) {
      this.append(" ");
      this.visitNode(node.check);
    }
    if (node.endModifiers && node.endModifiers.length > 0) {
      this.append(" ");
      this.compileList(node.endModifiers, " ");
    }
  }
  getAutoIncrement() {
    return "auto_increment";
  }
  visitReferences(node) {
    this.append("references ");
    this.visitNode(node.table);
    this.append(" (");
    this.compileList(node.columns);
    this.append(")");
    if (node.onDelete) {
      this.append(" on delete ");
      this.append(node.onDelete);
    }
    if (node.onUpdate) {
      this.append(" on update ");
      this.append(node.onUpdate);
    }
  }
  visitDropTable(node) {
    this.append("drop table ");
    if (node.ifExists) {
      this.append("if exists ");
    }
    this.visitNode(node.table);
    if (node.cascade) {
      this.append(" cascade");
    }
  }
  visitDataType(node) {
    this.append(node.dataType);
  }
  visitOrderBy(node) {
    this.append("order by ");
    this.compileList(node.items);
  }
  visitOrderByItem(node) {
    this.visitNode(node.orderBy);
    if (node.collation) {
      this.append(" ");
      this.visitNode(node.collation);
    }
    if (node.direction) {
      this.append(" ");
      this.visitNode(node.direction);
    }
    if (node.nulls) {
      this.append(" nulls ");
      this.append(node.nulls);
    }
  }
  visitGroupBy(node) {
    this.append("group by ");
    this.compileList(node.items);
  }
  visitGroupByItem(node) {
    this.visitNode(node.groupBy);
  }
  visitUpdateQuery(node) {
    const wrapInParens = this.parentNode !== void 0 && !ParensNode.is(this.parentNode) && !RawNode.is(this.parentNode) && !WhenNode.is(this.parentNode);
    if (this.parentNode === void 0 && node.explain) {
      this.visitNode(node.explain);
      this.append(" ");
    }
    if (wrapInParens) {
      this.append("(");
    }
    if (node.with) {
      this.visitNode(node.with);
      this.append(" ");
    }
    this.append("update ");
    if (node.top) {
      this.visitNode(node.top);
      this.append(" ");
    }
    if (node.table) {
      this.visitNode(node.table);
      this.append(" ");
    }
    this.append("set ");
    if (node.updates) {
      this.compileList(node.updates);
    }
    if (node.output) {
      this.append(" ");
      this.visitNode(node.output);
    }
    if (node.from) {
      this.append(" ");
      this.visitNode(node.from);
    }
    if (node.joins) {
      if (!node.from) {
        throw new Error("Joins in an update query are only supported as a part of a PostgreSQL 'update set from join' query. If you want to create a MySQL 'update join set' query, see https://kysely.dev/docs/examples/update/my-sql-joins");
      }
      this.append(" ");
      this.compileList(node.joins, " ");
    }
    if (node.where) {
      this.append(" ");
      this.visitNode(node.where);
    }
    if (node.returning) {
      this.append(" ");
      this.visitNode(node.returning);
    }
    if (node.orderBy) {
      this.append(" ");
      this.visitNode(node.orderBy);
    }
    if (node.limit) {
      this.append(" ");
      this.visitNode(node.limit);
    }
    if (wrapInParens) {
      this.append(")");
    }
    if (node.endModifiers?.length) {
      this.append(" ");
      this.compileList(node.endModifiers, " ");
    }
  }
  visitColumnUpdate(node) {
    this.visitNode(node.column);
    this.append(" = ");
    this.visitNode(node.value);
  }
  visitLimit(node) {
    this.append("limit ");
    this.visitNode(node.limit);
  }
  visitOffset(node) {
    this.append("offset ");
    this.visitNode(node.offset);
  }
  visitOnConflict(node) {
    this.append("on conflict");
    if (node.columns) {
      this.append(" (");
      this.compileList(node.columns);
      this.append(")");
    } else if (node.constraint) {
      this.append(" on constraint ");
      this.visitNode(node.constraint);
    } else if (node.indexExpression) {
      this.append(" (");
      this.visitNode(node.indexExpression);
      this.append(")");
    }
    if (node.indexWhere) {
      this.append(" ");
      this.visitNode(node.indexWhere);
    }
    if (node.doNothing === true) {
      this.append(" do nothing");
    } else if (node.updates) {
      this.append(" do update set ");
      this.compileList(node.updates);
      if (node.updateWhere) {
        this.append(" ");
        this.visitNode(node.updateWhere);
      }
    }
  }
  visitOnDuplicateKey(node) {
    this.append("on duplicate key update ");
    this.compileList(node.updates);
  }
  visitCreateIndex(node) {
    this.append("create ");
    if (node.unique) {
      this.append("unique ");
    }
    this.append("index ");
    if (node.ifNotExists) {
      this.append("if not exists ");
    }
    this.visitNode(node.name);
    if (node.table) {
      this.append(" on ");
      this.visitNode(node.table);
    }
    if (node.using) {
      this.append(" using ");
      this.visitNode(node.using);
    }
    if (node.columns) {
      this.append(" (");
      this.compileList(node.columns);
      this.append(")");
    }
    if (node.nullsNotDistinct) {
      this.append(" nulls not distinct");
    }
    if (node.where) {
      this.append(" ");
      this.visitNode(node.where);
    }
  }
  visitDropIndex(node) {
    this.append("drop index ");
    if (node.ifExists) {
      this.append("if exists ");
    }
    this.visitNode(node.name);
    if (node.table) {
      this.append(" on ");
      this.visitNode(node.table);
    }
    if (node.cascade) {
      this.append(" cascade");
    }
  }
  visitCreateSchema(node) {
    this.append("create schema ");
    if (node.ifNotExists) {
      this.append("if not exists ");
    }
    this.visitNode(node.schema);
  }
  visitDropSchema(node) {
    this.append("drop schema ");
    if (node.ifExists) {
      this.append("if exists ");
    }
    this.visitNode(node.schema);
    if (node.cascade) {
      this.append(" cascade");
    }
  }
  visitPrimaryKeyConstraint(node) {
    if (node.name) {
      this.append("constraint ");
      this.visitNode(node.name);
      this.append(" ");
    }
    this.append("primary key (");
    this.compileList(node.columns);
    this.append(")");
    this.buildDeferrable(node);
  }
  buildDeferrable(node) {
    if (node.deferrable !== void 0) {
      if (node.deferrable) {
        this.append(" deferrable");
      } else {
        this.append(" not deferrable");
      }
    }
    if (node.initiallyDeferred !== void 0) {
      if (node.initiallyDeferred) {
        this.append(" initially deferred");
      } else {
        this.append(" initially immediate");
      }
    }
  }
  visitUniqueConstraint(node) {
    if (node.name) {
      this.append("constraint ");
      this.visitNode(node.name);
      this.append(" ");
    }
    this.append("unique");
    if (node.nullsNotDistinct) {
      this.append(" nulls not distinct");
    }
    this.append(" (");
    this.compileList(node.columns);
    this.append(")");
    this.buildDeferrable(node);
  }
  visitCheckConstraint(node) {
    if (node.name) {
      this.append("constraint ");
      this.visitNode(node.name);
      this.append(" ");
    }
    this.append("check (");
    this.visitNode(node.expression);
    this.append(")");
  }
  visitForeignKeyConstraint(node) {
    if (node.name) {
      this.append("constraint ");
      this.visitNode(node.name);
      this.append(" ");
    }
    this.append("foreign key (");
    this.compileList(node.columns);
    this.append(") ");
    this.visitNode(node.references);
    if (node.onDelete) {
      this.append(" on delete ");
      this.append(node.onDelete);
    }
    if (node.onUpdate) {
      this.append(" on update ");
      this.append(node.onUpdate);
    }
    this.buildDeferrable(node);
  }
  visitList(node) {
    this.compileList(node.items);
  }
  visitWith(node) {
    this.append("with ");
    if (node.recursive) {
      this.append("recursive ");
    }
    this.compileList(node.expressions);
  }
  visitCommonTableExpression(node) {
    this.visitNode(node.name);
    this.append(" as ");
    if (isBoolean(node.materialized)) {
      if (!node.materialized) {
        this.append("not ");
      }
      this.append("materialized ");
    }
    this.visitNode(node.expression);
  }
  visitCommonTableExpressionName(node) {
    this.visitNode(node.table);
    if (node.columns) {
      this.append("(");
      this.compileList(node.columns);
      this.append(")");
    }
  }
  visitAlterTable(node) {
    this.append("alter table ");
    this.visitNode(node.table);
    this.append(" ");
    if (node.renameTo) {
      this.append("rename to ");
      this.visitNode(node.renameTo);
    }
    if (node.setSchema) {
      this.append("set schema ");
      this.visitNode(node.setSchema);
    }
    if (node.addConstraint) {
      this.visitNode(node.addConstraint);
    }
    if (node.dropConstraint) {
      this.visitNode(node.dropConstraint);
    }
    if (node.renameConstraint) {
      this.visitNode(node.renameConstraint);
    }
    if (node.columnAlterations) {
      this.compileColumnAlterations(node.columnAlterations);
    }
    if (node.addIndex) {
      this.visitNode(node.addIndex);
    }
    if (node.dropIndex) {
      this.visitNode(node.dropIndex);
    }
  }
  visitAddColumn(node) {
    this.append("add column ");
    this.visitNode(node.column);
  }
  visitRenameColumn(node) {
    this.append("rename column ");
    this.visitNode(node.column);
    this.append(" to ");
    this.visitNode(node.renameTo);
  }
  visitDropColumn(node) {
    this.append("drop column ");
    this.visitNode(node.column);
  }
  visitAlterColumn(node) {
    this.append("alter column ");
    this.visitNode(node.column);
    this.append(" ");
    if (node.dataType) {
      if (this.announcesNewColumnDataType()) {
        this.append("type ");
      }
      this.visitNode(node.dataType);
      if (node.dataTypeExpression) {
        this.append("using ");
        this.visitNode(node.dataTypeExpression);
      }
    }
    if (node.setDefault) {
      this.append("set default ");
      this.visitNode(node.setDefault);
    }
    if (node.dropDefault) {
      this.append("drop default");
    }
    if (node.setNotNull) {
      this.append("set not null");
    }
    if (node.dropNotNull) {
      this.append("drop not null");
    }
  }
  visitModifyColumn(node) {
    this.append("modify column ");
    this.visitNode(node.column);
  }
  visitAddConstraint(node) {
    this.append("add ");
    this.visitNode(node.constraint);
  }
  visitDropConstraint(node) {
    this.append("drop constraint ");
    if (node.ifExists) {
      this.append("if exists ");
    }
    this.visitNode(node.constraintName);
    if (node.modifier === "cascade") {
      this.append(" cascade");
    } else if (node.modifier === "restrict") {
      this.append(" restrict");
    }
  }
  visitRenameConstraint(node) {
    this.append("rename constraint ");
    this.visitNode(node.oldName);
    this.append(" to ");
    this.visitNode(node.newName);
  }
  visitSetOperation(node) {
    this.append(node.operator);
    this.append(" ");
    if (node.all) {
      this.append("all ");
    }
    this.visitNode(node.expression);
  }
  visitCreateView(node) {
    this.append("create ");
    if (node.orReplace) {
      this.append("or replace ");
    }
    if (node.materialized) {
      this.append("materialized ");
    }
    if (node.temporary) {
      this.append("temporary ");
    }
    this.append("view ");
    if (node.ifNotExists) {
      this.append("if not exists ");
    }
    this.visitNode(node.name);
    this.append(" ");
    if (node.columns) {
      this.append("(");
      this.compileList(node.columns);
      this.append(") ");
    }
    if (node.as) {
      this.append("as ");
      this.visitNode(node.as);
    }
  }
  visitRefreshMaterializedView(node) {
    this.append("refresh materialized view ");
    if (node.concurrently) {
      this.append("concurrently ");
    }
    this.visitNode(node.name);
    if (node.withNoData) {
      this.append(" with no data");
    } else {
      this.append(" with data");
    }
  }
  visitDropView(node) {
    this.append("drop ");
    if (node.materialized) {
      this.append("materialized ");
    }
    this.append("view ");
    if (node.ifExists) {
      this.append("if exists ");
    }
    this.visitNode(node.name);
    if (node.cascade) {
      this.append(" cascade");
    }
  }
  visitGenerated(node) {
    this.append("generated ");
    if (node.always) {
      this.append("always ");
    }
    if (node.byDefault) {
      this.append("by default ");
    }
    this.append("as ");
    if (node.identity) {
      this.append("identity");
    }
    if (node.expression) {
      this.append("(");
      this.visitNode(node.expression);
      this.append(")");
    }
    if (node.stored) {
      this.append(" stored");
    }
  }
  visitDefaultValue(node) {
    this.append("default ");
    this.visitNode(node.defaultValue);
  }
  visitSelectModifier(node) {
    if (node.rawModifier) {
      this.visitNode(node.rawModifier);
    } else {
      this.append(SELECT_MODIFIER_SQL[node.modifier]);
    }
    if (node.of) {
      this.append(" of ");
      this.compileList(node.of, ", ");
    }
  }
  visitCreateType(node) {
    this.append("create type ");
    this.visitNode(node.name);
    if (node.enum) {
      this.append(" as enum ");
      this.visitNode(node.enum);
    }
  }
  visitDropType(node) {
    this.append("drop type ");
    if (node.ifExists) {
      this.append("if exists ");
    }
    this.visitNode(node.name);
  }
  visitExplain(node) {
    this.append("explain");
    if (node.options || node.format) {
      this.append(" ");
      this.append(this.getLeftExplainOptionsWrapper());
      if (node.options) {
        this.visitNode(node.options);
        if (node.format) {
          this.append(this.getExplainOptionsDelimiter());
        }
      }
      if (node.format) {
        this.append("format");
        this.append(this.getExplainOptionAssignment());
        this.append(node.format);
      }
      this.append(this.getRightExplainOptionsWrapper());
    }
  }
  visitDefaultInsertValue(_) {
    this.append("default");
  }
  visitAggregateFunction(node) {
    this.append(node.func);
    this.append("(");
    if (node.distinct) {
      this.append("distinct ");
    }
    this.compileList(node.aggregated);
    if (node.orderBy) {
      this.append(" ");
      this.visitNode(node.orderBy);
    }
    this.append(")");
    if (node.withinGroup) {
      this.append(" within group (");
      this.visitNode(node.withinGroup);
      this.append(")");
    }
    if (node.filter) {
      this.append(" filter(");
      this.visitNode(node.filter);
      this.append(")");
    }
    if (node.over) {
      this.append(" ");
      this.visitNode(node.over);
    }
  }
  visitOver(node) {
    this.append("over(");
    if (node.partitionBy) {
      this.visitNode(node.partitionBy);
      if (node.orderBy) {
        this.append(" ");
      }
    }
    if (node.orderBy) {
      this.visitNode(node.orderBy);
    }
    this.append(")");
  }
  visitPartitionBy(node) {
    this.append("partition by ");
    this.compileList(node.items);
  }
  visitPartitionByItem(node) {
    this.visitNode(node.partitionBy);
  }
  visitBinaryOperation(node) {
    this.visitNode(node.leftOperand);
    this.append(" ");
    this.visitNode(node.operator);
    this.append(" ");
    this.visitNode(node.rightOperand);
  }
  visitUnaryOperation(node) {
    this.visitNode(node.operator);
    if (!this.isMinusOperator(node.operator)) {
      this.append(" ");
    }
    this.visitNode(node.operand);
  }
  isMinusOperator(node) {
    return OperatorNode.is(node) && node.operator === "-";
  }
  visitUsing(node) {
    this.append("using ");
    this.compileList(node.tables);
  }
  visitFunction(node) {
    this.append(node.func);
    this.append("(");
    this.compileList(node.arguments);
    this.append(")");
  }
  visitCase(node) {
    this.append("case");
    if (node.value) {
      this.append(" ");
      this.visitNode(node.value);
    }
    if (node.when) {
      this.append(" ");
      this.compileList(node.when, " ");
    }
    if (node.else) {
      this.append(" else ");
      this.visitNode(node.else);
    }
    this.append(" end");
    if (node.isStatement) {
      this.append(" case");
    }
  }
  visitWhen(node) {
    this.append("when ");
    this.visitNode(node.condition);
    if (node.result) {
      this.append(" then ");
      this.visitNode(node.result);
    }
  }
  visitJSONReference(node) {
    this.visitNode(node.reference);
    this.visitNode(node.traversal);
  }
  visitJSONPath(node) {
    if (node.inOperator) {
      this.visitNode(node.inOperator);
    }
    this.append("'$");
    for (const pathLeg of node.pathLegs) {
      this.visitNode(pathLeg);
    }
    this.append("'");
  }
  visitJSONPathLeg(node) {
    const isArrayLocation = node.type === "ArrayLocation";
    this.append(isArrayLocation ? "[" : ".");
    this.append(String(node.value));
    if (isArrayLocation) {
      this.append("]");
    }
  }
  visitJSONOperatorChain(node) {
    for (let i = 0, len = node.values.length; i < len; i++) {
      if (i === len - 1) {
        this.visitNode(node.operator);
      } else {
        this.append("->");
      }
      this.visitNode(node.values[i]);
    }
  }
  visitMergeQuery(node) {
    if (node.with) {
      this.visitNode(node.with);
      this.append(" ");
    }
    this.append("merge ");
    if (node.top) {
      this.visitNode(node.top);
      this.append(" ");
    }
    this.append("into ");
    this.visitNode(node.into);
    if (node.using) {
      this.append(" ");
      this.visitNode(node.using);
    }
    if (node.whens) {
      this.append(" ");
      this.compileList(node.whens, " ");
    }
    if (node.returning) {
      this.append(" ");
      this.visitNode(node.returning);
    }
    if (node.output) {
      this.append(" ");
      this.visitNode(node.output);
    }
    if (node.endModifiers?.length) {
      this.append(" ");
      this.compileList(node.endModifiers, " ");
    }
  }
  visitMatched(node) {
    if (node.not) {
      this.append("not ");
    }
    this.append("matched");
    if (node.bySource) {
      this.append(" by source");
    }
  }
  visitAddIndex(node) {
    this.append("add ");
    if (node.unique) {
      this.append("unique ");
    }
    this.append("index ");
    this.visitNode(node.name);
    if (node.columns) {
      this.append(" (");
      this.compileList(node.columns);
      this.append(")");
    }
    if (node.using) {
      this.append(" using ");
      this.visitNode(node.using);
    }
  }
  visitCast(node) {
    this.append("cast(");
    this.visitNode(node.expression);
    this.append(" as ");
    this.visitNode(node.dataType);
    this.append(")");
  }
  visitFetch(node) {
    this.append("fetch next ");
    this.visitNode(node.rowCount);
    this.append(` rows ${node.modifier}`);
  }
  visitOutput(node) {
    this.append("output ");
    this.compileList(node.selections);
  }
  visitTop(node) {
    this.append(`top(${node.expression})`);
    if (node.modifiers) {
      this.append(` ${node.modifiers}`);
    }
  }
  visitOrAction(node) {
    this.append(node.action);
  }
  visitCollate(node) {
    this.append("collate ");
    this.visitNode(node.collation);
  }
  append(str) {
    this.#sql += str;
  }
  appendValue(parameter) {
    this.addParameter(parameter);
    this.append(this.getCurrentParameterPlaceholder());
  }
  getLeftIdentifierWrapper() {
    return '"';
  }
  getRightIdentifierWrapper() {
    return '"';
  }
  getCurrentParameterPlaceholder() {
    return "$" + this.numParameters;
  }
  getLeftExplainOptionsWrapper() {
    return "(";
  }
  getExplainOptionAssignment() {
    return " ";
  }
  getExplainOptionsDelimiter() {
    return ", ";
  }
  getRightExplainOptionsWrapper() {
    return ")";
  }
  sanitizeIdentifier(identifier) {
    const leftWrap = this.getLeftIdentifierWrapper();
    const rightWrap = this.getRightIdentifierWrapper();
    let sanitized = "";
    for (const c2 of identifier) {
      sanitized += c2;
      if (c2 === leftWrap) {
        sanitized += leftWrap;
      } else if (c2 === rightWrap) {
        sanitized += rightWrap;
      }
    }
    return sanitized;
  }
  sanitizeStringLiteral(value) {
    return value.replace(LIT_WRAP_REGEX, "''");
  }
  addParameter(parameter) {
    this.#parameters.push(parameter);
  }
  appendImmediateValue(value) {
    if (isString$1(value)) {
      this.appendStringLiteral(value);
    } else if (isNumber$3(value) || isBoolean(value) || isBigInt(value)) {
      this.append(value.toString());
    } else if (isNull(value)) {
      this.append("null");
    } else if (isDate$1(value)) {
      this.appendImmediateValue(value.toISOString());
    } else {
      throw new Error(`invalid immediate value ${value}`);
    }
  }
  appendStringLiteral(value) {
    this.append("'");
    this.append(this.sanitizeStringLiteral(value));
    this.append("'");
  }
  sortSelectModifiers(arr) {
    arr.sort((left2, right2) => left2.modifier && right2.modifier ? SELECT_MODIFIER_PRIORITY[left2.modifier] - SELECT_MODIFIER_PRIORITY[right2.modifier] : 1);
    return freeze(arr);
  }
  compileColumnAlterations(columnAlterations) {
    this.compileList(columnAlterations);
  }
  /**
   * controls whether the dialect adds a "type" keyword before a column's new data
   * type in an ALTER TABLE statement.
   */
  announcesNewColumnDataType() {
    return true;
  }
}
const SELECT_MODIFIER_SQL = freeze({
  ForKeyShare: "for key share",
  ForNoKeyUpdate: "for no key update",
  ForUpdate: "for update",
  ForShare: "for share",
  NoWait: "nowait",
  SkipLocked: "skip locked",
  Distinct: "distinct"
});
const SELECT_MODIFIER_PRIORITY = freeze({
  ForKeyShare: 1,
  ForNoKeyUpdate: 1,
  ForUpdate: 1,
  ForShare: 1,
  NoWait: 2,
  SkipLocked: 2,
  Distinct: 0
});
const JOIN_TYPE_SQL = freeze({
  InnerJoin: "inner join",
  LeftJoin: "left join",
  RightJoin: "right join",
  FullJoin: "full join",
  CrossJoin: "cross join",
  LateralInnerJoin: "inner join lateral",
  LateralLeftJoin: "left join lateral",
  LateralCrossJoin: "cross join lateral",
  OuterApply: "outer apply",
  CrossApply: "cross apply",
  Using: "using"
});
const CompiledQuery = freeze({
  raw(sql2, parameters = []) {
    return freeze({
      sql: sql2,
      query: RawNode.createWithSql(sql2),
      parameters: freeze(parameters),
      queryId: createQueryId()
    });
  }
});
class DialectAdapterBase {
  get supportsCreateIfNotExists() {
    return true;
  }
  get supportsTransactionalDdl() {
    return false;
  }
  get supportsReturning() {
    return false;
  }
  get supportsOutput() {
    return false;
  }
}
function parseSavepointCommand(command, savepointName) {
  return RawNode.createWithChildren([
    RawNode.createWithSql(`${command} `),
    IdentifierNode.create(savepointName)
    // ensures savepointName gets sanitized
  ]);
}
class SqliteDriver {
  #config;
  #connectionMutex = new ConnectionMutex();
  #db;
  #connection;
  constructor(config2) {
    this.#config = freeze({ ...config2 });
  }
  async init() {
    this.#db = isFunction$1(this.#config.database) ? await this.#config.database() : this.#config.database;
    this.#connection = new SqliteConnection(this.#db);
    if (this.#config.onCreateConnection) {
      await this.#config.onCreateConnection(this.#connection);
    }
  }
  async acquireConnection() {
    await this.#connectionMutex.lock();
    return this.#connection;
  }
  async beginTransaction(connection2) {
    await connection2.executeQuery(CompiledQuery.raw("begin"));
  }
  async commitTransaction(connection2) {
    await connection2.executeQuery(CompiledQuery.raw("commit"));
  }
  async rollbackTransaction(connection2) {
    await connection2.executeQuery(CompiledQuery.raw("rollback"));
  }
  async savepoint(connection2, savepointName, compileQuery) {
    await connection2.executeQuery(compileQuery(parseSavepointCommand("savepoint", savepointName), createQueryId()));
  }
  async rollbackToSavepoint(connection2, savepointName, compileQuery) {
    await connection2.executeQuery(compileQuery(parseSavepointCommand("rollback to", savepointName), createQueryId()));
  }
  async releaseSavepoint(connection2, savepointName, compileQuery) {
    await connection2.executeQuery(compileQuery(parseSavepointCommand("release", savepointName), createQueryId()));
  }
  async releaseConnection() {
    this.#connectionMutex.unlock();
  }
  async destroy() {
    this.#db?.close();
  }
}
class SqliteConnection {
  #db;
  constructor(db) {
    this.#db = db;
  }
  executeQuery(compiledQuery) {
    const { sql: sql2, parameters } = compiledQuery;
    const stmt = this.#db.prepare(sql2);
    if (stmt.reader) {
      return Promise.resolve({
        rows: stmt.all(parameters)
      });
    }
    const { changes, lastInsertRowid } = stmt.run(parameters);
    return Promise.resolve({
      numAffectedRows: changes !== void 0 && changes !== null ? BigInt(changes) : void 0,
      insertId: lastInsertRowid !== void 0 && lastInsertRowid !== null ? BigInt(lastInsertRowid) : void 0,
      rows: []
    });
  }
  async *streamQuery(compiledQuery, _chunkSize) {
    const { sql: sql2, parameters, query: query2 } = compiledQuery;
    const stmt = this.#db.prepare(sql2);
    if (SelectQueryNode.is(query2)) {
      const iter = stmt.iterate(parameters);
      for (const row of iter) {
        yield {
          rows: [row]
        };
      }
    } else {
      throw new Error("Sqlite driver only supports streaming of select queries");
    }
  }
}
class ConnectionMutex {
  #promise;
  #resolve;
  async lock() {
    while (this.#promise) {
      await this.#promise;
    }
    this.#promise = new Promise((resolve2) => {
      this.#resolve = resolve2;
    });
  }
  unlock() {
    const resolve2 = this.#resolve;
    this.#promise = void 0;
    this.#resolve = void 0;
    resolve2?.();
  }
}
const ID_WRAP_REGEX$2 = /"/g;
class SqliteQueryCompiler extends DefaultQueryCompiler {
  visitOrAction(node) {
    this.append("or ");
    this.append(node.action);
  }
  getCurrentParameterPlaceholder() {
    return "?";
  }
  getLeftExplainOptionsWrapper() {
    return "";
  }
  getRightExplainOptionsWrapper() {
    return "";
  }
  getLeftIdentifierWrapper() {
    return '"';
  }
  getRightIdentifierWrapper() {
    return '"';
  }
  getAutoIncrement() {
    return "autoincrement";
  }
  sanitizeIdentifier(identifier) {
    return identifier.replace(ID_WRAP_REGEX$2, '""');
  }
  visitDefaultInsertValue(_) {
    this.append("null");
  }
}
const DEFAULT_MIGRATION_TABLE = "kysely_migration";
const DEFAULT_MIGRATION_LOCK_TABLE = "kysely_migration_lock";
freeze({ __noMigrations__: true });
class SqliteIntrospector {
  #db;
  constructor(db) {
    this.#db = db;
  }
  async getSchemas() {
    return [];
  }
  async getTables(options = { withInternalKyselyTables: false }) {
    return await this.#getTableMetadata(options);
  }
  async getMetadata(options) {
    return {
      tables: await this.getTables(options)
    };
  }
  #tablesQuery(qb2, options) {
    let tablesQuery = qb2.selectFrom("sqlite_master").where("type", "in", ["table", "view"]).where("name", "not like", "sqlite_%").select(["name", "sql", "type"]).orderBy("name");
    if (!options.withInternalKyselyTables) {
      tablesQuery = tablesQuery.where("name", "!=", DEFAULT_MIGRATION_TABLE).where("name", "!=", DEFAULT_MIGRATION_LOCK_TABLE);
    }
    return tablesQuery;
  }
  async #getTableMetadata(options) {
    const tablesResult = await this.#tablesQuery(this.#db, options).execute();
    const tableMetadata = await this.#db.with("table_list", (qb2) => this.#tablesQuery(qb2, options)).selectFrom([
      "table_list as tl",
      sql`pragma_table_info(tl.name)`.as("p")
    ]).select([
      "tl.name as table",
      "p.cid",
      "p.name",
      "p.type",
      "p.notnull",
      "p.dflt_value",
      "p.pk"
    ]).orderBy("tl.name").orderBy("p.cid").execute();
    const columnsByTable = {};
    for (const row of tableMetadata) {
      columnsByTable[row.table] ??= [];
      columnsByTable[row.table].push(row);
    }
    return tablesResult.map(({ name: name2, sql: sql2, type: type2 }) => {
      let autoIncrementCol = sql2?.split(/[\(\),]/)?.find((it) => it.toLowerCase().includes("autoincrement"))?.trimStart()?.split(/\s+/)?.[0]?.replace(/["`]/g, "");
      const columns = columnsByTable[name2] ?? [];
      if (!autoIncrementCol) {
        const pkCols = columns.filter((r2) => r2.pk > 0);
        if (pkCols.length === 1 && pkCols[0].type.toLowerCase() === "integer") {
          autoIncrementCol = pkCols[0].name;
        }
      }
      return {
        name: name2,
        isView: type2 === "view",
        columns: columns.map((col) => ({
          name: col.name,
          dataType: col.type,
          isNullable: !col.notnull,
          isAutoIncrementing: col.name === autoIncrementCol,
          hasDefaultValue: col.dflt_value != null,
          comment: void 0
        }))
      };
    });
  }
}
class SqliteAdapter extends DialectAdapterBase {
  get supportsTransactionalDdl() {
    return false;
  }
  get supportsReturning() {
    return true;
  }
  async acquireMigrationLock(_db, _opt) {
  }
  async releaseMigrationLock(_db, _opt) {
  }
}
class SqliteDialect {
  #config;
  constructor(config2) {
    this.#config = freeze({ ...config2 });
  }
  createDriver() {
    return new SqliteDriver(this.#config);
  }
  createQueryCompiler() {
    return new SqliteQueryCompiler();
  }
  createAdapter() {
    return new SqliteAdapter();
  }
  createIntrospector(db) {
    return new SqliteIntrospector(db);
  }
}
const ID_WRAP_REGEX$1 = /"/g;
class PostgresQueryCompiler extends DefaultQueryCompiler {
  sanitizeIdentifier(identifier) {
    return identifier.replace(ID_WRAP_REGEX$1, '""');
  }
}
class PostgresIntrospector {
  #db;
  constructor(db) {
    this.#db = db;
  }
  async getSchemas() {
    let rawSchemas = await this.#db.selectFrom("pg_catalog.pg_namespace").select("nspname").$castTo().execute();
    return rawSchemas.map((it) => ({ name: it.nspname }));
  }
  async getTables(options = { withInternalKyselyTables: false }) {
    let query2 = this.#db.selectFrom("pg_catalog.pg_attribute as a").innerJoin("pg_catalog.pg_class as c", "a.attrelid", "c.oid").innerJoin("pg_catalog.pg_namespace as ns", "c.relnamespace", "ns.oid").innerJoin("pg_catalog.pg_type as typ", "a.atttypid", "typ.oid").innerJoin("pg_catalog.pg_namespace as dtns", "typ.typnamespace", "dtns.oid").select([
      "a.attname as column",
      "a.attnotnull as not_null",
      "a.atthasdef as has_default",
      "c.relname as table",
      "c.relkind as table_type",
      "ns.nspname as schema",
      "typ.typname as type",
      "dtns.nspname as type_schema",
      sql`col_description(a.attrelid, a.attnum)`.as("column_description"),
      sql`pg_get_serial_sequence(quote_ident(ns.nspname) || '.' || quote_ident(c.relname), a.attname)`.as("auto_incrementing")
    ]).where("c.relkind", "in", [
      "r",
      "v",
      "p"
    ]).where("ns.nspname", "!~", "^pg_").where("ns.nspname", "!=", "information_schema").where("ns.nspname", "!=", "crdb_internal").where(sql`has_schema_privilege(ns.nspname, 'USAGE')`).where("a.attnum", ">=", 0).where("a.attisdropped", "!=", true).orderBy("ns.nspname").orderBy("c.relname").orderBy("a.attnum").$castTo();
    if (!options.withInternalKyselyTables) {
      query2 = query2.where("c.relname", "!=", DEFAULT_MIGRATION_TABLE).where("c.relname", "!=", DEFAULT_MIGRATION_LOCK_TABLE);
    }
    const rawColumns = await query2.execute();
    return this.#parseTableMetadata(rawColumns);
  }
  async getMetadata(options) {
    return {
      tables: await this.getTables(options)
    };
  }
  #parseTableMetadata(columns) {
    return columns.reduce((tables, it) => {
      let table = tables.find((tbl) => tbl.name === it.table && tbl.schema === it.schema);
      if (!table) {
        table = freeze({
          name: it.table,
          isView: it.table_type === "v",
          schema: it.schema,
          columns: []
        });
        tables.push(table);
      }
      table.columns.push(freeze({
        name: it.column,
        dataType: it.type,
        dataTypeSchema: it.type_schema,
        isNullable: !it.not_null,
        isAutoIncrementing: it.auto_incrementing !== null,
        hasDefaultValue: it.has_default,
        comment: it.column_description ?? void 0
      }));
      return tables;
    }, []);
  }
}
const LOCK_ID$1 = BigInt("3853314791062309107");
class PostgresAdapter extends DialectAdapterBase {
  get supportsTransactionalDdl() {
    return true;
  }
  get supportsReturning() {
    return true;
  }
  async acquireMigrationLock(db, _opt) {
    await sql`select pg_advisory_xact_lock(${sql.lit(LOCK_ID$1)})`.execute(db);
  }
  async releaseMigrationLock(_db, _opt) {
  }
}
function extendStackTrace(err2, stackError) {
  if (isStackHolder(err2) && stackError.stack) {
    const stackExtension = stackError.stack.split("\n").slice(1).join("\n");
    err2.stack += `
${stackExtension}`;
    return err2;
  }
  return err2;
}
function isStackHolder(obj) {
  return isObject(obj) && isString$1(obj.stack);
}
const PRIVATE_RELEASE_METHOD$1 = /* @__PURE__ */ Symbol();
class MysqlDriver {
  #config;
  #connections = /* @__PURE__ */ new WeakMap();
  #pool;
  constructor(configOrPool) {
    this.#config = freeze({ ...configOrPool });
  }
  async init() {
    this.#pool = isFunction$1(this.#config.pool) ? await this.#config.pool() : this.#config.pool;
  }
  async acquireConnection() {
    const rawConnection = await this.#acquireConnection();
    let connection2 = this.#connections.get(rawConnection);
    if (!connection2) {
      connection2 = new MysqlConnection(rawConnection);
      this.#connections.set(rawConnection, connection2);
      if (this.#config?.onCreateConnection) {
        await this.#config.onCreateConnection(connection2);
      }
    }
    if (this.#config?.onReserveConnection) {
      await this.#config.onReserveConnection(connection2);
    }
    return connection2;
  }
  async #acquireConnection() {
    return new Promise((resolve2, reject) => {
      this.#pool.getConnection(async (err2, rawConnection) => {
        if (err2) {
          reject(err2);
        } else {
          resolve2(rawConnection);
        }
      });
    });
  }
  async beginTransaction(connection2, settings) {
    if (settings.isolationLevel || settings.accessMode) {
      const parts = [];
      if (settings.isolationLevel) {
        parts.push(`isolation level ${settings.isolationLevel}`);
      }
      if (settings.accessMode) {
        parts.push(settings.accessMode);
      }
      const sql2 = `set transaction ${parts.join(", ")}`;
      await connection2.executeQuery(CompiledQuery.raw(sql2));
    }
    await connection2.executeQuery(CompiledQuery.raw("begin"));
  }
  async commitTransaction(connection2) {
    await connection2.executeQuery(CompiledQuery.raw("commit"));
  }
  async rollbackTransaction(connection2) {
    await connection2.executeQuery(CompiledQuery.raw("rollback"));
  }
  async savepoint(connection2, savepointName, compileQuery) {
    await connection2.executeQuery(compileQuery(parseSavepointCommand("savepoint", savepointName), createQueryId()));
  }
  async rollbackToSavepoint(connection2, savepointName, compileQuery) {
    await connection2.executeQuery(compileQuery(parseSavepointCommand("rollback to", savepointName), createQueryId()));
  }
  async releaseSavepoint(connection2, savepointName, compileQuery) {
    await connection2.executeQuery(compileQuery(parseSavepointCommand("release savepoint", savepointName), createQueryId()));
  }
  async releaseConnection(connection2) {
    connection2[PRIVATE_RELEASE_METHOD$1]();
  }
  async destroy() {
    return new Promise((resolve2, reject) => {
      this.#pool.end((err2) => {
        if (err2) {
          reject(err2);
        } else {
          resolve2();
        }
      });
    });
  }
}
function isOkPacket(obj) {
  return isObject(obj) && "insertId" in obj && "affectedRows" in obj;
}
class MysqlConnection {
  #rawConnection;
  constructor(rawConnection) {
    this.#rawConnection = rawConnection;
  }
  async executeQuery(compiledQuery) {
    try {
      const result2 = await this.#executeQuery(compiledQuery);
      if (isOkPacket(result2)) {
        const { insertId, affectedRows, changedRows } = result2;
        return {
          insertId: insertId !== void 0 && insertId !== null && insertId.toString() !== "0" ? BigInt(insertId) : void 0,
          numAffectedRows: affectedRows !== void 0 && affectedRows !== null ? BigInt(affectedRows) : void 0,
          numChangedRows: changedRows !== void 0 && changedRows !== null ? BigInt(changedRows) : void 0,
          rows: []
        };
      } else if (Array.isArray(result2)) {
        return {
          rows: result2
        };
      }
      return {
        rows: []
      };
    } catch (err2) {
      throw extendStackTrace(err2, new Error());
    }
  }
  #executeQuery(compiledQuery) {
    return new Promise((resolve2, reject) => {
      this.#rawConnection.query(compiledQuery.sql, compiledQuery.parameters, (err2, result2) => {
        if (err2) {
          reject(err2);
        } else {
          resolve2(result2);
        }
      });
    });
  }
  async *streamQuery(compiledQuery, _chunkSize) {
    const stream2 = this.#rawConnection.query(compiledQuery.sql, compiledQuery.parameters).stream({
      objectMode: true
    });
    try {
      for await (const row of stream2) {
        yield {
          rows: [row]
        };
      }
    } catch (ex) {
      if (ex && typeof ex === "object" && "code" in ex && // @ts-ignore
      ex.code === "ERR_STREAM_PREMATURE_CLOSE") {
        return;
      }
      throw ex;
    }
  }
  [PRIVATE_RELEASE_METHOD$1]() {
    this.#rawConnection.release();
  }
}
const ID_WRAP_REGEX = /`/g;
class MysqlQueryCompiler extends DefaultQueryCompiler {
  getCurrentParameterPlaceholder() {
    return "?";
  }
  getLeftExplainOptionsWrapper() {
    return "";
  }
  getExplainOptionAssignment() {
    return "=";
  }
  getExplainOptionsDelimiter() {
    return " ";
  }
  getRightExplainOptionsWrapper() {
    return "";
  }
  getLeftIdentifierWrapper() {
    return "`";
  }
  getRightIdentifierWrapper() {
    return "`";
  }
  sanitizeIdentifier(identifier) {
    return identifier.replace(ID_WRAP_REGEX, "``");
  }
  visitCreateIndex(node) {
    this.append("create ");
    if (node.unique) {
      this.append("unique ");
    }
    this.append("index ");
    if (node.ifNotExists) {
      this.append("if not exists ");
    }
    this.visitNode(node.name);
    if (node.using) {
      this.append(" using ");
      this.visitNode(node.using);
    }
    if (node.table) {
      this.append(" on ");
      this.visitNode(node.table);
    }
    if (node.columns) {
      this.append(" (");
      this.compileList(node.columns);
      this.append(")");
    }
    if (node.where) {
      this.append(" ");
      this.visitNode(node.where);
    }
  }
}
class MysqlIntrospector {
  #db;
  constructor(db) {
    this.#db = db;
  }
  async getSchemas() {
    let rawSchemas = await this.#db.selectFrom("information_schema.schemata").select("schema_name").$castTo().execute();
    return rawSchemas.map((it) => ({ name: it.SCHEMA_NAME }));
  }
  async getTables(options = { withInternalKyselyTables: false }) {
    let query2 = this.#db.selectFrom("information_schema.columns as columns").innerJoin("information_schema.tables as tables", (b) => b.onRef("columns.TABLE_CATALOG", "=", "tables.TABLE_CATALOG").onRef("columns.TABLE_SCHEMA", "=", "tables.TABLE_SCHEMA").onRef("columns.TABLE_NAME", "=", "tables.TABLE_NAME")).select([
      "columns.COLUMN_NAME",
      "columns.COLUMN_DEFAULT",
      "columns.TABLE_NAME",
      "columns.TABLE_SCHEMA",
      "tables.TABLE_TYPE",
      "columns.IS_NULLABLE",
      "columns.DATA_TYPE",
      "columns.EXTRA",
      "columns.COLUMN_COMMENT"
    ]).where("columns.TABLE_SCHEMA", "=", sql`database()`).orderBy("columns.TABLE_NAME").orderBy("columns.ORDINAL_POSITION").$castTo();
    if (!options.withInternalKyselyTables) {
      query2 = query2.where("columns.TABLE_NAME", "!=", DEFAULT_MIGRATION_TABLE).where("columns.TABLE_NAME", "!=", DEFAULT_MIGRATION_LOCK_TABLE);
    }
    const rawColumns = await query2.execute();
    return this.#parseTableMetadata(rawColumns);
  }
  async getMetadata(options) {
    return {
      tables: await this.getTables(options)
    };
  }
  #parseTableMetadata(columns) {
    return columns.reduce((tables, it) => {
      let table = tables.find((tbl) => tbl.name === it.TABLE_NAME);
      if (!table) {
        table = freeze({
          name: it.TABLE_NAME,
          isView: it.TABLE_TYPE === "VIEW",
          schema: it.TABLE_SCHEMA,
          columns: []
        });
        tables.push(table);
      }
      table.columns.push(freeze({
        name: it.COLUMN_NAME,
        dataType: it.DATA_TYPE,
        isNullable: it.IS_NULLABLE === "YES",
        isAutoIncrementing: it.EXTRA.toLowerCase().includes("auto_increment"),
        hasDefaultValue: it.COLUMN_DEFAULT !== null,
        comment: it.COLUMN_COMMENT === "" ? void 0 : it.COLUMN_COMMENT
      }));
      return tables;
    }, []);
  }
}
const LOCK_ID = "ea586330-2c93-47c8-908d-981d9d270f9d";
const LOCK_TIMEOUT_SECONDS = 60 * 60;
class MysqlAdapter extends DialectAdapterBase {
  get supportsTransactionalDdl() {
    return false;
  }
  get supportsReturning() {
    return false;
  }
  async acquireMigrationLock(db, _opt) {
    await sql`select get_lock(${sql.lit(LOCK_ID)}, ${sql.lit(LOCK_TIMEOUT_SECONDS)})`.execute(db);
  }
  async releaseMigrationLock(db, _opt) {
    await sql`select release_lock(${sql.lit(LOCK_ID)})`.execute(db);
  }
}
class MysqlDialect {
  #config;
  constructor(config2) {
    this.#config = config2;
  }
  createDriver() {
    return new MysqlDriver(this.#config);
  }
  createQueryCompiler() {
    return new MysqlQueryCompiler();
  }
  createAdapter() {
    return new MysqlAdapter();
  }
  createIntrospector(db) {
    return new MysqlIntrospector(db);
  }
}
const PRIVATE_RELEASE_METHOD = /* @__PURE__ */ Symbol();
class PostgresDriver {
  #config;
  #connections = /* @__PURE__ */ new WeakMap();
  #pool;
  constructor(config2) {
    this.#config = freeze({ ...config2 });
  }
  async init() {
    this.#pool = isFunction$1(this.#config.pool) ? await this.#config.pool() : this.#config.pool;
  }
  async acquireConnection() {
    const client2 = await this.#pool.connect();
    let connection2 = this.#connections.get(client2);
    if (!connection2) {
      connection2 = new PostgresConnection(client2, {
        cursor: this.#config.cursor ?? null
      });
      this.#connections.set(client2, connection2);
      if (this.#config.onCreateConnection) {
        await this.#config.onCreateConnection(connection2);
      }
    }
    if (this.#config.onReserveConnection) {
      await this.#config.onReserveConnection(connection2);
    }
    return connection2;
  }
  async beginTransaction(connection2, settings) {
    if (settings.isolationLevel || settings.accessMode) {
      let sql2 = "start transaction";
      if (settings.isolationLevel) {
        sql2 += ` isolation level ${settings.isolationLevel}`;
      }
      if (settings.accessMode) {
        sql2 += ` ${settings.accessMode}`;
      }
      await connection2.executeQuery(CompiledQuery.raw(sql2));
    } else {
      await connection2.executeQuery(CompiledQuery.raw("begin"));
    }
  }
  async commitTransaction(connection2) {
    await connection2.executeQuery(CompiledQuery.raw("commit"));
  }
  async rollbackTransaction(connection2) {
    await connection2.executeQuery(CompiledQuery.raw("rollback"));
  }
  async savepoint(connection2, savepointName, compileQuery) {
    await connection2.executeQuery(compileQuery(parseSavepointCommand("savepoint", savepointName), createQueryId()));
  }
  async rollbackToSavepoint(connection2, savepointName, compileQuery) {
    await connection2.executeQuery(compileQuery(parseSavepointCommand("rollback to", savepointName), createQueryId()));
  }
  async releaseSavepoint(connection2, savepointName, compileQuery) {
    await connection2.executeQuery(compileQuery(parseSavepointCommand("release", savepointName), createQueryId()));
  }
  async releaseConnection(connection2) {
    connection2[PRIVATE_RELEASE_METHOD]();
  }
  async destroy() {
    if (this.#pool) {
      const pool = this.#pool;
      this.#pool = void 0;
      await pool.end();
    }
  }
}
class PostgresConnection {
  #client;
  #options;
  constructor(client2, options) {
    this.#client = client2;
    this.#options = options;
  }
  async executeQuery(compiledQuery) {
    try {
      const { command, rowCount, rows } = await this.#client.query(compiledQuery.sql, [...compiledQuery.parameters]);
      return {
        numAffectedRows: command === "INSERT" || command === "UPDATE" || command === "DELETE" || command === "MERGE" ? BigInt(rowCount) : void 0,
        rows: rows ?? []
      };
    } catch (err2) {
      throw extendStackTrace(err2, new Error());
    }
  }
  async *streamQuery(compiledQuery, chunkSize) {
    if (!this.#options.cursor) {
      throw new Error("'cursor' is not present in your postgres dialect config. It's required to make streaming work in postgres.");
    }
    if (!Number.isInteger(chunkSize) || chunkSize <= 0) {
      throw new Error("chunkSize must be a positive integer");
    }
    const cursor = this.#client.query(new this.#options.cursor(compiledQuery.sql, compiledQuery.parameters.slice()));
    try {
      while (true) {
        const rows = await cursor.read(chunkSize);
        if (rows.length === 0) {
          break;
        }
        yield {
          rows
        };
      }
    } finally {
      await cursor.close();
    }
  }
  [PRIVATE_RELEASE_METHOD]() {
    this.#client.release();
  }
}
class PostgresDialect {
  #config;
  constructor(config2) {
    this.#config = config2;
  }
  createDriver() {
    return new PostgresDriver(this.#config);
  }
  createQueryCompiler() {
    return new PostgresQueryCompiler();
  }
  createAdapter() {
    return new PostgresAdapter();
  }
  createIntrospector(db) {
    return new PostgresIntrospector(db);
  }
}
class MssqlAdapter extends DialectAdapterBase {
  get supportsCreateIfNotExists() {
    return false;
  }
  get supportsTransactionalDdl() {
    return true;
  }
  get supportsOutput() {
    return true;
  }
  async acquireMigrationLock(db) {
    await sql`exec sp_getapplock @DbPrincipal = ${sql.lit("dbo")}, @Resource = ${sql.lit(DEFAULT_MIGRATION_TABLE)}, @LockMode = ${sql.lit("Exclusive")}`.execute(db);
  }
  async releaseMigrationLock() {
  }
}
const PRIVATE_RESET_METHOD = /* @__PURE__ */ Symbol();
const PRIVATE_DESTROY_METHOD = /* @__PURE__ */ Symbol();
const PRIVATE_VALIDATE_METHOD = /* @__PURE__ */ Symbol();
class MssqlDriver {
  #config;
  #pool;
  constructor(config2) {
    this.#config = freeze({ ...config2 });
    const { tarn, tedious, validateConnections } = this.#config;
    const { validateConnections: deprecatedValidateConnections, ...poolOptions } = tarn.options;
    this.#pool = new tarn.Pool({
      ...poolOptions,
      create: async () => {
        const connection2 = await tedious.connectionFactory();
        return await new MssqlConnection(connection2, tedious).connect();
      },
      destroy: async (connection2) => {
        await connection2[PRIVATE_DESTROY_METHOD]();
      },
      // @ts-ignore `tarn` accepts a function that returns a promise here, but
      // the types are not aligned and it type errors.
      validate: validateConnections === false || deprecatedValidateConnections === false ? void 0 : (connection2) => connection2[PRIVATE_VALIDATE_METHOD]()
    });
  }
  async init() {
  }
  async acquireConnection() {
    return await this.#pool.acquire().promise;
  }
  async beginTransaction(connection2, settings) {
    await connection2.beginTransaction(settings);
  }
  async commitTransaction(connection2) {
    await connection2.commitTransaction();
  }
  async rollbackTransaction(connection2) {
    await connection2.rollbackTransaction();
  }
  async savepoint(connection2, savepointName) {
    await connection2.savepoint(savepointName);
  }
  async rollbackToSavepoint(connection2, savepointName) {
    await connection2.rollbackTransaction(savepointName);
  }
  async releaseConnection(connection2) {
    if (this.#config.resetConnectionsOnRelease || this.#config.tedious.resetConnectionOnRelease) {
      await connection2[PRIVATE_RESET_METHOD]();
    }
    this.#pool.release(connection2);
  }
  async destroy() {
    await this.#pool.destroy();
  }
}
class MssqlConnection {
  #connection;
  #hasSocketError;
  #tedious;
  constructor(connection2, tedious) {
    this.#connection = connection2;
    this.#hasSocketError = false;
    this.#tedious = tedious;
  }
  async beginTransaction(settings) {
    const { isolationLevel } = settings;
    await new Promise((resolve2, reject) => this.#connection.beginTransaction((error2) => {
      if (error2)
        reject(error2);
      else
        resolve2(void 0);
    }, isolationLevel ? randomString(8) : void 0, isolationLevel ? this.#getTediousIsolationLevel(isolationLevel) : void 0));
  }
  async commitTransaction() {
    await new Promise((resolve2, reject) => this.#connection.commitTransaction((error2) => {
      if (error2)
        reject(error2);
      else
        resolve2(void 0);
    }));
  }
  async connect() {
    const { promise: waitForConnected, reject, resolve: resolve2 } = new Deferred();
    this.#connection.connect((error2) => {
      if (error2) {
        return reject(error2);
      }
      resolve2();
    });
    this.#connection.on("error", (error2) => {
      if (error2 instanceof Error && "code" in error2 && error2.code === "ESOCKET") {
        this.#hasSocketError = true;
      }
      console.error(error2);
      reject(error2);
    });
    function endListener() {
      reject(new Error("The connection ended without ever completing the connection"));
    }
    this.#connection.once("end", endListener);
    await waitForConnected;
    this.#connection.off("end", endListener);
    return this;
  }
  async executeQuery(compiledQuery) {
    try {
      const deferred = new Deferred();
      const request = new MssqlRequest({
        compiledQuery,
        tedious: this.#tedious,
        onDone: deferred
      });
      this.#connection.execSql(request.request);
      const { rowCount, rows } = await deferred.promise;
      return {
        numAffectedRows: rowCount !== void 0 ? BigInt(rowCount) : void 0,
        rows
      };
    } catch (err2) {
      throw extendStackTrace(err2, new Error());
    }
  }
  async rollbackTransaction(savepointName) {
    await new Promise((resolve2, reject) => this.#connection.rollbackTransaction((error2) => {
      if (error2)
        reject(error2);
      else
        resolve2(void 0);
    }, savepointName));
  }
  async savepoint(savepointName) {
    await new Promise((resolve2, reject) => this.#connection.saveTransaction((error2) => {
      if (error2)
        reject(error2);
      else
        resolve2(void 0);
    }, savepointName));
  }
  async *streamQuery(compiledQuery, chunkSize) {
    if (!Number.isInteger(chunkSize) || chunkSize <= 0) {
      throw new Error("chunkSize must be a positive integer");
    }
    const request = new MssqlRequest({
      compiledQuery,
      streamChunkSize: chunkSize,
      tedious: this.#tedious
    });
    this.#connection.execSql(request.request);
    try {
      while (true) {
        const rows = await request.readChunk();
        if (rows.length === 0) {
          break;
        }
        yield { rows };
        if (rows.length < chunkSize) {
          break;
        }
      }
    } finally {
      await this.#cancelRequest(request);
    }
  }
  #getTediousIsolationLevel(isolationLevel) {
    const { ISOLATION_LEVEL } = this.#tedious;
    const mapper = {
      "read committed": ISOLATION_LEVEL.READ_COMMITTED,
      "read uncommitted": ISOLATION_LEVEL.READ_UNCOMMITTED,
      "repeatable read": ISOLATION_LEVEL.REPEATABLE_READ,
      serializable: ISOLATION_LEVEL.SERIALIZABLE,
      snapshot: ISOLATION_LEVEL.SNAPSHOT
    };
    const tediousIsolationLevel = mapper[isolationLevel];
    if (tediousIsolationLevel === void 0) {
      throw new Error(`Unknown isolation level: ${isolationLevel}`);
    }
    return tediousIsolationLevel;
  }
  #cancelRequest(request) {
    return new Promise((resolve2) => {
      request.request.once("requestCompleted", resolve2);
      const wasCanceled = this.#connection.cancel();
      if (!wasCanceled) {
        request.request.off("requestCompleted", resolve2);
        resolve2();
      }
    });
  }
  [PRIVATE_DESTROY_METHOD]() {
    if ("closed" in this.#connection && this.#connection.closed) {
      return Promise.resolve();
    }
    return new Promise((resolve2) => {
      this.#connection.once("end", resolve2);
      this.#connection.close();
    });
  }
  async [PRIVATE_RESET_METHOD]() {
    await new Promise((resolve2, reject) => {
      this.#connection.reset((error2) => {
        if (error2) {
          return reject(error2);
        }
        resolve2();
      });
    });
  }
  async [PRIVATE_VALIDATE_METHOD]() {
    if (this.#hasSocketError || this.#isConnectionClosed()) {
      return false;
    }
    try {
      const deferred = new Deferred();
      const request = new MssqlRequest({
        compiledQuery: CompiledQuery.raw("select 1"),
        onDone: deferred,
        tedious: this.#tedious
      });
      this.#connection.execSql(request.request);
      await deferred.promise;
      return true;
    } catch {
      return false;
    }
  }
  #isConnectionClosed() {
    return "closed" in this.#connection && Boolean(this.#connection.closed);
  }
}
class MssqlRequest {
  #request;
  #rows;
  #streamChunkSize;
  #subscribers;
  #tedious;
  #rowCount;
  constructor(props) {
    const { compiledQuery, onDone, streamChunkSize, tedious } = props;
    this.#rows = [];
    this.#streamChunkSize = streamChunkSize;
    this.#subscribers = {};
    this.#tedious = tedious;
    if (onDone) {
      const subscriptionKey = "onDone";
      this.#subscribers[subscriptionKey] = (event, error2) => {
        if (event === "chunkReady") {
          return;
        }
        delete this.#subscribers[subscriptionKey];
        if (event === "error") {
          return onDone.reject(error2);
        }
        onDone.resolve({
          rowCount: this.#rowCount,
          rows: this.#rows
        });
      };
    }
    this.#request = new this.#tedious.Request(compiledQuery.sql, (err2, rowCount) => {
      if (err2) {
        return Object.values(this.#subscribers).forEach((subscriber) => subscriber("error", err2 instanceof AggregateError ? err2.errors : err2));
      }
      this.#rowCount = rowCount;
    });
    this.#addParametersToRequest(compiledQuery.parameters);
    this.#attachListeners();
  }
  get request() {
    return this.#request;
  }
  readChunk() {
    const subscriptionKey = this.readChunk.name;
    return new Promise((resolve2, reject) => {
      this.#subscribers[subscriptionKey] = (event, error2) => {
        delete this.#subscribers[subscriptionKey];
        if (event === "error") {
          return reject(error2);
        }
        resolve2(this.#rows.splice(0, this.#streamChunkSize));
      };
      this.#request.resume();
    });
  }
  #addParametersToRequest(parameters) {
    for (let i = 0; i < parameters.length; i++) {
      const parameter = parameters[i];
      this.#request.addParameter(String(i + 1), this.#getTediousDataType(parameter), parameter);
    }
  }
  #attachListeners() {
    const pauseAndEmitChunkReady = this.#streamChunkSize ? () => {
      if (this.#streamChunkSize <= this.#rows.length) {
        this.#request.pause();
        Object.values(this.#subscribers).forEach((subscriber) => subscriber("chunkReady"));
      }
    } : () => {
    };
    const rowListener = (columns) => {
      const row = {};
      for (const column of columns) {
        row[column.metadata.colName] = column.value;
      }
      this.#rows.push(row);
      pauseAndEmitChunkReady();
    };
    this.#request.on("row", rowListener);
    this.#request.once("requestCompleted", () => {
      Object.values(this.#subscribers).forEach((subscriber) => subscriber("completed"));
      this.#request.off("row", rowListener);
    });
  }
  #getTediousDataType(value) {
    if (isNull(value) || isUndefined$1(value) || isString$1(value)) {
      return this.#tedious.TYPES.NVarChar;
    }
    if (isBigInt(value) || isNumber$3(value) && value % 1 === 0) {
      if (value < -2147483648 || value > 2147483647) {
        return this.#tedious.TYPES.BigInt;
      } else {
        return this.#tedious.TYPES.Int;
      }
    }
    if (isNumber$3(value)) {
      return this.#tedious.TYPES.Float;
    }
    if (isBoolean(value)) {
      return this.#tedious.TYPES.Bit;
    }
    if (isDate$1(value)) {
      return this.#tedious.TYPES.DateTime;
    }
    if (isBuffer(value)) {
      return this.#tedious.TYPES.VarBinary;
    }
    return this.#tedious.TYPES.NVarChar;
  }
}
class MssqlIntrospector {
  #db;
  constructor(db) {
    this.#db = db;
  }
  async getSchemas() {
    return await this.#db.selectFrom("sys.schemas").select("name").execute();
  }
  async getTables(options = { withInternalKyselyTables: false }) {
    const rawColumns = await this.#db.selectFrom("sys.tables as tables").leftJoin("sys.schemas as table_schemas", "table_schemas.schema_id", "tables.schema_id").innerJoin("sys.columns as columns", "columns.object_id", "tables.object_id").innerJoin("sys.types as types", "types.user_type_id", "columns.user_type_id").leftJoin("sys.schemas as type_schemas", "type_schemas.schema_id", "types.schema_id").leftJoin("sys.extended_properties as comments", (join2) => join2.onRef("comments.major_id", "=", "tables.object_id").onRef("comments.minor_id", "=", "columns.column_id").on("comments.name", "=", "MS_Description")).$if(!options.withInternalKyselyTables, (qb2) => qb2.where("tables.name", "!=", DEFAULT_MIGRATION_TABLE).where("tables.name", "!=", DEFAULT_MIGRATION_LOCK_TABLE)).select([
      "tables.name as table_name",
      (eb) => eb.ref("tables.type").$castTo().as("table_type"),
      "table_schemas.name as table_schema_name",
      "columns.default_object_id as column_default_object_id",
      "columns.generated_always_type_desc as column_generated_always_type",
      "columns.is_computed as column_is_computed",
      "columns.is_identity as column_is_identity",
      "columns.is_nullable as column_is_nullable",
      "columns.is_rowguidcol as column_is_rowguidcol",
      "columns.name as column_name",
      "types.is_nullable as type_is_nullable",
      "types.name as type_name",
      "type_schemas.name as type_schema_name",
      "comments.value as column_comment"
    ]).unionAll(this.#db.selectFrom("sys.views as views").leftJoin("sys.schemas as view_schemas", "view_schemas.schema_id", "views.schema_id").innerJoin("sys.columns as columns", "columns.object_id", "views.object_id").innerJoin("sys.types as types", "types.user_type_id", "columns.user_type_id").leftJoin("sys.schemas as type_schemas", "type_schemas.schema_id", "types.schema_id").leftJoin("sys.extended_properties as comments", (join2) => join2.onRef("comments.major_id", "=", "views.object_id").onRef("comments.minor_id", "=", "columns.column_id").on("comments.name", "=", "MS_Description")).select([
      "views.name as table_name",
      "views.type as table_type",
      "view_schemas.name as table_schema_name",
      "columns.default_object_id as column_default_object_id",
      "columns.generated_always_type_desc as column_generated_always_type",
      "columns.is_computed as column_is_computed",
      "columns.is_identity as column_is_identity",
      "columns.is_nullable as column_is_nullable",
      "columns.is_rowguidcol as column_is_rowguidcol",
      "columns.name as column_name",
      "types.is_nullable as type_is_nullable",
      "types.name as type_name",
      "type_schemas.name as type_schema_name",
      "comments.value as column_comment"
    ])).orderBy("table_schema_name").orderBy("table_name").orderBy("column_name").execute();
    const tableDictionary = {};
    for (const rawColumn of rawColumns) {
      const key = `${rawColumn.table_schema_name}.${rawColumn.table_name}`;
      const table = tableDictionary[key] = tableDictionary[key] || freeze({
        columns: [],
        isView: rawColumn.table_type === "V ",
        name: rawColumn.table_name,
        schema: rawColumn.table_schema_name ?? void 0
      });
      table.columns.push(freeze({
        dataType: rawColumn.type_name,
        dataTypeSchema: rawColumn.type_schema_name ?? void 0,
        hasDefaultValue: rawColumn.column_default_object_id > 0 || rawColumn.column_generated_always_type !== "NOT_APPLICABLE" || rawColumn.column_is_identity || rawColumn.column_is_computed || rawColumn.column_is_rowguidcol,
        isAutoIncrementing: rawColumn.column_is_identity,
        isNullable: rawColumn.column_is_nullable && rawColumn.type_is_nullable,
        name: rawColumn.column_name,
        comment: rawColumn.column_comment ?? void 0
      }));
    }
    return Object.values(tableDictionary);
  }
  async getMetadata(options) {
    return {
      tables: await this.getTables(options)
    };
  }
}
const COLLATION_CHAR_REGEX = /^[a-z0-9_]$/i;
class MssqlQueryCompiler extends DefaultQueryCompiler {
  getCurrentParameterPlaceholder() {
    return `@${this.numParameters}`;
  }
  visitOffset(node) {
    super.visitOffset(node);
    this.append(" rows");
  }
  // mssql allows multi-column alterations in a single statement,
  // but you can only use the command keyword/s once.
  // it also doesn't support multiple kinds of commands in the same
  // alter table statement, but we compile that anyway for the sake
  // of WYSIWYG.
  compileColumnAlterations(columnAlterations) {
    const nodesByKind = {};
    for (const columnAlteration of columnAlterations) {
      if (!nodesByKind[columnAlteration.kind]) {
        nodesByKind[columnAlteration.kind] = [];
      }
      nodesByKind[columnAlteration.kind].push(columnAlteration);
    }
    let first = true;
    if (nodesByKind.AddColumnNode) {
      this.append("add ");
      this.compileList(nodesByKind.AddColumnNode);
      first = false;
    }
    if (nodesByKind.AlterColumnNode) {
      if (!first)
        this.append(", ");
      this.compileList(nodesByKind.AlterColumnNode);
    }
    if (nodesByKind.DropColumnNode) {
      if (!first)
        this.append(", ");
      this.append("drop column ");
      this.compileList(nodesByKind.DropColumnNode);
    }
    if (nodesByKind.ModifyColumnNode) {
      if (!first)
        this.append(", ");
      this.compileList(nodesByKind.ModifyColumnNode);
    }
    if (nodesByKind.RenameColumnNode) {
      if (!first)
        this.append(", ");
      this.compileList(nodesByKind.RenameColumnNode);
    }
  }
  visitAddColumn(node) {
    this.visitNode(node.column);
  }
  visitDropColumn(node) {
    this.visitNode(node.column);
  }
  visitMergeQuery(node) {
    super.visitMergeQuery(node);
    this.append(";");
  }
  visitCollate(node) {
    this.append("collate ");
    const { name: name2 } = node.collation;
    for (const char2 of name2) {
      if (!COLLATION_CHAR_REGEX.test(char2)) {
        throw new Error(`Invalid collation: ${name2}`);
      }
    }
    this.append(name2);
  }
  announcesNewColumnDataType() {
    return false;
  }
}
class MssqlDialect {
  #config;
  constructor(config2) {
    this.#config = config2;
  }
  createDriver() {
    return new MssqlDriver(this.#config);
  }
  createQueryCompiler() {
    return new MssqlQueryCompiler();
  }
  createAdapter() {
    return new MssqlAdapter();
  }
  createIntrospector(db) {
    return new MssqlIntrospector(db);
  }
}
function getKyselyDatabaseType(db) {
  if (!db) return null;
  if ("dialect" in db) return getKyselyDatabaseType(db.dialect);
  if ("createDriver" in db) {
    if (db instanceof SqliteDialect) return "sqlite";
    if (db instanceof MysqlDialect) return "mysql";
    if (db instanceof PostgresDialect) return "postgres";
    if (db instanceof MssqlDialect) return "mssql";
  }
  if ("aggregate" in db) return "sqlite";
  if ("getConnection" in db) return "mysql";
  if ("connect" in db) return "postgres";
  if ("fileControl" in db) return "sqlite";
  if ("open" in db && "close" in db && "prepare" in db) return "sqlite";
  return null;
}
const createKyselyAdapter = async (config2) => {
  const db = config2.database;
  if (!db) return {
    kysely: null,
    databaseType: null,
    transaction: void 0
  };
  if ("db" in db) return {
    kysely: db.db,
    databaseType: db.type,
    transaction: db.transaction
  };
  if ("dialect" in db) return {
    kysely: new Kysely({ dialect: db.dialect }),
    databaseType: db.type,
    transaction: db.transaction
  };
  let dialect = void 0;
  const databaseType = getKyselyDatabaseType(db);
  if ("createDriver" in db) dialect = db;
  if ("aggregate" in db && !("createSession" in db)) dialect = new SqliteDialect({ database: db });
  if ("getConnection" in db) dialect = new MysqlDialect(db);
  if ("connect" in db) dialect = new PostgresDialect({ pool: db });
  if ("fileControl" in db) {
    const { BunSqliteDialect } = await import("./bun-sqlite-dialect-DYuF9Has.js");
    dialect = new BunSqliteDialect({ database: db });
  }
  if ("createSession" in db) {
    let DatabaseSync = void 0;
    try {
      const nodeSqlite = "node:sqlite";
      ({ DatabaseSync } = await import(
        /* @vite-ignore */
        /* webpackIgnore: true */
        nodeSqlite
      ));
    } catch (error2) {
      if (error2 !== null && typeof error2 === "object" && "code" in error2 && error2.code !== "ERR_UNKNOWN_BUILTIN_MODULE") throw error2;
    }
    if (DatabaseSync && db instanceof DatabaseSync) {
      const { NodeSqliteDialect } = await import("./node-sqlite-dialect-Dir7dq9K.js");
      dialect = new NodeSqliteDialect({ database: db });
    }
  }
  return {
    kysely: dialect ? new Kysely({ dialect }) : null,
    databaseType,
    transaction: void 0
  };
};
const initGetDefaultModelName = ({ usePlural, schema: schema2 }) => {
  const getDefaultModelName = (model) => {
    if (usePlural && model.charAt(model.length - 1) === "s") {
      const pluralessModel = model.slice(0, -1);
      let m$1 = schema2[pluralessModel] ? pluralessModel : void 0;
      if (!m$1) m$1 = Object.entries(schema2).find(([_, f]) => f.modelName === pluralessModel)?.[0];
      if (m$1) return m$1;
    }
    let m = schema2[model] ? model : void 0;
    if (!m) m = Object.entries(schema2).find(([_, f]) => f.modelName === model)?.[0];
    if (!m) throw new BetterAuthError(`Model "${model}" not found in schema`);
    return m;
  };
  return getDefaultModelName;
};
const initGetDefaultFieldName = ({ schema: schema2, usePlural }) => {
  const getDefaultModelName = initGetDefaultModelName({
    schema: schema2,
    usePlural
  });
  const getDefaultFieldName = ({ field, model: unsafeModel }) => {
    if (field === "id" || field === "_id") return "id";
    const model = getDefaultModelName(unsafeModel);
    let f = schema2[model]?.fields[field];
    if (!f) {
      const result2 = Object.entries(schema2[model].fields).find(([_, f$1]) => f$1.fieldName === field);
      if (result2) {
        f = result2[1];
        field = result2[0];
      }
    }
    if (!f) throw new BetterAuthError(`Field ${field} not found in model ${model}`);
    return field;
  };
  return getDefaultFieldName;
};
const initGetIdField = ({ usePlural, schema: schema2, disableIdGeneration, options, customIdGenerator, supportsUUIDs }) => {
  const getDefaultModelName = initGetDefaultModelName({
    usePlural,
    schema: schema2
  });
  const idField = ({ customModelName, forceAllowId }) => {
    const useNumberId = options.advanced?.database?.useNumberId || options.advanced?.database?.generateId === "serial";
    const useUUIDs = options.advanced?.database?.generateId === "uuid";
    const shouldGenerateId = (() => {
      if (disableIdGeneration) return false;
      else if (useNumberId && !forceAllowId) return false;
      else if (useUUIDs) return !supportsUUIDs;
      else return true;
    })();
    const model = getDefaultModelName(customModelName ?? "id");
    return {
      type: useNumberId ? "number" : "string",
      required: shouldGenerateId ? true : false,
      ...shouldGenerateId ? { defaultValue() {
        if (disableIdGeneration) return void 0;
        const generateId$1$1 = options.advanced?.database?.generateId;
        if (generateId$1$1 === false || useNumberId) return void 0;
        if (typeof generateId$1$1 === "function") return generateId$1$1({ model });
        if (customIdGenerator) return customIdGenerator({ model });
        if (generateId$1$1 === "uuid") return crypto.randomUUID();
        return generateId$1();
      } } : {},
      transform: {
        input: (value) => {
          if (!value) return void 0;
          if (useNumberId) {
            const numberValue = Number(value);
            if (isNaN(numberValue)) return;
            return numberValue;
          }
          if (useUUIDs) {
            if (shouldGenerateId && !forceAllowId) return value;
            if (disableIdGeneration) return void 0;
            if (supportsUUIDs) return void 0;
            if (forceAllowId && typeof value === "string") if (/^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(value)) return value;
            else {
              const stack = (/* @__PURE__ */ new Error()).stack?.split("\n").filter((_, i) => i !== 1).join("\n").replace("Error:", "");
              logger.warn("[Adapter Factory] - Invalid UUID value for field `id` provided when `forceAllowId` is true. Generating a new UUID.", stack);
            }
            if (typeof value !== "string" && !supportsUUIDs) return crypto.randomUUID();
            return;
          }
          return value;
        },
        output: (value) => {
          if (!value) return void 0;
          return String(value);
        }
      }
    };
  };
  return idField;
};
const initGetFieldAttributes = ({ usePlural, schema: schema2, options, customIdGenerator, disableIdGeneration }) => {
  const getDefaultModelName = initGetDefaultModelName({
    usePlural,
    schema: schema2
  });
  const getDefaultFieldName = initGetDefaultFieldName({
    usePlural,
    schema: schema2
  });
  const idField = initGetIdField({
    usePlural,
    schema: schema2,
    options,
    customIdGenerator,
    disableIdGeneration
  });
  const getFieldAttributes = ({ model, field }) => {
    const defaultModelName = getDefaultModelName(model);
    const defaultFieldName = getDefaultFieldName({
      field,
      model: defaultModelName
    });
    const fields2 = schema2[defaultModelName].fields;
    fields2.id = idField({ customModelName: defaultModelName });
    const fieldAttributes = fields2[defaultFieldName];
    if (!fieldAttributes) throw new BetterAuthError(`Field ${field} not found in model ${model}`);
    return fieldAttributes;
  };
  return getFieldAttributes;
};
const initGetFieldName = ({ schema: schema2, usePlural }) => {
  const getDefaultModelName = initGetDefaultModelName({
    schema: schema2,
    usePlural
  });
  const getDefaultFieldName = initGetDefaultFieldName({
    schema: schema2,
    usePlural
  });
  function getFieldName({ model: modelName, field: fieldName }) {
    const model = getDefaultModelName(modelName);
    const field = getDefaultFieldName({
      model,
      field: fieldName
    });
    return schema2[model]?.fields[field]?.fieldName || field;
  }
  return getFieldName;
};
const initGetModelName = ({ usePlural, schema: schema2 }) => {
  const getDefaultModelName = initGetDefaultModelName({
    schema: schema2,
    usePlural
  });
  const getModelName = (model) => {
    const defaultModelKey = getDefaultModelName(model);
    if (schema2 && schema2[defaultModelKey] && schema2[defaultModelKey].modelName !== model) return usePlural ? `${schema2[defaultModelKey].modelName}s` : schema2[defaultModelKey].modelName;
    return usePlural ? `${model}s` : model;
  };
  return getModelName;
};
function withApplyDefault(value, field, action) {
  if (action === "update") {
    if (value === void 0 && field.onUpdate !== void 0) {
      if (typeof field.onUpdate === "function") return field.onUpdate();
      return field.onUpdate;
    }
    return value;
  }
  if (action === "create") {
    if (value === void 0 || field.required === true && value === null) {
      if (field.defaultValue !== void 0) {
        if (typeof field.defaultValue === "function") return field.defaultValue();
        return field.defaultValue;
      }
    }
  }
  return value;
}
let debugLogs = [];
let transactionId = -1;
const createAsIsTransaction = (adapter) => (fn2) => fn2(adapter);
const createAdapterFactory = ({ adapter: customAdapter, config: cfg }) => (options) => {
  const uniqueAdapterFactoryInstanceId = Math.random().toString(36).substring(2, 15);
  const config2 = {
    ...cfg,
    supportsBooleans: cfg.supportsBooleans ?? true,
    supportsDates: cfg.supportsDates ?? true,
    supportsJSON: cfg.supportsJSON ?? false,
    adapterName: cfg.adapterName ?? cfg.adapterId,
    supportsNumericIds: cfg.supportsNumericIds ?? true,
    supportsUUIDs: cfg.supportsUUIDs ?? false,
    supportsArrays: cfg.supportsArrays ?? false,
    transaction: cfg.transaction ?? false,
    disableTransformInput: cfg.disableTransformInput ?? false,
    disableTransformOutput: cfg.disableTransformOutput ?? false,
    disableTransformJoin: cfg.disableTransformJoin ?? false
  };
  if ((options.advanced?.database?.useNumberId === true || options.advanced?.database?.generateId === "serial") && config2.supportsNumericIds === false) throw new BetterAuthError(`[${config2.adapterName}] Your database or database adapter does not support numeric ids. Please disable "useNumberId" in your config.`);
  const schema2 = getAuthTables(options);
  const debugLog = (...args) => {
    if (config2.debugLogs === true || typeof config2.debugLogs === "object") {
      const logger$1 = createLogger({ level: "info" });
      if (typeof config2.debugLogs === "object" && "isRunningAdapterTests" in config2.debugLogs) {
        if (config2.debugLogs.isRunningAdapterTests) {
          args.shift();
          debugLogs.push({
            instance: uniqueAdapterFactoryInstanceId,
            args
          });
        }
        return;
      }
      if (typeof config2.debugLogs === "object" && config2.debugLogs.logCondition && !config2.debugLogs.logCondition?.()) return;
      if (typeof args[0] === "object" && "method" in args[0]) {
        const method = args.shift().method;
        if (typeof config2.debugLogs === "object") {
          if (method === "create" && !config2.debugLogs.create) return;
          else if (method === "update" && !config2.debugLogs.update) return;
          else if (method === "updateMany" && !config2.debugLogs.updateMany) return;
          else if (method === "findOne" && !config2.debugLogs.findOne) return;
          else if (method === "findMany" && !config2.debugLogs.findMany) return;
          else if (method === "delete" && !config2.debugLogs.delete) return;
          else if (method === "deleteMany" && !config2.debugLogs.deleteMany) return;
          else if (method === "count" && !config2.debugLogs.count) return;
        }
        logger$1.info(`[${config2.adapterName}]`, ...args);
      } else logger$1.info(`[${config2.adapterName}]`, ...args);
    }
  };
  const logger2 = createLogger(options.logger);
  const getDefaultModelName = initGetDefaultModelName({
    usePlural: config2.usePlural,
    schema: schema2
  });
  const getDefaultFieldName = initGetDefaultFieldName({
    usePlural: config2.usePlural,
    schema: schema2
  });
  const getModelName = initGetModelName({
    usePlural: config2.usePlural,
    schema: schema2
  });
  const getFieldName = initGetFieldName({
    schema: schema2,
    usePlural: config2.usePlural
  });
  const idField = initGetIdField({
    schema: schema2,
    options,
    usePlural: config2.usePlural,
    disableIdGeneration: config2.disableIdGeneration,
    customIdGenerator: config2.customIdGenerator,
    supportsUUIDs: config2.supportsUUIDs
  });
  const getFieldAttributes = initGetFieldAttributes({
    schema: schema2,
    options,
    usePlural: config2.usePlural,
    disableIdGeneration: config2.disableIdGeneration,
    customIdGenerator: config2.customIdGenerator
  });
  const transformInput = async (data, defaultModelName, action, forceAllowId) => {
    const transformedData = {};
    const fields2 = schema2[defaultModelName].fields;
    const newMappedKeys = config2.mapKeysTransformInput ?? {};
    const useNumberId = options.advanced?.database?.useNumberId || options.advanced?.database?.generateId === "serial";
    fields2.id = idField({
      customModelName: defaultModelName,
      forceAllowId: forceAllowId && "id" in data
    });
    for (const field in fields2) {
      let value = data[field];
      const fieldAttributes = fields2[field];
      const newFieldName = newMappedKeys[field] || fields2[field].fieldName || field;
      if (value === void 0 && (fieldAttributes.defaultValue === void 0 && !fieldAttributes.transform?.input && !(action === "update" && fieldAttributes.onUpdate) || action === "update" && !fieldAttributes.onUpdate)) continue;
      if (fieldAttributes && fieldAttributes.type === "date" && !(value instanceof Date) && typeof value === "string") try {
        value = new Date(value);
      } catch {
        logger2.error("[Adapter Factory] Failed to convert string to date", {
          value,
          field
        });
      }
      let newValue = withApplyDefault(value, fieldAttributes, action);
      if (fieldAttributes.transform?.input) newValue = await fieldAttributes.transform.input(newValue);
      if (fieldAttributes.references?.field === "id" && useNumberId) if (Array.isArray(newValue)) newValue = newValue.map((x) => x !== null ? Number(x) : null);
      else newValue = newValue !== null ? Number(newValue) : null;
      else if (config2.supportsJSON === false && typeof newValue === "object" && fieldAttributes.type === "json") newValue = JSON.stringify(newValue);
      else if (config2.supportsArrays === false && Array.isArray(newValue) && (fieldAttributes.type === "string[]" || fieldAttributes.type === "number[]")) newValue = JSON.stringify(newValue);
      else if (config2.supportsDates === false && newValue instanceof Date && fieldAttributes.type === "date") newValue = newValue.toISOString();
      else if (config2.supportsBooleans === false && typeof newValue === "boolean") newValue = newValue ? 1 : 0;
      if (config2.customTransformInput) newValue = config2.customTransformInput({
        data: newValue,
        action,
        field: newFieldName,
        fieldAttributes,
        model: getModelName(defaultModelName),
        schema: schema2,
        options
      });
      if (newValue !== void 0) transformedData[newFieldName] = newValue;
    }
    return transformedData;
  };
  const transformOutput = async (data, unsafe_model, select = [], join2) => {
    const transformSingleOutput = async (data$1, unsafe_model$1, select$1 = []) => {
      if (!data$1) return null;
      const newMappedKeys = config2.mapKeysTransformOutput ?? {};
      const transformedData$1 = {};
      const tableSchema = schema2[getDefaultModelName(unsafe_model$1)].fields;
      const idKey = Object.entries(newMappedKeys).find(([_, v]) => v === "id")?.[0];
      tableSchema[idKey ?? "id"] = { type: options.advanced?.database?.useNumberId || options.advanced?.database?.generateId === "serial" ? "number" : "string" };
      for (const key in tableSchema) {
        if (select$1.length && !select$1.includes(key)) continue;
        const field = tableSchema[key];
        if (field) {
          const originalKey = field.fieldName || key;
          let newValue = data$1[Object.entries(newMappedKeys).find(([_, v]) => v === originalKey)?.[0] || originalKey];
          if (field.transform?.output) newValue = await field.transform.output(newValue);
          const newFieldName = newMappedKeys[key] || key;
          if (originalKey === "id" || field.references?.field === "id") {
            if (typeof newValue !== "undefined" && newValue !== null) newValue = String(newValue);
          } else if (config2.supportsJSON === false && typeof newValue === "string" && field.type === "json") newValue = safeJSONParse(newValue);
          else if (config2.supportsArrays === false && typeof newValue === "string" && (field.type === "string[]" || field.type === "number[]")) newValue = safeJSONParse(newValue);
          else if (config2.supportsDates === false && typeof newValue === "string" && field.type === "date") newValue = new Date(newValue);
          else if (config2.supportsBooleans === false && typeof newValue === "number" && field.type === "boolean") newValue = newValue === 1;
          if (config2.customTransformOutput) newValue = config2.customTransformOutput({
            data: newValue,
            field: newFieldName,
            fieldAttributes: field,
            select: select$1,
            model: getModelName(unsafe_model$1),
            schema: schema2,
            options
          });
          transformedData$1[newFieldName] = newValue;
        }
      }
      return transformedData$1;
    };
    if (!join2 || Object.keys(join2).length === 0) return await transformSingleOutput(data, unsafe_model, select);
    unsafe_model = getDefaultModelName(unsafe_model);
    const transformedData = await transformSingleOutput(data, unsafe_model, select);
    const requiredModels = Object.entries(join2).map(([model, joinConfig]) => ({
      modelName: getModelName(model),
      defaultModelName: getDefaultModelName(model),
      joinConfig
    }));
    if (!data) return null;
    for (const { modelName, defaultModelName, joinConfig } of requiredModels) {
      let joinedData = await (async () => {
        if (options.experimental?.joins) return data[modelName];
        else return await handleFallbackJoin({
          baseModel: unsafe_model,
          baseData: transformedData,
          joinModel: modelName,
          specificJoinConfig: joinConfig
        });
      })();
      if (joinedData === void 0 || joinedData === null) joinedData = joinConfig.relation === "one-to-one" ? null : [];
      if (joinConfig.relation === "one-to-many" && !Array.isArray(joinedData)) joinedData = [joinedData];
      const transformed = [];
      if (Array.isArray(joinedData)) for (const item of joinedData) {
        const transformedItem = await transformSingleOutput(item, modelName, []);
        transformed.push(transformedItem);
      }
      else {
        const transformedItem = await transformSingleOutput(joinedData, modelName, []);
        transformed.push(transformedItem);
      }
      transformedData[defaultModelName] = (joinConfig.relation === "one-to-one" ? transformed[0] : transformed) ?? null;
    }
    return transformedData;
  };
  const transformWhereClause = ({ model, where, action }) => {
    if (!where) return void 0;
    const newMappedKeys = config2.mapKeysTransformInput ?? {};
    return where.map((w) => {
      const { field: unsafe_field, value, operator: operator2 = "eq", connector = "AND" } = w;
      if (operator2 === "in") {
        if (!Array.isArray(value)) throw new BetterAuthError("Value must be an array");
      }
      let newValue = value;
      const defaultModelName = getDefaultModelName(model);
      const defaultFieldName = getDefaultFieldName({
        field: unsafe_field,
        model
      });
      const fieldName = newMappedKeys[defaultFieldName] || getFieldName({
        field: defaultFieldName,
        model: defaultModelName
      });
      const fieldAttr = getFieldAttributes({
        field: defaultFieldName,
        model: defaultModelName
      });
      const useNumberId = options.advanced?.database?.useNumberId || options.advanced?.database?.generateId === "serial";
      if (defaultFieldName === "id" || fieldAttr.references?.field === "id") {
        if (useNumberId) if (Array.isArray(value)) newValue = value.map(Number);
        else newValue = Number(value);
      }
      if (fieldAttr.type === "date" && value instanceof Date && !config2.supportsDates) newValue = value.toISOString();
      if (fieldAttr.type === "boolean" && typeof value === "boolean" && !config2.supportsBooleans) newValue = value ? 1 : 0;
      if (fieldAttr.type === "json" && typeof value === "object" && !config2.supportsJSON) try {
        newValue = JSON.stringify(value);
      } catch (error2) {
        throw new Error(`Failed to stringify JSON value for field ${fieldName}`, { cause: error2 });
      }
      if (config2.customTransformInput) newValue = config2.customTransformInput({
        data: newValue,
        fieldAttributes: fieldAttr,
        field: fieldName,
        model: getModelName(model),
        schema: schema2,
        options,
        action
      });
      return {
        operator: operator2,
        connector,
        field: fieldName,
        value: newValue
      };
    });
  };
  const transformJoinClause = (baseModel, unsanitizedJoin, select) => {
    if (!unsanitizedJoin) return void 0;
    if (Object.keys(unsanitizedJoin).length === 0) return void 0;
    const transformedJoin = {};
    for (const [model, join2] of Object.entries(unsanitizedJoin)) {
      if (!join2) continue;
      const defaultModelName = getDefaultModelName(model);
      const defaultBaseModelName = getDefaultModelName(baseModel);
      let foreignKeys = Object.entries(schema2[defaultModelName].fields).filter(([field, fieldAttributes]) => fieldAttributes.references && getDefaultModelName(fieldAttributes.references.model) === defaultBaseModelName);
      let isForwardJoin = true;
      if (!foreignKeys.length) {
        foreignKeys = Object.entries(schema2[defaultBaseModelName].fields).filter(([field, fieldAttributes]) => fieldAttributes.references && getDefaultModelName(fieldAttributes.references.model) === defaultModelName);
        isForwardJoin = false;
      }
      if (!foreignKeys.length) throw new BetterAuthError(`No foreign key found for model ${model} and base model ${baseModel} while performing join operation.`);
      else if (foreignKeys.length > 1) throw new BetterAuthError(`Multiple foreign keys found for model ${model} and base model ${baseModel} while performing join operation. Only one foreign key is supported.`);
      const [foreignKey, foreignKeyAttributes] = foreignKeys[0];
      if (!foreignKeyAttributes.references) throw new BetterAuthError(`No references found for foreign key ${foreignKey} on model ${model} while performing join operation.`);
      let from;
      let to;
      let requiredSelectField;
      if (isForwardJoin) {
        requiredSelectField = foreignKeyAttributes.references.field;
        from = getFieldName({
          model: baseModel,
          field: requiredSelectField
        });
        to = getFieldName({
          model,
          field: foreignKey
        });
      } else {
        requiredSelectField = foreignKey;
        from = getFieldName({
          model: baseModel,
          field: requiredSelectField
        });
        to = getFieldName({
          model,
          field: foreignKeyAttributes.references.field
        });
      }
      if (select && !select.includes(requiredSelectField)) select.push(requiredSelectField);
      const isUnique = to === "id" ? true : foreignKeyAttributes.unique ?? false;
      let limit = options.advanced?.database?.defaultFindManyLimit ?? 100;
      if (isUnique) limit = 1;
      else if (typeof join2 === "object" && typeof join2.limit === "number") limit = join2.limit;
      transformedJoin[getModelName(model)] = {
        on: {
          from,
          to
        },
        limit,
        relation: isUnique ? "one-to-one" : "one-to-many"
      };
    }
    return {
      join: transformedJoin,
      select
    };
  };
  const handleFallbackJoin = async ({ baseModel, baseData, joinModel, specificJoinConfig: joinConfig }) => {
    if (!baseData) return baseData;
    const modelName = getModelName(joinModel);
    const field = joinConfig.on.to;
    const value = baseData[getDefaultFieldName({
      field: joinConfig.on.from,
      model: baseModel
    })];
    if (value === null || value === void 0) return joinConfig.relation === "one-to-one" ? null : [];
    let result2;
    const where = transformWhereClause({
      model: modelName,
      where: [{
        field,
        value,
        operator: "eq",
        connector: "AND"
      }],
      action: "findOne"
    });
    try {
      if (joinConfig.relation === "one-to-one") result2 = await adapterInstance.findOne({
        model: modelName,
        where
      });
      else {
        const limit = joinConfig.limit ?? options.advanced?.database?.defaultFindManyLimit ?? 100;
        result2 = await adapterInstance.findMany({
          model: modelName,
          where,
          limit
        });
      }
    } catch (error2) {
      logger2.error(`Failed to query fallback join for model ${modelName}:`, {
        where,
        limit: joinConfig.limit
      });
      console.error(error2);
      throw error2;
    }
    return result2;
  };
  const adapterInstance = customAdapter({
    options,
    schema: schema2,
    debugLog,
    getFieldName,
    getModelName,
    getDefaultModelName,
    getDefaultFieldName,
    getFieldAttributes,
    transformInput,
    transformOutput,
    transformWhereClause
  });
  let lazyLoadTransaction = null;
  const adapter = {
    transaction: async (cb) => {
      if (!lazyLoadTransaction) if (!config2.transaction) lazyLoadTransaction = createAsIsTransaction(adapter);
      else {
        logger2.debug(`[${config2.adapterName}] - Using provided transaction implementation.`);
        lazyLoadTransaction = config2.transaction;
      }
      return lazyLoadTransaction(cb);
    },
    create: async ({ data: unsafeData, model: unsafeModel, select, forceAllowId = false }) => {
      transactionId++;
      const thisTransactionId = transactionId;
      const model = getModelName(unsafeModel);
      unsafeModel = getDefaultModelName(unsafeModel);
      if ("id" in unsafeData && typeof unsafeData.id !== "undefined" && !forceAllowId) {
        logger2.warn(`[${config2.adapterName}] - You are trying to create a record with an id. This is not allowed as we handle id generation for you, unless you pass in the \`forceAllowId\` parameter. The id will be ignored.`);
        const stack = (/* @__PURE__ */ new Error()).stack?.split("\n").filter((_, i) => i !== 1).join("\n").replace("Error:", "Create method with `id` being called at:");
        console.log(stack);
        unsafeData.id = void 0;
      }
      debugLog({ method: "create" }, `${formatTransactionId(thisTransactionId)} ${formatStep(1, 4)}`, `${formatMethod("create")} ${formatAction("Unsafe Input")}:`, {
        model,
        data: unsafeData
      });
      let data = unsafeData;
      if (!config2.disableTransformInput) data = await transformInput(unsafeData, unsafeModel, "create", forceAllowId);
      debugLog({ method: "create" }, `${formatTransactionId(thisTransactionId)} ${formatStep(2, 4)}`, `${formatMethod("create")} ${formatAction("Parsed Input")}:`, {
        model,
        data
      });
      const res2 = await adapterInstance.create({
        data,
        model
      });
      debugLog({ method: "create" }, `${formatTransactionId(thisTransactionId)} ${formatStep(3, 4)}`, `${formatMethod("create")} ${formatAction("DB Result")}:`, {
        model,
        res: res2
      });
      let transformed = res2;
      if (!config2.disableTransformOutput) transformed = await transformOutput(res2, unsafeModel, select, void 0);
      debugLog({ method: "create" }, `${formatTransactionId(thisTransactionId)} ${formatStep(4, 4)}`, `${formatMethod("create")} ${formatAction("Parsed Result")}:`, {
        model,
        data: transformed
      });
      return transformed;
    },
    update: async ({ model: unsafeModel, where: unsafeWhere, update: unsafeData }) => {
      transactionId++;
      const thisTransactionId = transactionId;
      unsafeModel = getDefaultModelName(unsafeModel);
      const model = getModelName(unsafeModel);
      const where = transformWhereClause({
        model: unsafeModel,
        where: unsafeWhere,
        action: "update"
      });
      debugLog({ method: "update" }, `${formatTransactionId(thisTransactionId)} ${formatStep(1, 4)}`, `${formatMethod("update")} ${formatAction("Unsafe Input")}:`, {
        model,
        data: unsafeData
      });
      let data = unsafeData;
      if (!config2.disableTransformInput) data = await transformInput(unsafeData, unsafeModel, "update");
      debugLog({ method: "update" }, `${formatTransactionId(thisTransactionId)} ${formatStep(2, 4)}`, `${formatMethod("update")} ${formatAction("Parsed Input")}:`, {
        model,
        data
      });
      const res2 = await adapterInstance.update({
        model,
        where,
        update: data
      });
      debugLog({ method: "update" }, `${formatTransactionId(thisTransactionId)} ${formatStep(3, 4)}`, `${formatMethod("update")} ${formatAction("DB Result")}:`, {
        model,
        data: res2
      });
      let transformed = res2;
      if (!config2.disableTransformOutput) transformed = await transformOutput(res2, unsafeModel, void 0, void 0);
      debugLog({ method: "update" }, `${formatTransactionId(thisTransactionId)} ${formatStep(4, 4)}`, `${formatMethod("update")} ${formatAction("Parsed Result")}:`, {
        model,
        data: transformed
      });
      return transformed;
    },
    updateMany: async ({ model: unsafeModel, where: unsafeWhere, update: unsafeData }) => {
      transactionId++;
      const thisTransactionId = transactionId;
      const model = getModelName(unsafeModel);
      const where = transformWhereClause({
        model: unsafeModel,
        where: unsafeWhere,
        action: "updateMany"
      });
      unsafeModel = getDefaultModelName(unsafeModel);
      debugLog({ method: "updateMany" }, `${formatTransactionId(thisTransactionId)} ${formatStep(1, 4)}`, `${formatMethod("updateMany")} ${formatAction("Unsafe Input")}:`, {
        model,
        data: unsafeData
      });
      let data = unsafeData;
      if (!config2.disableTransformInput) data = await transformInput(unsafeData, unsafeModel, "update");
      debugLog({ method: "updateMany" }, `${formatTransactionId(thisTransactionId)} ${formatStep(2, 4)}`, `${formatMethod("updateMany")} ${formatAction("Parsed Input")}:`, {
        model,
        data
      });
      const updatedCount = await adapterInstance.updateMany({
        model,
        where,
        update: data
      });
      debugLog({ method: "updateMany" }, `${formatTransactionId(thisTransactionId)} ${formatStep(3, 4)}`, `${formatMethod("updateMany")} ${formatAction("DB Result")}:`, {
        model,
        data: updatedCount
      });
      debugLog({ method: "updateMany" }, `${formatTransactionId(thisTransactionId)} ${formatStep(4, 4)}`, `${formatMethod("updateMany")} ${formatAction("Parsed Result")}:`, {
        model,
        data: updatedCount
      });
      return updatedCount;
    },
    findOne: async ({ model: unsafeModel, where: unsafeWhere, select, join: unsafeJoin }) => {
      transactionId++;
      const thisTransactionId = transactionId;
      const model = getModelName(unsafeModel);
      const where = transformWhereClause({
        model: unsafeModel,
        where: unsafeWhere,
        action: "findOne"
      });
      unsafeModel = getDefaultModelName(unsafeModel);
      let join2;
      let passJoinToAdapter = true;
      if (!config2.disableTransformJoin) {
        const result2 = transformJoinClause(unsafeModel, unsafeJoin, select);
        if (result2) {
          join2 = result2.join;
          select = result2.select;
        }
        if (!options.experimental?.joins && join2 && Object.keys(join2).length > 0) passJoinToAdapter = false;
      } else join2 = unsafeJoin;
      debugLog({ method: "findOne" }, `${formatTransactionId(thisTransactionId)} ${formatStep(1, 3)}`, `${formatMethod("findOne")}:`, {
        model,
        where,
        select,
        join: join2
      });
      const res2 = await adapterInstance.findOne({
        model,
        where,
        select,
        join: passJoinToAdapter ? join2 : void 0
      });
      debugLog({ method: "findOne" }, `${formatTransactionId(thisTransactionId)} ${formatStep(2, 3)}`, `${formatMethod("findOne")} ${formatAction("DB Result")}:`, {
        model,
        data: res2
      });
      let transformed = res2;
      if (!config2.disableTransformOutput) transformed = await transformOutput(res2, unsafeModel, select, join2);
      debugLog({ method: "findOne" }, `${formatTransactionId(thisTransactionId)} ${formatStep(3, 3)}`, `${formatMethod("findOne")} ${formatAction("Parsed Result")}:`, {
        model,
        data: transformed
      });
      return transformed;
    },
    findMany: async ({ model: unsafeModel, where: unsafeWhere, limit: unsafeLimit, sortBy, offset: offset2, join: unsafeJoin }) => {
      transactionId++;
      const thisTransactionId = transactionId;
      const limit = unsafeLimit ?? options.advanced?.database?.defaultFindManyLimit ?? 100;
      const model = getModelName(unsafeModel);
      const where = transformWhereClause({
        model: unsafeModel,
        where: unsafeWhere,
        action: "findMany"
      });
      unsafeModel = getDefaultModelName(unsafeModel);
      let join2;
      let passJoinToAdapter = true;
      if (!config2.disableTransformJoin) {
        const result2 = transformJoinClause(unsafeModel, unsafeJoin, void 0);
        if (result2) join2 = result2.join;
        if (!options.experimental?.joins && join2 && Object.keys(join2).length > 0) passJoinToAdapter = false;
      } else join2 = unsafeJoin;
      debugLog({ method: "findMany" }, `${formatTransactionId(thisTransactionId)} ${formatStep(1, 3)}`, `${formatMethod("findMany")}:`, {
        model,
        where,
        limit,
        sortBy,
        offset: offset2,
        join: join2
      });
      const res2 = await adapterInstance.findMany({
        model,
        where,
        limit,
        sortBy,
        offset: offset2,
        join: passJoinToAdapter ? join2 : void 0
      });
      debugLog({ method: "findMany" }, `${formatTransactionId(thisTransactionId)} ${formatStep(2, 3)}`, `${formatMethod("findMany")} ${formatAction("DB Result")}:`, {
        model,
        data: res2
      });
      let transformed = res2;
      if (!config2.disableTransformOutput) transformed = await Promise.all(res2.map(async (r2) => {
        return await transformOutput(r2, unsafeModel, void 0, join2);
      }));
      debugLog({ method: "findMany" }, `${formatTransactionId(thisTransactionId)} ${formatStep(3, 3)}`, `${formatMethod("findMany")} ${formatAction("Parsed Result")}:`, {
        model,
        data: transformed
      });
      return transformed;
    },
    delete: async ({ model: unsafeModel, where: unsafeWhere }) => {
      transactionId++;
      const thisTransactionId = transactionId;
      const model = getModelName(unsafeModel);
      const where = transformWhereClause({
        model: unsafeModel,
        where: unsafeWhere,
        action: "delete"
      });
      unsafeModel = getDefaultModelName(unsafeModel);
      debugLog({ method: "delete" }, `${formatTransactionId(thisTransactionId)} ${formatStep(1, 2)}`, `${formatMethod("delete")}:`, {
        model,
        where
      });
      await adapterInstance.delete({
        model,
        where
      });
      debugLog({ method: "delete" }, `${formatTransactionId(thisTransactionId)} ${formatStep(2, 2)}`, `${formatMethod("delete")} ${formatAction("DB Result")}:`, { model });
    },
    deleteMany: async ({ model: unsafeModel, where: unsafeWhere }) => {
      transactionId++;
      const thisTransactionId = transactionId;
      const model = getModelName(unsafeModel);
      const where = transformWhereClause({
        model: unsafeModel,
        where: unsafeWhere,
        action: "deleteMany"
      });
      unsafeModel = getDefaultModelName(unsafeModel);
      debugLog({ method: "deleteMany" }, `${formatTransactionId(thisTransactionId)} ${formatStep(1, 2)}`, `${formatMethod("deleteMany")} ${formatAction("DeleteMany")}:`, {
        model,
        where
      });
      const res2 = await adapterInstance.deleteMany({
        model,
        where
      });
      debugLog({ method: "deleteMany" }, `${formatTransactionId(thisTransactionId)} ${formatStep(2, 2)}`, `${formatMethod("deleteMany")} ${formatAction("DB Result")}:`, {
        model,
        data: res2
      });
      return res2;
    },
    count: async ({ model: unsafeModel, where: unsafeWhere }) => {
      transactionId++;
      const thisTransactionId = transactionId;
      const model = getModelName(unsafeModel);
      const where = transformWhereClause({
        model: unsafeModel,
        where: unsafeWhere,
        action: "count"
      });
      unsafeModel = getDefaultModelName(unsafeModel);
      debugLog({ method: "count" }, `${formatTransactionId(thisTransactionId)} ${formatStep(1, 2)}`, `${formatMethod("count")}:`, {
        model,
        where
      });
      const res2 = await adapterInstance.count({
        model,
        where
      });
      debugLog({ method: "count" }, `${formatTransactionId(thisTransactionId)} ${formatStep(2, 2)}`, `${formatMethod("count")}:`, {
        model,
        data: res2
      });
      return res2;
    },
    createSchema: adapterInstance.createSchema ? async (_, file) => {
      const tables = getAuthTables(options);
      if (options.secondaryStorage && !options.session?.storeSessionInDatabase) delete tables.session;
      return adapterInstance.createSchema({
        file,
        tables
      });
    } : void 0,
    options: {
      adapterConfig: config2,
      ...adapterInstance.options ?? {}
    },
    id: config2.adapterId,
    ...config2.debugLogs?.isRunningAdapterTests ? { adapterTestDebugLogs: {
      resetDebugLogs() {
        debugLogs = debugLogs.filter((log) => log.instance !== uniqueAdapterFactoryInstanceId);
      },
      printDebugLogs() {
        const separator = ``.repeat(80);
        const logs = debugLogs.filter((log$1) => log$1.instance === uniqueAdapterFactoryInstanceId);
        if (logs.length === 0) return;
        const log = logs.reverse().map((log$1) => {
          log$1.args[0] = `
${log$1.args[0]}`;
          return [...log$1.args, "\n"];
        }).reduce((prev, curr) => {
          return [...curr, ...prev];
        }, [`
${separator}`]);
        console.log(...log);
      }
    } } : {}
  };
  return adapter;
};
function formatTransactionId(transactionId$1) {
  if (getColorDepth() < 8) return `#${transactionId$1}`;
  return `${TTY_COLORS.fg.magenta}#${transactionId$1}${TTY_COLORS.reset}`;
}
function formatStep(step, total) {
  return `${TTY_COLORS.bg.black}${TTY_COLORS.fg.yellow}[${step}/${total}]${TTY_COLORS.reset}`;
}
function formatMethod(method) {
  return `${TTY_COLORS.bright}${method}${TTY_COLORS.reset}`;
}
function formatAction(action) {
  return `${TTY_COLORS.dim}(${action})${TTY_COLORS.reset}`;
}
const map$1 = {
  postgres: {
    string: [
      "character varying",
      "varchar",
      "text",
      "uuid"
    ],
    number: [
      "int4",
      "integer",
      "bigint",
      "smallint",
      "numeric",
      "real",
      "double precision"
    ],
    boolean: ["bool", "boolean"],
    date: [
      "timestamptz",
      "timestamp",
      "date"
    ],
    json: ["json", "jsonb"]
  },
  mysql: {
    string: [
      "varchar",
      "text",
      "uuid"
    ],
    number: [
      "integer",
      "int",
      "bigint",
      "smallint",
      "decimal",
      "float",
      "double"
    ],
    boolean: ["boolean", "tinyint"],
    date: [
      "timestamp",
      "datetime",
      "date"
    ],
    json: ["json"]
  },
  sqlite: {
    string: ["TEXT"],
    number: ["INTEGER", "REAL"],
    boolean: ["INTEGER", "BOOLEAN"],
    date: ["DATE", "INTEGER"],
    json: ["TEXT"]
  },
  mssql: {
    string: [
      "varchar",
      "nvarchar",
      "uniqueidentifier"
    ],
    number: [
      "int",
      "bigint",
      "smallint",
      "decimal",
      "float",
      "double"
    ],
    boolean: ["bit", "smallint"],
    date: [
      "datetime2",
      "date",
      "datetime"
    ],
    json: ["varchar", "nvarchar"]
  }
};
function matchType(columnDataType, fieldType, dbType) {
  function normalize2(type2) {
    return type2.toLowerCase().split("(")[0].trim();
  }
  if (fieldType === "string[]" || fieldType === "number[]") return columnDataType.toLowerCase().includes("json");
  const types2 = map$1[dbType];
  return (Array.isArray(fieldType) ? types2["string"].map((t2) => t2.toLowerCase()) : types2[fieldType].map((t2) => t2.toLowerCase())).includes(normalize2(columnDataType));
}
async function getPostgresSchema(db) {
  try {
    const result2 = await sql`SHOW search_path`.execute(db);
    if (result2.rows[0]?.search_path) return result2.rows[0].search_path.split(",").map((s2) => s2.trim()).map((s2) => s2.replace(/^["']|["']$/g, "")).filter((s2) => !s2.startsWith("$"))[0] || "public";
  } catch {
  }
  return "public";
}
async function getMigrations(config2) {
  const betterAuthSchema = getSchema(config2);
  const logger$1 = createLogger(config2.logger);
  let { kysely: db, databaseType: dbType } = await createKyselyAdapter(config2);
  if (!dbType) {
    logger$1.warn("Could not determine database type, defaulting to sqlite. Please provide a type in the database options to avoid this.");
    dbType = "sqlite";
  }
  if (!db) {
    logger$1.error("Only kysely adapter is supported for migrations. You can use `generate` command to generate the schema, if you're using a different adapter.");
    process.exit(1);
  }
  let currentSchema = "public";
  if (dbType === "postgres") {
    currentSchema = await getPostgresSchema(db);
    logger$1.debug(`PostgreSQL migration: Using schema '${currentSchema}' (from search_path)`);
    try {
      if (!(await sql`
				SELECT schema_name 
				FROM information_schema.schemata 
				WHERE schema_name = ${currentSchema}
			`.execute(db)).rows[0]) logger$1.warn(`Schema '${currentSchema}' does not exist. Tables will be inspected from available schemas. Consider creating the schema first or checking your database configuration.`);
    } catch (error2) {
      logger$1.debug(`Could not verify schema existence: ${error2 instanceof Error ? error2.message : String(error2)}`);
    }
  }
  const allTableMetadata = await db.introspection.getTables();
  let tableMetadata = allTableMetadata;
  if (dbType === "postgres") try {
    const tablesInSchema = await sql`
				SELECT table_name 
				FROM information_schema.tables 
				WHERE table_schema = ${currentSchema}
				AND table_type = 'BASE TABLE'
			`.execute(db);
    const tableNamesInSchema = new Set(tablesInSchema.rows.map((row) => row.table_name));
    tableMetadata = allTableMetadata.filter((table) => table.schema === currentSchema && tableNamesInSchema.has(table.name));
    logger$1.debug(`Found ${tableMetadata.length} table(s) in schema '${currentSchema}': ${tableMetadata.map((t2) => t2.name).join(", ") || "(none)"}`);
  } catch (error2) {
    logger$1.warn(`Could not filter tables by schema. Using all discovered tables. Error: ${error2 instanceof Error ? error2.message : String(error2)}`);
  }
  const toBeCreated = [];
  const toBeAdded = [];
  for (const [key, value] of Object.entries(betterAuthSchema)) {
    const table = tableMetadata.find((t2) => t2.name === key);
    if (!table) {
      const tIndex = toBeCreated.findIndex((t2) => t2.table === key);
      const tableData = {
        table: key,
        fields: value.fields,
        order: value.order || Infinity
      };
      const insertIndex = toBeCreated.findIndex((t2) => (t2.order || Infinity) > tableData.order);
      if (insertIndex === -1) if (tIndex === -1) toBeCreated.push(tableData);
      else toBeCreated[tIndex].fields = {
        ...toBeCreated[tIndex].fields,
        ...value.fields
      };
      else toBeCreated.splice(insertIndex, 0, tableData);
      continue;
    }
    const toBeAddedFields = {};
    for (const [fieldName, field] of Object.entries(value.fields)) {
      const column = table.columns.find((c2) => c2.name === fieldName);
      if (!column) {
        toBeAddedFields[fieldName] = field;
        continue;
      }
      if (matchType(column.dataType, field.type, dbType)) continue;
      else logger$1.warn(`Field ${fieldName} in table ${key} has a different type in the database. Expected ${field.type} but got ${column.dataType}.`);
    }
    if (Object.keys(toBeAddedFields).length > 0) toBeAdded.push({
      table: key,
      fields: toBeAddedFields,
      order: value.order || Infinity
    });
  }
  const migrations = [];
  const useUUIDs = config2.advanced?.database?.generateId === "uuid";
  const useNumberId = config2.advanced?.database?.useNumberId || config2.advanced?.database?.generateId === "serial";
  function getType2(field, fieldName) {
    const type2 = field.type;
    const provider = dbType || "sqlite";
    const typeMap = {
      string: {
        sqlite: "text",
        postgres: "text",
        mysql: field.unique ? "varchar(255)" : field.references ? "varchar(36)" : field.sortable ? "varchar(255)" : field.index ? "varchar(255)" : "text",
        mssql: field.unique || field.sortable ? "varchar(255)" : field.references ? "varchar(36)" : "varchar(8000)"
      },
      boolean: {
        sqlite: "integer",
        postgres: "boolean",
        mysql: "boolean",
        mssql: "smallint"
      },
      number: {
        sqlite: field.bigint ? "bigint" : "integer",
        postgres: field.bigint ? "bigint" : "integer",
        mysql: field.bigint ? "bigint" : "integer",
        mssql: field.bigint ? "bigint" : "integer"
      },
      date: {
        sqlite: "date",
        postgres: "timestamptz",
        mysql: "timestamp(3)",
        mssql: sql`datetime2(3)`
      },
      json: {
        sqlite: "text",
        postgres: "jsonb",
        mysql: "json",
        mssql: "varchar(8000)"
      },
      id: {
        postgres: useNumberId ? sql`integer GENERATED BY DEFAULT AS IDENTITY` : useUUIDs ? "uuid" : "text",
        mysql: useNumberId ? "integer" : useUUIDs ? "varchar(36)" : "varchar(36)",
        mssql: useNumberId ? "integer" : useUUIDs ? "varchar(36)" : "varchar(36)",
        sqlite: useNumberId ? "integer" : "text"
      },
      foreignKeyId: {
        postgres: useNumberId ? "integer" : useUUIDs ? "uuid" : "text",
        mysql: useNumberId ? "integer" : useUUIDs ? "varchar(36)" : "varchar(36)",
        mssql: useNumberId ? "integer" : useUUIDs ? "varchar(36)" : "varchar(36)",
        sqlite: useNumberId ? "integer" : "text"
      },
      "string[]": {
        sqlite: "text",
        postgres: "jsonb",
        mysql: "json",
        mssql: "varchar(8000)"
      },
      "number[]": {
        sqlite: "text",
        postgres: "jsonb",
        mysql: "json",
        mssql: "varchar(8000)"
      }
    };
    if (fieldName === "id" || field.references?.field === "id") {
      if (fieldName === "id") return typeMap.id[provider];
      return typeMap.foreignKeyId[provider];
    }
    if (Array.isArray(type2)) return "text";
    if (!(type2 in typeMap)) throw new Error(`Unsupported field type '${String(type2)}' for field '${fieldName}'. Allowed types are: string, number, boolean, date, string[], number[]. If you need to store structured data, store it as a JSON string (type: "string") or split it into primitive fields. See https://better-auth.com/docs/advanced/schema#additional-fields`);
    return typeMap[type2][provider];
  }
  const getModelName = initGetModelName({
    schema: getAuthTables(config2),
    usePlural: false
  });
  const getFieldName = initGetFieldName({
    schema: getAuthTables(config2),
    usePlural: false
  });
  function getReferencePath(model, field) {
    try {
      return `${getModelName(model)}.${getFieldName({
        model,
        field
      })}`;
    } catch {
      return `${model}.${field}`;
    }
  }
  if (toBeAdded.length) for (const table of toBeAdded) for (const [fieldName, field] of Object.entries(table.fields)) {
    const type2 = getType2(field, fieldName);
    const builder = db.schema.alterTable(table.table);
    if (field.index) {
      const index2 = db.schema.alterTable(table.table).addIndex(`${table.table}_${fieldName}_idx`);
      migrations.push(index2);
    }
    const built = builder.addColumn(fieldName, type2, (col) => {
      col = field.required !== false ? col.notNull() : col;
      if (field.references) col = col.references(getReferencePath(field.references.model, field.references.field)).onDelete(field.references.onDelete || "cascade");
      if (field.unique) col = col.unique();
      if (field.type === "date" && typeof field.defaultValue === "function" && (dbType === "postgres" || dbType === "mysql" || dbType === "mssql")) if (dbType === "mysql") col = col.defaultTo(sql`CURRENT_TIMESTAMP(3)`);
      else col = col.defaultTo(sql`CURRENT_TIMESTAMP`);
      return col;
    });
    migrations.push(built);
  }
  const toBeIndexed = [];
  if (config2.advanced?.database?.useNumberId) logger$1.warn("`useNumberId` is deprecated. Please use `generateId` with `serial` instead.");
  if (toBeCreated.length) for (const table of toBeCreated) {
    const idType = getType2({ type: useNumberId ? "number" : "string" }, "id");
    let dbT = db.schema.createTable(table.table).addColumn("id", idType, (col) => {
      if (useNumberId) {
        if (dbType === "postgres") return col.primaryKey().notNull();
        else if (dbType === "sqlite") return col.primaryKey().notNull();
        else if (dbType === "mssql") return col.identity().primaryKey().notNull();
        return col.autoIncrement().primaryKey().notNull();
      }
      if (useUUIDs) {
        if (dbType === "postgres") return col.primaryKey().defaultTo(sql`pg_catalog.gen_random_uuid()`).notNull();
        return col.primaryKey().notNull();
      }
      return col.primaryKey().notNull();
    });
    for (const [fieldName, field] of Object.entries(table.fields)) {
      const type2 = getType2(field, fieldName);
      dbT = dbT.addColumn(fieldName, type2, (col) => {
        col = field.required !== false ? col.notNull() : col;
        if (field.references) col = col.references(getReferencePath(field.references.model, field.references.field)).onDelete(field.references.onDelete || "cascade");
        if (field.unique) col = col.unique();
        if (field.type === "date" && typeof field.defaultValue === "function" && (dbType === "postgres" || dbType === "mysql" || dbType === "mssql")) if (dbType === "mysql") col = col.defaultTo(sql`CURRENT_TIMESTAMP(3)`);
        else col = col.defaultTo(sql`CURRENT_TIMESTAMP`);
        return col;
      });
      if (field.index) {
        const builder = db.schema.createIndex(`${table.table}_${fieldName}_${field.unique ? "uidx" : "idx"}`).on(table.table).columns([fieldName]);
        toBeIndexed.push(field.unique ? builder.unique() : builder);
      }
    }
    migrations.push(dbT);
  }
  if (toBeIndexed.length) for (const index2 of toBeIndexed) migrations.push(index2);
  async function runMigrations() {
    for (const migration of migrations) await migration.execute();
  }
  async function compileMigrations() {
    return migrations.map((m) => m.compile().sql).join(";\n\n") + ";";
  }
  return {
    toBeCreated,
    toBeAdded,
    runMigrations,
    compileMigrations
  };
}
var db_exports = /* @__PURE__ */ __export$1({
  convertFromDB: () => convertFromDB,
  convertToDB: () => convertToDB,
  createFieldAttribute: () => createFieldAttribute,
  createInternalAdapter: () => createInternalAdapter,
  getAdapter: () => getAdapter,
  getBaseAdapter: () => getBaseAdapter,
  getMigrations: () => getMigrations,
  getSchema: () => getSchema,
  getWithHooks: () => getWithHooks,
  matchType: () => matchType,
  mergeSchema: () => mergeSchema,
  parseAccountInput: () => parseAccountInput,
  parseAccountOutput: () => parseAccountOutput,
  parseAdditionalUserInput: () => parseAdditionalUserInput,
  parseInputData: () => parseInputData,
  parseSessionInput: () => parseSessionInput,
  parseSessionOutput: () => parseSessionOutput,
  parseUserInput: () => parseUserInput,
  parseUserOutput: () => parseUserOutput,
  toZodSchema: () => toZodSchema
});
__reExport$1(db_exports, import___better_auth_core_db);
const getSession = () => createAuthEndpoint("/get-session", {
  method: "GET",
  operationId: "getSession",
  query: getSessionQuerySchema,
  requireHeaders: true,
  metadata: { openapi: {
    operationId: "getSession",
    description: "Get the current session",
    responses: { "200": {
      description: "Success",
      content: { "application/json": { schema: {
        type: "object",
        nullable: true,
        properties: {
          session: { $ref: "#/components/schemas/Session" },
          user: { $ref: "#/components/schemas/User" }
        },
        required: ["session", "user"]
      } } }
    } }
  } }
}, async (ctx) => {
  try {
    const sessionCookieToken = await ctx.getSignedCookie(ctx.context.authCookies.sessionToken.name, ctx.context.secret);
    if (!sessionCookieToken) return null;
    const sessionDataCookie = getChunkedCookie(ctx, ctx.context.authCookies.sessionData.name);
    let sessionDataPayload = null;
    if (sessionDataCookie) {
      const strategy = ctx.context.options.session?.cookieCache?.strategy || "compact";
      if (strategy === "jwe") {
        const payload = await symmetricDecodeJWT(sessionDataCookie, ctx.context.secret, "better-auth-session");
        if (payload && payload.session && payload.user) sessionDataPayload = {
          session: {
            session: payload.session,
            user: payload.user,
            updatedAt: payload.updatedAt,
            version: payload.version
          },
          expiresAt: payload.exp ? payload.exp * 1e3 : Date.now()
        };
        else {
          expireCookie(ctx, ctx.context.authCookies.sessionData);
          return ctx.json(null);
        }
      } else if (strategy === "jwt") {
        const payload = await verifyJWT(sessionDataCookie, ctx.context.secret);
        if (payload && payload.session && payload.user) sessionDataPayload = {
          session: {
            session: payload.session,
            user: payload.user,
            updatedAt: payload.updatedAt,
            version: payload.version
          },
          expiresAt: payload.exp ? payload.exp * 1e3 : Date.now()
        };
        else {
          expireCookie(ctx, ctx.context.authCookies.sessionData);
          return ctx.json(null);
        }
      } else {
        const parsed = safeJSONParse(binary.decode(base64Url.decode(sessionDataCookie)));
        if (parsed) if (await createHMAC("SHA-256", "base64urlnopad").verify(ctx.context.secret, JSON.stringify({
          ...parsed.session,
          expiresAt: parsed.expiresAt
        }), parsed.signature)) sessionDataPayload = parsed;
        else {
          expireCookie(ctx, ctx.context.authCookies.sessionData);
          return ctx.json(null);
        }
      }
    }
    const dontRememberMe = await ctx.getSignedCookie(ctx.context.authCookies.dontRememberToken.name, ctx.context.secret);
    if (sessionDataPayload?.session && ctx.context.options.session?.cookieCache?.enabled && !ctx.query?.disableCookieCache) {
      const session$1 = sessionDataPayload.session;
      const versionConfig = ctx.context.options.session?.cookieCache?.version;
      let expectedVersion = "1";
      if (versionConfig) {
        if (typeof versionConfig === "string") expectedVersion = versionConfig;
        else if (typeof versionConfig === "function") {
          const result2 = versionConfig(session$1.session, session$1.user);
          expectedVersion = result2 instanceof Promise ? await result2 : result2;
        }
      }
      if ((session$1.version || "1") !== expectedVersion) expireCookie(ctx, ctx.context.authCookies.sessionData);
      else {
        const cachedSessionExpiresAt = new Date(session$1.session.expiresAt);
        if (sessionDataPayload.expiresAt < Date.now() || cachedSessionExpiresAt < /* @__PURE__ */ new Date()) expireCookie(ctx, ctx.context.authCookies.sessionData);
        else {
          const cookieRefreshCache = ctx.context.sessionConfig.cookieRefreshCache;
          if (cookieRefreshCache === false) {
            ctx.context.session = session$1;
            const parsedSession$2 = parseSessionOutput(ctx.context.options, {
              ...session$1.session,
              expiresAt: new Date(session$1.session.expiresAt),
              createdAt: new Date(session$1.session.createdAt),
              updatedAt: new Date(session$1.session.updatedAt)
            });
            const parsedUser$2 = parseUserOutput(ctx.context.options, {
              ...session$1.user,
              createdAt: new Date(session$1.user.createdAt),
              updatedAt: new Date(session$1.user.updatedAt)
            });
            return ctx.json({
              session: parsedSession$2,
              user: parsedUser$2
            });
          }
          if (sessionDataPayload.expiresAt - Date.now() < cookieRefreshCache.updateAge * 1e3) {
            const newExpiresAt = getDate(ctx.context.options.session?.cookieCache?.maxAge || 300, "sec");
            const refreshedSession = {
              session: {
                ...session$1.session,
                expiresAt: newExpiresAt
              },
              user: session$1.user,
              updatedAt: Date.now()
            };
            await setCookieCache(ctx, refreshedSession, false);
            const parsedRefreshedSession = parseSessionOutput(ctx.context.options, {
              ...refreshedSession.session,
              expiresAt: new Date(refreshedSession.session.expiresAt),
              createdAt: new Date(refreshedSession.session.createdAt),
              updatedAt: new Date(refreshedSession.session.updatedAt)
            });
            const parsedRefreshedUser = parseUserOutput(ctx.context.options, {
              ...refreshedSession.user,
              createdAt: new Date(refreshedSession.user.createdAt),
              updatedAt: new Date(refreshedSession.user.updatedAt)
            });
            ctx.context.session = {
              session: parsedRefreshedSession,
              user: parsedRefreshedUser
            };
            return ctx.json({
              session: parsedRefreshedSession,
              user: parsedRefreshedUser
            });
          }
          const parsedSession$1 = parseSessionOutput(ctx.context.options, {
            ...session$1.session,
            expiresAt: new Date(session$1.session.expiresAt),
            createdAt: new Date(session$1.session.createdAt),
            updatedAt: new Date(session$1.session.updatedAt)
          });
          const parsedUser$1 = parseUserOutput(ctx.context.options, {
            ...session$1.user,
            createdAt: new Date(session$1.user.createdAt),
            updatedAt: new Date(session$1.user.updatedAt)
          });
          ctx.context.session = {
            session: parsedSession$1,
            user: parsedUser$1
          };
          return ctx.json({
            session: parsedSession$1,
            user: parsedUser$1
          });
        }
      }
    }
    const session = await ctx.context.internalAdapter.findSession(sessionCookieToken);
    ctx.context.session = session;
    if (!session || session.session.expiresAt < /* @__PURE__ */ new Date()) {
      deleteSessionCookie(ctx);
      if (session)
        await ctx.context.internalAdapter.deleteSession(session.session.token);
      return ctx.json(null);
    }
    if (dontRememberMe || ctx.query?.disableRefresh) {
      const parsedSession$1 = parseSessionOutput(ctx.context.options, session.session);
      const parsedUser$1 = parseUserOutput(ctx.context.options, session.user);
      return ctx.json({
        session: parsedSession$1,
        user: parsedUser$1
      });
    }
    const expiresIn = ctx.context.sessionConfig.expiresIn;
    const updateAge = ctx.context.sessionConfig.updateAge;
    if (session.session.expiresAt.valueOf() - expiresIn * 1e3 + updateAge * 1e3 <= Date.now() && (!ctx.query?.disableRefresh || !ctx.context.options.session?.disableSessionRefresh)) {
      const updatedSession = await ctx.context.internalAdapter.updateSession(session.session.token, {
        expiresAt: getDate(ctx.context.sessionConfig.expiresIn, "sec"),
        updatedAt: /* @__PURE__ */ new Date()
      });
      if (!updatedSession) {
        deleteSessionCookie(ctx);
        return ctx.json(null, { status: 401 });
      }
      const maxAge = (updatedSession.expiresAt.valueOf() - Date.now()) / 1e3;
      await setSessionCookie(ctx, {
        session: updatedSession,
        user: session.user
      }, false, { maxAge });
      const parsedUpdatedSession = parseSessionOutput(ctx.context.options, updatedSession);
      const parsedUser$1 = parseUserOutput(ctx.context.options, session.user);
      return ctx.json({
        session: parsedUpdatedSession,
        user: parsedUser$1
      });
    }
    await setCookieCache(ctx, session, !!dontRememberMe);
    const parsedSession = parseSessionOutput(ctx.context.options, session.session);
    const parsedUser = parseUserOutput(ctx.context.options, session.user);
    return ctx.json({
      session: parsedSession,
      user: parsedUser
    });
  } catch (error2) {
    ctx.context.logger.error("INTERNAL_SERVER_ERROR", error2);
    throw new APIError$1("INTERNAL_SERVER_ERROR", { message: BASE_ERROR_CODES.FAILED_TO_GET_SESSION });
  }
});
const getSessionFromCtx = async (ctx, config2) => {
  if (ctx.context.session) return ctx.context.session;
  const session = await getSession()({
    ...ctx,
    asResponse: false,
    headers: ctx.headers,
    returnHeaders: false,
    returnStatus: false,
    query: {
      ...config2,
      ...ctx.query
    }
  }).catch((e2) => {
    return null;
  });
  ctx.context.session = session;
  return session;
};
const sessionMiddleware = createAuthMiddleware(async (ctx) => {
  const session = await getSessionFromCtx(ctx);
  if (!session?.session) throw new APIError$1("UNAUTHORIZED");
  return { session };
});
const sensitiveSessionMiddleware = createAuthMiddleware(async (ctx) => {
  const session = await getSessionFromCtx(ctx, { disableCookieCache: true });
  if (!session?.session) throw new APIError$1("UNAUTHORIZED");
  return { session };
});
createAuthMiddleware(async (ctx) => {
  const session = await getSessionFromCtx(ctx);
  if (!session?.session && (ctx.request || ctx.headers)) throw new APIError$1("UNAUTHORIZED");
  return { session };
});
const freshSessionMiddleware = createAuthMiddleware(async (ctx) => {
  const session = await getSessionFromCtx(ctx);
  if (!session?.session) throw new APIError$1("UNAUTHORIZED");
  if (ctx.context.sessionConfig.freshAge === 0) return { session };
  const freshAge = ctx.context.sessionConfig.freshAge;
  const lastUpdated = new Date(session.session.updatedAt || session.session.createdAt).getTime();
  if (!(Date.now() - lastUpdated < freshAge * 1e3)) throw new APIError$1("FORBIDDEN", { message: "Session is not fresh" });
  return { session };
});
const listSessions = () => createAuthEndpoint("/list-sessions", {
  method: "GET",
  operationId: "listUserSessions",
  use: [sessionMiddleware],
  requireHeaders: true,
  metadata: { openapi: {
    operationId: "listUserSessions",
    description: "List all active sessions for the user",
    responses: { "200": {
      description: "Success",
      content: { "application/json": { schema: {
        type: "array",
        items: { $ref: "#/components/schemas/Session" }
      } } }
    } }
  } }
}, async (ctx) => {
  try {
    const activeSessions = (await ctx.context.internalAdapter.listSessions(ctx.context.session.user.id)).filter((session) => {
      return session.expiresAt > /* @__PURE__ */ new Date();
    });
    return ctx.json(activeSessions.map((session) => parseSessionOutput(ctx.context.options, session)));
  } catch (e2) {
    ctx.context.logger.error(e2);
    throw ctx.error("INTERNAL_SERVER_ERROR");
  }
});
const revokeSession = createAuthEndpoint("/revoke-session", {
  method: "POST",
  body: z.object({ token: z.string().meta({ description: "The token to revoke" }) }),
  use: [sensitiveSessionMiddleware],
  requireHeaders: true,
  metadata: { openapi: {
    description: "Revoke a single session",
    requestBody: { content: { "application/json": { schema: {
      type: "object",
      properties: { token: {
        type: "string",
        description: "The token to revoke"
      } },
      required: ["token"]
    } } } },
    responses: { "200": {
      description: "Success",
      content: { "application/json": { schema: {
        type: "object",
        properties: { status: {
          type: "boolean",
          description: "Indicates if the session was revoked successfully"
        } },
        required: ["status"]
      } } }
    } }
  } }
}, async (ctx) => {
  const token2 = ctx.body.token;
  if ((await ctx.context.internalAdapter.findSession(token2))?.session.userId === ctx.context.session.user.id) try {
    await ctx.context.internalAdapter.deleteSession(token2);
  } catch (error2) {
    ctx.context.logger.error(error2 && typeof error2 === "object" && "name" in error2 ? error2.name : "", error2);
    throw new APIError$1("INTERNAL_SERVER_ERROR");
  }
  return ctx.json({ status: true });
});
const revokeSessions = createAuthEndpoint("/revoke-sessions", {
  method: "POST",
  use: [sensitiveSessionMiddleware],
  requireHeaders: true,
  metadata: { openapi: {
    description: "Revoke all sessions for the user",
    responses: { "200": {
      description: "Success",
      content: { "application/json": { schema: {
        type: "object",
        properties: { status: {
          type: "boolean",
          description: "Indicates if all sessions were revoked successfully"
        } },
        required: ["status"]
      } } }
    } }
  } }
}, async (ctx) => {
  try {
    await ctx.context.internalAdapter.deleteSessions(ctx.context.session.user.id);
  } catch (error2) {
    ctx.context.logger.error(error2 && typeof error2 === "object" && "name" in error2 ? error2.name : "", error2);
    throw new APIError$1("INTERNAL_SERVER_ERROR");
  }
  return ctx.json({ status: true });
});
const revokeOtherSessions = createAuthEndpoint("/revoke-other-sessions", {
  method: "POST",
  requireHeaders: true,
  use: [sensitiveSessionMiddleware],
  metadata: { openapi: {
    description: "Revoke all other sessions for the user except the current one",
    responses: { "200": {
      description: "Success",
      content: { "application/json": { schema: {
        type: "object",
        properties: { status: {
          type: "boolean",
          description: "Indicates if all other sessions were revoked successfully"
        } },
        required: ["status"]
      } } }
    } }
  } }
}, async (ctx) => {
  const session = ctx.context.session;
  if (!session.user) throw new APIError$1("UNAUTHORIZED");
  const otherSessions = (await ctx.context.internalAdapter.listSessions(session.user.id)).filter((session$1) => {
    return session$1.expiresAt > /* @__PURE__ */ new Date();
  }).filter((session$1) => session$1.token !== ctx.context.session.session.token);
  await Promise.all(otherSessions.map((session$1) => ctx.context.internalAdapter.deleteSession(session$1.token)));
  return ctx.json({ status: true });
});
function decryptOAuthToken(token2, ctx) {
  if (!token2) return token2;
  if (ctx.options.account?.encryptOAuthTokens) return symmetricDecrypt({
    key: ctx.secret,
    data: token2
  });
  return token2;
}
function setTokenUtil(token2, ctx) {
  if (ctx.options.account?.encryptOAuthTokens && token2) return symmetricEncrypt({
    key: ctx.secret,
    data: token2
  });
  return token2;
}
function getOAuth2Tokens(data) {
  const getDate2 = (seconds) => {
    const now2 = /* @__PURE__ */ new Date();
    return new Date(now2.getTime() + seconds * 1e3);
  };
  return {
    tokenType: data.token_type,
    accessToken: data.access_token,
    refreshToken: data.refresh_token,
    accessTokenExpiresAt: data.expires_in ? getDate2(data.expires_in) : void 0,
    refreshTokenExpiresAt: data.refresh_token_expires_in ? getDate2(data.refresh_token_expires_in) : void 0,
    scopes: data?.scope ? typeof data.scope === "string" ? data.scope.split(" ") : data.scope : [],
    idToken: data.id_token,
    raw: data
  };
}
async function generateCodeChallenge(codeVerifier) {
  const data = new TextEncoder().encode(codeVerifier);
  const hash = await crypto.subtle.digest("SHA-256", data);
  return base64Url.encode(new Uint8Array(hash), { padding: false });
}
async function createAuthorizationURL({ id, options, authorizationEndpoint, state, codeVerifier, scopes, claims, redirectURI, duration, prompt, accessType, responseType, display, loginHint, hd, responseMode, additionalParams, scopeJoiner }) {
  const url = new URL(options.authorizationEndpoint || authorizationEndpoint);
  url.searchParams.set("response_type", responseType || "code");
  const primaryClientId = Array.isArray(options.clientId) ? options.clientId[0] : options.clientId;
  url.searchParams.set("client_id", primaryClientId);
  url.searchParams.set("state", state);
  if (scopes) url.searchParams.set("scope", scopes.join(scopeJoiner || " "));
  url.searchParams.set("redirect_uri", options.redirectURI || redirectURI);
  duration && url.searchParams.set("duration", duration);
  display && url.searchParams.set("display", display);
  loginHint && url.searchParams.set("login_hint", loginHint);
  prompt && url.searchParams.set("prompt", prompt);
  hd && url.searchParams.set("hd", hd);
  accessType && url.searchParams.set("access_type", accessType);
  responseMode && url.searchParams.set("response_mode", responseMode);
  if (codeVerifier) {
    const codeChallenge = await generateCodeChallenge(codeVerifier);
    url.searchParams.set("code_challenge_method", "S256");
    url.searchParams.set("code_challenge", codeChallenge);
  }
  if (claims) {
    const claimsObj = claims.reduce((acc, claim) => {
      acc[claim] = null;
      return acc;
    }, {});
    url.searchParams.set("claims", JSON.stringify({ id_token: {
      email: null,
      email_verified: null,
      ...claimsObj
    } }));
  }
  if (additionalParams) Object.entries(additionalParams).forEach(([key, value]) => {
    url.searchParams.set(key, value);
  });
  return url;
}
var __defProp$3 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var BetterFetchError = class extends Error {
  constructor(status, statusText, error2) {
    super(statusText || status.toString(), {
      cause: error2
    });
    this.status = status;
    this.statusText = statusText;
    this.error = error2;
    Error.captureStackTrace(this, this.constructor);
  }
};
var initializePlugins = async (url, options) => {
  var _a2, _b, _c, _d, _e, _f;
  let opts = options || {};
  const hooks = {
    onRequest: [options == null ? void 0 : options.onRequest],
    onResponse: [options == null ? void 0 : options.onResponse],
    onSuccess: [options == null ? void 0 : options.onSuccess],
    onError: [options == null ? void 0 : options.onError],
    onRetry: [options == null ? void 0 : options.onRetry]
  };
  if (!options || !(options == null ? void 0 : options.plugins)) {
    return {
      url,
      options: opts,
      hooks
    };
  }
  for (const plugin of (options == null ? void 0 : options.plugins) || []) {
    if (plugin.init) {
      const pluginRes = await ((_a2 = plugin.init) == null ? void 0 : _a2.call(plugin, url.toString(), options));
      opts = pluginRes.options || opts;
      url = pluginRes.url;
    }
    hooks.onRequest.push((_b = plugin.hooks) == null ? void 0 : _b.onRequest);
    hooks.onResponse.push((_c = plugin.hooks) == null ? void 0 : _c.onResponse);
    hooks.onSuccess.push((_d = plugin.hooks) == null ? void 0 : _d.onSuccess);
    hooks.onError.push((_e = plugin.hooks) == null ? void 0 : _e.onError);
    hooks.onRetry.push((_f = plugin.hooks) == null ? void 0 : _f.onRetry);
  }
  return {
    url,
    options: opts,
    hooks
  };
};
var LinearRetryStrategy = class {
  constructor(options) {
    this.options = options;
  }
  shouldAttemptRetry(attempt, response) {
    if (this.options.shouldRetry) {
      return Promise.resolve(
        attempt < this.options.attempts && this.options.shouldRetry(response)
      );
    }
    return Promise.resolve(attempt < this.options.attempts);
  }
  getDelay() {
    return this.options.delay;
  }
};
var ExponentialRetryStrategy = class {
  constructor(options) {
    this.options = options;
  }
  shouldAttemptRetry(attempt, response) {
    if (this.options.shouldRetry) {
      return Promise.resolve(
        attempt < this.options.attempts && this.options.shouldRetry(response)
      );
    }
    return Promise.resolve(attempt < this.options.attempts);
  }
  getDelay(attempt) {
    const delay2 = Math.min(
      this.options.maxDelay,
      this.options.baseDelay * 2 ** attempt
    );
    return delay2;
  }
};
function createRetryStrategy(options) {
  if (typeof options === "number") {
    return new LinearRetryStrategy({
      type: "linear",
      attempts: options,
      delay: 1e3
    });
  }
  switch (options.type) {
    case "linear":
      return new LinearRetryStrategy(options);
    case "exponential":
      return new ExponentialRetryStrategy(options);
    default:
      throw new Error("Invalid retry strategy");
  }
}
var getAuthHeader = async (options) => {
  const headers = {};
  const getValue = async (value) => typeof value === "function" ? await value() : value;
  if (options == null ? void 0 : options.auth) {
    if (options.auth.type === "Bearer") {
      const token2 = await getValue(options.auth.token);
      if (!token2) {
        return headers;
      }
      headers["authorization"] = `Bearer ${token2}`;
    } else if (options.auth.type === "Basic") {
      const [username, password] = await Promise.all([
        getValue(options.auth.username),
        getValue(options.auth.password)
      ]);
      if (!username || !password) {
        return headers;
      }
      headers["authorization"] = `Basic ${btoa(`${username}:${password}`)}`;
    } else if (options.auth.type === "Custom") {
      const [prefix, value] = await Promise.all([
        getValue(options.auth.prefix),
        getValue(options.auth.value)
      ]);
      if (!value) {
        return headers;
      }
      headers["authorization"] = `${prefix != null ? prefix : ""} ${value}`;
    }
  }
  return headers;
};
var JSON_RE = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i;
function detectResponseType(request) {
  const _contentType = request.headers.get("content-type");
  const textTypes = /* @__PURE__ */ new Set([
    "image/svg",
    "application/xml",
    "application/xhtml",
    "application/html"
  ]);
  if (!_contentType) {
    return "json";
  }
  const contentType = _contentType.split(";").shift() || "";
  if (JSON_RE.test(contentType)) {
    return "json";
  }
  if (textTypes.has(contentType) || contentType.startsWith("text/")) {
    return "text";
  }
  return "blob";
}
function isJSONParsable(value) {
  try {
    JSON.parse(value);
    return true;
  } catch (error2) {
    return false;
  }
}
function isJSONSerializable(value) {
  if (value === void 0) {
    return false;
  }
  const t2 = typeof value;
  if (t2 === "string" || t2 === "number" || t2 === "boolean" || t2 === null) {
    return true;
  }
  if (t2 !== "object") {
    return false;
  }
  if (Array.isArray(value)) {
    return true;
  }
  if (value.buffer) {
    return false;
  }
  return value.constructor && value.constructor.name === "Object" || typeof value.toJSON === "function";
}
function jsonParse(text2) {
  try {
    return JSON.parse(text2);
  } catch (error2) {
    return text2;
  }
}
function isFunction(value) {
  return typeof value === "function";
}
function getFetch(options) {
  if (options == null ? void 0 : options.customFetchImpl) {
    return options.customFetchImpl;
  }
  if (typeof globalThis !== "undefined" && isFunction(globalThis.fetch)) {
    return globalThis.fetch;
  }
  if (typeof window !== "undefined" && isFunction(window.fetch)) {
    return window.fetch;
  }
  throw new Error("No fetch implementation found");
}
async function getHeaders(opts) {
  const headers = new Headers(opts == null ? void 0 : opts.headers);
  const authHeader = await getAuthHeader(opts);
  for (const [key, value] of Object.entries(authHeader || {})) {
    headers.set(key, value);
  }
  if (!headers.has("content-type")) {
    const t2 = detectContentType(opts == null ? void 0 : opts.body);
    if (t2) {
      headers.set("content-type", t2);
    }
  }
  return headers;
}
function detectContentType(body) {
  if (isJSONSerializable(body)) {
    return "application/json";
  }
  return null;
}
function getBody(options) {
  if (!(options == null ? void 0 : options.body)) {
    return null;
  }
  const headers = new Headers(options == null ? void 0 : options.headers);
  if (isJSONSerializable(options.body) && !headers.has("content-type")) {
    for (const [key, value] of Object.entries(options == null ? void 0 : options.body)) {
      if (value instanceof Date) {
        options.body[key] = value.toISOString();
      }
    }
    return JSON.stringify(options.body);
  }
  if (headers.has("content-type") && headers.get("content-type") === "application/x-www-form-urlencoded") {
    if (isJSONSerializable(options.body)) {
      return new URLSearchParams(options.body).toString();
    }
    return options.body;
  }
  return options.body;
}
function getMethod(url, options) {
  var _a2;
  if (options == null ? void 0 : options.method) {
    return options.method.toUpperCase();
  }
  if (url.startsWith("@")) {
    const pMethod = (_a2 = url.split("@")[1]) == null ? void 0 : _a2.split("/")[0];
    if (!methods.includes(pMethod)) {
      return (options == null ? void 0 : options.body) ? "POST" : "GET";
    }
    return pMethod.toUpperCase();
  }
  return (options == null ? void 0 : options.body) ? "POST" : "GET";
}
function getTimeout(options, controller) {
  let abortTimeout;
  if (!(options == null ? void 0 : options.signal) && (options == null ? void 0 : options.timeout)) {
    abortTimeout = setTimeout(() => controller == null ? void 0 : controller.abort(), options == null ? void 0 : options.timeout);
  }
  return {
    abortTimeout,
    clearTimeout: () => {
      if (abortTimeout) {
        clearTimeout(abortTimeout);
      }
    }
  };
}
var ValidationError3 = class _ValidationError extends Error {
  constructor(issues, message2) {
    super(message2 || JSON.stringify(issues, null, 2));
    this.issues = issues;
    Object.setPrototypeOf(this, _ValidationError.prototype);
  }
};
async function parseStandardSchema(schema2, input) {
  const result2 = await schema2["~standard"].validate(input);
  if (result2.issues) {
    throw new ValidationError3(result2.issues);
  }
  return result2.value;
}
var methods = ["get", "post", "put", "patch", "delete"];
function getURL2(url, option2) {
  const { baseURL: baseURL2, params, query: query2 } = option2 || {
    query: {},
    params: {},
    baseURL: ""
  };
  let basePath = url.startsWith("http") ? url.split("/").slice(0, 3).join("/") : baseURL2 || "";
  if (url.startsWith("@")) {
    const m = url.toString().split("@")[1].split("/")[0];
    if (methods.includes(m)) {
      url = url.replace(`@${m}/`, "/");
    }
  }
  if (!basePath.endsWith("/")) basePath += "/";
  let [path, urlQuery] = url.replace(basePath, "").split("?");
  const queryParams = new URLSearchParams(urlQuery);
  for (const [key, value] of Object.entries(query2 || {})) {
    if (value == null) continue;
    let serializedValue;
    if (typeof value === "string") {
      serializedValue = value;
    } else if (Array.isArray(value)) {
      for (const val of value) {
        queryParams.append(key, val);
      }
      continue;
    } else {
      serializedValue = JSON.stringify(value);
    }
    queryParams.set(key, serializedValue);
  }
  if (params) {
    if (Array.isArray(params)) {
      const paramPaths = path.split("/").filter((p) => p.startsWith(":"));
      for (const [index2, key] of paramPaths.entries()) {
        const value = params[index2];
        path = path.replace(key, value);
      }
    } else {
      for (const [key, value] of Object.entries(params)) {
        path = path.replace(`:${key}`, String(value));
      }
    }
  }
  path = path.split("/").map(encodeURIComponent).join("/");
  if (path.startsWith("/")) path = path.slice(1);
  let queryParamString = queryParams.toString();
  queryParamString = queryParamString.length > 0 ? `?${queryParamString}`.replace(/\+/g, "%20") : "";
  if (!basePath.startsWith("http")) {
    return `${basePath}${path}${queryParamString}`;
  }
  const _url = new URL(`${path}${queryParamString}`, basePath);
  return _url;
}
var betterFetch = async (url, options) => {
  var _a2, _b, _c, _d, _e, _f, _g, _h;
  const {
    hooks,
    url: __url,
    options: opts
  } = await initializePlugins(url, options);
  const fetch2 = getFetch(opts);
  const controller = new AbortController();
  const signal = (_a2 = opts.signal) != null ? _a2 : controller.signal;
  const _url = getURL2(__url, opts);
  const body = getBody(opts);
  const headers = await getHeaders(opts);
  const method = getMethod(__url, opts);
  let context = __spreadProps(__spreadValues({}, opts), {
    url: _url,
    headers,
    body,
    method,
    signal
  });
  for (const onRequest of hooks.onRequest) {
    if (onRequest) {
      const res2 = await onRequest(context);
      if (typeof res2 === "object" && res2 !== null) {
        context = res2;
      }
    }
  }
  if ("pipeTo" in context && typeof context.pipeTo === "function" || typeof ((_b = options == null ? void 0 : options.body) == null ? void 0 : _b.pipe) === "function") {
    if (!("duplex" in context)) {
      context.duplex = "half";
    }
  }
  const { clearTimeout: clearTimeout2 } = getTimeout(opts, controller);
  let response = await fetch2(context.url, context);
  clearTimeout2();
  const responseContext = {
    response,
    request: context
  };
  for (const onResponse of hooks.onResponse) {
    if (onResponse) {
      const r2 = await onResponse(__spreadProps(__spreadValues({}, responseContext), {
        response: ((_c = options == null ? void 0 : options.hookOptions) == null ? void 0 : _c.cloneResponse) ? response.clone() : response
      }));
      if (r2 instanceof Response) {
        response = r2;
      } else if (typeof r2 === "object" && r2 !== null) {
        response = r2.response;
      }
    }
  }
  if (response.ok) {
    const hasBody = context.method !== "HEAD";
    if (!hasBody) {
      return {
        data: "",
        error: null
      };
    }
    const responseType = detectResponseType(response);
    const successContext = {
      data: null,
      response,
      request: context
    };
    if (responseType === "json" || responseType === "text") {
      const text2 = await response.text();
      const parser22 = (_d = context.jsonParser) != null ? _d : jsonParse;
      successContext.data = await parser22(text2);
    } else {
      successContext.data = await response[responseType]();
    }
    if (context == null ? void 0 : context.output) {
      if (context.output && !context.disableValidation) {
        successContext.data = await parseStandardSchema(
          context.output,
          successContext.data
        );
      }
    }
    for (const onSuccess of hooks.onSuccess) {
      if (onSuccess) {
        await onSuccess(__spreadProps(__spreadValues({}, successContext), {
          response: ((_e = options == null ? void 0 : options.hookOptions) == null ? void 0 : _e.cloneResponse) ? response.clone() : response
        }));
      }
    }
    if (options == null ? void 0 : options.throw) {
      return successContext.data;
    }
    return {
      data: successContext.data,
      error: null
    };
  }
  const parser2 = (_f = options == null ? void 0 : options.jsonParser) != null ? _f : jsonParse;
  const responseText = await response.text();
  const isJSONResponse2 = isJSONParsable(responseText);
  const errorObject = isJSONResponse2 ? await parser2(responseText) : null;
  const errorContext = {
    response,
    responseText,
    request: context,
    error: __spreadProps(__spreadValues({}, errorObject), {
      status: response.status,
      statusText: response.statusText
    })
  };
  for (const onError of hooks.onError) {
    if (onError) {
      await onError(__spreadProps(__spreadValues({}, errorContext), {
        response: ((_g = options == null ? void 0 : options.hookOptions) == null ? void 0 : _g.cloneResponse) ? response.clone() : response
      }));
    }
  }
  if (options == null ? void 0 : options.retry) {
    const retryStrategy = createRetryStrategy(options.retry);
    const _retryAttempt = (_h = options.retryAttempt) != null ? _h : 0;
    if (await retryStrategy.shouldAttemptRetry(_retryAttempt, response)) {
      for (const onRetry of hooks.onRetry) {
        if (onRetry) {
          await onRetry(responseContext);
        }
      }
      const delay2 = retryStrategy.getDelay(_retryAttempt);
      await new Promise((resolve2) => setTimeout(resolve2, delay2));
      return await betterFetch(url, __spreadProps(__spreadValues({}, options), {
        retryAttempt: _retryAttempt + 1
      }));
    }
  }
  if (options == null ? void 0 : options.throw) {
    throw new BetterFetchError(
      response.status,
      response.statusText,
      isJSONResponse2 ? errorObject : responseText
    );
  }
  return {
    data: null,
    error: __spreadProps(__spreadValues({}, errorObject), {
      status: response.status,
      statusText: response.statusText
    })
  };
};
function createRefreshAccessTokenRequest({ refreshToken: refreshToken2, options, authentication, extraParams, resource }) {
  const body = new URLSearchParams();
  const headers = {
    "content-type": "application/x-www-form-urlencoded",
    accept: "application/json"
  };
  body.set("grant_type", "refresh_token");
  body.set("refresh_token", refreshToken2);
  if (authentication === "basic") {
    const primaryClientId = Array.isArray(options.clientId) ? options.clientId[0] : options.clientId;
    if (primaryClientId) headers["authorization"] = "Basic " + base64$1.encode(`${primaryClientId}:${options.clientSecret ?? ""}`);
    else headers["authorization"] = "Basic " + base64$1.encode(`:${options.clientSecret ?? ""}`);
  } else {
    const primaryClientId = Array.isArray(options.clientId) ? options.clientId[0] : options.clientId;
    body.set("client_id", primaryClientId);
    if (options.clientSecret) body.set("client_secret", options.clientSecret);
  }
  if (resource) if (typeof resource === "string") body.append("resource", resource);
  else for (const _resource of resource) body.append("resource", _resource);
  if (extraParams) for (const [key, value] of Object.entries(extraParams)) body.set(key, value);
  return {
    body,
    headers
  };
}
async function refreshAccessToken({ refreshToken: refreshToken2, options, tokenEndpoint, authentication, extraParams }) {
  const { body, headers } = createRefreshAccessTokenRequest({
    refreshToken: refreshToken2,
    options,
    authentication,
    extraParams
  });
  const { data, error: error2 } = await betterFetch(tokenEndpoint, {
    method: "POST",
    body,
    headers
  });
  if (error2) throw error2;
  const tokens = {
    accessToken: data.access_token,
    refreshToken: data.refresh_token,
    tokenType: data.token_type,
    scopes: data.scope?.split(" "),
    idToken: data.id_token
  };
  if (data.expires_in) {
    const now2 = /* @__PURE__ */ new Date();
    tokens.accessTokenExpiresAt = new Date(now2.getTime() + data.expires_in * 1e3);
  }
  return tokens;
}
function createAuthorizationCodeRequest({ code, codeVerifier, redirectURI, options, authentication, deviceId, headers, additionalParams = {}, resource }) {
  const body = new URLSearchParams();
  const requestHeaders = {
    "content-type": "application/x-www-form-urlencoded",
    accept: "application/json",
    ...headers
  };
  body.set("grant_type", "authorization_code");
  body.set("code", code);
  codeVerifier && body.set("code_verifier", codeVerifier);
  options.clientKey && body.set("client_key", options.clientKey);
  deviceId && body.set("device_id", deviceId);
  body.set("redirect_uri", options.redirectURI || redirectURI);
  if (resource) if (typeof resource === "string") body.append("resource", resource);
  else for (const _resource of resource) body.append("resource", _resource);
  if (authentication === "basic") {
    const primaryClientId = Array.isArray(options.clientId) ? options.clientId[0] : options.clientId;
    requestHeaders["authorization"] = `Basic ${base64$1.encode(`${primaryClientId}:${options.clientSecret ?? ""}`)}`;
  } else {
    const primaryClientId = Array.isArray(options.clientId) ? options.clientId[0] : options.clientId;
    body.set("client_id", primaryClientId);
    if (options.clientSecret) body.set("client_secret", options.clientSecret);
  }
  for (const [key, value] of Object.entries(additionalParams)) if (!body.has(key)) body.append(key, value);
  return {
    body,
    headers: requestHeaders
  };
}
async function validateAuthorizationCode({ code, codeVerifier, redirectURI, options, tokenEndpoint, authentication, deviceId, headers, additionalParams = {}, resource }) {
  const { body, headers: requestHeaders } = createAuthorizationCodeRequest({
    code,
    codeVerifier,
    redirectURI,
    options,
    authentication,
    deviceId,
    headers,
    additionalParams,
    resource
  });
  const { data, error: error2 } = await betterFetch(tokenEndpoint, {
    method: "POST",
    body,
    headers: requestHeaders
  });
  if (error2) throw error2;
  return getOAuth2Tokens(data);
}
const apple = (options) => {
  const tokenEndpoint = "https://appleid.apple.com/auth/token";
  return {
    id: "apple",
    name: "Apple",
    async createAuthorizationURL({ state, scopes, redirectURI }) {
      const _scope = options.disableDefaultScope ? [] : ["email", "name"];
      if (options.scope) _scope.push(...options.scope);
      if (scopes) _scope.push(...scopes);
      return await createAuthorizationURL({
        id: "apple",
        options,
        authorizationEndpoint: "https://appleid.apple.com/auth/authorize",
        scopes: _scope,
        state,
        redirectURI,
        responseMode: "form_post",
        responseType: "code id_token"
      });
    },
    validateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {
      return validateAuthorizationCode({
        code,
        codeVerifier,
        redirectURI,
        options,
        tokenEndpoint
      });
    },
    async verifyIdToken(token2, nonce) {
      if (options.disableIdTokenSignIn) return false;
      if (options.verifyIdToken) return options.verifyIdToken(token2, nonce);
      const { kid, alg: jwtAlg } = decodeProtectedHeader(token2);
      if (!kid || !jwtAlg) return false;
      const { payload: jwtClaims } = await jwtVerify(token2, await getApplePublicKey(kid), {
        algorithms: [jwtAlg],
        issuer: "https://appleid.apple.com",
        audience: options.audience && options.audience.length ? options.audience : options.appBundleIdentifier ? options.appBundleIdentifier : options.clientId,
        maxTokenAge: "1h"
      });
      ["email_verified", "is_private_email"].forEach((field) => {
        if (jwtClaims[field] !== void 0) jwtClaims[field] = Boolean(jwtClaims[field]);
      });
      if (nonce && jwtClaims.nonce !== nonce) return false;
      return !!jwtClaims;
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken2) => {
      return refreshAccessToken({
        refreshToken: refreshToken2,
        options: {
          clientId: options.clientId,
          clientKey: options.clientKey,
          clientSecret: options.clientSecret
        },
        tokenEndpoint: "https://appleid.apple.com/auth/token"
      });
    },
    async getUserInfo(token2) {
      if (options.getUserInfo) return options.getUserInfo(token2);
      if (!token2.idToken) return null;
      const profile = decodeJwt(token2.idToken);
      if (!profile) return null;
      let name2;
      if (token2.user?.name) name2 = `${token2.user.name.firstName || ""} ${token2.user.name.lastName || ""}`.trim() || " ";
      else name2 = profile.name || " ";
      const emailVerified = typeof profile.email_verified === "boolean" ? profile.email_verified : profile.email_verified === "true";
      const enrichedProfile = {
        ...profile,
        name: name2
      };
      const userMap = await options.mapProfileToUser?.(enrichedProfile);
      return {
        user: {
          id: profile.sub,
          name: enrichedProfile.name,
          emailVerified,
          email: profile.email,
          ...userMap
        },
        data: enrichedProfile
      };
    },
    options
  };
};
const getApplePublicKey = async (kid) => {
  const { data } = await betterFetch(`https://appleid.apple.com/auth/keys`);
  if (!data?.keys) throw new APIError("BAD_REQUEST", { message: "Keys not found" });
  const jwk = data.keys.find((key) => key.kid === kid);
  if (!jwk) throw new Error(`JWK with kid ${kid} not found`);
  return await importJWK(jwk, jwk.alg);
};
const atlassian = (options) => {
  return {
    id: "atlassian",
    name: "Atlassian",
    async createAuthorizationURL({ state, scopes, codeVerifier, redirectURI }) {
      if (!options.clientId || !options.clientSecret) {
        logger.error("Client Id and Secret are required for Atlassian");
        throw new BetterAuthError("CLIENT_ID_AND_SECRET_REQUIRED");
      }
      if (!codeVerifier) throw new BetterAuthError("codeVerifier is required for Atlassian");
      const _scopes = options.disableDefaultScope ? [] : ["read:jira-user", "offline_access"];
      if (options.scope) _scopes.push(...options.scope);
      if (scopes) _scopes.push(...scopes);
      return createAuthorizationURL({
        id: "atlassian",
        options,
        authorizationEndpoint: "https://auth.atlassian.com/authorize",
        scopes: _scopes,
        state,
        codeVerifier,
        redirectURI,
        additionalParams: { audience: "api.atlassian.com" },
        prompt: options.prompt
      });
    },
    validateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {
      return validateAuthorizationCode({
        code,
        codeVerifier,
        redirectURI,
        options,
        tokenEndpoint: "https://auth.atlassian.com/oauth/token"
      });
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken2) => {
      return refreshAccessToken({
        refreshToken: refreshToken2,
        options: {
          clientId: options.clientId,
          clientSecret: options.clientSecret
        },
        tokenEndpoint: "https://auth.atlassian.com/oauth/token"
      });
    },
    async getUserInfo(token2) {
      if (options.getUserInfo) return options.getUserInfo(token2);
      if (!token2.accessToken) return null;
      try {
        const { data: profile } = await betterFetch("https://api.atlassian.com/me", { headers: { Authorization: `Bearer ${token2.accessToken}` } });
        if (!profile) return null;
        const userMap = await options.mapProfileToUser?.(profile);
        return {
          user: {
            id: profile.account_id,
            name: profile.name,
            email: profile.email,
            image: profile.picture,
            emailVerified: false,
            ...userMap
          },
          data: profile
        };
      } catch (error2) {
        logger.error("Failed to fetch user info from Figma:", error2);
        return null;
      }
    },
    options
  };
};
const cognito = (options) => {
  if (!options.domain || !options.region || !options.userPoolId) {
    logger.error("Domain, region and userPoolId are required for Amazon Cognito. Make sure to provide them in the options.");
    throw new BetterAuthError("DOMAIN_AND_REGION_REQUIRED");
  }
  const cleanDomain = options.domain.replace(/^https?:\/\//, "");
  const authorizationEndpoint = `https://${cleanDomain}/oauth2/authorize`;
  const tokenEndpoint = `https://${cleanDomain}/oauth2/token`;
  const userInfoEndpoint = `https://${cleanDomain}/oauth2/userinfo`;
  return {
    id: "cognito",
    name: "Cognito",
    async createAuthorizationURL({ state, scopes, codeVerifier, redirectURI }) {
      if (!options.clientId) {
        logger.error("ClientId is required for Amazon Cognito. Make sure to provide them in the options.");
        throw new BetterAuthError("CLIENT_ID_AND_SECRET_REQUIRED");
      }
      if (options.requireClientSecret && !options.clientSecret) {
        logger.error("Client Secret is required when requireClientSecret is true. Make sure to provide it in the options.");
        throw new BetterAuthError("CLIENT_SECRET_REQUIRED");
      }
      const _scopes = options.disableDefaultScope ? [] : [
        "openid",
        "profile",
        "email"
      ];
      if (options.scope) _scopes.push(...options.scope);
      if (scopes) _scopes.push(...scopes);
      const url = await createAuthorizationURL({
        id: "cognito",
        options: { ...options },
        authorizationEndpoint,
        scopes: _scopes,
        state,
        codeVerifier,
        redirectURI,
        prompt: options.prompt
      });
      const scopeValue = url.searchParams.get("scope");
      if (scopeValue) {
        url.searchParams.delete("scope");
        const encodedScope = encodeURIComponent(scopeValue);
        const urlString = url.toString();
        const separator = urlString.includes("?") ? "&" : "?";
        return new URL(`${urlString}${separator}scope=${encodedScope}`);
      }
      return url;
    },
    validateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {
      return validateAuthorizationCode({
        code,
        codeVerifier,
        redirectURI,
        options,
        tokenEndpoint
      });
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken2) => {
      return refreshAccessToken({
        refreshToken: refreshToken2,
        options: {
          clientId: options.clientId,
          clientKey: options.clientKey,
          clientSecret: options.clientSecret
        },
        tokenEndpoint
      });
    },
    async verifyIdToken(token2, nonce) {
      if (options.disableIdTokenSignIn) return false;
      if (options.verifyIdToken) return options.verifyIdToken(token2, nonce);
      try {
        const { kid, alg: jwtAlg } = decodeProtectedHeader(token2);
        if (!kid || !jwtAlg) return false;
        const publicKey = await getCognitoPublicKey(kid, options.region, options.userPoolId);
        const expectedIssuer = `https://cognito-idp.${options.region}.amazonaws.com/${options.userPoolId}`;
        const { payload: jwtClaims } = await jwtVerify(token2, publicKey, {
          algorithms: [jwtAlg],
          issuer: expectedIssuer,
          audience: options.clientId,
          maxTokenAge: "1h"
        });
        if (nonce && jwtClaims.nonce !== nonce) return false;
        return true;
      } catch (error2) {
        logger.error("Failed to verify ID token:", error2);
        return false;
      }
    },
    async getUserInfo(token2) {
      if (options.getUserInfo) return options.getUserInfo(token2);
      if (token2.idToken) try {
        const profile = decodeJwt(token2.idToken);
        if (!profile) return null;
        const name2 = profile.name || profile.given_name || profile.username || profile.email;
        const enrichedProfile = {
          ...profile,
          name: name2
        };
        const userMap = await options.mapProfileToUser?.(enrichedProfile);
        return {
          user: {
            id: profile.sub,
            name: enrichedProfile.name,
            email: profile.email,
            image: profile.picture,
            emailVerified: profile.email_verified,
            ...userMap
          },
          data: enrichedProfile
        };
      } catch (error2) {
        logger.error("Failed to decode ID token:", error2);
      }
      if (token2.accessToken) try {
        const { data: userInfo } = await betterFetch(userInfoEndpoint, { headers: { Authorization: `Bearer ${token2.accessToken}` } });
        if (userInfo) {
          const userMap = await options.mapProfileToUser?.(userInfo);
          return {
            user: {
              id: userInfo.sub,
              name: userInfo.name || userInfo.given_name || userInfo.username,
              email: userInfo.email,
              image: userInfo.picture,
              emailVerified: userInfo.email_verified,
              ...userMap
            },
            data: userInfo
          };
        }
      } catch (error2) {
        logger.error("Failed to fetch user info from Cognito:", error2);
      }
      return null;
    },
    options
  };
};
const getCognitoPublicKey = async (kid, region, userPoolId) => {
  const COGNITO_JWKS_URI = `https://cognito-idp.${region}.amazonaws.com/${userPoolId}/.well-known/jwks.json`;
  try {
    const { data } = await betterFetch(COGNITO_JWKS_URI);
    if (!data?.keys) throw new APIError("BAD_REQUEST", { message: "Keys not found" });
    const jwk = data.keys.find((key) => key.kid === kid);
    if (!jwk) throw new Error(`JWK with kid ${kid} not found`);
    return await importJWK(jwk, jwk.alg);
  } catch (error2) {
    logger.error("Failed to fetch Cognito public key:", error2);
    throw error2;
  }
};
const discord = (options) => {
  return {
    id: "discord",
    name: "Discord",
    createAuthorizationURL({ state, scopes, redirectURI }) {
      const _scopes = options.disableDefaultScope ? [] : ["identify", "email"];
      if (scopes) _scopes.push(...scopes);
      if (options.scope) _scopes.push(...options.scope);
      const permissionsParam = _scopes.includes("bot") && options.permissions !== void 0 ? `&permissions=${options.permissions}` : "";
      return new URL(`https://discord.com/api/oauth2/authorize?scope=${_scopes.join("+")}&response_type=code&client_id=${options.clientId}&redirect_uri=${encodeURIComponent(options.redirectURI || redirectURI)}&state=${state}&prompt=${options.prompt || "none"}${permissionsParam}`);
    },
    validateAuthorizationCode: async ({ code, redirectURI }) => {
      return validateAuthorizationCode({
        code,
        redirectURI,
        options,
        tokenEndpoint: "https://discord.com/api/oauth2/token"
      });
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken2) => {
      return refreshAccessToken({
        refreshToken: refreshToken2,
        options: {
          clientId: options.clientId,
          clientKey: options.clientKey,
          clientSecret: options.clientSecret
        },
        tokenEndpoint: "https://discord.com/api/oauth2/token"
      });
    },
    async getUserInfo(token2) {
      if (options.getUserInfo) return options.getUserInfo(token2);
      const { data: profile, error: error2 } = await betterFetch("https://discord.com/api/users/@me", { headers: { authorization: `Bearer ${token2.accessToken}` } });
      if (error2) return null;
      if (profile.avatar === null) profile.image_url = `https://cdn.discordapp.com/embed/avatars/${profile.discriminator === "0" ? Number(BigInt(profile.id) >> BigInt(22)) % 6 : parseInt(profile.discriminator) % 5}.png`;
      else {
        const format2 = profile.avatar.startsWith("a_") ? "gif" : "png";
        profile.image_url = `https://cdn.discordapp.com/avatars/${profile.id}/${profile.avatar}.${format2}`;
      }
      const userMap = await options.mapProfileToUser?.(profile);
      return {
        user: {
          id: profile.id,
          name: profile.global_name || profile.username || "",
          email: profile.email,
          emailVerified: profile.verified,
          image: profile.image_url,
          ...userMap
        },
        data: profile
      };
    },
    options
  };
};
const dropbox = (options) => {
  const tokenEndpoint = "https://api.dropboxapi.com/oauth2/token";
  return {
    id: "dropbox",
    name: "Dropbox",
    createAuthorizationURL: async ({ state, scopes, codeVerifier, redirectURI }) => {
      const _scopes = options.disableDefaultScope ? [] : ["account_info.read"];
      if (options.scope) _scopes.push(...options.scope);
      if (scopes) _scopes.push(...scopes);
      const additionalParams = {};
      if (options.accessType) additionalParams.token_access_type = options.accessType;
      return await createAuthorizationURL({
        id: "dropbox",
        options,
        authorizationEndpoint: "https://www.dropbox.com/oauth2/authorize",
        scopes: _scopes,
        state,
        redirectURI,
        codeVerifier,
        additionalParams
      });
    },
    validateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {
      return await validateAuthorizationCode({
        code,
        codeVerifier,
        redirectURI,
        options,
        tokenEndpoint
      });
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken2) => {
      return refreshAccessToken({
        refreshToken: refreshToken2,
        options: {
          clientId: options.clientId,
          clientKey: options.clientKey,
          clientSecret: options.clientSecret
        },
        tokenEndpoint: "https://api.dropbox.com/oauth2/token"
      });
    },
    async getUserInfo(token2) {
      if (options.getUserInfo) return options.getUserInfo(token2);
      const { data: profile, error: error2 } = await betterFetch("https://api.dropboxapi.com/2/users/get_current_account", {
        method: "POST",
        headers: { Authorization: `Bearer ${token2.accessToken}` }
      });
      if (error2) return null;
      const userMap = await options.mapProfileToUser?.(profile);
      return {
        user: {
          id: profile.account_id,
          name: profile.name?.display_name,
          email: profile.email,
          emailVerified: profile.email_verified || false,
          image: profile.profile_photo_url,
          ...userMap
        },
        data: profile
      };
    },
    options
  };
};
const facebook = (options) => {
  return {
    id: "facebook",
    name: "Facebook",
    async createAuthorizationURL({ state, scopes, redirectURI, loginHint }) {
      const _scopes = options.disableDefaultScope ? [] : ["email", "public_profile"];
      if (options.scope) _scopes.push(...options.scope);
      if (scopes) _scopes.push(...scopes);
      return await createAuthorizationURL({
        id: "facebook",
        options,
        authorizationEndpoint: "https://www.facebook.com/v24.0/dialog/oauth",
        scopes: _scopes,
        state,
        redirectURI,
        loginHint,
        additionalParams: options.configId ? { config_id: options.configId } : {}
      });
    },
    validateAuthorizationCode: async ({ code, redirectURI }) => {
      return validateAuthorizationCode({
        code,
        redirectURI,
        options,
        tokenEndpoint: "https://graph.facebook.com/v24.0/oauth/access_token"
      });
    },
    async verifyIdToken(token2, nonce) {
      if (options.disableIdTokenSignIn) return false;
      if (options.verifyIdToken) return options.verifyIdToken(token2, nonce);
      if (token2.split(".").length === 3) try {
        const { payload: jwtClaims } = await jwtVerify(token2, createRemoteJWKSet(new URL("https://limited.facebook.com/.well-known/oauth/openid/jwks/")), {
          algorithms: ["RS256"],
          audience: options.clientId,
          issuer: "https://www.facebook.com"
        });
        if (nonce && jwtClaims.nonce !== nonce) return false;
        return !!jwtClaims;
      } catch {
        return false;
      }
      return true;
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken2) => {
      return refreshAccessToken({
        refreshToken: refreshToken2,
        options: {
          clientId: options.clientId,
          clientKey: options.clientKey,
          clientSecret: options.clientSecret
        },
        tokenEndpoint: "https://graph.facebook.com/v24.0/oauth/access_token"
      });
    },
    async getUserInfo(token2) {
      if (options.getUserInfo) return options.getUserInfo(token2);
      if (token2.idToken && token2.idToken.split(".").length === 3) {
        const profile$1 = decodeJwt(token2.idToken);
        const user = {
          id: profile$1.sub,
          name: profile$1.name,
          email: profile$1.email,
          picture: { data: {
            url: profile$1.picture,
            height: 100,
            width: 100,
            is_silhouette: false
          } }
        };
        const userMap$1 = await options.mapProfileToUser?.({
          ...user,
          email_verified: false
        });
        return {
          user: {
            ...user,
            emailVerified: false,
            ...userMap$1
          },
          data: profile$1
        };
      }
      const { data: profile, error: error2 } = await betterFetch("https://graph.facebook.com/me?fields=" + [
        "id",
        "name",
        "email",
        "picture",
        ...options?.fields || []
      ].join(","), { auth: {
        type: "Bearer",
        token: token2.accessToken
      } });
      if (error2) return null;
      const userMap = await options.mapProfileToUser?.(profile);
      return {
        user: {
          id: profile.id,
          name: profile.name,
          email: profile.email,
          image: profile.picture.data.url,
          emailVerified: profile.email_verified,
          ...userMap
        },
        data: profile
      };
    },
    options
  };
};
const figma = (options) => {
  return {
    id: "figma",
    name: "Figma",
    async createAuthorizationURL({ state, scopes, codeVerifier, redirectURI }) {
      if (!options.clientId || !options.clientSecret) {
        logger.error("Client Id and Client Secret are required for Figma. Make sure to provide them in the options.");
        throw new BetterAuthError("CLIENT_ID_AND_SECRET_REQUIRED");
      }
      if (!codeVerifier) throw new BetterAuthError("codeVerifier is required for Figma");
      const _scopes = options.disableDefaultScope ? [] : ["current_user:read"];
      if (options.scope) _scopes.push(...options.scope);
      if (scopes) _scopes.push(...scopes);
      return await createAuthorizationURL({
        id: "figma",
        options,
        authorizationEndpoint: "https://www.figma.com/oauth",
        scopes: _scopes,
        state,
        codeVerifier,
        redirectURI
      });
    },
    validateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {
      return validateAuthorizationCode({
        code,
        codeVerifier,
        redirectURI,
        options,
        tokenEndpoint: "https://api.figma.com/v1/oauth/token",
        authentication: "basic"
      });
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken2) => {
      return refreshAccessToken({
        refreshToken: refreshToken2,
        options: {
          clientId: options.clientId,
          clientKey: options.clientKey,
          clientSecret: options.clientSecret
        },
        tokenEndpoint: "https://api.figma.com/v1/oauth/token",
        authentication: "basic"
      });
    },
    async getUserInfo(token2) {
      if (options.getUserInfo) return options.getUserInfo(token2);
      try {
        const { data: profile } = await betterFetch("https://api.figma.com/v1/me", { headers: { Authorization: `Bearer ${token2.accessToken}` } });
        if (!profile) {
          logger.error("Failed to fetch user from Figma");
          return null;
        }
        const userMap = await options.mapProfileToUser?.(profile);
        return {
          user: {
            id: profile.id,
            name: profile.handle,
            email: profile.email,
            image: profile.img_url,
            emailVerified: false,
            ...userMap
          },
          data: profile
        };
      } catch (error2) {
        logger.error("Failed to fetch user info from Figma:", error2);
        return null;
      }
    },
    options
  };
};
const github = (options) => {
  const tokenEndpoint = "https://github.com/login/oauth/access_token";
  return {
    id: "github",
    name: "GitHub",
    createAuthorizationURL({ state, scopes, loginHint, codeVerifier, redirectURI }) {
      const _scopes = options.disableDefaultScope ? [] : ["read:user", "user:email"];
      if (options.scope) _scopes.push(...options.scope);
      if (scopes) _scopes.push(...scopes);
      return createAuthorizationURL({
        id: "github",
        options,
        authorizationEndpoint: "https://github.com/login/oauth/authorize",
        scopes: _scopes,
        state,
        codeVerifier,
        redirectURI,
        loginHint,
        prompt: options.prompt
      });
    },
    validateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {
      const { body, headers: requestHeaders } = createAuthorizationCodeRequest({
        code,
        codeVerifier,
        redirectURI,
        options
      });
      const { data, error: error2 } = await betterFetch(tokenEndpoint, {
        method: "POST",
        body,
        headers: requestHeaders
      });
      if (error2) {
        logger.error("GitHub OAuth token exchange failed:", error2);
        return null;
      }
      if ("error" in data) {
        logger.error("GitHub OAuth token exchange failed:", data);
        return null;
      }
      return getOAuth2Tokens(data);
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken2) => {
      return refreshAccessToken({
        refreshToken: refreshToken2,
        options: {
          clientId: options.clientId,
          clientKey: options.clientKey,
          clientSecret: options.clientSecret
        },
        tokenEndpoint: "https://github.com/login/oauth/access_token"
      });
    },
    async getUserInfo(token2) {
      if (options.getUserInfo) return options.getUserInfo(token2);
      const { data: profile, error: error2 } = await betterFetch("https://api.github.com/user", { headers: {
        "User-Agent": "better-auth",
        authorization: `Bearer ${token2.accessToken}`
      } });
      if (error2) return null;
      const { data: emails } = await betterFetch("https://api.github.com/user/emails", { headers: {
        Authorization: `Bearer ${token2.accessToken}`,
        "User-Agent": "better-auth"
      } });
      if (!profile.email && emails) profile.email = (emails.find((e2) => e2.primary) ?? emails[0])?.email;
      const emailVerified = emails?.find((e2) => e2.email === profile.email)?.verified ?? false;
      const userMap = await options.mapProfileToUser?.(profile);
      return {
        user: {
          id: profile.id,
          name: profile.name || profile.login,
          email: profile.email,
          image: profile.avatar_url,
          emailVerified,
          ...userMap
        },
        data: profile
      };
    },
    options
  };
};
const cleanDoubleSlashes = (input = "") => {
  return input.split("://").map((str) => str.replace(/\/{2,}/g, "/")).join("://");
};
const issuerToEndpoints = (issuer) => {
  const baseUrl = issuer || "https://gitlab.com";
  return {
    authorizationEndpoint: cleanDoubleSlashes(`${baseUrl}/oauth/authorize`),
    tokenEndpoint: cleanDoubleSlashes(`${baseUrl}/oauth/token`),
    userinfoEndpoint: cleanDoubleSlashes(`${baseUrl}/api/v4/user`)
  };
};
const gitlab = (options) => {
  const { authorizationEndpoint, tokenEndpoint, userinfoEndpoint } = issuerToEndpoints(options.issuer);
  const issuerId = "gitlab";
  return {
    id: issuerId,
    name: "Gitlab",
    createAuthorizationURL: async ({ state, scopes, codeVerifier, loginHint, redirectURI }) => {
      const _scopes = options.disableDefaultScope ? [] : ["read_user"];
      if (options.scope) _scopes.push(...options.scope);
      if (scopes) _scopes.push(...scopes);
      return await createAuthorizationURL({
        id: issuerId,
        options,
        authorizationEndpoint,
        scopes: _scopes,
        state,
        redirectURI,
        codeVerifier,
        loginHint
      });
    },
    validateAuthorizationCode: async ({ code, redirectURI, codeVerifier }) => {
      return validateAuthorizationCode({
        code,
        redirectURI,
        options,
        codeVerifier,
        tokenEndpoint
      });
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken2) => {
      return refreshAccessToken({
        refreshToken: refreshToken2,
        options: {
          clientId: options.clientId,
          clientKey: options.clientKey,
          clientSecret: options.clientSecret
        },
        tokenEndpoint
      });
    },
    async getUserInfo(token2) {
      if (options.getUserInfo) return options.getUserInfo(token2);
      const { data: profile, error: error2 } = await betterFetch(userinfoEndpoint, { headers: { authorization: `Bearer ${token2.accessToken}` } });
      if (error2 || profile.state !== "active" || profile.locked) return null;
      const userMap = await options.mapProfileToUser?.(profile);
      return {
        user: {
          id: profile.id,
          name: profile.name ?? profile.username,
          email: profile.email,
          image: profile.avatar_url,
          emailVerified: profile.email_verified ?? false,
          ...userMap
        },
        data: profile
      };
    },
    options
  };
};
const google = (options) => {
  return {
    id: "google",
    name: "Google",
    async createAuthorizationURL({ state, scopes, codeVerifier, redirectURI, loginHint, display }) {
      if (!options.clientId || !options.clientSecret) {
        logger.error("Client Id and Client Secret is required for Google. Make sure to provide them in the options.");
        throw new BetterAuthError("CLIENT_ID_AND_SECRET_REQUIRED");
      }
      if (!codeVerifier) throw new BetterAuthError("codeVerifier is required for Google");
      const _scopes = options.disableDefaultScope ? [] : [
        "email",
        "profile",
        "openid"
      ];
      if (options.scope) _scopes.push(...options.scope);
      if (scopes) _scopes.push(...scopes);
      return await createAuthorizationURL({
        id: "google",
        options,
        authorizationEndpoint: "https://accounts.google.com/o/oauth2/v2/auth",
        scopes: _scopes,
        state,
        codeVerifier,
        redirectURI,
        prompt: options.prompt,
        accessType: options.accessType,
        display: display || options.display,
        loginHint,
        hd: options.hd,
        additionalParams: { include_granted_scopes: "true" }
      });
    },
    validateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {
      return validateAuthorizationCode({
        code,
        codeVerifier,
        redirectURI,
        options,
        tokenEndpoint: "https://oauth2.googleapis.com/token"
      });
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken2) => {
      return refreshAccessToken({
        refreshToken: refreshToken2,
        options: {
          clientId: options.clientId,
          clientKey: options.clientKey,
          clientSecret: options.clientSecret
        },
        tokenEndpoint: "https://oauth2.googleapis.com/token"
      });
    },
    async verifyIdToken(token2, nonce) {
      if (options.disableIdTokenSignIn) return false;
      if (options.verifyIdToken) return options.verifyIdToken(token2, nonce);
      const { kid, alg: jwtAlg } = decodeProtectedHeader(token2);
      if (!kid || !jwtAlg) return false;
      const { payload: jwtClaims } = await jwtVerify(token2, await getGooglePublicKey(kid), {
        algorithms: [jwtAlg],
        issuer: ["https://accounts.google.com", "accounts.google.com"],
        audience: options.clientId,
        maxTokenAge: "1h"
      });
      if (nonce && jwtClaims.nonce !== nonce) return false;
      return true;
    },
    async getUserInfo(token2) {
      if (options.getUserInfo) return options.getUserInfo(token2);
      if (!token2.idToken) return null;
      const user = decodeJwt(token2.idToken);
      const userMap = await options.mapProfileToUser?.(user);
      return {
        user: {
          id: user.sub,
          name: user.name,
          email: user.email,
          image: user.picture,
          emailVerified: user.email_verified,
          ...userMap
        },
        data: user
      };
    },
    options
  };
};
const getGooglePublicKey = async (kid) => {
  const { data } = await betterFetch("https://www.googleapis.com/oauth2/v3/certs");
  if (!data?.keys) throw new APIError("BAD_REQUEST", { message: "Keys not found" });
  const jwk = data.keys.find((key) => key.kid === kid);
  if (!jwk) throw new Error(`JWK with kid ${kid} not found`);
  return await importJWK(jwk, jwk.alg);
};
const huggingface = (options) => {
  return {
    id: "huggingface",
    name: "Hugging Face",
    createAuthorizationURL({ state, scopes, codeVerifier, redirectURI }) {
      const _scopes = options.disableDefaultScope ? [] : [
        "openid",
        "profile",
        "email"
      ];
      if (options.scope) _scopes.push(...options.scope);
      if (scopes) _scopes.push(...scopes);
      return createAuthorizationURL({
        id: "huggingface",
        options,
        authorizationEndpoint: "https://huggingface.co/oauth/authorize",
        scopes: _scopes,
        state,
        codeVerifier,
        redirectURI
      });
    },
    validateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {
      return validateAuthorizationCode({
        code,
        codeVerifier,
        redirectURI,
        options,
        tokenEndpoint: "https://huggingface.co/oauth/token"
      });
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken2) => {
      return refreshAccessToken({
        refreshToken: refreshToken2,
        options: {
          clientId: options.clientId,
          clientKey: options.clientKey,
          clientSecret: options.clientSecret
        },
        tokenEndpoint: "https://huggingface.co/oauth/token"
      });
    },
    async getUserInfo(token2) {
      if (options.getUserInfo) return options.getUserInfo(token2);
      const { data: profile, error: error2 } = await betterFetch("https://huggingface.co/oauth/userinfo", {
        method: "GET",
        headers: { Authorization: `Bearer ${token2.accessToken}` }
      });
      if (error2) return null;
      const userMap = await options.mapProfileToUser?.(profile);
      return {
        user: {
          id: profile.sub,
          name: profile.name || profile.preferred_username,
          email: profile.email,
          image: profile.picture,
          emailVerified: profile.email_verified ?? false,
          ...userMap
        },
        data: profile
      };
    },
    options
  };
};
const kakao = (options) => {
  return {
    id: "kakao",
    name: "Kakao",
    createAuthorizationURL({ state, scopes, redirectURI }) {
      const _scopes = options.disableDefaultScope ? [] : [
        "account_email",
        "profile_image",
        "profile_nickname"
      ];
      if (options.scope) _scopes.push(...options.scope);
      if (scopes) _scopes.push(...scopes);
      return createAuthorizationURL({
        id: "kakao",
        options,
        authorizationEndpoint: "https://kauth.kakao.com/oauth/authorize",
        scopes: _scopes,
        state,
        redirectURI
      });
    },
    validateAuthorizationCode: async ({ code, redirectURI }) => {
      return validateAuthorizationCode({
        code,
        redirectURI,
        options,
        tokenEndpoint: "https://kauth.kakao.com/oauth/token"
      });
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken2) => {
      return refreshAccessToken({
        refreshToken: refreshToken2,
        options: {
          clientId: options.clientId,
          clientKey: options.clientKey,
          clientSecret: options.clientSecret
        },
        tokenEndpoint: "https://kauth.kakao.com/oauth/token"
      });
    },
    async getUserInfo(token2) {
      if (options.getUserInfo) return options.getUserInfo(token2);
      const { data: profile, error: error2 } = await betterFetch("https://kapi.kakao.com/v2/user/me", { headers: { Authorization: `Bearer ${token2.accessToken}` } });
      if (error2 || !profile) return null;
      const userMap = await options.mapProfileToUser?.(profile);
      const account = profile.kakao_account || {};
      const kakaoProfile = account.profile || {};
      return {
        user: {
          id: String(profile.id),
          name: kakaoProfile.nickname || account.name || void 0,
          email: account.email,
          image: kakaoProfile.profile_image_url || kakaoProfile.thumbnail_image_url,
          emailVerified: !!account.is_email_valid && !!account.is_email_verified,
          ...userMap
        },
        data: profile
      };
    },
    options
  };
};
const kick = (options) => {
  return {
    id: "kick",
    name: "Kick",
    createAuthorizationURL({ state, scopes, redirectURI, codeVerifier }) {
      const _scopes = options.disableDefaultScope ? [] : ["user:read"];
      if (options.scope) _scopes.push(...options.scope);
      if (scopes) _scopes.push(...scopes);
      return createAuthorizationURL({
        id: "kick",
        redirectURI,
        options,
        authorizationEndpoint: "https://id.kick.com/oauth/authorize",
        scopes: _scopes,
        codeVerifier,
        state
      });
    },
    async validateAuthorizationCode({ code, redirectURI, codeVerifier }) {
      return validateAuthorizationCode({
        code,
        redirectURI,
        options,
        tokenEndpoint: "https://id.kick.com/oauth/token",
        codeVerifier
      });
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken2) => {
      return refreshAccessToken({
        refreshToken: refreshToken2,
        options: {
          clientId: options.clientId,
          clientSecret: options.clientSecret
        },
        tokenEndpoint: "https://id.kick.com/oauth/token"
      });
    },
    async getUserInfo(token2) {
      if (options.getUserInfo) return options.getUserInfo(token2);
      const { data, error: error2 } = await betterFetch("https://api.kick.com/public/v1/users", {
        method: "GET",
        headers: { Authorization: `Bearer ${token2.accessToken}` }
      });
      if (error2) return null;
      const profile = data.data[0];
      const userMap = await options.mapProfileToUser?.(profile);
      return {
        user: {
          id: profile.user_id,
          name: profile.name,
          email: profile.email,
          image: profile.profile_picture,
          emailVerified: false,
          ...userMap
        },
        data: profile
      };
    },
    options
  };
};
const line = (options) => {
  const authorizationEndpoint = "https://access.line.me/oauth2/v2.1/authorize";
  const tokenEndpoint = "https://api.line.me/oauth2/v2.1/token";
  const userInfoEndpoint = "https://api.line.me/oauth2/v2.1/userinfo";
  const verifyIdTokenEndpoint = "https://api.line.me/oauth2/v2.1/verify";
  return {
    id: "line",
    name: "LINE",
    async createAuthorizationURL({ state, scopes, codeVerifier, redirectURI, loginHint }) {
      const _scopes = options.disableDefaultScope ? [] : [
        "openid",
        "profile",
        "email"
      ];
      if (options.scope) _scopes.push(...options.scope);
      if (scopes) _scopes.push(...scopes);
      return await createAuthorizationURL({
        id: "line",
        options,
        authorizationEndpoint,
        scopes: _scopes,
        state,
        codeVerifier,
        redirectURI,
        loginHint
      });
    },
    validateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {
      return validateAuthorizationCode({
        code,
        codeVerifier,
        redirectURI,
        options,
        tokenEndpoint
      });
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken2) => {
      return refreshAccessToken({
        refreshToken: refreshToken2,
        options: {
          clientId: options.clientId,
          clientSecret: options.clientSecret
        },
        tokenEndpoint
      });
    },
    async verifyIdToken(token2, nonce) {
      if (options.disableIdTokenSignIn) return false;
      if (options.verifyIdToken) return options.verifyIdToken(token2, nonce);
      const body = new URLSearchParams();
      body.set("id_token", token2);
      body.set("client_id", options.clientId);
      if (nonce) body.set("nonce", nonce);
      const { data, error: error2 } = await betterFetch(verifyIdTokenEndpoint, {
        method: "POST",
        headers: { "content-type": "application/x-www-form-urlencoded" },
        body
      });
      if (error2 || !data) return false;
      if (data.aud !== options.clientId) return false;
      if (data.nonce && data.nonce !== nonce) return false;
      return true;
    },
    async getUserInfo(token2) {
      if (options.getUserInfo) return options.getUserInfo(token2);
      let profile = null;
      if (token2.idToken) try {
        profile = decodeJwt(token2.idToken);
      } catch {
      }
      if (!profile) {
        const { data } = await betterFetch(userInfoEndpoint, { headers: { authorization: `Bearer ${token2.accessToken}` } });
        profile = data || null;
      }
      if (!profile) return null;
      const userMap = await options.mapProfileToUser?.(profile);
      const id = profile.sub || profile.userId;
      const name2 = profile.name || profile.displayName;
      const image = profile.picture || profile.pictureUrl || void 0;
      return {
        user: {
          id,
          name: name2,
          email: profile.email,
          image,
          emailVerified: false,
          ...userMap
        },
        data: profile
      };
    },
    options
  };
};
const linear = (options) => {
  const tokenEndpoint = "https://api.linear.app/oauth/token";
  return {
    id: "linear",
    name: "Linear",
    createAuthorizationURL({ state, scopes, loginHint, redirectURI }) {
      const _scopes = options.disableDefaultScope ? [] : ["read"];
      if (options.scope) _scopes.push(...options.scope);
      if (scopes) _scopes.push(...scopes);
      return createAuthorizationURL({
        id: "linear",
        options,
        authorizationEndpoint: "https://linear.app/oauth/authorize",
        scopes: _scopes,
        state,
        redirectURI,
        loginHint
      });
    },
    validateAuthorizationCode: async ({ code, redirectURI }) => {
      return validateAuthorizationCode({
        code,
        redirectURI,
        options,
        tokenEndpoint
      });
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken2) => {
      return refreshAccessToken({
        refreshToken: refreshToken2,
        options: {
          clientId: options.clientId,
          clientKey: options.clientKey,
          clientSecret: options.clientSecret
        },
        tokenEndpoint
      });
    },
    async getUserInfo(token2) {
      if (options.getUserInfo) return options.getUserInfo(token2);
      const { data: profile, error: error2 } = await betterFetch("https://api.linear.app/graphql", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token2.accessToken}`
        },
        body: JSON.stringify({ query: `
							query {
								viewer {
									id
									name
									email
									avatarUrl
									active
									createdAt
									updatedAt
								}
							}
						` })
      });
      if (error2 || !profile?.data?.viewer) return null;
      const userData = profile.data.viewer;
      const userMap = await options.mapProfileToUser?.(userData);
      return {
        user: {
          id: profile.data.viewer.id,
          name: profile.data.viewer.name,
          email: profile.data.viewer.email,
          image: profile.data.viewer.avatarUrl,
          emailVerified: false,
          ...userMap
        },
        data: userData
      };
    },
    options
  };
};
const linkedin = (options) => {
  const authorizationEndpoint = "https://www.linkedin.com/oauth/v2/authorization";
  const tokenEndpoint = "https://www.linkedin.com/oauth/v2/accessToken";
  return {
    id: "linkedin",
    name: "Linkedin",
    createAuthorizationURL: async ({ state, scopes, redirectURI, loginHint }) => {
      const _scopes = options.disableDefaultScope ? [] : [
        "profile",
        "email",
        "openid"
      ];
      if (options.scope) _scopes.push(...options.scope);
      if (scopes) _scopes.push(...scopes);
      return await createAuthorizationURL({
        id: "linkedin",
        options,
        authorizationEndpoint,
        scopes: _scopes,
        state,
        loginHint,
        redirectURI
      });
    },
    validateAuthorizationCode: async ({ code, redirectURI }) => {
      return await validateAuthorizationCode({
        code,
        redirectURI,
        options,
        tokenEndpoint
      });
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken2) => {
      return refreshAccessToken({
        refreshToken: refreshToken2,
        options: {
          clientId: options.clientId,
          clientKey: options.clientKey,
          clientSecret: options.clientSecret
        },
        tokenEndpoint
      });
    },
    async getUserInfo(token2) {
      if (options.getUserInfo) return options.getUserInfo(token2);
      const { data: profile, error: error2 } = await betterFetch("https://api.linkedin.com/v2/userinfo", {
        method: "GET",
        headers: { Authorization: `Bearer ${token2.accessToken}` }
      });
      if (error2) return null;
      const userMap = await options.mapProfileToUser?.(profile);
      return {
        user: {
          id: profile.sub,
          name: profile.name,
          email: profile.email,
          emailVerified: profile.email_verified || false,
          image: profile.picture,
          ...userMap
        },
        data: profile
      };
    },
    options
  };
};
const microsoft = (options) => {
  const tenant = options.tenantId || "common";
  const authority = options.authority || "https://login.microsoftonline.com";
  const authorizationEndpoint = `${authority}/${tenant}/oauth2/v2.0/authorize`;
  const tokenEndpoint = `${authority}/${tenant}/oauth2/v2.0/token`;
  return {
    id: "microsoft",
    name: "Microsoft EntraID",
    createAuthorizationURL(data) {
      const scopes = options.disableDefaultScope ? [] : [
        "openid",
        "profile",
        "email",
        "User.Read",
        "offline_access"
      ];
      if (options.scope) scopes.push(...options.scope);
      if (data.scopes) scopes.push(...data.scopes);
      return createAuthorizationURL({
        id: "microsoft",
        options,
        authorizationEndpoint,
        state: data.state,
        codeVerifier: data.codeVerifier,
        scopes,
        redirectURI: data.redirectURI,
        prompt: options.prompt,
        loginHint: data.loginHint
      });
    },
    validateAuthorizationCode({ code, codeVerifier, redirectURI }) {
      return validateAuthorizationCode({
        code,
        codeVerifier,
        redirectURI,
        options,
        tokenEndpoint
      });
    },
    async getUserInfo(token2) {
      if (options.getUserInfo) return options.getUserInfo(token2);
      if (!token2.idToken) return null;
      const user = decodeJwt(token2.idToken);
      const profilePhotoSize = options.profilePhotoSize || 48;
      await betterFetch(`https://graph.microsoft.com/v1.0/me/photos/${profilePhotoSize}x${profilePhotoSize}/$value`, {
        headers: { Authorization: `Bearer ${token2.accessToken}` },
        async onResponse(context) {
          if (options.disableProfilePhoto || !context.response.ok) return;
          try {
            const pictureBuffer = await context.response.clone().arrayBuffer();
            user.picture = `data:image/jpeg;base64, ${base64$1.encode(pictureBuffer)}`;
          } catch (e2) {
            logger.error(e2 && typeof e2 === "object" && "name" in e2 ? e2.name : "", e2);
          }
        }
      });
      const userMap = await options.mapProfileToUser?.(user);
      const emailVerified = user.email_verified !== void 0 ? user.email_verified : user.email && (user.verified_primary_email?.includes(user.email) || user.verified_secondary_email?.includes(user.email)) ? true : false;
      return {
        user: {
          id: user.sub,
          name: user.name,
          email: user.email,
          image: user.picture,
          emailVerified,
          ...userMap
        },
        data: user
      };
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken2) => {
      const scopes = options.disableDefaultScope ? [] : [
        "openid",
        "profile",
        "email",
        "User.Read",
        "offline_access"
      ];
      if (options.scope) scopes.push(...options.scope);
      return refreshAccessToken({
        refreshToken: refreshToken2,
        options: {
          clientId: options.clientId,
          clientSecret: options.clientSecret
        },
        extraParams: { scope: scopes.join(" ") },
        tokenEndpoint
      });
    },
    options
  };
};
const naver = (options) => {
  return {
    id: "naver",
    name: "Naver",
    createAuthorizationURL({ state, scopes, redirectURI }) {
      const _scopes = options.disableDefaultScope ? [] : ["profile", "email"];
      if (options.scope) _scopes.push(...options.scope);
      if (scopes) _scopes.push(...scopes);
      return createAuthorizationURL({
        id: "naver",
        options,
        authorizationEndpoint: "https://nid.naver.com/oauth2.0/authorize",
        scopes: _scopes,
        state,
        redirectURI
      });
    },
    validateAuthorizationCode: async ({ code, redirectURI }) => {
      return validateAuthorizationCode({
        code,
        redirectURI,
        options,
        tokenEndpoint: "https://nid.naver.com/oauth2.0/token"
      });
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken2) => {
      return refreshAccessToken({
        refreshToken: refreshToken2,
        options: {
          clientId: options.clientId,
          clientKey: options.clientKey,
          clientSecret: options.clientSecret
        },
        tokenEndpoint: "https://nid.naver.com/oauth2.0/token"
      });
    },
    async getUserInfo(token2) {
      if (options.getUserInfo) return options.getUserInfo(token2);
      const { data: profile, error: error2 } = await betterFetch("https://openapi.naver.com/v1/nid/me", { headers: { Authorization: `Bearer ${token2.accessToken}` } });
      if (error2 || !profile || profile.resultcode !== "00") return null;
      const userMap = await options.mapProfileToUser?.(profile);
      const res2 = profile.response || {};
      return {
        user: {
          id: res2.id,
          name: res2.name || res2.nickname,
          email: res2.email,
          image: res2.profile_image,
          emailVerified: false,
          ...userMap
        },
        data: profile
      };
    },
    options
  };
};
const notion = (options) => {
  const tokenEndpoint = "https://api.notion.com/v1/oauth/token";
  return {
    id: "notion",
    name: "Notion",
    createAuthorizationURL({ state, scopes, loginHint, redirectURI }) {
      const _scopes = options.disableDefaultScope ? [] : [];
      if (options.scope) _scopes.push(...options.scope);
      if (scopes) _scopes.push(...scopes);
      return createAuthorizationURL({
        id: "notion",
        options,
        authorizationEndpoint: "https://api.notion.com/v1/oauth/authorize",
        scopes: _scopes,
        state,
        redirectURI,
        loginHint,
        additionalParams: { owner: "user" }
      });
    },
    validateAuthorizationCode: async ({ code, redirectURI }) => {
      return validateAuthorizationCode({
        code,
        redirectURI,
        options,
        tokenEndpoint,
        authentication: "basic"
      });
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken2) => {
      return refreshAccessToken({
        refreshToken: refreshToken2,
        options: {
          clientId: options.clientId,
          clientKey: options.clientKey,
          clientSecret: options.clientSecret
        },
        tokenEndpoint
      });
    },
    async getUserInfo(token2) {
      if (options.getUserInfo) return options.getUserInfo(token2);
      const { data: profile, error: error2 } = await betterFetch("https://api.notion.com/v1/users/me", { headers: {
        Authorization: `Bearer ${token2.accessToken}`,
        "Notion-Version": "2022-06-28"
      } });
      if (error2 || !profile) return null;
      const userProfile = profile.bot?.owner?.user;
      if (!userProfile) return null;
      const userMap = await options.mapProfileToUser?.(userProfile);
      return {
        user: {
          id: userProfile.id,
          name: userProfile.name || "Notion User",
          email: userProfile.person?.email || null,
          image: userProfile.avatar_url,
          emailVerified: false,
          ...userMap
        },
        data: userProfile
      };
    },
    options
  };
};
const paybin = (options) => {
  const issuer = options.issuer || "https://idp.paybin.io";
  const authorizationEndpoint = `${issuer}/oauth2/authorize`;
  const tokenEndpoint = `${issuer}/oauth2/token`;
  return {
    id: "paybin",
    name: "Paybin",
    async createAuthorizationURL({ state, scopes, codeVerifier, redirectURI, loginHint }) {
      if (!options.clientId || !options.clientSecret) {
        logger.error("Client Id and Client Secret is required for Paybin. Make sure to provide them in the options.");
        throw new BetterAuthError("CLIENT_ID_AND_SECRET_REQUIRED");
      }
      if (!codeVerifier) throw new BetterAuthError("codeVerifier is required for Paybin");
      const _scopes = options.disableDefaultScope ? [] : [
        "openid",
        "email",
        "profile"
      ];
      if (options.scope) _scopes.push(...options.scope);
      if (scopes) _scopes.push(...scopes);
      return await createAuthorizationURL({
        id: "paybin",
        options,
        authorizationEndpoint,
        scopes: _scopes,
        state,
        codeVerifier,
        redirectURI,
        prompt: options.prompt,
        loginHint
      });
    },
    validateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {
      return validateAuthorizationCode({
        code,
        codeVerifier,
        redirectURI,
        options,
        tokenEndpoint
      });
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken2) => {
      return refreshAccessToken({
        refreshToken: refreshToken2,
        options: {
          clientId: options.clientId,
          clientKey: options.clientKey,
          clientSecret: options.clientSecret
        },
        tokenEndpoint
      });
    },
    async getUserInfo(token2) {
      if (options.getUserInfo) return options.getUserInfo(token2);
      if (!token2.idToken) return null;
      const user = decodeJwt(token2.idToken);
      const userMap = await options.mapProfileToUser?.(user);
      return {
        user: {
          id: user.sub,
          name: user.name || user.preferred_username || (user.email ? user.email.split("@")[0] : "User") || "User",
          email: user.email,
          image: user.picture,
          emailVerified: user.email_verified || false,
          ...userMap
        },
        data: user
      };
    },
    options
  };
};
const paypal = (options) => {
  const isSandbox = (options.environment || "sandbox") === "sandbox";
  const authorizationEndpoint = isSandbox ? "https://www.sandbox.paypal.com/signin/authorize" : "https://www.paypal.com/signin/authorize";
  const tokenEndpoint = isSandbox ? "https://api-m.sandbox.paypal.com/v1/oauth2/token" : "https://api-m.paypal.com/v1/oauth2/token";
  const userInfoEndpoint = isSandbox ? "https://api-m.sandbox.paypal.com/v1/identity/oauth2/userinfo" : "https://api-m.paypal.com/v1/identity/oauth2/userinfo";
  return {
    id: "paypal",
    name: "PayPal",
    async createAuthorizationURL({ state, codeVerifier, redirectURI }) {
      if (!options.clientId || !options.clientSecret) {
        logger.error("Client Id and Client Secret is required for PayPal. Make sure to provide them in the options.");
        throw new BetterAuthError("CLIENT_ID_AND_SECRET_REQUIRED");
      }
      return await createAuthorizationURL({
        id: "paypal",
        options,
        authorizationEndpoint,
        scopes: [],
        state,
        codeVerifier,
        redirectURI,
        prompt: options.prompt
      });
    },
    validateAuthorizationCode: async ({ code, redirectURI }) => {
      const credentials = base64$1.encode(`${options.clientId}:${options.clientSecret}`);
      try {
        const response = await betterFetch(tokenEndpoint, {
          method: "POST",
          headers: {
            Authorization: `Basic ${credentials}`,
            Accept: "application/json",
            "Accept-Language": "en_US",
            "Content-Type": "application/x-www-form-urlencoded"
          },
          body: new URLSearchParams({
            grant_type: "authorization_code",
            code,
            redirect_uri: redirectURI
          }).toString()
        });
        if (!response.data) throw new BetterAuthError("FAILED_TO_GET_ACCESS_TOKEN");
        const data = response.data;
        return {
          accessToken: data.access_token,
          refreshToken: data.refresh_token,
          accessTokenExpiresAt: data.expires_in ? new Date(Date.now() + data.expires_in * 1e3) : void 0,
          idToken: data.id_token
        };
      } catch (error2) {
        logger.error("PayPal token exchange failed:", error2);
        throw new BetterAuthError("FAILED_TO_GET_ACCESS_TOKEN");
      }
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken2) => {
      const credentials = base64$1.encode(`${options.clientId}:${options.clientSecret}`);
      try {
        const response = await betterFetch(tokenEndpoint, {
          method: "POST",
          headers: {
            Authorization: `Basic ${credentials}`,
            Accept: "application/json",
            "Accept-Language": "en_US",
            "Content-Type": "application/x-www-form-urlencoded"
          },
          body: new URLSearchParams({
            grant_type: "refresh_token",
            refresh_token: refreshToken2
          }).toString()
        });
        if (!response.data) throw new BetterAuthError("FAILED_TO_REFRESH_ACCESS_TOKEN");
        const data = response.data;
        return {
          accessToken: data.access_token,
          refreshToken: data.refresh_token,
          accessTokenExpiresAt: data.expires_in ? new Date(Date.now() + data.expires_in * 1e3) : void 0
        };
      } catch (error2) {
        logger.error("PayPal token refresh failed:", error2);
        throw new BetterAuthError("FAILED_TO_REFRESH_ACCESS_TOKEN");
      }
    },
    async verifyIdToken(token2, nonce) {
      if (options.disableIdTokenSignIn) return false;
      if (options.verifyIdToken) return options.verifyIdToken(token2, nonce);
      try {
        return !!decodeJwt(token2).sub;
      } catch (error2) {
        logger.error("Failed to verify PayPal ID token:", error2);
        return false;
      }
    },
    async getUserInfo(token2) {
      if (options.getUserInfo) return options.getUserInfo(token2);
      if (!token2.accessToken) {
        logger.error("Access token is required to fetch PayPal user info");
        return null;
      }
      try {
        const response = await betterFetch(`${userInfoEndpoint}?schema=paypalv1.1`, { headers: {
          Authorization: `Bearer ${token2.accessToken}`,
          Accept: "application/json"
        } });
        if (!response.data) {
          logger.error("Failed to fetch user info from PayPal");
          return null;
        }
        const userInfo = response.data;
        const userMap = await options.mapProfileToUser?.(userInfo);
        return {
          user: {
            id: userInfo.user_id,
            name: userInfo.name,
            email: userInfo.email,
            image: userInfo.picture,
            emailVerified: userInfo.email_verified,
            ...userMap
          },
          data: userInfo
        };
      } catch (error2) {
        logger.error("Failed to fetch user info from PayPal:", error2);
        return null;
      }
    },
    options
  };
};
const polar = (options) => {
  return {
    id: "polar",
    name: "Polar",
    createAuthorizationURL({ state, scopes, codeVerifier, redirectURI }) {
      const _scopes = options.disableDefaultScope ? [] : [
        "openid",
        "profile",
        "email"
      ];
      if (options.scope) _scopes.push(...options.scope);
      if (scopes) _scopes.push(...scopes);
      return createAuthorizationURL({
        id: "polar",
        options,
        authorizationEndpoint: "https://polar.sh/oauth2/authorize",
        scopes: _scopes,
        state,
        codeVerifier,
        redirectURI,
        prompt: options.prompt
      });
    },
    validateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {
      return validateAuthorizationCode({
        code,
        codeVerifier,
        redirectURI,
        options,
        tokenEndpoint: "https://api.polar.sh/v1/oauth2/token"
      });
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken2) => {
      return refreshAccessToken({
        refreshToken: refreshToken2,
        options: {
          clientId: options.clientId,
          clientKey: options.clientKey,
          clientSecret: options.clientSecret
        },
        tokenEndpoint: "https://api.polar.sh/v1/oauth2/token"
      });
    },
    async getUserInfo(token2) {
      if (options.getUserInfo) return options.getUserInfo(token2);
      const { data: profile, error: error2 } = await betterFetch("https://api.polar.sh/v1/oauth2/userinfo", { headers: { Authorization: `Bearer ${token2.accessToken}` } });
      if (error2) return null;
      const userMap = await options.mapProfileToUser?.(profile);
      return {
        user: {
          id: profile.id,
          name: profile.public_name || profile.username,
          email: profile.email,
          image: profile.avatar_url,
          emailVerified: profile.email_verified ?? false,
          ...userMap
        },
        data: profile
      };
    },
    options
  };
};
const reddit = (options) => {
  return {
    id: "reddit",
    name: "Reddit",
    createAuthorizationURL({ state, scopes, redirectURI }) {
      const _scopes = options.disableDefaultScope ? [] : ["identity"];
      if (options.scope) _scopes.push(...options.scope);
      if (scopes) _scopes.push(...scopes);
      return createAuthorizationURL({
        id: "reddit",
        options,
        authorizationEndpoint: "https://www.reddit.com/api/v1/authorize",
        scopes: _scopes,
        state,
        redirectURI,
        duration: options.duration
      });
    },
    validateAuthorizationCode: async ({ code, redirectURI }) => {
      const body = new URLSearchParams({
        grant_type: "authorization_code",
        code,
        redirect_uri: options.redirectURI || redirectURI
      });
      const { data, error: error2 } = await betterFetch("https://www.reddit.com/api/v1/access_token", {
        method: "POST",
        headers: {
          "content-type": "application/x-www-form-urlencoded",
          accept: "text/plain",
          "user-agent": "better-auth",
          Authorization: `Basic ${base64$1.encode(`${options.clientId}:${options.clientSecret}`)}`
        },
        body: body.toString()
      });
      if (error2) throw error2;
      return getOAuth2Tokens(data);
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken2) => {
      return refreshAccessToken({
        refreshToken: refreshToken2,
        options: {
          clientId: options.clientId,
          clientKey: options.clientKey,
          clientSecret: options.clientSecret
        },
        authentication: "basic",
        tokenEndpoint: "https://www.reddit.com/api/v1/access_token"
      });
    },
    async getUserInfo(token2) {
      if (options.getUserInfo) return options.getUserInfo(token2);
      const { data: profile, error: error2 } = await betterFetch("https://oauth.reddit.com/api/v1/me", { headers: {
        Authorization: `Bearer ${token2.accessToken}`,
        "User-Agent": "better-auth"
      } });
      if (error2) return null;
      const userMap = await options.mapProfileToUser?.(profile);
      return {
        user: {
          id: profile.id,
          name: profile.name,
          email: profile.oauth_client_id,
          emailVerified: profile.has_verified_email,
          image: profile.icon_img?.split("?")[0],
          ...userMap
        },
        data: profile
      };
    },
    options
  };
};
const roblox = (options) => {
  return {
    id: "roblox",
    name: "Roblox",
    createAuthorizationURL({ state, scopes, redirectURI }) {
      const _scopes = options.disableDefaultScope ? [] : ["openid", "profile"];
      if (options.scope) _scopes.push(...options.scope);
      if (scopes) _scopes.push(...scopes);
      return new URL(`https://apis.roblox.com/oauth/v1/authorize?scope=${_scopes.join("+")}&response_type=code&client_id=${options.clientId}&redirect_uri=${encodeURIComponent(options.redirectURI || redirectURI)}&state=${state}&prompt=${options.prompt || "select_account consent"}`);
    },
    validateAuthorizationCode: async ({ code, redirectURI }) => {
      return validateAuthorizationCode({
        code,
        redirectURI: options.redirectURI || redirectURI,
        options,
        tokenEndpoint: "https://apis.roblox.com/oauth/v1/token",
        authentication: "post"
      });
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken2) => {
      return refreshAccessToken({
        refreshToken: refreshToken2,
        options: {
          clientId: options.clientId,
          clientKey: options.clientKey,
          clientSecret: options.clientSecret
        },
        tokenEndpoint: "https://apis.roblox.com/oauth/v1/token"
      });
    },
    async getUserInfo(token2) {
      if (options.getUserInfo) return options.getUserInfo(token2);
      const { data: profile, error: error2 } = await betterFetch("https://apis.roblox.com/oauth/v1/userinfo", { headers: { authorization: `Bearer ${token2.accessToken}` } });
      if (error2) return null;
      const userMap = await options.mapProfileToUser?.(profile);
      return {
        user: {
          id: profile.sub,
          name: profile.nickname || profile.preferred_username || "",
          image: profile.picture,
          email: profile.preferred_username || null,
          emailVerified: false,
          ...userMap
        },
        data: { ...profile }
      };
    },
    options
  };
};
const salesforce = (options) => {
  const isSandbox = (options.environment ?? "production") === "sandbox";
  const authorizationEndpoint = options.loginUrl ? `https://${options.loginUrl}/services/oauth2/authorize` : isSandbox ? "https://test.salesforce.com/services/oauth2/authorize" : "https://login.salesforce.com/services/oauth2/authorize";
  const tokenEndpoint = options.loginUrl ? `https://${options.loginUrl}/services/oauth2/token` : isSandbox ? "https://test.salesforce.com/services/oauth2/token" : "https://login.salesforce.com/services/oauth2/token";
  const userInfoEndpoint = options.loginUrl ? `https://${options.loginUrl}/services/oauth2/userinfo` : isSandbox ? "https://test.salesforce.com/services/oauth2/userinfo" : "https://login.salesforce.com/services/oauth2/userinfo";
  return {
    id: "salesforce",
    name: "Salesforce",
    async createAuthorizationURL({ state, scopes, codeVerifier, redirectURI }) {
      if (!options.clientId || !options.clientSecret) {
        logger.error("Client Id and Client Secret are required for Salesforce. Make sure to provide them in the options.");
        throw new BetterAuthError("CLIENT_ID_AND_SECRET_REQUIRED");
      }
      if (!codeVerifier) throw new BetterAuthError("codeVerifier is required for Salesforce");
      const _scopes = options.disableDefaultScope ? [] : [
        "openid",
        "email",
        "profile"
      ];
      if (options.scope) _scopes.push(...options.scope);
      if (scopes) _scopes.push(...scopes);
      return createAuthorizationURL({
        id: "salesforce",
        options,
        authorizationEndpoint,
        scopes: _scopes,
        state,
        codeVerifier,
        redirectURI: options.redirectURI || redirectURI
      });
    },
    validateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {
      return validateAuthorizationCode({
        code,
        codeVerifier,
        redirectURI: options.redirectURI || redirectURI,
        options,
        tokenEndpoint
      });
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken2) => {
      return refreshAccessToken({
        refreshToken: refreshToken2,
        options: {
          clientId: options.clientId,
          clientSecret: options.clientSecret
        },
        tokenEndpoint
      });
    },
    async getUserInfo(token2) {
      if (options.getUserInfo) return options.getUserInfo(token2);
      try {
        const { data: user } = await betterFetch(userInfoEndpoint, { headers: { Authorization: `Bearer ${token2.accessToken}` } });
        if (!user) {
          logger.error("Failed to fetch user info from Salesforce");
          return null;
        }
        const userMap = await options.mapProfileToUser?.(user);
        return {
          user: {
            id: user.user_id,
            name: user.name,
            email: user.email,
            image: user.photos?.picture || user.photos?.thumbnail,
            emailVerified: user.email_verified ?? false,
            ...userMap
          },
          data: user
        };
      } catch (error2) {
        logger.error("Failed to fetch user info from Salesforce:", error2);
        return null;
      }
    },
    options
  };
};
const slack = (options) => {
  return {
    id: "slack",
    name: "Slack",
    createAuthorizationURL({ state, scopes, redirectURI }) {
      const _scopes = options.disableDefaultScope ? [] : [
        "openid",
        "profile",
        "email"
      ];
      if (scopes) _scopes.push(...scopes);
      if (options.scope) _scopes.push(...options.scope);
      const url = new URL("https://slack.com/openid/connect/authorize");
      url.searchParams.set("scope", _scopes.join(" "));
      url.searchParams.set("response_type", "code");
      url.searchParams.set("client_id", options.clientId);
      url.searchParams.set("redirect_uri", options.redirectURI || redirectURI);
      url.searchParams.set("state", state);
      return url;
    },
    validateAuthorizationCode: async ({ code, redirectURI }) => {
      return validateAuthorizationCode({
        code,
        redirectURI,
        options,
        tokenEndpoint: "https://slack.com/api/openid.connect.token"
      });
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken2) => {
      return refreshAccessToken({
        refreshToken: refreshToken2,
        options: {
          clientId: options.clientId,
          clientKey: options.clientKey,
          clientSecret: options.clientSecret
        },
        tokenEndpoint: "https://slack.com/api/openid.connect.token"
      });
    },
    async getUserInfo(token2) {
      if (options.getUserInfo) return options.getUserInfo(token2);
      const { data: profile, error: error2 } = await betterFetch("https://slack.com/api/openid.connect.userInfo", { headers: { authorization: `Bearer ${token2.accessToken}` } });
      if (error2) return null;
      const userMap = await options.mapProfileToUser?.(profile);
      return {
        user: {
          id: profile["https://slack.com/user_id"],
          name: profile.name || "",
          email: profile.email,
          emailVerified: profile.email_verified,
          image: profile.picture || profile["https://slack.com/user_image_512"],
          ...userMap
        },
        data: profile
      };
    },
    options
  };
};
const spotify = (options) => {
  return {
    id: "spotify",
    name: "Spotify",
    createAuthorizationURL({ state, scopes, codeVerifier, redirectURI }) {
      const _scopes = options.disableDefaultScope ? [] : ["user-read-email"];
      if (options.scope) _scopes.push(...options.scope);
      if (scopes) _scopes.push(...scopes);
      return createAuthorizationURL({
        id: "spotify",
        options,
        authorizationEndpoint: "https://accounts.spotify.com/authorize",
        scopes: _scopes,
        state,
        codeVerifier,
        redirectURI
      });
    },
    validateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {
      return validateAuthorizationCode({
        code,
        codeVerifier,
        redirectURI,
        options,
        tokenEndpoint: "https://accounts.spotify.com/api/token"
      });
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken2) => {
      return refreshAccessToken({
        refreshToken: refreshToken2,
        options: {
          clientId: options.clientId,
          clientKey: options.clientKey,
          clientSecret: options.clientSecret
        },
        tokenEndpoint: "https://accounts.spotify.com/api/token"
      });
    },
    async getUserInfo(token2) {
      if (options.getUserInfo) return options.getUserInfo(token2);
      const { data: profile, error: error2 } = await betterFetch("https://api.spotify.com/v1/me", {
        method: "GET",
        headers: { Authorization: `Bearer ${token2.accessToken}` }
      });
      if (error2) return null;
      const userMap = await options.mapProfileToUser?.(profile);
      return {
        user: {
          id: profile.id,
          name: profile.display_name,
          email: profile.email,
          image: profile.images[0]?.url,
          emailVerified: false,
          ...userMap
        },
        data: profile
      };
    },
    options
  };
};
const tiktok = (options) => {
  return {
    id: "tiktok",
    name: "TikTok",
    createAuthorizationURL({ state, scopes, redirectURI }) {
      const _scopes = options.disableDefaultScope ? [] : ["user.info.profile"];
      if (options.scope) _scopes.push(...options.scope);
      if (scopes) _scopes.push(...scopes);
      return new URL(`https://www.tiktok.com/v2/auth/authorize?scope=${_scopes.join(",")}&response_type=code&client_key=${options.clientKey}&redirect_uri=${encodeURIComponent(options.redirectURI || redirectURI)}&state=${state}`);
    },
    validateAuthorizationCode: async ({ code, redirectURI }) => {
      return validateAuthorizationCode({
        code,
        redirectURI: options.redirectURI || redirectURI,
        options: {
          clientKey: options.clientKey,
          clientSecret: options.clientSecret
        },
        tokenEndpoint: "https://open.tiktokapis.com/v2/oauth/token/"
      });
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken2) => {
      return refreshAccessToken({
        refreshToken: refreshToken2,
        options: { clientSecret: options.clientSecret },
        tokenEndpoint: "https://open.tiktokapis.com/v2/oauth/token/",
        authentication: "post",
        extraParams: { client_key: options.clientKey }
      });
    },
    async getUserInfo(token2) {
      if (options.getUserInfo) return options.getUserInfo(token2);
      const { data: profile, error: error2 } = await betterFetch(`https://open.tiktokapis.com/v2/user/info/?fields=${[
        "open_id",
        "avatar_large_url",
        "display_name",
        "username"
      ].join(",")}`, { headers: { authorization: `Bearer ${token2.accessToken}` } });
      if (error2) return null;
      return {
        user: {
          email: profile.data.user.email || profile.data.user.username,
          id: profile.data.user.open_id,
          name: profile.data.user.display_name || profile.data.user.username,
          image: profile.data.user.avatar_large_url,
          emailVerified: false
        },
        data: profile
      };
    },
    options
  };
};
const twitch = (options) => {
  return {
    id: "twitch",
    name: "Twitch",
    createAuthorizationURL({ state, scopes, redirectURI }) {
      const _scopes = options.disableDefaultScope ? [] : ["user:read:email", "openid"];
      if (options.scope) _scopes.push(...options.scope);
      if (scopes) _scopes.push(...scopes);
      return createAuthorizationURL({
        id: "twitch",
        redirectURI,
        options,
        authorizationEndpoint: "https://id.twitch.tv/oauth2/authorize",
        scopes: _scopes,
        state,
        claims: options.claims || [
          "email",
          "email_verified",
          "preferred_username",
          "picture"
        ]
      });
    },
    validateAuthorizationCode: async ({ code, redirectURI }) => {
      return validateAuthorizationCode({
        code,
        redirectURI,
        options,
        tokenEndpoint: "https://id.twitch.tv/oauth2/token"
      });
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken2) => {
      return refreshAccessToken({
        refreshToken: refreshToken2,
        options: {
          clientId: options.clientId,
          clientKey: options.clientKey,
          clientSecret: options.clientSecret
        },
        tokenEndpoint: "https://id.twitch.tv/oauth2/token"
      });
    },
    async getUserInfo(token2) {
      if (options.getUserInfo) return options.getUserInfo(token2);
      const idToken = token2.idToken;
      if (!idToken) {
        logger.error("No idToken found in token");
        return null;
      }
      const profile = decodeJwt(idToken);
      const userMap = await options.mapProfileToUser?.(profile);
      return {
        user: {
          id: profile.sub,
          name: profile.preferred_username,
          email: profile.email,
          image: profile.picture,
          emailVerified: profile.email_verified,
          ...userMap
        },
        data: profile
      };
    },
    options
  };
};
const twitter = (options) => {
  return {
    id: "twitter",
    name: "Twitter",
    createAuthorizationURL(data) {
      const _scopes = options.disableDefaultScope ? [] : [
        "users.read",
        "tweet.read",
        "offline.access",
        "users.email"
      ];
      if (options.scope) _scopes.push(...options.scope);
      if (data.scopes) _scopes.push(...data.scopes);
      return createAuthorizationURL({
        id: "twitter",
        options,
        authorizationEndpoint: "https://x.com/i/oauth2/authorize",
        scopes: _scopes,
        state: data.state,
        codeVerifier: data.codeVerifier,
        redirectURI: data.redirectURI
      });
    },
    validateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {
      return validateAuthorizationCode({
        code,
        codeVerifier,
        authentication: "basic",
        redirectURI,
        options,
        tokenEndpoint: "https://api.x.com/2/oauth2/token"
      });
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken2) => {
      return refreshAccessToken({
        refreshToken: refreshToken2,
        options: {
          clientId: options.clientId,
          clientKey: options.clientKey,
          clientSecret: options.clientSecret
        },
        authentication: "basic",
        tokenEndpoint: "https://api.x.com/2/oauth2/token"
      });
    },
    async getUserInfo(token2) {
      if (options.getUserInfo) return options.getUserInfo(token2);
      const { data: profile, error: profileError } = await betterFetch("https://api.x.com/2/users/me?user.fields=profile_image_url", {
        method: "GET",
        headers: { Authorization: `Bearer ${token2.accessToken}` }
      });
      if (profileError) return null;
      const { data: emailData, error: emailError } = await betterFetch("https://api.x.com/2/users/me?user.fields=confirmed_email", {
        method: "GET",
        headers: { Authorization: `Bearer ${token2.accessToken}` }
      });
      let emailVerified = false;
      if (!emailError && emailData?.data?.confirmed_email) {
        profile.data.email = emailData.data.confirmed_email;
        emailVerified = true;
      }
      const userMap = await options.mapProfileToUser?.(profile);
      return {
        user: {
          id: profile.data.id,
          name: profile.data.name,
          email: profile.data.email || profile.data.username || null,
          image: profile.data.profile_image_url,
          emailVerified,
          ...userMap
        },
        data: profile
      };
    },
    options
  };
};
const vercel = (options) => {
  return {
    id: "vercel",
    name: "Vercel",
    createAuthorizationURL({ state, scopes, codeVerifier, redirectURI }) {
      if (!codeVerifier) throw new BetterAuthError("codeVerifier is required for Vercel");
      let _scopes = void 0;
      if (options.scope !== void 0 || scopes !== void 0) {
        _scopes = [];
        if (options.scope) _scopes.push(...options.scope);
        if (scopes) _scopes.push(...scopes);
      }
      return createAuthorizationURL({
        id: "vercel",
        options,
        authorizationEndpoint: "https://vercel.com/oauth/authorize",
        scopes: _scopes,
        state,
        codeVerifier,
        redirectURI
      });
    },
    validateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {
      return validateAuthorizationCode({
        code,
        codeVerifier,
        redirectURI,
        options,
        tokenEndpoint: "https://api.vercel.com/login/oauth/token"
      });
    },
    async getUserInfo(token2) {
      if (options.getUserInfo) return options.getUserInfo(token2);
      const { data: profile, error: error2 } = await betterFetch("https://api.vercel.com/login/oauth/userinfo", { headers: { Authorization: `Bearer ${token2.accessToken}` } });
      if (error2 || !profile) return null;
      const userMap = await options.mapProfileToUser?.(profile);
      return {
        user: {
          id: profile.sub,
          name: profile.name ?? profile.preferred_username,
          email: profile.email,
          image: profile.picture,
          emailVerified: profile.email_verified ?? false,
          ...userMap
        },
        data: profile
      };
    },
    options
  };
};
const vk = (options) => {
  return {
    id: "vk",
    name: "VK",
    async createAuthorizationURL({ state, scopes, codeVerifier, redirectURI }) {
      const _scopes = options.disableDefaultScope ? [] : ["email", "phone"];
      if (options.scope) _scopes.push(...options.scope);
      if (scopes) _scopes.push(...scopes);
      return createAuthorizationURL({
        id: "vk",
        options,
        authorizationEndpoint: "https://id.vk.com/authorize",
        scopes: _scopes,
        state,
        redirectURI,
        codeVerifier
      });
    },
    validateAuthorizationCode: async ({ code, codeVerifier, redirectURI, deviceId }) => {
      return validateAuthorizationCode({
        code,
        codeVerifier,
        redirectURI: options.redirectURI || redirectURI,
        options,
        deviceId,
        tokenEndpoint: "https://id.vk.com/oauth2/auth"
      });
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken2) => {
      return refreshAccessToken({
        refreshToken: refreshToken2,
        options: {
          clientId: options.clientId,
          clientKey: options.clientKey,
          clientSecret: options.clientSecret
        },
        tokenEndpoint: "https://id.vk.com/oauth2/auth"
      });
    },
    async getUserInfo(data) {
      if (options.getUserInfo) return options.getUserInfo(data);
      if (!data.accessToken) return null;
      const formBody = new URLSearchParams({
        access_token: data.accessToken,
        client_id: options.clientId
      }).toString();
      const { data: profile, error: error2 } = await betterFetch("https://id.vk.com/oauth2/user_info", {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        body: formBody
      });
      if (error2) return null;
      const userMap = await options.mapProfileToUser?.(profile);
      if (!profile.user.email && !userMap?.email) return null;
      return {
        user: {
          id: profile.user.user_id,
          first_name: profile.user.first_name,
          last_name: profile.user.last_name,
          email: profile.user.email,
          image: profile.user.avatar,
          emailVerified: false,
          birthday: profile.user.birthday,
          sex: profile.user.sex,
          name: `${profile.user.first_name} ${profile.user.last_name}`,
          ...userMap
        },
        data: profile
      };
    },
    options
  };
};
const zoom = (userOptions) => {
  const options = {
    pkce: true,
    ...userOptions
  };
  return {
    id: "zoom",
    name: "Zoom",
    createAuthorizationURL: async ({ state, redirectURI, codeVerifier }) => {
      const params = new URLSearchParams({
        response_type: "code",
        redirect_uri: options.redirectURI ? options.redirectURI : redirectURI,
        client_id: options.clientId,
        state
      });
      if (options.pkce) {
        const codeChallenge = await generateCodeChallenge(codeVerifier);
        params.set("code_challenge_method", "S256");
        params.set("code_challenge", codeChallenge);
      }
      const url = new URL("https://zoom.us/oauth/authorize");
      url.search = params.toString();
      return url;
    },
    validateAuthorizationCode: async ({ code, redirectURI, codeVerifier }) => {
      return validateAuthorizationCode({
        code,
        redirectURI: options.redirectURI || redirectURI,
        codeVerifier,
        options,
        tokenEndpoint: "https://zoom.us/oauth/token",
        authentication: "post"
      });
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken2) => refreshAccessToken({
      refreshToken: refreshToken2,
      options: {
        clientId: options.clientId,
        clientKey: options.clientKey,
        clientSecret: options.clientSecret
      },
      tokenEndpoint: "https://zoom.us/oauth/token"
    }),
    async getUserInfo(token2) {
      if (options.getUserInfo) return options.getUserInfo(token2);
      const { data: profile, error: error2 } = await betterFetch("https://api.zoom.us/v2/users/me", { headers: { authorization: `Bearer ${token2.accessToken}` } });
      if (error2) return null;
      const userMap = await options.mapProfileToUser?.(profile);
      return {
        user: {
          id: profile.id,
          name: profile.display_name,
          image: profile.pic_url,
          email: profile.email,
          emailVerified: Boolean(profile.verified),
          ...userMap
        },
        data: { ...profile }
      };
    }
  };
};
const socialProviders = {
  apple,
  atlassian,
  cognito,
  discord,
  facebook,
  figma,
  github,
  microsoft,
  google,
  huggingface,
  slack,
  spotify,
  twitch,
  twitter,
  dropbox,
  kick,
  linear,
  linkedin,
  gitlab,
  tiktok,
  reddit,
  roblox,
  salesforce,
  vk,
  zoom,
  notion,
  kakao,
  naver,
  line,
  paybin,
  paypal,
  polar,
  vercel
};
const socialProviderList = Object.keys(socialProviders);
const SocialProviderListEnum = z.enum(socialProviderList).or(z.string());
const listUserAccounts = createAuthEndpoint("/list-accounts", {
  method: "GET",
  use: [sessionMiddleware],
  metadata: { openapi: {
    operationId: "listUserAccounts",
    description: "List all accounts linked to the user",
    responses: { "200": {
      description: "Success",
      content: { "application/json": { schema: {
        type: "array",
        items: {
          type: "object",
          properties: {
            id: { type: "string" },
            providerId: { type: "string" },
            createdAt: {
              type: "string",
              format: "date-time"
            },
            updatedAt: {
              type: "string",
              format: "date-time"
            },
            accountId: { type: "string" },
            userId: { type: "string" },
            scopes: {
              type: "array",
              items: { type: "string" }
            }
          },
          required: [
            "id",
            "providerId",
            "createdAt",
            "updatedAt",
            "accountId",
            "userId",
            "scopes"
          ]
        }
      } } }
    } }
  } }
}, async (c2) => {
  const session = c2.context.session;
  const accounts = await c2.context.internalAdapter.findAccounts(session.user.id);
  return c2.json(accounts.map((a) => {
    const { scope, ...parsed } = parseAccountOutput(c2.context.options, a);
    return {
      ...parsed,
      scopes: scope?.split(",") || []
    };
  }));
});
const linkSocialAccount = createAuthEndpoint("/link-social", {
  method: "POST",
  requireHeaders: true,
  body: z.object({
    callbackURL: z.string().meta({ description: "The URL to redirect to after the user has signed in" }).optional(),
    provider: SocialProviderListEnum,
    idToken: z.object({
      token: z.string(),
      nonce: z.string().optional(),
      accessToken: z.string().optional(),
      refreshToken: z.string().optional(),
      scopes: z.array(z.string()).optional()
    }).optional(),
    requestSignUp: z.boolean().optional(),
    scopes: z.array(z.string()).meta({ description: "Additional scopes to request from the provider" }).optional(),
    errorCallbackURL: z.string().meta({ description: "The URL to redirect to if there is an error during the link process" }).optional(),
    disableRedirect: z.boolean().meta({ description: "Disable automatic redirection to the provider. Useful for handling the redirection yourself" }).optional(),
    additionalData: z.record(z.string(), z.any()).optional()
  }),
  use: [sessionMiddleware],
  metadata: { openapi: {
    description: "Link a social account to the user",
    operationId: "linkSocialAccount",
    responses: { "200": {
      description: "Success",
      content: { "application/json": { schema: {
        type: "object",
        properties: {
          url: {
            type: "string",
            description: "The authorization URL to redirect the user to"
          },
          redirect: {
            type: "boolean",
            description: "Indicates if the user should be redirected to the authorization URL"
          },
          status: { type: "boolean" }
        },
        required: ["redirect"]
      } } }
    } }
  } }
}, async (c2) => {
  const session = c2.context.session;
  const provider = c2.context.socialProviders.find((p) => p.id === c2.body.provider);
  if (!provider) {
    c2.context.logger.error("Provider not found. Make sure to add the provider in your auth config", { provider: c2.body.provider });
    throw new APIError$1("NOT_FOUND", { message: BASE_ERROR_CODES.PROVIDER_NOT_FOUND });
  }
  if (c2.body.idToken) {
    if (!provider.verifyIdToken) {
      c2.context.logger.error("Provider does not support id token verification", { provider: c2.body.provider });
      throw new APIError$1("NOT_FOUND", { message: BASE_ERROR_CODES.ID_TOKEN_NOT_SUPPORTED });
    }
    const { token: token2, nonce } = c2.body.idToken;
    if (!await provider.verifyIdToken(token2, nonce)) {
      c2.context.logger.error("Invalid id token", { provider: c2.body.provider });
      throw new APIError$1("UNAUTHORIZED", { message: BASE_ERROR_CODES.INVALID_TOKEN });
    }
    const linkingUserInfo = await provider.getUserInfo({
      idToken: token2,
      accessToken: c2.body.idToken.accessToken,
      refreshToken: c2.body.idToken.refreshToken
    });
    if (!linkingUserInfo || !linkingUserInfo?.user) {
      c2.context.logger.error("Failed to get user info", { provider: c2.body.provider });
      throw new APIError$1("UNAUTHORIZED", { message: BASE_ERROR_CODES.FAILED_TO_GET_USER_INFO });
    }
    const linkingUserId = String(linkingUserInfo.user.id);
    if (!linkingUserInfo.user.email) {
      c2.context.logger.error("User email not found", { provider: c2.body.provider });
      throw new APIError$1("UNAUTHORIZED", { message: BASE_ERROR_CODES.USER_EMAIL_NOT_FOUND });
    }
    if ((await c2.context.internalAdapter.findAccounts(session.user.id)).find((a) => a.providerId === provider.id && a.accountId === linkingUserId)) return c2.json({
      url: "",
      status: true,
      redirect: false
    });
    if (!c2.context.options.account?.accountLinking?.trustedProviders?.includes(provider.id) && !linkingUserInfo.user.emailVerified || c2.context.options.account?.accountLinking?.enabled === false) throw new APIError$1("UNAUTHORIZED", { message: "Account not linked - linking not allowed" });
    if (linkingUserInfo.user.email !== session.user.email && c2.context.options.account?.accountLinking?.allowDifferentEmails !== true) throw new APIError$1("UNAUTHORIZED", { message: "Account not linked - different emails not allowed" });
    try {
      await c2.context.internalAdapter.createAccount({
        userId: session.user.id,
        providerId: provider.id,
        accountId: linkingUserId,
        accessToken: c2.body.idToken.accessToken,
        idToken: token2,
        refreshToken: c2.body.idToken.refreshToken,
        scope: c2.body.idToken.scopes?.join(",")
      });
    } catch {
      throw new APIError$1("EXPECTATION_FAILED", { message: "Account not linked - unable to create account" });
    }
    if (c2.context.options.account?.accountLinking?.updateUserInfoOnLink === true) try {
      await c2.context.internalAdapter.updateUser(session.user.id, {
        name: linkingUserInfo.user?.name,
        image: linkingUserInfo.user?.image
      });
    } catch (e2) {
      console.warn("Could not update user - " + e2.toString());
    }
    return c2.json({
      url: "",
      status: true,
      redirect: false
    });
  }
  const state = await generateState(c2, {
    userId: session.user.id,
    email: session.user.email
  }, c2.body.additionalData);
  const url = await provider.createAuthorizationURL({
    state: state.state,
    codeVerifier: state.codeVerifier,
    redirectURI: `${c2.context.baseURL}/callback/${provider.id}`,
    scopes: c2.body.scopes
  });
  if (!c2.body.disableRedirect) c2.setHeader("Location", url.toString());
  return c2.json({
    url: url.toString(),
    redirect: !c2.body.disableRedirect
  });
});
const unlinkAccount = createAuthEndpoint("/unlink-account", {
  method: "POST",
  body: z.object({
    providerId: z.string(),
    accountId: z.string().optional()
  }),
  use: [freshSessionMiddleware],
  metadata: { openapi: {
    description: "Unlink an account",
    responses: { "200": {
      description: "Success",
      content: { "application/json": { schema: {
        type: "object",
        properties: { status: { type: "boolean" } }
      } } }
    } }
  } }
}, async (ctx) => {
  const { providerId, accountId } = ctx.body;
  const accounts = await ctx.context.internalAdapter.findAccounts(ctx.context.session.user.id);
  if (accounts.length === 1 && !ctx.context.options.account?.accountLinking?.allowUnlinkingAll) throw new APIError$1("BAD_REQUEST", { message: BASE_ERROR_CODES.FAILED_TO_UNLINK_LAST_ACCOUNT });
  const accountExist = accounts.find((account) => accountId ? account.accountId === accountId && account.providerId === providerId : account.providerId === providerId);
  if (!accountExist) throw new APIError$1("BAD_REQUEST", { message: BASE_ERROR_CODES.ACCOUNT_NOT_FOUND });
  await ctx.context.internalAdapter.deleteAccount(accountExist.id);
  return ctx.json({ status: true });
});
const getAccessToken = createAuthEndpoint("/get-access-token", {
  method: "POST",
  body: z.object({
    providerId: z.string().meta({ description: "The provider ID for the OAuth provider" }),
    accountId: z.string().meta({ description: "The account ID associated with the refresh token" }).optional(),
    userId: z.string().meta({ description: "The user ID associated with the account" }).optional()
  }),
  metadata: { openapi: {
    description: "Get a valid access token, doing a refresh if needed",
    responses: {
      200: {
        description: "A Valid access token",
        content: { "application/json": { schema: {
          type: "object",
          properties: {
            tokenType: { type: "string" },
            idToken: { type: "string" },
            accessToken: { type: "string" },
            accessTokenExpiresAt: {
              type: "string",
              format: "date-time"
            }
          }
        } } }
      },
      400: { description: "Invalid refresh token or provider configuration" }
    }
  } }
}, async (ctx) => {
  const { providerId, accountId, userId } = ctx.body || {};
  const req2 = ctx.request;
  const session = await getSessionFromCtx(ctx);
  if (req2 && !session) throw ctx.error("UNAUTHORIZED");
  const resolvedUserId = session?.user?.id || userId;
  if (!resolvedUserId) throw ctx.error("UNAUTHORIZED");
  if (!ctx.context.socialProviders.find((p) => p.id === providerId)) throw new APIError$1("BAD_REQUEST", { message: `Provider ${providerId} is not supported.` });
  const accountData = await getAccountCookie(ctx);
  let account = void 0;
  if (accountData && providerId === accountData.providerId && (!accountId || accountData.id === accountId)) account = accountData;
  else account = (await ctx.context.internalAdapter.findAccounts(resolvedUserId)).find((acc) => accountId ? acc.id === accountId && acc.providerId === providerId : acc.providerId === providerId);
  if (!account) throw new APIError$1("BAD_REQUEST", { message: "Account not found" });
  const provider = ctx.context.socialProviders.find((p) => p.id === providerId);
  if (!provider) throw new APIError$1("BAD_REQUEST", { message: `Provider ${providerId} not found.` });
  try {
    let newTokens = null;
    const accessTokenExpired = account.accessTokenExpiresAt && new Date(account.accessTokenExpiresAt).getTime() - Date.now() < 5e3;
    if (account.refreshToken && accessTokenExpired && provider.refreshAccessToken) {
      const refreshToken$1 = await decryptOAuthToken(account.refreshToken, ctx.context);
      newTokens = await provider.refreshAccessToken(refreshToken$1);
      const updatedData = {
        accessToken: await setTokenUtil(newTokens.accessToken, ctx.context),
        accessTokenExpiresAt: newTokens.accessTokenExpiresAt,
        refreshToken: await setTokenUtil(newTokens.refreshToken, ctx.context),
        refreshTokenExpiresAt: newTokens.refreshTokenExpiresAt
      };
      let updatedAccount = null;
      if (account.id) updatedAccount = await ctx.context.internalAdapter.updateAccount(account.id, updatedData);
      if (ctx.context.options.account?.storeAccountCookie) await setAccountCookie(ctx, {
        ...account,
        ...updatedAccount ?? updatedData
      });
    }
    const accessTokenExpiresAt = (() => {
      if (newTokens?.accessTokenExpiresAt) {
        if (typeof newTokens.accessTokenExpiresAt === "string") return new Date(newTokens.accessTokenExpiresAt);
        return newTokens.accessTokenExpiresAt;
      }
      if (account.accessTokenExpiresAt) {
        if (typeof account.accessTokenExpiresAt === "string") return new Date(account.accessTokenExpiresAt);
        return account.accessTokenExpiresAt;
      }
    })();
    const tokens = {
      accessToken: newTokens?.accessToken ?? await decryptOAuthToken(account.accessToken ?? "", ctx.context),
      accessTokenExpiresAt,
      scopes: account.scope?.split(",") ?? [],
      idToken: newTokens?.idToken ?? account.idToken ?? void 0
    };
    return ctx.json(tokens);
  } catch (error2) {
    throw new APIError$1("BAD_REQUEST", {
      message: "Failed to get a valid access token",
      cause: error2
    });
  }
});
const refreshToken = createAuthEndpoint("/refresh-token", {
  method: "POST",
  body: z.object({
    providerId: z.string().meta({ description: "The provider ID for the OAuth provider" }),
    accountId: z.string().meta({ description: "The account ID associated with the refresh token" }).optional(),
    userId: z.string().meta({ description: "The user ID associated with the account" }).optional()
  }),
  metadata: { openapi: {
    description: "Refresh the access token using a refresh token",
    responses: {
      200: {
        description: "Access token refreshed successfully",
        content: { "application/json": { schema: {
          type: "object",
          properties: {
            tokenType: { type: "string" },
            idToken: { type: "string" },
            accessToken: { type: "string" },
            refreshToken: { type: "string" },
            accessTokenExpiresAt: {
              type: "string",
              format: "date-time"
            },
            refreshTokenExpiresAt: {
              type: "string",
              format: "date-time"
            }
          }
        } } }
      },
      400: { description: "Invalid refresh token or provider configuration" }
    }
  } }
}, async (ctx) => {
  const { providerId, accountId, userId } = ctx.body;
  const req2 = ctx.request;
  const session = await getSessionFromCtx(ctx);
  if (req2 && !session) throw ctx.error("UNAUTHORIZED");
  const resolvedUserId = session?.user?.id || userId;
  if (!resolvedUserId) throw new APIError$1("BAD_REQUEST", { message: `Either userId or session is required` });
  const provider = ctx.context.socialProviders.find((p) => p.id === providerId);
  if (!provider) throw new APIError$1("BAD_REQUEST", { message: `Provider ${providerId} not found.` });
  if (!provider.refreshAccessToken) throw new APIError$1("BAD_REQUEST", { message: `Provider ${providerId} does not support token refreshing.` });
  let account = void 0;
  const accountData = await getAccountCookie(ctx);
  if (accountData && (!providerId || providerId === accountData?.providerId)) account = accountData;
  else account = (await ctx.context.internalAdapter.findAccounts(resolvedUserId)).find((acc) => accountId ? acc.id === accountId && acc.providerId === providerId : acc.providerId === providerId);
  if (!account) throw new APIError$1("BAD_REQUEST", { message: "Account not found" });
  let refreshToken$1 = void 0;
  if (accountData && providerId === accountData.providerId) refreshToken$1 = accountData.refreshToken ?? void 0;
  else refreshToken$1 = account.refreshToken ?? void 0;
  if (!refreshToken$1) throw new APIError$1("BAD_REQUEST", { message: "Refresh token not found" });
  try {
    const decryptedRefreshToken = await decryptOAuthToken(refreshToken$1, ctx.context);
    const tokens = await provider.refreshAccessToken(decryptedRefreshToken);
    if (account.id) {
      const updateData = {
        ...account || {},
        accessToken: await setTokenUtil(tokens.accessToken, ctx.context),
        refreshToken: await setTokenUtil(tokens.refreshToken, ctx.context),
        accessTokenExpiresAt: tokens.accessTokenExpiresAt,
        refreshTokenExpiresAt: tokens.refreshTokenExpiresAt,
        scope: tokens.scopes?.join(",") || account.scope,
        idToken: tokens.idToken || account.idToken
      };
      await ctx.context.internalAdapter.updateAccount(account.id, updateData);
    }
    if (accountData && providerId === accountData.providerId && ctx.context.options.account?.storeAccountCookie) await setAccountCookie(ctx, {
      ...accountData,
      accessToken: await setTokenUtil(tokens.accessToken, ctx.context),
      refreshToken: await setTokenUtil(tokens.refreshToken, ctx.context),
      accessTokenExpiresAt: tokens.accessTokenExpiresAt,
      refreshTokenExpiresAt: tokens.refreshTokenExpiresAt,
      scope: tokens.scopes?.join(",") || accountData.scope,
      idToken: tokens.idToken || accountData.idToken
    });
    return ctx.json({
      accessToken: tokens.accessToken,
      refreshToken: tokens.refreshToken,
      accessTokenExpiresAt: tokens.accessTokenExpiresAt,
      refreshTokenExpiresAt: tokens.refreshTokenExpiresAt,
      scope: tokens.scopes?.join(",") || account.scope,
      idToken: tokens.idToken || account.idToken,
      providerId: account.providerId,
      accountId: account.accountId
    });
  } catch (error2) {
    throw new APIError$1("BAD_REQUEST", {
      message: "Failed to refresh access token",
      cause: error2
    });
  }
});
const accountInfoQuerySchema = z.optional(z.object({ accountId: z.string().meta({ description: "The provider given account id for which to get the account info" }).optional() }));
const accountInfo = createAuthEndpoint("/account-info", {
  method: "GET",
  use: [sessionMiddleware],
  metadata: { openapi: {
    description: "Get the account info provided by the provider",
    responses: { "200": {
      description: "Success",
      content: { "application/json": { schema: {
        type: "object",
        properties: {
          user: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              email: { type: "string" },
              image: { type: "string" },
              emailVerified: { type: "boolean" }
            },
            required: ["id", "emailVerified"]
          },
          data: {
            type: "object",
            properties: {},
            additionalProperties: true
          }
        },
        required: ["user", "data"],
        additionalProperties: false
      } } }
    } }
  } },
  query: accountInfoQuerySchema
}, async (ctx) => {
  const providedAccountId = ctx.query?.accountId;
  let account = void 0;
  if (!providedAccountId) {
    if (ctx.context.options.account?.storeAccountCookie) {
      const accountData = await getAccountCookie(ctx);
      if (accountData) account = accountData;
    }
  } else {
    const accountData = await ctx.context.internalAdapter.findAccount(providedAccountId);
    if (accountData) account = accountData;
  }
  if (!account || account.userId !== ctx.context.session.user.id) throw new APIError$1("BAD_REQUEST", { message: "Account not found" });
  const provider = ctx.context.socialProviders.find((p) => p.id === account.providerId);
  if (!provider) throw new APIError$1("INTERNAL_SERVER_ERROR", { message: `Provider account provider is ${account.providerId} but it is not configured` });
  const tokens = await getAccessToken({
    ...ctx,
    method: "POST",
    body: {
      accountId: account.id,
      providerId: account.providerId
    },
    returnHeaders: false,
    returnStatus: false
  });
  if (!tokens.accessToken) throw new APIError$1("BAD_REQUEST", { message: "Access token not found" });
  const info2 = await provider.getUserInfo({
    ...tokens,
    accessToken: tokens.accessToken
  });
  return ctx.json(info2);
});
async function createEmailVerificationToken(secret, email, updateTo, expiresIn = 3600, extraPayload) {
  return await signJWT({
    email: email.toLowerCase(),
    updateTo,
    ...extraPayload
  }, secret, expiresIn);
}
async function sendVerificationEmailFn(ctx, user) {
  if (!ctx.context.options.emailVerification?.sendVerificationEmail) {
    ctx.context.logger.error("Verification email isn't enabled.");
    throw new APIError$1("BAD_REQUEST", { message: "Verification email isn't enabled" });
  }
  const token2 = await createEmailVerificationToken(ctx.context.secret, user.email, void 0, ctx.context.options.emailVerification?.expiresIn);
  const callbackURL = ctx.body.callbackURL ? encodeURIComponent(ctx.body.callbackURL) : encodeURIComponent("/");
  const url = `${ctx.context.baseURL}/verify-email?token=${token2}&callbackURL=${callbackURL}`;
  await ctx.context.runInBackgroundOrAwait(ctx.context.options.emailVerification.sendVerificationEmail({
    user,
    url,
    token: token2
  }, ctx.request));
}
const sendVerificationEmail = createAuthEndpoint("/send-verification-email", {
  method: "POST",
  operationId: "sendVerificationEmail",
  body: z.object({
    email: z.email().meta({ description: "The email to send the verification email to" }),
    callbackURL: z.string().meta({ description: "The URL to use for email verification callback" }).optional()
  }),
  metadata: { openapi: {
    operationId: "sendVerificationEmail",
    description: "Send a verification email to the user",
    requestBody: { content: { "application/json": { schema: {
      type: "object",
      properties: {
        email: {
          type: "string",
          description: "The email to send the verification email to",
          example: "user@example.com"
        },
        callbackURL: {
          type: "string",
          description: "The URL to use for email verification callback",
          example: "https://example.com/callback",
          nullable: true
        }
      },
      required: ["email"]
    } } } },
    responses: {
      "200": {
        description: "Success",
        content: { "application/json": { schema: {
          type: "object",
          properties: { status: {
            type: "boolean",
            description: "Indicates if the email was sent successfully",
            example: true
          } }
        } } }
      },
      "400": {
        description: "Bad Request",
        content: { "application/json": { schema: {
          type: "object",
          properties: { message: {
            type: "string",
            description: "Error message",
            example: "Verification email isn't enabled"
          } }
        } } }
      }
    }
  } }
}, async (ctx) => {
  if (!ctx.context.options.emailVerification?.sendVerificationEmail) {
    ctx.context.logger.error("Verification email isn't enabled.");
    throw new APIError$1("BAD_REQUEST", { message: "Verification email isn't enabled" });
  }
  const { email } = ctx.body;
  const session = await getSessionFromCtx(ctx);
  if (!session) {
    const user = await ctx.context.internalAdapter.findUserByEmail(email);
    if (!user) {
      await createEmailVerificationToken(ctx.context.secret, email, void 0, ctx.context.options.emailVerification?.expiresIn);
      return ctx.json({ status: true });
    }
    await sendVerificationEmailFn(ctx, user.user);
    return ctx.json({ status: true });
  }
  if (session?.user.email !== email) throw new APIError$1("BAD_REQUEST", { message: BASE_ERROR_CODES.EMAIL_MISMATCH });
  if (session?.user.emailVerified) throw new APIError$1("BAD_REQUEST", { message: BASE_ERROR_CODES.EMAIL_ALREADY_VERIFIED });
  await sendVerificationEmailFn(ctx, session.user);
  return ctx.json({ status: true });
});
const verifyEmail = createAuthEndpoint("/verify-email", {
  method: "GET",
  operationId: "verifyEmail",
  query: z.object({
    token: z.string().meta({ description: "The token to verify the email" }),
    callbackURL: z.string().meta({ description: "The URL to redirect to after email verification" }).optional()
  }),
  use: [originCheck((ctx) => ctx.query.callbackURL)],
  metadata: { openapi: {
    description: "Verify the email of the user",
    parameters: [{
      name: "token",
      in: "query",
      description: "The token to verify the email",
      required: true,
      schema: { type: "string" }
    }, {
      name: "callbackURL",
      in: "query",
      description: "The URL to redirect to after email verification",
      required: false,
      schema: { type: "string" }
    }],
    responses: { "200": {
      description: "Success",
      content: { "application/json": { schema: {
        type: "object",
        properties: {
          user: {
            type: "object",
            $ref: "#/components/schemas/User"
          },
          status: {
            type: "boolean",
            description: "Indicates if the email was verified successfully"
          }
        },
        required: ["user", "status"]
      } } }
    } }
  } }
}, async (ctx) => {
  function redirectOnError(error2) {
    if (ctx.query.callbackURL) {
      if (ctx.query.callbackURL.includes("?")) throw ctx.redirect(`${ctx.query.callbackURL}&error=${error2}`);
      throw ctx.redirect(`${ctx.query.callbackURL}?error=${error2}`);
    }
    throw new APIError$1("UNAUTHORIZED", { message: error2 });
  }
  const { token: token2 } = ctx.query;
  let jwt;
  try {
    jwt = await jwtVerify(token2, new TextEncoder().encode(ctx.context.secret), { algorithms: ["HS256"] });
  } catch (e2) {
    if (e2 instanceof JWTExpired) return redirectOnError("token_expired");
    return redirectOnError("invalid_token");
  }
  const parsed = z.object({
    email: z.email(),
    updateTo: z.string().optional(),
    requestType: z.string().optional()
  }).parse(jwt.payload);
  const user = await ctx.context.internalAdapter.findUserByEmail(parsed.email);
  if (!user) return redirectOnError("user_not_found");
  if (parsed.updateTo) {
    const session = await getSessionFromCtx(ctx);
    if (session && session.user.email !== parsed.email) return redirectOnError("unauthorized");
    switch (parsed.requestType) {
      case "change-email-confirmation": {
        const newToken = await createEmailVerificationToken(ctx.context.secret, parsed.email, parsed.updateTo, ctx.context.options.emailVerification?.expiresIn, { requestType: "change-email-verification" });
        const updateCallbackURL = ctx.query.callbackURL ? encodeURIComponent(ctx.query.callbackURL) : encodeURIComponent("/");
        const url = `${ctx.context.baseURL}/verify-email?token=${newToken}&callbackURL=${updateCallbackURL}`;
        if (ctx.context.options.emailVerification?.sendVerificationEmail) await ctx.context.runInBackgroundOrAwait(ctx.context.options.emailVerification.sendVerificationEmail({
          user: {
            ...user.user,
            email: parsed.updateTo
          },
          url,
          token: newToken
        }, ctx.request));
        if (ctx.query.callbackURL) throw ctx.redirect(ctx.query.callbackURL);
        return ctx.json({ status: true });
      }
      case "change-email-verification": {
        let activeSession = session;
        if (!activeSession) {
          const newSession = await ctx.context.internalAdapter.createSession(user.user.id);
          if (!newSession) throw new APIError$1("INTERNAL_SERVER_ERROR", { message: BASE_ERROR_CODES.FAILED_TO_CREATE_SESSION });
          activeSession = {
            session: newSession,
            user: user.user
          };
        }
        if (ctx.context.options.emailVerification?.onEmailVerification) await ctx.context.options.emailVerification.onEmailVerification(user.user, ctx.request);
        const updatedUser$1 = await ctx.context.internalAdapter.updateUserByEmail(parsed.email, {
          email: parsed.updateTo,
          emailVerified: true
        });
        if (ctx.context.options.emailVerification?.afterEmailVerification) await ctx.context.options.emailVerification.afterEmailVerification(updatedUser$1, ctx.request);
        await setSessionCookie(ctx, {
          session: activeSession.session,
          user: {
            ...activeSession.user,
            email: parsed.updateTo,
            emailVerified: true
          }
        });
        if (ctx.query.callbackURL) throw ctx.redirect(ctx.query.callbackURL);
        return ctx.json({
          status: true,
          user: parseUserOutput(ctx.context.options, updatedUser$1)
        });
      }
      default: {
        let activeSession = session;
        if (!activeSession) {
          const newSession = await ctx.context.internalAdapter.createSession(user.user.id);
          if (!newSession) throw new APIError$1("INTERNAL_SERVER_ERROR", { message: BASE_ERROR_CODES.FAILED_TO_CREATE_SESSION });
          activeSession = {
            session: newSession,
            user: user.user
          };
        }
        const updatedUser$1 = await ctx.context.internalAdapter.updateUserByEmail(parsed.email, {
          email: parsed.updateTo,
          emailVerified: false
        });
        const newToken = await createEmailVerificationToken(ctx.context.secret, parsed.updateTo);
        const updateCallbackURL = ctx.query.callbackURL ? encodeURIComponent(ctx.query.callbackURL) : encodeURIComponent("/");
        if (ctx.context.options.emailVerification?.sendVerificationEmail) await ctx.context.runInBackgroundOrAwait(ctx.context.options.emailVerification.sendVerificationEmail({
          user: updatedUser$1,
          url: `${ctx.context.baseURL}/verify-email?token=${newToken}&callbackURL=${updateCallbackURL}`,
          token: newToken
        }, ctx.request));
        await setSessionCookie(ctx, {
          session: activeSession.session,
          user: {
            ...activeSession.user,
            email: parsed.updateTo,
            emailVerified: false
          }
        });
        if (ctx.query.callbackURL) throw ctx.redirect(ctx.query.callbackURL);
        return ctx.json({
          status: true,
          user: parseUserOutput(ctx.context.options, updatedUser$1)
        });
      }
    }
  }
  if (user.user.emailVerified) {
    if (ctx.query.callbackURL) throw ctx.redirect(ctx.query.callbackURL);
    return ctx.json({
      status: true,
      user: null
    });
  }
  if (ctx.context.options.emailVerification?.beforeEmailVerification) await ctx.context.options.emailVerification.beforeEmailVerification(user.user, ctx.request);
  if (ctx.context.options.emailVerification?.onEmailVerification) await ctx.context.options.emailVerification.onEmailVerification(user.user, ctx.request);
  const updatedUser = await ctx.context.internalAdapter.updateUserByEmail(parsed.email, { emailVerified: true });
  if (ctx.context.options.emailVerification?.afterEmailVerification) await ctx.context.options.emailVerification.afterEmailVerification(updatedUser, ctx.request);
  if (ctx.context.options.emailVerification?.autoSignInAfterVerification) {
    const currentSession = await getSessionFromCtx(ctx);
    if (!currentSession || currentSession.user.email !== parsed.email) {
      const session = await ctx.context.internalAdapter.createSession(user.user.id);
      if (!session) throw new APIError$1("INTERNAL_SERVER_ERROR", { message: "Failed to create session" });
      await setSessionCookie(ctx, {
        session,
        user: {
          ...user.user,
          emailVerified: true
        }
      });
    } else await setSessionCookie(ctx, {
      session: currentSession.session,
      user: {
        ...currentSession.user,
        emailVerified: true
      }
    });
  }
  if (ctx.query.callbackURL) throw ctx.redirect(ctx.query.callbackURL);
  return ctx.json({
    status: true,
    user: null
  });
});
async function handleOAuthUserInfo(c2, opts) {
  const { userInfo, account, callbackURL, disableSignUp, overrideUserInfo } = opts;
  const dbUser = await c2.context.internalAdapter.findOAuthUser(userInfo.email.toLowerCase(), account.accountId, account.providerId).catch((e2) => {
    logger.error("Better auth was unable to query your database.\nError: ", e2);
    const errorURL = c2.context.options.onAPIError?.errorURL || `${c2.context.baseURL}/error`;
    throw c2.redirect(`${errorURL}?error=internal_server_error`);
  });
  let user = dbUser?.user;
  const isRegister = !user;
  if (dbUser) {
    const linkedAccount = dbUser.linkedAccount ?? dbUser.accounts.find((acc) => acc.providerId === account.providerId && acc.accountId === account.accountId);
    if (!linkedAccount) {
      const accountLinking = c2.context.options.account?.accountLinking;
      const trustedProviders = c2.context.options.account?.accountLinking?.trustedProviders;
      if (!(opts.isTrustedProvider || trustedProviders?.includes(account.providerId)) && !userInfo.emailVerified || accountLinking?.enabled === false || accountLinking?.disableImplicitLinking === true) {
        if (isDevelopment()) logger.warn(`User already exist but account isn't linked to ${account.providerId}. To read more about how account linking works in Better Auth see https://www.better-auth.com/docs/concepts/users-accounts#account-linking.`);
        return {
          error: "account not linked",
          data: null
        };
      }
      try {
        await c2.context.internalAdapter.linkAccount({
          providerId: account.providerId,
          accountId: userInfo.id.toString(),
          userId: dbUser.user.id,
          accessToken: await setTokenUtil(account.accessToken, c2.context),
          refreshToken: await setTokenUtil(account.refreshToken, c2.context),
          idToken: account.idToken,
          accessTokenExpiresAt: account.accessTokenExpiresAt,
          refreshTokenExpiresAt: account.refreshTokenExpiresAt,
          scope: account.scope
        });
      } catch (e2) {
        logger.error("Unable to link account", e2);
        return {
          error: "unable to link account",
          data: null
        };
      }
      if (userInfo.emailVerified && !dbUser.user.emailVerified && userInfo.email.toLowerCase() === dbUser.user.email) await c2.context.internalAdapter.updateUser(dbUser.user.id, { emailVerified: true });
    } else {
      const freshTokens = c2.context.options.account?.updateAccountOnSignIn !== false ? Object.fromEntries(Object.entries({
        idToken: account.idToken,
        accessToken: await setTokenUtil(account.accessToken, c2.context),
        refreshToken: await setTokenUtil(account.refreshToken, c2.context),
        accessTokenExpiresAt: account.accessTokenExpiresAt,
        refreshTokenExpiresAt: account.refreshTokenExpiresAt,
        scope: account.scope
      }).filter(([_, value]) => value !== void 0)) : {};
      if (c2.context.options.account?.storeAccountCookie) await setAccountCookie(c2, {
        ...linkedAccount,
        ...freshTokens
      });
      if (Object.keys(freshTokens).length > 0) await c2.context.internalAdapter.updateAccount(linkedAccount.id, freshTokens);
      if (userInfo.emailVerified && !dbUser.user.emailVerified && userInfo.email.toLowerCase() === dbUser.user.email) await c2.context.internalAdapter.updateUser(dbUser.user.id, { emailVerified: true });
    }
    if (overrideUserInfo) {
      const { id: _, ...restUserInfo } = userInfo;
      user = await c2.context.internalAdapter.updateUser(dbUser.user.id, {
        ...restUserInfo,
        email: userInfo.email.toLowerCase(),
        emailVerified: userInfo.email.toLowerCase() === dbUser.user.email ? dbUser.user.emailVerified || userInfo.emailVerified : userInfo.emailVerified
      });
    }
  } else {
    if (disableSignUp) return {
      error: "signup disabled",
      data: null,
      isRegister: false
    };
    try {
      const { id: _, ...restUserInfo } = userInfo;
      const accountData = {
        accessToken: await setTokenUtil(account.accessToken, c2.context),
        refreshToken: await setTokenUtil(account.refreshToken, c2.context),
        idToken: account.idToken,
        accessTokenExpiresAt: account.accessTokenExpiresAt,
        refreshTokenExpiresAt: account.refreshTokenExpiresAt,
        scope: account.scope,
        providerId: account.providerId,
        accountId: userInfo.id.toString()
      };
      const { user: createdUser, account: createdAccount } = await c2.context.internalAdapter.createOAuthUser({
        ...restUserInfo,
        email: userInfo.email.toLowerCase()
      }, accountData);
      user = createdUser;
      if (c2.context.options.account?.storeAccountCookie) await setAccountCookie(c2, createdAccount);
      if (!userInfo.emailVerified && user && c2.context.options.emailVerification?.sendOnSignUp && c2.context.options.emailVerification?.sendVerificationEmail) {
        const token2 = await createEmailVerificationToken(c2.context.secret, user.email, void 0, c2.context.options.emailVerification?.expiresIn);
        const url = `${c2.context.baseURL}/verify-email?token=${token2}&callbackURL=${callbackURL}`;
        await c2.context.runInBackgroundOrAwait(c2.context.options.emailVerification.sendVerificationEmail({
          user,
          url,
          token: token2
        }, c2.request));
      }
    } catch (e2) {
      logger.error(e2);
      if (e2 instanceof APIError$1) return {
        error: e2.message,
        data: null,
        isRegister: false
      };
      return {
        error: "unable to create user",
        data: null,
        isRegister: false
      };
    }
  }
  if (!user) return {
    error: "unable to create user",
    data: null,
    isRegister: false
  };
  const session = await c2.context.internalAdapter.createSession(user.id);
  if (!session) return {
    error: "unable to create session",
    data: null,
    isRegister: false
  };
  return {
    data: {
      session,
      user
    },
    error: null,
    isRegister
  };
}
const schema$1 = z.object({
  code: z.string().optional(),
  error: z.string().optional(),
  device_id: z.string().optional(),
  error_description: z.string().optional(),
  state: z.string().optional(),
  user: z.string().optional()
});
const callbackOAuth = createAuthEndpoint("/callback/:id", {
  method: ["GET", "POST"],
  operationId: "handleOAuthCallback",
  body: schema$1.optional(),
  query: schema$1.optional(),
  metadata: {
    ...HIDE_METADATA,
    allowedMediaTypes: ["application/x-www-form-urlencoded", "application/json"]
  }
}, async (c2) => {
  let queryOrBody;
  const defaultErrorURL = c2.context.options.onAPIError?.errorURL || `${c2.context.baseURL}/error`;
  if (c2.method === "POST") {
    const postData = c2.body ? schema$1.parse(c2.body) : {};
    const queryData = c2.query ? schema$1.parse(c2.query) : {};
    const mergedData = schema$1.parse({
      ...postData,
      ...queryData
    });
    const params = new URLSearchParams();
    for (const [key, value] of Object.entries(mergedData)) if (value !== void 0 && value !== null) params.set(key, String(value));
    const redirectURL = `${c2.context.baseURL}/callback/${c2.params.id}?${params.toString()}`;
    throw c2.redirect(redirectURL);
  }
  try {
    if (c2.method === "GET") queryOrBody = schema$1.parse(c2.query);
    else if (c2.method === "POST") queryOrBody = schema$1.parse(c2.body);
    else throw new Error("Unsupported method");
  } catch (e2) {
    c2.context.logger.error("INVALID_CALLBACK_REQUEST", e2);
    throw c2.redirect(`${defaultErrorURL}?error=invalid_callback_request`);
  }
  const { code, error: error2, state, error_description, device_id, user: userData } = queryOrBody;
  if (!state) {
    c2.context.logger.error("State not found", error2);
    const url = `${defaultErrorURL}${defaultErrorURL.includes("?") ? "&" : "?"}state=state_not_found`;
    throw c2.redirect(url);
  }
  const { codeVerifier, callbackURL, link, errorURL, newUserURL, requestSignUp } = await parseState(c2);
  function redirectOnError(error$1, description) {
    const baseURL2 = errorURL ?? defaultErrorURL;
    const params = new URLSearchParams({ error: error$1 });
    if (description) params.set("error_description", description);
    const url = `${baseURL2}${baseURL2.includes("?") ? "&" : "?"}${params.toString()}`;
    throw c2.redirect(url);
  }
  if (error2) redirectOnError(error2, error_description);
  if (!code) {
    c2.context.logger.error("Code not found");
    throw redirectOnError("no_code");
  }
  const provider = c2.context.socialProviders.find((p) => p.id === c2.params.id);
  if (!provider) {
    c2.context.logger.error("Oauth provider with id", c2.params.id, "not found");
    throw redirectOnError("oauth_provider_not_found");
  }
  let tokens;
  try {
    tokens = await provider.validateAuthorizationCode({
      code,
      codeVerifier,
      deviceId: device_id,
      redirectURI: `${c2.context.baseURL}/callback/${provider.id}`
    });
  } catch (e2) {
    c2.context.logger.error("", e2);
    throw redirectOnError("invalid_code");
  }
  if (!tokens) throw redirectOnError("invalid_code");
  const parsedUserData = userData ? safeJSONParse(userData) : null;
  const userInfo = await provider.getUserInfo({
    ...tokens,
    user: parsedUserData ?? void 0
  }).then((res2) => res2?.user);
  if (!userInfo) {
    c2.context.logger.error("Unable to get user info");
    return redirectOnError("unable_to_get_user_info");
  }
  if (!callbackURL) {
    c2.context.logger.error("No callback URL found");
    throw redirectOnError("no_callback_url");
  }
  if (link) {
    if (!c2.context.options.account?.accountLinking?.trustedProviders?.includes(provider.id) && !userInfo.emailVerified || c2.context.options.account?.accountLinking?.enabled === false) {
      c2.context.logger.error("Unable to link account - untrusted provider");
      return redirectOnError("unable_to_link_account");
    }
    if (userInfo.email !== link.email && c2.context.options.account?.accountLinking?.allowDifferentEmails !== true) return redirectOnError("email_doesn't_match");
    const existingAccount = await c2.context.internalAdapter.findAccount(String(userInfo.id));
    if (existingAccount) {
      if (existingAccount.userId.toString() !== link.userId.toString()) return redirectOnError("account_already_linked_to_different_user");
      const updateData = Object.fromEntries(Object.entries({
        accessToken: await setTokenUtil(tokens.accessToken, c2.context),
        refreshToken: await setTokenUtil(tokens.refreshToken, c2.context),
        idToken: tokens.idToken,
        accessTokenExpiresAt: tokens.accessTokenExpiresAt,
        refreshTokenExpiresAt: tokens.refreshTokenExpiresAt,
        scope: tokens.scopes?.join(",")
      }).filter(([_, value]) => value !== void 0));
      await c2.context.internalAdapter.updateAccount(existingAccount.id, updateData);
    } else if (!await c2.context.internalAdapter.createAccount({
      userId: link.userId,
      providerId: provider.id,
      accountId: String(userInfo.id),
      ...tokens,
      accessToken: await setTokenUtil(tokens.accessToken, c2.context),
      refreshToken: await setTokenUtil(tokens.refreshToken, c2.context),
      scope: tokens.scopes?.join(",")
    })) return redirectOnError("unable_to_link_account");
    let toRedirectTo$1;
    try {
      toRedirectTo$1 = callbackURL.toString();
    } catch {
      toRedirectTo$1 = callbackURL;
    }
    throw c2.redirect(toRedirectTo$1);
  }
  if (!userInfo.email) {
    c2.context.logger.error("Provider did not return email. This could be due to misconfiguration in the provider settings.");
    return redirectOnError("email_not_found");
  }
  const accountData = {
    providerId: provider.id,
    accountId: String(userInfo.id),
    ...tokens,
    scope: tokens.scopes?.join(",")
  };
  const result2 = await handleOAuthUserInfo(c2, {
    userInfo: {
      ...userInfo,
      id: String(userInfo.id),
      email: userInfo.email,
      name: userInfo.name || userInfo.email
    },
    account: accountData,
    callbackURL,
    disableSignUp: provider.disableImplicitSignUp && !requestSignUp || provider.options?.disableSignUp,
    overrideUserInfo: provider.options?.overrideUserInfoOnSignIn
  });
  if (result2.error) {
    c2.context.logger.error(result2.error.split(" ").join("_"));
    return redirectOnError(result2.error.split(" ").join("_"));
  }
  const { session, user } = result2.data;
  await setSessionCookie(c2, {
    session,
    user
  });
  let toRedirectTo;
  try {
    toRedirectTo = (result2.isRegister ? newUserURL || callbackURL : callbackURL).toString();
  } catch {
    toRedirectTo = result2.isRegister ? newUserURL || callbackURL : callbackURL;
  }
  throw c2.redirect(toRedirectTo);
});
function sanitize(input) {
  return input.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/&(?!amp;|lt;|gt;|quot;|#39;|#x[0-9a-fA-F]+;|#[0-9]+;)/g, "&amp;");
}
const html = (options, code = "Unknown", description = null) => {
  const custom = options.onAPIError?.customizeDefaultErrorPage;
  return `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Error</title>
    <style>
      * {
        box-sizing: border-box;
      }
      body {
        font-family: ${custom?.font?.defaultFamily || "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif"};
        background: ${custom?.colors?.background || "var(--background)"};
        color: var(--foreground);
        margin: 0;
      }
      :root,
      :host {
        --spacing: 0.25rem;
        --container-md: 28rem;
        --text-sm: ${custom?.size?.textSm || "0.875rem"};
        --text-sm--line-height: calc(1.25 / 0.875);
        --text-2xl: ${custom?.size?.text2xl || "1.5rem"};
        --text-2xl--line-height: calc(2 / 1.5);
        --text-4xl: ${custom?.size?.text4xl || "2.25rem"};
        --text-4xl--line-height: calc(2.5 / 2.25);
        --text-6xl: ${custom?.size?.text6xl || "3rem"};
        --text-6xl--line-height: 1;
        --font-weight-medium: 500;
        --font-weight-semibold: 600;
        --font-weight-bold: 700;
        --default-transition-duration: 150ms;
        --default-transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
        --radius: ${custom?.size?.radiusSm || "0.625rem"};
        --default-mono-font-family: ${custom?.font?.monoFamily || "var(--font-geist-mono)"};
        --primary: ${custom?.colors?.primary || "black"};
        --primary-foreground: ${custom?.colors?.primaryForeground || "white"};
        --background: ${custom?.colors?.background || "white"};
        --foreground: ${custom?.colors?.foreground || "oklch(0.271 0 0)"};
        --border: ${custom?.colors?.border || "oklch(0.89 0 0)"};
        --destructive: ${custom?.colors?.destructive || "oklch(0.55 0.15 25.723)"};
        --muted-foreground: ${custom?.colors?.mutedForeground || "oklch(0.545 0 0)"};
        --corner-border: ${custom?.colors?.cornerBorder || "#404040"};
      }

      button, .btn {
        cursor: pointer;
        background: none;
        border: none;
        color: inherit;
        font: inherit;
        transition: all var(--default-transition-duration)
          var(--default-transition-timing-function);
      }
      button:hover, .btn:hover {
        opacity: 0.8;
      }

      @media (prefers-color-scheme: dark) {
        :root,
        :host {
          --primary: ${custom?.colors?.primary || "white"};
          --primary-foreground: ${custom?.colors?.primaryForeground || "black"};
          --background: ${custom?.colors?.background || "oklch(0.15 0 0)"};
          --foreground: ${custom?.colors?.foreground || "oklch(0.98 0 0)"};
          --border: ${custom?.colors?.border || "oklch(0.27 0 0)"};
          --destructive: ${custom?.colors?.destructive || "oklch(0.65 0.15 25.723)"};
          --muted-foreground: ${custom?.colors?.mutedForeground || "oklch(0.65 0 0)"};
          --corner-border: ${custom?.colors?.cornerBorder || "#a0a0a0"};
        }
      }
      @media (max-width: 640px) {
        :root, :host {
          --text-6xl: 2.5rem;
          --text-2xl: 1.25rem;
          --text-sm: 0.8125rem;
        }
      }
      @media (max-width: 480px) {
        :root, :host {
          --text-6xl: 2rem;
          --text-2xl: 1.125rem;
        }
      }
    </style>
  </head>
  <body style="width: 100vw; min-height: 100vh; overflow-x: hidden; overflow-y: auto;">
    <div
        style="
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 1.5rem;
            position: relative;
            width: 100%;
            min-height: 100vh;
            padding: 1rem;
        "
        >
${custom?.disableBackgroundGrid ? "" : `
      <div
        style="
          position: absolute;
          inset: 0;
          background-image: linear-gradient(to right, ${custom?.colors?.gridColor || "var(--border)"} 1px, transparent 1px),
            linear-gradient(to bottom, ${custom?.colors?.gridColor || "var(--border)"} 1px, transparent 1px);
          background-size: 40px 40px;
          opacity: 0.6;
          pointer-events: none;
          width: 100vw;
          height: 100vh;
        "
      ></div>
      <div
        style="
          position: absolute;
          inset: 0;
          display: flex;
          align-items: center;
          justify-content: center;
          background: ${custom?.colors?.background || "var(--background)"};
          mask-image: radial-gradient(ellipse at center, transparent 20%, black);
          -webkit-mask-image: radial-gradient(ellipse at center, transparent 20%, black);
          pointer-events: none;
        "
      ></div>
`}

<div
  style="
    position: relative;
    z-index: 10;
    border: 2px solid var(--border);
    background: ${custom?.colors?.cardBackground || "var(--background)"};
    padding: 1.5rem;
    max-width: 42rem;
    width: 100%;
  "
>
    ${custom?.disableCornerDecorations ? "" : `
        <!-- Corner decorations -->
        <div
          style="
            position: absolute;
            top: -2px;
            left: -2px;
            width: 2rem;
            height: 2rem;
            border-top: 4px solid var(--corner-border);
            border-left: 4px solid var(--corner-border);
          "
        ></div>
        <div
          style="
            position: absolute;
            top: -2px;
            right: -2px;
            width: 2rem;
            height: 2rem;
            border-top: 4px solid var(--corner-border);
            border-right: 4px solid var(--corner-border);
          "
        ></div>
  
        <div
          style="
            position: absolute;
            bottom: -2px;
            left: -2px;
            width: 2rem;
            height: 2rem;
            border-bottom: 4px solid var(--corner-border);
            border-left: 4px solid var(--corner-border);
          "
        ></div>
        <div
          style="
            position: absolute;
            bottom: -2px;
            right: -2px;
            width: 2rem;
            height: 2rem;
            border-bottom: 4px solid var(--corner-border);
            border-right: 4px solid var(--corner-border);
          "
        ></div>`}

        <div style="text-align: center; margin-bottom: 1.5rem;">
          <div style="margin-bottom: 1.5rem;">
            <div
              style="
                display: inline-block;
                border: 2px solid ${custom?.disableTitleBorder ? "transparent" : custom?.colors?.titleBorder || "var(--destructive)"};
                padding: 0.375rem 1rem;
              "
            >
              <h1
                style="
                  font-size: var(--text-6xl);
                  font-weight: var(--font-weight-semibold);
                  color: ${custom?.colors?.titleColor || "var(--foreground)"};
                  letter-spacing: -0.02em;
                  margin: 0;
                "
              >
                ERROR
              </h1>
            </div>
            <div
              style="
                height: 2px;
                background-color: var(--border);
                width: calc(100% + 3rem);
                margin-left: -1.5rem;
                margin-top: 1.5rem;
              "
            ></div>
          </div>

          <h2
            style="
              font-size: var(--text-2xl);
              font-weight: var(--font-weight-semibold);
              color: var(--foreground);
              margin: 0 0 1rem;
            "
          >
            Something went wrong
          </h2>

          <div
            style="
                display: inline-flex;
                align-items: center;
                gap: 0.5rem;
                border: 2px solid var(--border);
                background-color: var(--muted);
                padding: 0.375rem 0.75rem;
                margin: 0 0 1rem;
                flex-wrap: wrap;
                justify-content: center;
            "
            >
            <span
                style="
                font-size: 0.75rem;
                color: var(--muted-foreground);
                font-weight: var(--font-weight-semibold);
                "
            >
                CODE:
            </span>
            <span
                style="
                font-size: var(--text-sm);
                font-family: var(--default-mono-font-family, monospace);
                color: var(--foreground);
                word-break: break-all;
                "
            >
                ${sanitize(code)}
            </span>
            </div>

          <p
            style="
              color: var(--muted-foreground);
              max-width: 28rem;
              margin: 0 auto;
              font-size: var(--text-sm);
              line-height: 1.5;
              text-wrap: pretty;
            "
          >
            ${!description ? `We encountered an unexpected error. Please try again or return to the home page. If you're a developer, you can find more information about the error <a href='https://better-auth.com/docs/reference/errors/${encodeURIComponent(code)}' target='_blank' rel="noopener noreferrer" style='color: var(--foreground); text-decoration: underline;'>here</a>.` : description}
          </p>
        </div>

        <div
          style="
            display: flex;
            gap: 0.75rem;
            margin-top: 1.5rem;
            justify-content: center;
            flex-wrap: wrap;
          "
        >
          <a
            href="/"
            style="
              text-decoration: none;
            "
          >
            <div
              style="
                border: 2px solid var(--border);
                background: var(--primary);
                color: var(--primary-foreground);
                padding: 0.5rem 1rem;
                border-radius: 0;
                white-space: nowrap;
              "
              class="btn"
            >
              Go Home
            </div>
          </a>
          <a
            href="https://better-auth.com/docs/reference/errors/${encodeURIComponent(code)}?askai=${encodeURIComponent(`What does the error code ${code} mean?`)}"
            target="_blank"
            rel="noopener noreferrer"
            style="
              text-decoration: none;
            "
          >
            <div
              style="
                border: 2px solid var(--border);
                background: transparent;
                color: var(--foreground);
                padding: 0.5rem 1rem;
                border-radius: 0;
                white-space: nowrap;
              "
              class="btn"
            >
              Ask AI
            </div>
          </a>
        </div>
      </div>
    </div>
  </body>
</html>`;
};
const error = createAuthEndpoint("/error", {
  method: "GET",
  metadata: {
    ...HIDE_METADATA,
    openapi: {
      description: "Displays an error page",
      responses: { "200": {
        description: "Success",
        content: { "text/html": { schema: {
          type: "string",
          description: "The HTML content of the error page"
        } } }
      } }
    }
  }
}, async (c2) => {
  const url = new URL(c2.request?.url || "");
  const unsanitizedCode = url.searchParams.get("error") || "UNKNOWN";
  const unsanitizedDescription = url.searchParams.get("error_description") || null;
  const safeCode = /^[\'A-Za-z0-9_-]+$/.test(unsanitizedCode) ? unsanitizedCode : "UNKNOWN";
  const safeDescription = unsanitizedDescription ? sanitize(unsanitizedDescription) : null;
  const queryParams = new URLSearchParams();
  queryParams.set("error", safeCode);
  if (unsanitizedDescription) queryParams.set("error_description", unsanitizedDescription);
  const options = c2.context.options;
  const errorURL = options.onAPIError?.errorURL;
  if (errorURL) return new Response(null, {
    status: 302,
    headers: { Location: `${errorURL}${errorURL.includes("?") ? "&" : "?"}${queryParams.toString()}` }
  });
  if (isProduction && !options.onAPIError?.customizeDefaultErrorPage) return new Response(null, {
    status: 302,
    headers: { Location: `/?${queryParams.toString()}` }
  });
  return new Response(html(c2.context.options, safeCode, safeDescription), { headers: { "Content-Type": "text/html" } });
});
const ok = createAuthEndpoint("/ok", {
  method: "GET",
  metadata: {
    ...HIDE_METADATA,
    openapi: {
      description: "Check if the API is working",
      responses: { "200": {
        description: "API is working",
        content: { "application/json": { schema: {
          type: "object",
          properties: { ok: {
            type: "boolean",
            description: "Indicates if the API is working"
          } },
          required: ["ok"]
        } } }
      } }
    }
  }
}, async (ctx) => {
  return ctx.json({ ok: true });
});
async function validatePassword(ctx, data) {
  const credentialAccount = (await ctx.context.internalAdapter.findAccounts(data.userId))?.find((account) => account.providerId === "credential");
  const currentPassword = credentialAccount?.password;
  if (!credentialAccount || !currentPassword) return false;
  return await ctx.context.password.verify({
    hash: currentPassword,
    password: data.password
  });
}
async function checkPassword(userId, c2) {
  const credentialAccount = (await c2.context.internalAdapter.findAccounts(userId))?.find((account) => account.providerId === "credential");
  const currentPassword = credentialAccount?.password;
  if (!credentialAccount || !currentPassword || !c2.body.password) throw new APIError$1("BAD_REQUEST", { message: "No password credential found" });
  if (!await c2.context.password.verify({
    hash: currentPassword,
    password: c2.body.password
  })) throw new APIError$1("BAD_REQUEST", { message: "Invalid password" });
  return true;
}
function redirectError(ctx, callbackURL, query2) {
  const url = callbackURL ? new URL(callbackURL, ctx.baseURL) : new URL(`${ctx.baseURL}/error`);
  if (query2) Object.entries(query2).forEach(([k, v]) => url.searchParams.set(k, v));
  return url.href;
}
function redirectCallback(ctx, callbackURL, query2) {
  const url = new URL(callbackURL, ctx.baseURL);
  if (query2) Object.entries(query2).forEach(([k, v]) => url.searchParams.set(k, v));
  return url.href;
}
const requestPasswordReset = createAuthEndpoint("/request-password-reset", {
  method: "POST",
  body: z.object({
    email: z.email().meta({ description: "The email address of the user to send a password reset email to" }),
    redirectTo: z.string().meta({ description: "The URL to redirect the user to reset their password. If the token isn't valid or expired, it'll be redirected with a query parameter `?error=INVALID_TOKEN`. If the token is valid, it'll be redirected with a query parameter `?token=VALID_TOKEN" }).optional()
  }),
  metadata: { openapi: {
    operationId: "requestPasswordReset",
    description: "Send a password reset email to the user",
    responses: { "200": {
      description: "Success",
      content: { "application/json": { schema: {
        type: "object",
        properties: {
          status: { type: "boolean" },
          message: { type: "string" }
        }
      } } }
    } }
  } }
}, async (ctx) => {
  if (!ctx.context.options.emailAndPassword?.sendResetPassword) {
    ctx.context.logger.error("Reset password isn't enabled.Please pass an emailAndPassword.sendResetPassword function in your auth config!");
    throw new APIError$1("BAD_REQUEST", { message: "Reset password isn't enabled" });
  }
  const { email, redirectTo } = ctx.body;
  const user = await ctx.context.internalAdapter.findUserByEmail(email, { includeAccounts: true });
  if (!user) {
    generateId$1(24);
    await ctx.context.internalAdapter.findVerificationValue("dummy-verification-token");
    ctx.context.logger.error("Reset Password: User not found", { email });
    return ctx.json({
      status: true,
      message: "If this email exists in our system, check your email for the reset link"
    });
  }
  const expiresAt = getDate(ctx.context.options.emailAndPassword.resetPasswordTokenExpiresIn || 3600 * 1, "sec");
  const verificationToken = generateId$1(24);
  await ctx.context.internalAdapter.createVerificationValue({
    value: user.user.id,
    identifier: `reset-password:${verificationToken}`,
    expiresAt
  });
  const callbackURL = redirectTo ? encodeURIComponent(redirectTo) : "";
  const url = `${ctx.context.baseURL}/reset-password/${verificationToken}?callbackURL=${callbackURL}`;
  await ctx.context.runInBackgroundOrAwait(ctx.context.options.emailAndPassword.sendResetPassword({
    user: user.user,
    url,
    token: verificationToken
  }, ctx.request));
  return ctx.json({
    status: true,
    message: "If this email exists in our system, check your email for the reset link"
  });
});
const requestPasswordResetCallback = createAuthEndpoint("/reset-password/:token", {
  method: "GET",
  operationId: "forgetPasswordCallback",
  query: z.object({ callbackURL: z.string().meta({ description: "The URL to redirect the user to reset their password" }) }),
  use: [originCheck((ctx) => ctx.query.callbackURL)],
  metadata: { openapi: {
    operationId: "resetPasswordCallback",
    description: "Redirects the user to the callback URL with the token",
    parameters: [{
      name: "token",
      in: "path",
      required: true,
      description: "The token to reset the password",
      schema: { type: "string" }
    }, {
      name: "callbackURL",
      in: "query",
      required: true,
      description: "The URL to redirect the user to reset their password",
      schema: { type: "string" }
    }],
    responses: { "200": {
      description: "Success",
      content: { "application/json": { schema: {
        type: "object",
        properties: { token: { type: "string" } }
      } } }
    } }
  } }
}, async (ctx) => {
  const { token: token2 } = ctx.params;
  const { callbackURL } = ctx.query;
  if (!token2 || !callbackURL) throw ctx.redirect(redirectError(ctx.context, callbackURL, { error: "INVALID_TOKEN" }));
  const verification = await ctx.context.internalAdapter.findVerificationValue(`reset-password:${token2}`);
  if (!verification || verification.expiresAt < /* @__PURE__ */ new Date()) throw ctx.redirect(redirectError(ctx.context, callbackURL, { error: "INVALID_TOKEN" }));
  throw ctx.redirect(redirectCallback(ctx.context, callbackURL, { token: token2 }));
});
const resetPassword = createAuthEndpoint("/reset-password", {
  method: "POST",
  operationId: "resetPassword",
  query: z.object({ token: z.string().optional() }).optional(),
  body: z.object({
    newPassword: z.string().meta({ description: "The new password to set" }),
    token: z.string().meta({ description: "The token to reset the password" }).optional()
  }),
  metadata: { openapi: {
    operationId: "resetPassword",
    description: "Reset the password for a user",
    responses: { "200": {
      description: "Success",
      content: { "application/json": { schema: {
        type: "object",
        properties: { status: { type: "boolean" } }
      } } }
    } }
  } }
}, async (ctx) => {
  const token2 = ctx.body.token || ctx.query?.token;
  if (!token2) throw new APIError$1("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_TOKEN });
  const { newPassword } = ctx.body;
  const minLength = ctx.context.password?.config.minPasswordLength;
  const maxLength = ctx.context.password?.config.maxPasswordLength;
  if (newPassword.length < minLength) throw new APIError$1("BAD_REQUEST", { message: BASE_ERROR_CODES.PASSWORD_TOO_SHORT });
  if (newPassword.length > maxLength) throw new APIError$1("BAD_REQUEST", { message: BASE_ERROR_CODES.PASSWORD_TOO_LONG });
  const id = `reset-password:${token2}`;
  const verification = await ctx.context.internalAdapter.findVerificationValue(id);
  if (!verification || verification.expiresAt < /* @__PURE__ */ new Date()) throw new APIError$1("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_TOKEN });
  const userId = verification.value;
  const hashedPassword = await ctx.context.password.hash(newPassword);
  if (!(await ctx.context.internalAdapter.findAccounts(userId)).find((ac) => ac.providerId === "credential")) await ctx.context.internalAdapter.createAccount({
    userId,
    providerId: "credential",
    password: hashedPassword,
    accountId: userId
  });
  else await ctx.context.internalAdapter.updatePassword(userId, hashedPassword);
  await ctx.context.internalAdapter.deleteVerificationValue(verification.id);
  if (ctx.context.options.emailAndPassword?.onPasswordReset) {
    const user = await ctx.context.internalAdapter.findUserById(userId);
    if (user) await ctx.context.options.emailAndPassword.onPasswordReset({ user }, ctx.request);
  }
  if (ctx.context.options.emailAndPassword?.revokeSessionsOnPasswordReset) await ctx.context.internalAdapter.deleteSessions(userId);
  return ctx.json({ status: true });
});
const verifyPassword = createAuthEndpoint("/verify-password", {
  method: "POST",
  body: z.object({ password: z.string().meta({ description: "The password to verify" }) }),
  metadata: {
    scope: "server",
    openapi: {
      operationId: "verifyPassword",
      description: "Verify the current user's password",
      responses: { "200": {
        description: "Success",
        content: { "application/json": { schema: {
          type: "object",
          properties: { status: { type: "boolean" } }
        } } }
      } }
    }
  },
  use: [sensitiveSessionMiddleware]
}, async (ctx) => {
  const { password } = ctx.body;
  const session = ctx.context.session;
  if (!await validatePassword(ctx, {
    password,
    userId: session.user.id
  })) throw new APIError$1("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_PASSWORD });
  return ctx.json({ status: true });
});
const socialSignInBodySchema = z.object({
  callbackURL: z.string().meta({ description: "Callback URL to redirect to after the user has signed in" }).optional(),
  newUserCallbackURL: z.string().optional(),
  errorCallbackURL: z.string().meta({ description: "Callback URL to redirect to if an error happens" }).optional(),
  provider: SocialProviderListEnum,
  disableRedirect: z.boolean().meta({ description: "Disable automatic redirection to the provider. Useful for handling the redirection yourself" }).optional(),
  idToken: z.optional(z.object({
    token: z.string().meta({ description: "ID token from the provider" }),
    nonce: z.string().meta({ description: "Nonce used to generate the token" }).optional(),
    accessToken: z.string().meta({ description: "Access token from the provider" }).optional(),
    refreshToken: z.string().meta({ description: "Refresh token from the provider" }).optional(),
    expiresAt: z.number().meta({ description: "Expiry date of the token" }).optional()
  })),
  scopes: z.array(z.string()).meta({ description: "Array of scopes to request from the provider. This will override the default scopes passed." }).optional(),
  requestSignUp: z.boolean().meta({ description: "Explicitly request sign-up. Useful when disableImplicitSignUp is true for this provider" }).optional(),
  loginHint: z.string().meta({ description: "The login hint to use for the authorization code request" }).optional(),
  additionalData: z.record(z.string(), z.any()).optional().meta({ description: "Additional data to be passed through the OAuth flow" })
});
const signInSocial = () => createAuthEndpoint("/sign-in/social", {
  method: "POST",
  operationId: "socialSignIn",
  body: socialSignInBodySchema,
  metadata: {
    $Infer: {
      body: {},
      returned: {}
    },
    openapi: {
      description: "Sign in with a social provider",
      operationId: "socialSignIn",
      responses: { "200": {
        description: "Success - Returns either session details or redirect URL",
        content: { "application/json": { schema: {
          type: "object",
          description: "Session response when idToken is provided",
          properties: {
            token: { type: "string" },
            user: {
              type: "object",
              $ref: "#/components/schemas/User"
            },
            url: { type: "string" },
            redirect: {
              type: "boolean",
              enum: [false]
            }
          },
          required: [
            "redirect",
            "token",
            "user"
          ]
        } } }
      } }
    }
  }
}, async (c2) => {
  const provider = c2.context.socialProviders.find((p) => p.id === c2.body.provider);
  if (!provider) {
    c2.context.logger.error("Provider not found. Make sure to add the provider in your auth config", { provider: c2.body.provider });
    throw new APIError$1("NOT_FOUND", { message: BASE_ERROR_CODES.PROVIDER_NOT_FOUND });
  }
  if (c2.body.idToken) {
    if (!provider.verifyIdToken) {
      c2.context.logger.error("Provider does not support id token verification", { provider: c2.body.provider });
      throw new APIError$1("NOT_FOUND", { message: BASE_ERROR_CODES.ID_TOKEN_NOT_SUPPORTED });
    }
    const { token: token2, nonce } = c2.body.idToken;
    if (!await provider.verifyIdToken(token2, nonce)) {
      c2.context.logger.error("Invalid id token", { provider: c2.body.provider });
      throw new APIError$1("UNAUTHORIZED", { message: BASE_ERROR_CODES.INVALID_TOKEN });
    }
    const userInfo = await provider.getUserInfo({
      idToken: token2,
      accessToken: c2.body.idToken.accessToken,
      refreshToken: c2.body.idToken.refreshToken
    });
    if (!userInfo || !userInfo?.user) {
      c2.context.logger.error("Failed to get user info", { provider: c2.body.provider });
      throw new APIError$1("UNAUTHORIZED", { message: BASE_ERROR_CODES.FAILED_TO_GET_USER_INFO });
    }
    if (!userInfo.user.email) {
      c2.context.logger.error("User email not found", { provider: c2.body.provider });
      throw new APIError$1("UNAUTHORIZED", { message: BASE_ERROR_CODES.USER_EMAIL_NOT_FOUND });
    }
    const data = await handleOAuthUserInfo(c2, {
      userInfo: {
        ...userInfo.user,
        email: userInfo.user.email,
        id: String(userInfo.user.id),
        name: userInfo.user.name || "",
        image: userInfo.user.image,
        emailVerified: userInfo.user.emailVerified || false
      },
      account: {
        providerId: provider.id,
        accountId: String(userInfo.user.id),
        accessToken: c2.body.idToken.accessToken
      },
      callbackURL: c2.body.callbackURL,
      disableSignUp: provider.disableImplicitSignUp && !c2.body.requestSignUp || provider.disableSignUp
    });
    if (data.error) throw new APIError$1("UNAUTHORIZED", { message: data.error });
    await setSessionCookie(c2, data.data);
    return c2.json({
      redirect: false,
      token: data.data.session.token,
      url: void 0,
      user: parseUserOutput(c2.context.options, data.data.user)
    });
  }
  const { codeVerifier, state } = await generateState(c2, void 0, c2.body.additionalData);
  const url = await provider.createAuthorizationURL({
    state,
    codeVerifier,
    redirectURI: `${c2.context.baseURL}/callback/${provider.id}`,
    scopes: c2.body.scopes,
    loginHint: c2.body.loginHint
  });
  if (!c2.body.disableRedirect) c2.setHeader("Location", url.toString());
  return c2.json({
    url: url.toString(),
    redirect: !c2.body.disableRedirect
  });
});
const signInEmail = () => createAuthEndpoint("/sign-in/email", {
  method: "POST",
  operationId: "signInEmail",
  use: [formCsrfMiddleware],
  body: z.object({
    email: z.string().meta({ description: "Email of the user" }),
    password: z.string().meta({ description: "Password of the user" }),
    callbackURL: z.string().meta({ description: "Callback URL to use as a redirect for email verification" }).optional(),
    rememberMe: z.boolean().meta({ description: "If this is false, the session will not be remembered. Default is `true`." }).default(true).optional()
  }),
  metadata: {
    allowedMediaTypes: ["application/x-www-form-urlencoded", "application/json"],
    $Infer: {
      body: {},
      returned: {}
    },
    openapi: {
      operationId: "signInEmail",
      description: "Sign in with email and password",
      responses: { "200": {
        description: "Success - Returns either session details or redirect URL",
        content: { "application/json": { schema: {
          type: "object",
          description: "Session response when idToken is provided",
          properties: {
            redirect: {
              type: "boolean",
              enum: [false]
            },
            token: {
              type: "string",
              description: "Session token"
            },
            url: {
              type: "string",
              nullable: true
            },
            user: {
              type: "object",
              $ref: "#/components/schemas/User"
            }
          },
          required: [
            "redirect",
            "token",
            "user"
          ]
        } } }
      } }
    }
  }
}, async (ctx) => {
  if (!ctx.context.options?.emailAndPassword?.enabled) {
    ctx.context.logger.error("Email and password is not enabled. Make sure to enable it in the options on you `auth.ts` file. Check `https://better-auth.com/docs/authentication/email-password` for more!");
    throw new APIError$1("BAD_REQUEST", { message: "Email and password is not enabled" });
  }
  const { email, password } = ctx.body;
  if (!z.email().safeParse(email).success) throw new APIError$1("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_EMAIL });
  const user = await ctx.context.internalAdapter.findUserByEmail(email, { includeAccounts: true });
  if (!user) {
    await ctx.context.password.hash(password);
    ctx.context.logger.error("User not found", { email });
    throw new APIError$1("UNAUTHORIZED", { message: BASE_ERROR_CODES.INVALID_EMAIL_OR_PASSWORD });
  }
  const credentialAccount = user.accounts.find((a) => a.providerId === "credential");
  if (!credentialAccount) {
    await ctx.context.password.hash(password);
    ctx.context.logger.error("Credential account not found", { email });
    throw new APIError$1("UNAUTHORIZED", { message: BASE_ERROR_CODES.INVALID_EMAIL_OR_PASSWORD });
  }
  const currentPassword = credentialAccount?.password;
  if (!currentPassword) {
    await ctx.context.password.hash(password);
    ctx.context.logger.error("Password not found", { email });
    throw new APIError$1("UNAUTHORIZED", { message: BASE_ERROR_CODES.INVALID_EMAIL_OR_PASSWORD });
  }
  if (!await ctx.context.password.verify({
    hash: currentPassword,
    password
  })) {
    ctx.context.logger.error("Invalid password");
    throw new APIError$1("UNAUTHORIZED", { message: BASE_ERROR_CODES.INVALID_EMAIL_OR_PASSWORD });
  }
  if (ctx.context.options?.emailAndPassword?.requireEmailVerification && !user.user.emailVerified) {
    if (!ctx.context.options?.emailVerification?.sendVerificationEmail) throw new APIError$1("FORBIDDEN", { message: BASE_ERROR_CODES.EMAIL_NOT_VERIFIED });
    if (ctx.context.options?.emailVerification?.sendOnSignIn) {
      const token2 = await createEmailVerificationToken(ctx.context.secret, user.user.email, void 0, ctx.context.options.emailVerification?.expiresIn);
      const callbackURL = ctx.body.callbackURL ? encodeURIComponent(ctx.body.callbackURL) : encodeURIComponent("/");
      const url = `${ctx.context.baseURL}/verify-email?token=${token2}&callbackURL=${callbackURL}`;
      await ctx.context.runInBackgroundOrAwait(ctx.context.options.emailVerification.sendVerificationEmail({
        user: user.user,
        url,
        token: token2
      }, ctx.request));
    }
    throw new APIError$1("FORBIDDEN", { message: BASE_ERROR_CODES.EMAIL_NOT_VERIFIED });
  }
  const session = await ctx.context.internalAdapter.createSession(user.user.id, ctx.body.rememberMe === false);
  if (!session) {
    ctx.context.logger.error("Failed to create session");
    throw new APIError$1("UNAUTHORIZED", { message: BASE_ERROR_CODES.FAILED_TO_CREATE_SESSION });
  }
  await setSessionCookie(ctx, {
    session,
    user: user.user
  }, ctx.body.rememberMe === false);
  if (ctx.body.callbackURL) ctx.setHeader("Location", ctx.body.callbackURL);
  return ctx.json({
    redirect: !!ctx.body.callbackURL,
    token: session.token,
    url: ctx.body.callbackURL,
    user: parseUserOutput(ctx.context.options, user.user)
  });
});
const signOut = createAuthEndpoint("/sign-out", {
  method: "POST",
  operationId: "signOut",
  requireHeaders: true,
  metadata: { openapi: {
    operationId: "signOut",
    description: "Sign out the current user",
    responses: { "200": {
      description: "Success",
      content: { "application/json": { schema: {
        type: "object",
        properties: { success: { type: "boolean" } }
      } } }
    } }
  } }
}, async (ctx) => {
  const sessionCookieToken = await ctx.getSignedCookie(ctx.context.authCookies.sessionToken.name, ctx.context.secret);
  if (sessionCookieToken) try {
    await ctx.context.internalAdapter.deleteSession(sessionCookieToken);
  } catch (e2) {
    ctx.context.logger.error("Failed to delete session from database", e2);
  }
  deleteSessionCookie(ctx);
  return ctx.json({ success: true });
});
const signUpEmailBodySchema = z.object({
  name: z.string(),
  email: z.email(),
  password: z.string().nonempty(),
  image: z.string().optional(),
  callbackURL: z.string().optional(),
  rememberMe: z.boolean().optional()
}).and(z.record(z.string(), z.any()));
const signUpEmail = () => createAuthEndpoint("/sign-up/email", {
  method: "POST",
  operationId: "signUpWithEmailAndPassword",
  use: [formCsrfMiddleware],
  body: signUpEmailBodySchema,
  metadata: {
    allowedMediaTypes: ["application/x-www-form-urlencoded", "application/json"],
    $Infer: {
      body: {},
      returned: {}
    },
    openapi: {
      operationId: "signUpWithEmailAndPassword",
      description: "Sign up a user using email and password",
      requestBody: { content: { "application/json": { schema: {
        type: "object",
        properties: {
          name: {
            type: "string",
            description: "The name of the user"
          },
          email: {
            type: "string",
            description: "The email of the user"
          },
          password: {
            type: "string",
            description: "The password of the user"
          },
          image: {
            type: "string",
            description: "The profile image URL of the user"
          },
          callbackURL: {
            type: "string",
            description: "The URL to use for email verification callback"
          },
          rememberMe: {
            type: "boolean",
            description: "If this is false, the session will not be remembered. Default is `true`."
          }
        },
        required: [
          "name",
          "email",
          "password"
        ]
      } } } },
      responses: {
        "200": {
          description: "Successfully created user",
          content: { "application/json": { schema: {
            type: "object",
            properties: {
              token: {
                type: "string",
                nullable: true,
                description: "Authentication token for the session"
              },
              user: {
                type: "object",
                properties: {
                  id: {
                    type: "string",
                    description: "The unique identifier of the user"
                  },
                  email: {
                    type: "string",
                    format: "email",
                    description: "The email address of the user"
                  },
                  name: {
                    type: "string",
                    description: "The name of the user"
                  },
                  image: {
                    type: "string",
                    format: "uri",
                    nullable: true,
                    description: "The profile image URL of the user"
                  },
                  emailVerified: {
                    type: "boolean",
                    description: "Whether the email has been verified"
                  },
                  createdAt: {
                    type: "string",
                    format: "date-time",
                    description: "When the user was created"
                  },
                  updatedAt: {
                    type: "string",
                    format: "date-time",
                    description: "When the user was last updated"
                  }
                },
                required: [
                  "id",
                  "email",
                  "name",
                  "emailVerified",
                  "createdAt",
                  "updatedAt"
                ]
              }
            },
            required: ["user"]
          } } }
        },
        "422": {
          description: "Unprocessable Entity. User already exists or failed to create user.",
          content: { "application/json": { schema: {
            type: "object",
            properties: { message: { type: "string" } }
          } } }
        }
      }
    }
  }
}, async (ctx) => {
  return runWithTransaction(ctx.context.adapter, async () => {
    if (!ctx.context.options.emailAndPassword?.enabled || ctx.context.options.emailAndPassword?.disableSignUp) throw new APIError$1("BAD_REQUEST", { message: "Email and password sign up is not enabled" });
    const body = ctx.body;
    const { name: name2, email, password, image, callbackURL: _callbackURL, rememberMe, ...rest } = body;
    if (!z.email().safeParse(email).success) throw new APIError$1("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_EMAIL });
    if (!password || typeof password !== "string") throw new APIError$1("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_PASSWORD });
    const minPasswordLength = ctx.context.password.config.minPasswordLength;
    if (password.length < minPasswordLength) {
      ctx.context.logger.error("Password is too short");
      throw new APIError$1("BAD_REQUEST", { message: BASE_ERROR_CODES.PASSWORD_TOO_SHORT });
    }
    const maxPasswordLength = ctx.context.password.config.maxPasswordLength;
    if (password.length > maxPasswordLength) {
      ctx.context.logger.error("Password is too long");
      throw new APIError$1("BAD_REQUEST", { message: BASE_ERROR_CODES.PASSWORD_TOO_LONG });
    }
    if ((await ctx.context.internalAdapter.findUserByEmail(email))?.user) {
      ctx.context.logger.info(`Sign-up attempt for existing email: ${email}`);
      throw new APIError$1("UNPROCESSABLE_ENTITY", { message: BASE_ERROR_CODES.USER_ALREADY_EXISTS_USE_ANOTHER_EMAIL });
    }
    const hash = await ctx.context.password.hash(password);
    let createdUser;
    try {
      const data = parseUserInput(ctx.context.options, rest, "create");
      createdUser = await ctx.context.internalAdapter.createUser({
        email: email.toLowerCase(),
        name: name2,
        image,
        ...data,
        emailVerified: false
      });
      if (!createdUser) throw new APIError$1("BAD_REQUEST", { message: BASE_ERROR_CODES.FAILED_TO_CREATE_USER });
    } catch (e2) {
      if (isDevelopment()) ctx.context.logger.error("Failed to create user", e2);
      if (e2 instanceof APIError$1) throw e2;
      ctx.context.logger?.error("Failed to create user", e2);
      throw new APIError$1("UNPROCESSABLE_ENTITY", { message: BASE_ERROR_CODES.FAILED_TO_CREATE_USER });
    }
    if (!createdUser) throw new APIError$1("UNPROCESSABLE_ENTITY", { message: BASE_ERROR_CODES.FAILED_TO_CREATE_USER });
    await ctx.context.internalAdapter.linkAccount({
      userId: createdUser.id,
      providerId: "credential",
      accountId: createdUser.id,
      password: hash
    });
    if (ctx.context.options.emailVerification?.sendOnSignUp ?? ctx.context.options.emailAndPassword.requireEmailVerification) {
      const token2 = await createEmailVerificationToken(ctx.context.secret, createdUser.email, void 0, ctx.context.options.emailVerification?.expiresIn);
      const callbackURL = body.callbackURL ? encodeURIComponent(body.callbackURL) : encodeURIComponent("/");
      const url = `${ctx.context.baseURL}/verify-email?token=${token2}&callbackURL=${callbackURL}`;
      if (ctx.context.options.emailVerification?.sendVerificationEmail) await ctx.context.runInBackgroundOrAwait(ctx.context.options.emailVerification.sendVerificationEmail({
        user: createdUser,
        url,
        token: token2
      }, ctx.request));
    }
    if (ctx.context.options.emailAndPassword.autoSignIn === false || ctx.context.options.emailAndPassword.requireEmailVerification) return ctx.json({
      token: null,
      user: parseUserOutput(ctx.context.options, createdUser)
    });
    const session = await ctx.context.internalAdapter.createSession(createdUser.id, rememberMe === false);
    if (!session) throw new APIError$1("BAD_REQUEST", { message: BASE_ERROR_CODES.FAILED_TO_CREATE_SESSION });
    await setSessionCookie(ctx, {
      session,
      user: createdUser
    }, rememberMe === false);
    return ctx.json({
      token: session.token,
      user: parseUserOutput(ctx.context.options, createdUser)
    });
  });
});
const updateUserBodySchema = z.record(z.string().meta({ description: "Field name must be a string" }), z.any());
const updateUser = () => createAuthEndpoint("/update-user", {
  method: "POST",
  operationId: "updateUser",
  body: updateUserBodySchema,
  use: [sessionMiddleware],
  metadata: {
    $Infer: { body: {} },
    openapi: {
      operationId: "updateUser",
      description: "Update the current user",
      requestBody: { content: { "application/json": { schema: {
        type: "object",
        properties: {
          name: {
            type: "string",
            description: "The name of the user"
          },
          image: {
            type: "string",
            description: "The image of the user",
            nullable: true
          }
        }
      } } } },
      responses: { "200": {
        description: "Success",
        content: { "application/json": { schema: {
          type: "object",
          properties: { user: {
            type: "object",
            $ref: "#/components/schemas/User"
          } }
        } } }
      } }
    }
  }
}, async (ctx) => {
  const body = ctx.body;
  if (typeof body !== "object" || Array.isArray(body)) throw new APIError$1("BAD_REQUEST", { message: "Body must be an object" });
  if (body.email) throw new APIError$1("BAD_REQUEST", { message: BASE_ERROR_CODES.EMAIL_CAN_NOT_BE_UPDATED });
  const { name: name2, image, ...rest } = body;
  const session = ctx.context.session;
  const additionalFields = parseUserInput(ctx.context.options, rest, "update");
  if (image === void 0 && name2 === void 0 && Object.keys(additionalFields).length === 0) throw new APIError$1("BAD_REQUEST", { message: "No fields to update" });
  const updatedUser = await ctx.context.internalAdapter.updateUser(session.user.id, {
    name: name2,
    image,
    ...additionalFields
  }) ?? {
    ...session.user,
    ...name2 !== void 0 && { name: name2 },
    ...image !== void 0 && { image },
    ...additionalFields
  };
  await setSessionCookie(ctx, {
    session: session.session,
    user: updatedUser
  });
  return ctx.json({ status: true });
});
const changePassword = createAuthEndpoint("/change-password", {
  method: "POST",
  operationId: "changePassword",
  body: z.object({
    newPassword: z.string().meta({ description: "The new password to set" }),
    currentPassword: z.string().meta({ description: "The current password is required" }),
    revokeOtherSessions: z.boolean().meta({ description: "Must be a boolean value" }).optional()
  }),
  use: [sensitiveSessionMiddleware],
  metadata: { openapi: {
    operationId: "changePassword",
    description: "Change the password of the user",
    responses: { "200": {
      description: "Password successfully changed",
      content: { "application/json": { schema: {
        type: "object",
        properties: {
          token: {
            type: "string",
            nullable: true,
            description: "New session token if other sessions were revoked"
          },
          user: {
            type: "object",
            properties: {
              id: {
                type: "string",
                description: "The unique identifier of the user"
              },
              email: {
                type: "string",
                format: "email",
                description: "The email address of the user"
              },
              name: {
                type: "string",
                description: "The name of the user"
              },
              image: {
                type: "string",
                format: "uri",
                nullable: true,
                description: "The profile image URL of the user"
              },
              emailVerified: {
                type: "boolean",
                description: "Whether the email has been verified"
              },
              createdAt: {
                type: "string",
                format: "date-time",
                description: "When the user was created"
              },
              updatedAt: {
                type: "string",
                format: "date-time",
                description: "When the user was last updated"
              }
            },
            required: [
              "id",
              "email",
              "name",
              "emailVerified",
              "createdAt",
              "updatedAt"
            ]
          }
        },
        required: ["user"]
      } } }
    } }
  } }
}, async (ctx) => {
  const { newPassword, currentPassword, revokeOtherSessions: revokeOtherSessions2 } = ctx.body;
  const session = ctx.context.session;
  const minPasswordLength = ctx.context.password.config.minPasswordLength;
  if (newPassword.length < minPasswordLength) {
    ctx.context.logger.error("Password is too short");
    throw new APIError$1("BAD_REQUEST", { message: BASE_ERROR_CODES.PASSWORD_TOO_SHORT });
  }
  const maxPasswordLength = ctx.context.password.config.maxPasswordLength;
  if (newPassword.length > maxPasswordLength) {
    ctx.context.logger.error("Password is too long");
    throw new APIError$1("BAD_REQUEST", { message: BASE_ERROR_CODES.PASSWORD_TOO_LONG });
  }
  const account = (await ctx.context.internalAdapter.findAccounts(session.user.id)).find((account$1) => account$1.providerId === "credential" && account$1.password);
  if (!account || !account.password) throw new APIError$1("BAD_REQUEST", { message: BASE_ERROR_CODES.CREDENTIAL_ACCOUNT_NOT_FOUND });
  const passwordHash = await ctx.context.password.hash(newPassword);
  if (!await ctx.context.password.verify({
    hash: account.password,
    password: currentPassword
  })) throw new APIError$1("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_PASSWORD });
  await ctx.context.internalAdapter.updateAccount(account.id, { password: passwordHash });
  let token2 = null;
  if (revokeOtherSessions2) {
    await ctx.context.internalAdapter.deleteSessions(session.user.id);
    const newSession = await ctx.context.internalAdapter.createSession(session.user.id);
    if (!newSession) throw new APIError$1("INTERNAL_SERVER_ERROR", { message: BASE_ERROR_CODES.FAILED_TO_GET_SESSION });
    await setSessionCookie(ctx, {
      session: newSession,
      user: session.user
    });
    token2 = newSession.token;
  }
  return ctx.json({
    token: token2,
    user: parseUserOutput(ctx.context.options, session.user)
  });
});
const setPassword = createAuthEndpoint({
  method: "POST",
  body: z.object({ newPassword: z.string().meta({ description: "The new password to set is required" }) }),
  use: [sensitiveSessionMiddleware]
}, async (ctx) => {
  const { newPassword } = ctx.body;
  const session = ctx.context.session;
  const minPasswordLength = ctx.context.password.config.minPasswordLength;
  if (newPassword.length < minPasswordLength) {
    ctx.context.logger.error("Password is too short");
    throw new APIError$1("BAD_REQUEST", { message: BASE_ERROR_CODES.PASSWORD_TOO_SHORT });
  }
  const maxPasswordLength = ctx.context.password.config.maxPasswordLength;
  if (newPassword.length > maxPasswordLength) {
    ctx.context.logger.error("Password is too long");
    throw new APIError$1("BAD_REQUEST", { message: BASE_ERROR_CODES.PASSWORD_TOO_LONG });
  }
  const account = (await ctx.context.internalAdapter.findAccounts(session.user.id)).find((account$1) => account$1.providerId === "credential" && account$1.password);
  const passwordHash = await ctx.context.password.hash(newPassword);
  if (!account) {
    await ctx.context.internalAdapter.linkAccount({
      userId: session.user.id,
      providerId: "credential",
      accountId: session.user.id,
      password: passwordHash
    });
    return ctx.json({ status: true });
  }
  throw new APIError$1("BAD_REQUEST", { message: "user already has a password" });
});
const deleteUser = createAuthEndpoint("/delete-user", {
  method: "POST",
  use: [sensitiveSessionMiddleware],
  body: z.object({
    callbackURL: z.string().meta({ description: "The callback URL to redirect to after the user is deleted" }).optional(),
    password: z.string().meta({ description: "The password of the user is required to delete the user" }).optional(),
    token: z.string().meta({ description: "The token to delete the user is required" }).optional()
  }),
  metadata: { openapi: {
    operationId: "deleteUser",
    description: "Delete the user",
    requestBody: { content: { "application/json": { schema: {
      type: "object",
      properties: {
        callbackURL: {
          type: "string",
          description: "The callback URL to redirect to after the user is deleted"
        },
        password: {
          type: "string",
          description: "The user's password. Required if session is not fresh"
        },
        token: {
          type: "string",
          description: "The deletion verification token"
        }
      }
    } } } },
    responses: { "200": {
      description: "User deletion processed successfully",
      content: { "application/json": { schema: {
        type: "object",
        properties: {
          success: {
            type: "boolean",
            description: "Indicates if the operation was successful"
          },
          message: {
            type: "string",
            enum: ["User deleted", "Verification email sent"],
            description: "Status message of the deletion process"
          }
        },
        required: ["success", "message"]
      } } }
    } }
  } }
}, async (ctx) => {
  if (!ctx.context.options.user?.deleteUser?.enabled) {
    ctx.context.logger.error("Delete user is disabled. Enable it in the options");
    throw new APIError$1("NOT_FOUND");
  }
  const session = ctx.context.session;
  if (ctx.body.password) {
    const account = (await ctx.context.internalAdapter.findAccounts(session.user.id)).find((account$1) => account$1.providerId === "credential" && account$1.password);
    if (!account || !account.password) throw new APIError$1("BAD_REQUEST", { message: BASE_ERROR_CODES.CREDENTIAL_ACCOUNT_NOT_FOUND });
    if (!await ctx.context.password.verify({
      hash: account.password,
      password: ctx.body.password
    })) throw new APIError$1("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_PASSWORD });
  }
  if (ctx.body.token) {
    await deleteUserCallback({
      ...ctx,
      query: { token: ctx.body.token }
    });
    return ctx.json({
      success: true,
      message: "User deleted"
    });
  }
  if (ctx.context.options.user.deleteUser?.sendDeleteAccountVerification) {
    const token2 = generateRandomString(32, "0-9", "a-z");
    await ctx.context.internalAdapter.createVerificationValue({
      value: session.user.id,
      identifier: `delete-account-${token2}`,
      expiresAt: new Date(Date.now() + (ctx.context.options.user.deleteUser?.deleteTokenExpiresIn || 3600 * 24) * 1e3)
    });
    const url = `${ctx.context.baseURL}/delete-user/callback?token=${token2}&callbackURL=${ctx.body.callbackURL || "/"}`;
    await ctx.context.runInBackgroundOrAwait(ctx.context.options.user.deleteUser.sendDeleteAccountVerification({
      user: session.user,
      url,
      token: token2
    }, ctx.request));
    return ctx.json({
      success: true,
      message: "Verification email sent"
    });
  }
  if (!ctx.body.password && ctx.context.sessionConfig.freshAge !== 0) {
    const currentAge = new Date(session.session.createdAt).getTime();
    const freshAge = ctx.context.sessionConfig.freshAge * 1e3;
    if (Date.now() - currentAge > freshAge * 1e3) throw new APIError$1("BAD_REQUEST", { message: BASE_ERROR_CODES.SESSION_EXPIRED });
  }
  const beforeDelete = ctx.context.options.user.deleteUser?.beforeDelete;
  if (beforeDelete) await beforeDelete(session.user, ctx.request);
  await ctx.context.internalAdapter.deleteUser(session.user.id);
  await ctx.context.internalAdapter.deleteSessions(session.user.id);
  deleteSessionCookie(ctx);
  const afterDelete = ctx.context.options.user.deleteUser?.afterDelete;
  if (afterDelete) await afterDelete(session.user, ctx.request);
  return ctx.json({
    success: true,
    message: "User deleted"
  });
});
const deleteUserCallback = createAuthEndpoint("/delete-user/callback", {
  method: "GET",
  query: z.object({
    token: z.string().meta({ description: "The token to verify the deletion request" }),
    callbackURL: z.string().meta({ description: "The URL to redirect to after deletion" }).optional()
  }),
  use: [originCheck((ctx) => ctx.query.callbackURL)],
  metadata: { openapi: {
    description: "Callback to complete user deletion with verification token",
    responses: { "200": {
      description: "User successfully deleted",
      content: { "application/json": { schema: {
        type: "object",
        properties: {
          success: {
            type: "boolean",
            description: "Indicates if the deletion was successful"
          },
          message: {
            type: "string",
            enum: ["User deleted"],
            description: "Confirmation message"
          }
        },
        required: ["success", "message"]
      } } }
    } }
  } }
}, async (ctx) => {
  if (!ctx.context.options.user?.deleteUser?.enabled) {
    ctx.context.logger.error("Delete user is disabled. Enable it in the options");
    throw new APIError$1("NOT_FOUND");
  }
  const session = await getSessionFromCtx(ctx);
  if (!session) throw new APIError$1("NOT_FOUND", { message: BASE_ERROR_CODES.FAILED_TO_GET_USER_INFO });
  const token2 = await ctx.context.internalAdapter.findVerificationValue(`delete-account-${ctx.query.token}`);
  if (!token2 || token2.expiresAt < /* @__PURE__ */ new Date()) throw new APIError$1("NOT_FOUND", { message: BASE_ERROR_CODES.INVALID_TOKEN });
  if (token2.value !== session.user.id) throw new APIError$1("NOT_FOUND", { message: BASE_ERROR_CODES.INVALID_TOKEN });
  const beforeDelete = ctx.context.options.user.deleteUser?.beforeDelete;
  if (beforeDelete) await beforeDelete(session.user, ctx.request);
  await ctx.context.internalAdapter.deleteUser(session.user.id);
  await ctx.context.internalAdapter.deleteSessions(session.user.id);
  await ctx.context.internalAdapter.deleteAccounts(session.user.id);
  await ctx.context.internalAdapter.deleteVerificationValue(token2.id);
  deleteSessionCookie(ctx);
  const afterDelete = ctx.context.options.user.deleteUser?.afterDelete;
  if (afterDelete) await afterDelete(session.user, ctx.request);
  if (ctx.query.callbackURL) throw ctx.redirect(ctx.query.callbackURL || "/");
  return ctx.json({
    success: true,
    message: "User deleted"
  });
});
const changeEmail = createAuthEndpoint("/change-email", {
  method: "POST",
  body: z.object({
    newEmail: z.email().meta({ description: "The new email address to set must be a valid email address" }),
    callbackURL: z.string().meta({ description: "The URL to redirect to after email verification" }).optional()
  }),
  use: [sensitiveSessionMiddleware],
  metadata: { openapi: {
    operationId: "changeEmail",
    responses: {
      "200": {
        description: "Email change request processed successfully",
        content: { "application/json": { schema: {
          type: "object",
          properties: {
            user: {
              type: "object",
              $ref: "#/components/schemas/User"
            },
            status: {
              type: "boolean",
              description: "Indicates if the request was successful"
            },
            message: {
              type: "string",
              enum: ["Email updated", "Verification email sent"],
              description: "Status message of the email change process",
              nullable: true
            }
          },
          required: ["status"]
        } } }
      },
      "422": {
        description: "Unprocessable Entity. Email already exists",
        content: { "application/json": { schema: {
          type: "object",
          properties: { message: { type: "string" } }
        } } }
      }
    }
  } }
}, async (ctx) => {
  if (!ctx.context.options.user?.changeEmail?.enabled) {
    ctx.context.logger.error("Change email is disabled.");
    throw new APIError$1("BAD_REQUEST", { message: "Change email is disabled" });
  }
  const newEmail = ctx.body.newEmail.toLowerCase();
  if (newEmail === ctx.context.session.user.email) {
    ctx.context.logger.error("Email is the same");
    throw new APIError$1("BAD_REQUEST", { message: "Email is the same" });
  }
  if (await ctx.context.internalAdapter.findUserByEmail(newEmail)) {
    ctx.context.logger.error("Email already exists");
    throw new APIError$1("UNPROCESSABLE_ENTITY", { message: BASE_ERROR_CODES.USER_ALREADY_EXISTS_USE_ANOTHER_EMAIL });
  }
  if (ctx.context.session.user.emailVerified !== true && ctx.context.options.user.changeEmail.updateEmailWithoutVerification) {
    await ctx.context.internalAdapter.updateUserByEmail(ctx.context.session.user.email, { email: newEmail });
    await setSessionCookie(ctx, {
      session: ctx.context.session.session,
      user: {
        ...ctx.context.session.user,
        email: newEmail
      }
    });
    if (ctx.context.options.emailVerification?.sendVerificationEmail) {
      const token$1 = await createEmailVerificationToken(ctx.context.secret, newEmail, void 0, ctx.context.options.emailVerification?.expiresIn);
      const url$1 = `${ctx.context.baseURL}/verify-email?token=${token$1}&callbackURL=${ctx.body.callbackURL || "/"}`;
      await ctx.context.runInBackgroundOrAwait(ctx.context.options.emailVerification.sendVerificationEmail({
        user: {
          ...ctx.context.session.user,
          email: newEmail
        },
        url: url$1,
        token: token$1
      }, ctx.request));
    }
    return ctx.json({ status: true });
  }
  if (ctx.context.session.user.emailVerified && (ctx.context.options.user.changeEmail.sendChangeEmailConfirmation || ctx.context.options.user.changeEmail.sendChangeEmailVerification)) {
    const token$1 = await createEmailVerificationToken(ctx.context.secret, ctx.context.session.user.email, newEmail, ctx.context.options.emailVerification?.expiresIn, { requestType: "change-email-confirmation" });
    const url$1 = `${ctx.context.baseURL}/verify-email?token=${token$1}&callbackURL=${ctx.body.callbackURL || "/"}`;
    const sendFn = ctx.context.options.user.changeEmail.sendChangeEmailConfirmation || ctx.context.options.user.changeEmail.sendChangeEmailVerification;
    if (sendFn) await ctx.context.runInBackgroundOrAwait(sendFn({
      user: ctx.context.session.user,
      newEmail,
      url: url$1,
      token: token$1
    }, ctx.request));
    return ctx.json({ status: true });
  }
  if (!ctx.context.options.emailVerification?.sendVerificationEmail) {
    ctx.context.logger.error("Verification email isn't enabled.");
    throw new APIError$1("BAD_REQUEST", { message: "Verification email isn't enabled" });
  }
  const token2 = await createEmailVerificationToken(ctx.context.secret, ctx.context.session.user.email, newEmail, ctx.context.options.emailVerification?.expiresIn, { requestType: "change-email-verification" });
  const url = `${ctx.context.baseURL}/verify-email?token=${token2}&callbackURL=${ctx.body.callbackURL || "/"}`;
  await ctx.context.runInBackgroundOrAwait(ctx.context.options.emailVerification.sendVerificationEmail({
    user: {
      ...ctx.context.session.user,
      email: newEmail
    },
    url,
    token: token2
  }, ctx.request));
  return ctx.json({ status: true });
});
function isPlainObject(value) {
  if (value === null || typeof value !== "object") {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  if (prototype !== null && prototype !== Object.prototype && Object.getPrototypeOf(prototype) !== null) {
    return false;
  }
  if (Symbol.iterator in value) {
    return false;
  }
  if (Symbol.toStringTag in value) {
    return Object.prototype.toString.call(value) === "[object Module]";
  }
  return true;
}
function _defu(baseObject, defaults2, namespace = ".", merger) {
  if (!isPlainObject(defaults2)) {
    return _defu(baseObject, {}, namespace, merger);
  }
  const object = Object.assign({}, defaults2);
  for (const key in baseObject) {
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const value = baseObject[key];
    if (value === null || value === void 0) {
      continue;
    }
    if (merger && merger(object, key, value, namespace)) {
      continue;
    }
    if (Array.isArray(value) && Array.isArray(object[key])) {
      object[key] = [...value, ...object[key]];
    } else if (isPlainObject(value) && isPlainObject(object[key])) {
      object[key] = _defu(
        value,
        object[key],
        (namespace ? `${namespace}.` : "") + key.toString(),
        merger
      );
    } else {
      object[key] = value;
    }
  }
  return object;
}
function createDefu(merger) {
  return (...arguments_) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    arguments_.reduce((p, c2) => _defu(p, c2, "", merger), {})
  );
}
const defu = createDefu();
const defuReplaceArrays = createDefu((obj, key, value) => {
  if (Array.isArray(obj[key]) && Array.isArray(value)) {
    obj[key] = value;
    return true;
  }
});
const hooksSourceWeakMap = /* @__PURE__ */ new WeakMap();
function toAuthEndpoints(endpoints, ctx) {
  const api = {};
  for (const [key, endpoint] of Object.entries(endpoints)) {
    api[key] = async (context) => {
      const run = async () => {
        const authContext = await ctx;
        let internalContext = {
          ...context,
          context: {
            ...authContext,
            returned: void 0,
            responseHeaders: void 0,
            session: null
          },
          path: endpoint.path,
          headers: context?.headers ? new Headers(context?.headers) : void 0
        };
        return runWithEndpointContext(internalContext, async () => {
          const { beforeHooks, afterHooks } = getHooks(authContext);
          const before = await runBeforeHooks(internalContext, beforeHooks);
          if ("context" in before && before.context && typeof before.context === "object") {
            const { headers, ...rest } = before.context;
            if (headers) headers.forEach((value, key$1) => {
              internalContext.headers.set(key$1, value);
            });
            internalContext = defuReplaceArrays(rest, internalContext);
          } else if (before) return context?.asResponse ? toResponse$1(before, { headers: context?.headers }) : context?.returnHeaders ? {
            headers: context?.headers,
            response: before
          } : before;
          internalContext.asResponse = false;
          internalContext.returnHeaders = true;
          internalContext.returnStatus = true;
          const result2 = await runWithEndpointContext(internalContext, () => endpoint(internalContext)).catch((e2) => {
            if (e2 instanceof APIError$1)
              return {
                response: e2,
                status: e2.statusCode,
                headers: e2.headers ? new Headers(e2.headers) : null
              };
            throw e2;
          });
          if (result2 && result2 instanceof Response) return result2;
          internalContext.context.returned = result2.response;
          internalContext.context.responseHeaders = result2.headers;
          const after = await runAfterHooks(internalContext, afterHooks);
          if (after.response) result2.response = after.response;
          if (result2.response instanceof APIError$1 && shouldPublishLog(authContext.logger.level, "debug")) result2.response.stack = result2.response.errorStack;
          if (result2.response instanceof APIError$1 && !context?.asResponse) throw result2.response;
          return context?.asResponse ? toResponse$1(result2.response, {
            headers: result2.headers,
            status: result2.status
          }) : context?.returnHeaders ? context?.returnStatus ? {
            headers: result2.headers,
            response: result2.response,
            status: result2.status
          } : {
            headers: result2.headers,
            response: result2.response
          } : context?.returnStatus ? {
            response: result2.response,
            status: result2.status
          } : result2.response;
        });
      };
      if (await hasRequestState()) return run();
      else return runWithRequestState(/* @__PURE__ */ new WeakMap(), run);
    };
    api[key].path = endpoint.path;
    api[key].options = endpoint.options;
  }
  return api;
}
async function runBeforeHooks(context, hooks) {
  let modifiedContext = {};
  for (const hook of hooks) {
    let matched = false;
    try {
      matched = hook.matcher(context);
    } catch (error2) {
      const hookSource = hooksSourceWeakMap.get(hook.handler) ?? "unknown";
      context.context.logger.error(`An error occurred during ${hookSource} hook matcher execution:`, error2);
      throw new APIError$1("INTERNAL_SERVER_ERROR", { message: `An error occurred during hook matcher execution. Check the logs for more details.` });
    }
    if (matched) {
      const result2 = await hook.handler({
        ...context,
        returnHeaders: false
      }).catch((e2) => {
        if (e2 instanceof APIError$1 && shouldPublishLog(context.context.logger.level, "debug")) e2.stack = e2.errorStack;
        throw e2;
      });
      if (result2 && typeof result2 === "object") {
        if ("context" in result2 && typeof result2.context === "object") {
          const { headers, ...rest } = result2.context;
          if (headers instanceof Headers) if (modifiedContext.headers) headers.forEach((value, key) => {
            modifiedContext.headers?.set(key, value);
          });
          else modifiedContext.headers = headers;
          modifiedContext = defuReplaceArrays(rest, modifiedContext);
          continue;
        }
        return result2;
      }
    }
  }
  return { context: modifiedContext };
}
async function runAfterHooks(context, hooks) {
  for (const hook of hooks) if (hook.matcher(context)) {
    const result2 = await hook.handler(context).catch((e2) => {
      if (e2 instanceof APIError$1) {
        if (shouldPublishLog(context.context.logger.level, "debug")) e2.stack = e2.errorStack;
        return {
          response: e2,
          headers: e2.headers ? new Headers(e2.headers) : null
        };
      }
      throw e2;
    });
    if (result2.headers) result2.headers.forEach((value, key) => {
      if (!context.context.responseHeaders) context.context.responseHeaders = new Headers({ [key]: value });
      else if (key.toLowerCase() === "set-cookie") context.context.responseHeaders.append(key, value);
      else context.context.responseHeaders.set(key, value);
    });
    if (result2.response) context.context.returned = result2.response;
  }
  return {
    response: context.context.returned,
    headers: context.context.responseHeaders
  };
}
function getHooks(authContext) {
  const plugins = authContext.options.plugins || [];
  const beforeHooks = [];
  const afterHooks = [];
  const beforeHookHandler = authContext.options.hooks?.before;
  if (beforeHookHandler) {
    hooksSourceWeakMap.set(beforeHookHandler, "user");
    beforeHooks.push({
      matcher: () => true,
      handler: beforeHookHandler
    });
  }
  const afterHookHandler = authContext.options.hooks?.after;
  if (afterHookHandler) {
    hooksSourceWeakMap.set(afterHookHandler, "user");
    afterHooks.push({
      matcher: () => true,
      handler: afterHookHandler
    });
  }
  const pluginBeforeHooks = plugins.filter((plugin) => plugin.hooks?.before).map((plugin) => plugin.hooks?.before).flat();
  const pluginAfterHooks = plugins.filter((plugin) => plugin.hooks?.after).map((plugin) => plugin.hooks?.after).flat();
  if (pluginBeforeHooks.length) beforeHooks.push(...pluginBeforeHooks);
  if (pluginAfterHooks.length) afterHooks.push(...pluginAfterHooks);
  return {
    beforeHooks,
    afterHooks
  };
}
function checkEndpointConflicts(options, logger$1) {
  const endpointRegistry = /* @__PURE__ */ new Map();
  options.plugins?.forEach((plugin) => {
    if (plugin.endpoints) {
      for (const [key, endpoint] of Object.entries(plugin.endpoints)) if (endpoint && "path" in endpoint && typeof endpoint.path === "string") {
        const path = endpoint.path;
        let methods2 = [];
        if (endpoint.options && "method" in endpoint.options) {
          if (Array.isArray(endpoint.options.method)) methods2 = endpoint.options.method;
          else if (typeof endpoint.options.method === "string") methods2 = [endpoint.options.method];
        }
        if (methods2.length === 0) methods2 = ["*"];
        if (!endpointRegistry.has(path)) endpointRegistry.set(path, []);
        endpointRegistry.get(path).push({
          pluginId: plugin.id,
          endpointKey: key,
          methods: methods2
        });
      }
    }
  });
  const conflicts = [];
  for (const [path, entries] of endpointRegistry.entries()) if (entries.length > 1) {
    const methodMap = /* @__PURE__ */ new Map();
    let hasConflict = false;
    for (const entry of entries) for (const method of entry.methods) {
      if (!methodMap.has(method)) methodMap.set(method, []);
      methodMap.get(method).push(entry.pluginId);
      if (methodMap.get(method).length > 1) hasConflict = true;
      if (method === "*" && entries.length > 1) hasConflict = true;
      else if (method !== "*" && methodMap.has("*")) hasConflict = true;
    }
    if (hasConflict) {
      const uniquePlugins = [...new Set(entries.map((e2) => e2.pluginId))];
      const conflictingMethods = [];
      for (const [method, plugins] of methodMap.entries()) if (plugins.length > 1 || method === "*" && entries.length > 1 || method !== "*" && methodMap.has("*")) conflictingMethods.push(method);
      conflicts.push({
        path,
        plugins: uniquePlugins,
        conflictingMethods
      });
    }
  }
  if (conflicts.length > 0) {
    const conflictMessages = conflicts.map((conflict) => `  - "${conflict.path}" [${conflict.conflictingMethods.join(", ")}] used by plugins: ${conflict.plugins.join(", ")}`).join("\n");
    logger$1.error(`Endpoint path conflicts detected! Multiple plugins are trying to use the same endpoint paths with conflicting HTTP methods:
${conflictMessages}

To resolve this, you can:
	1. Use only one of the conflicting plugins
	2. Configure the plugins to use different paths (if supported)
	3. Ensure plugins use different HTTP methods for the same path
`);
  }
}
function getEndpoints(ctx, options) {
  const pluginEndpoints = options.plugins?.reduce((acc, plugin) => {
    return {
      ...acc,
      ...plugin.endpoints
    };
  }, {}) ?? {};
  const middlewares = options.plugins?.map((plugin) => plugin.middlewares?.map((m) => {
    const middleware = (async (context) => {
      const authContext = await ctx;
      return m.middleware({
        ...context,
        context: {
          ...authContext,
          ...context.context
        }
      });
    });
    middleware.options = m.middleware.options;
    return {
      path: m.path,
      middleware
    };
  })).filter((plugin) => plugin !== void 0).flat() || [];
  return {
    api: toAuthEndpoints({
      signInSocial: signInSocial(),
      callbackOAuth,
      getSession: getSession(),
      signOut,
      signUpEmail: signUpEmail(),
      signInEmail: signInEmail(),
      resetPassword,
      verifyPassword,
      verifyEmail,
      sendVerificationEmail,
      changeEmail,
      changePassword,
      setPassword,
      updateUser: updateUser(),
      deleteUser,
      requestPasswordReset,
      requestPasswordResetCallback,
      listSessions: listSessions(),
      revokeSession,
      revokeSessions,
      revokeOtherSessions,
      linkSocialAccount,
      listUserAccounts,
      deleteUserCallback,
      unlinkAccount,
      refreshToken,
      getAccessToken,
      accountInfo,
      ...pluginEndpoints,
      ok,
      error
    }, ctx),
    middlewares
  };
}
const router$1 = (ctx, options) => {
  const { api, middlewares } = getEndpoints(ctx, options);
  const basePath = new URL(ctx.baseURL).pathname;
  return createRouter$1(api, {
    routerContext: ctx,
    openapi: { disabled: true },
    basePath,
    routerMiddleware: [{
      path: "/**",
      middleware: originCheckMiddleware
    }, ...middlewares],
    allowedMediaTypes: ["application/json"],
    skipTrailingSlashes: options.advanced?.skipTrailingSlashes ?? false,
    async onRequest(req2) {
      const disabledPaths = ctx.options.disabledPaths || [];
      const normalizedPath = normalizePathname(req2.url, basePath);
      if (disabledPaths.includes(normalizedPath)) return new Response("Not Found", { status: 404 });
      let currentRequest = req2;
      for (const plugin of ctx.options.plugins || []) if (plugin.onRequest) {
        const response = await plugin.onRequest(currentRequest, ctx);
        if (response && "response" in response) return response.response;
        if (response && "request" in response) currentRequest = response.request;
      }
      const rateLimitResponse2 = await onRequestRateLimit(currentRequest, ctx);
      if (rateLimitResponse2) return rateLimitResponse2;
      return currentRequest;
    },
    async onResponse(res2) {
      for (const plugin of ctx.options.plugins || []) if (plugin.onResponse) {
        const response = await plugin.onResponse(res2, ctx);
        if (response) return response.response;
      }
      return res2;
    },
    onError(e2) {
      if (e2 instanceof APIError$1 && e2.status === "FOUND") return;
      if (options.onAPIError?.throw) throw e2;
      if (options.onAPIError?.onError) {
        options.onAPIError.onError(e2, ctx);
        return;
      }
      const optLogLevel = options.logger?.level;
      const log = optLogLevel === "error" || optLogLevel === "warn" || optLogLevel === "debug" ? logger : void 0;
      if (options.logger?.disabled !== true) {
        if (e2 && typeof e2 === "object" && "message" in e2 && typeof e2.message === "string") {
          if (e2.message.includes("no column") || e2.message.includes("column") || e2.message.includes("relation") || e2.message.includes("table") || e2.message.includes("does not exist")) {
            ctx.logger?.error(e2.message);
            return;
          }
        }
        if (e2 instanceof APIError$1) {
          if (e2.status === "INTERNAL_SERVER_ERROR") ctx.logger.error(e2.status, e2);
          log?.error(e2.message);
        } else ctx.logger?.error(e2 && typeof e2 === "object" && "name" in e2 ? e2.name : "", e2);
      }
    }
  });
};
const DEFAULT_SECRET = "better-auth-secret-12345678901234567890";
async function runPluginInit(ctx) {
  let options = ctx.options;
  const plugins = options.plugins || [];
  let context = ctx;
  const dbHooks = [];
  for (const plugin of plugins) if (plugin.init) {
    const initPromise = plugin.init(context);
    let result2;
    if (isPromise(initPromise)) result2 = await initPromise;
    else result2 = initPromise;
    if (typeof result2 === "object") {
      if (result2.options) {
        const { databaseHooks, ...restOpts } = result2.options;
        if (databaseHooks) dbHooks.push(databaseHooks);
        options = defu(options, restOpts);
      }
      if (result2.context) context = {
        ...context,
        ...result2.context
      };
    }
  }
  dbHooks.push(options.databaseHooks);
  context.internalAdapter = createInternalAdapter(context.adapter, {
    options,
    logger: context.logger,
    hooks: dbHooks.filter((u) => u !== void 0),
    generateId: context.generateId
  });
  context.options = options;
  return { context };
}
function getInternalPlugins(options) {
  const plugins = [];
  if (options.advanced?.crossSubDomainCookies?.enabled) ;
  return plugins;
}
async function getTrustedOrigins(options, request) {
  const baseURL2 = getBaseURL(options.baseURL, options.basePath, request);
  const trustedOrigins = baseURL2 ? [new URL(baseURL2).origin] : [];
  if (options.trustedOrigins) {
    if (Array.isArray(options.trustedOrigins)) trustedOrigins.push(...options.trustedOrigins);
    if (typeof options.trustedOrigins === "function") {
      const validOrigins = await options.trustedOrigins(request);
      trustedOrigins.push(...validOrigins);
    }
  }
  const envTrustedOrigins = env.BETTER_AUTH_TRUSTED_ORIGINS;
  if (envTrustedOrigins) trustedOrigins.push(...envTrustedOrigins.split(","));
  return trustedOrigins.filter((v) => Boolean(v));
}
function getTelemetryAuthConfig(options, context) {
  return {
    database: context?.database,
    adapter: context?.adapter,
    emailVerification: {
      sendVerificationEmail: !!options.emailVerification?.sendVerificationEmail,
      sendOnSignUp: !!options.emailVerification?.sendOnSignUp,
      sendOnSignIn: !!options.emailVerification?.sendOnSignIn,
      autoSignInAfterVerification: !!options.emailVerification?.autoSignInAfterVerification,
      expiresIn: options.emailVerification?.expiresIn,
      onEmailVerification: !!options.emailVerification?.onEmailVerification,
      afterEmailVerification: !!options.emailVerification?.afterEmailVerification
    },
    emailAndPassword: {
      enabled: !!options.emailAndPassword?.enabled,
      disableSignUp: !!options.emailAndPassword?.disableSignUp,
      requireEmailVerification: !!options.emailAndPassword?.requireEmailVerification,
      maxPasswordLength: options.emailAndPassword?.maxPasswordLength,
      minPasswordLength: options.emailAndPassword?.minPasswordLength,
      sendResetPassword: !!options.emailAndPassword?.sendResetPassword,
      resetPasswordTokenExpiresIn: options.emailAndPassword?.resetPasswordTokenExpiresIn,
      onPasswordReset: !!options.emailAndPassword?.onPasswordReset,
      password: {
        hash: !!options.emailAndPassword?.password?.hash,
        verify: !!options.emailAndPassword?.password?.verify
      },
      autoSignIn: !!options.emailAndPassword?.autoSignIn,
      revokeSessionsOnPasswordReset: !!options.emailAndPassword?.revokeSessionsOnPasswordReset
    },
    socialProviders: Object.keys(options.socialProviders || {}).map((p) => {
      const provider = options.socialProviders?.[p];
      if (!provider) return {};
      return {
        id: p,
        mapProfileToUser: !!provider.mapProfileToUser,
        disableDefaultScope: !!provider.disableDefaultScope,
        disableIdTokenSignIn: !!provider.disableIdTokenSignIn,
        disableImplicitSignUp: provider.disableImplicitSignUp,
        disableSignUp: provider.disableSignUp,
        getUserInfo: !!provider.getUserInfo,
        overrideUserInfoOnSignIn: !!provider.overrideUserInfoOnSignIn,
        prompt: provider.prompt,
        verifyIdToken: !!provider.verifyIdToken,
        scope: provider.scope,
        refreshAccessToken: !!provider.refreshAccessToken
      };
    }),
    plugins: options.plugins?.map((p) => p.id.toString()),
    user: {
      modelName: options.user?.modelName,
      fields: options.user?.fields,
      additionalFields: options.user?.additionalFields,
      changeEmail: {
        enabled: options.user?.changeEmail?.enabled,
        sendChangeEmailVerification: !!options.user?.changeEmail?.sendChangeEmailVerification
      }
    },
    verification: {
      modelName: options.verification?.modelName,
      disableCleanup: options.verification?.disableCleanup,
      fields: options.verification?.fields
    },
    session: {
      modelName: options.session?.modelName,
      additionalFields: options.session?.additionalFields,
      cookieCache: {
        enabled: options.session?.cookieCache?.enabled,
        maxAge: options.session?.cookieCache?.maxAge,
        strategy: options.session?.cookieCache?.strategy
      },
      disableSessionRefresh: options.session?.disableSessionRefresh,
      expiresIn: options.session?.expiresIn,
      fields: options.session?.fields,
      freshAge: options.session?.freshAge,
      preserveSessionInDatabase: options.session?.preserveSessionInDatabase,
      storeSessionInDatabase: options.session?.storeSessionInDatabase,
      updateAge: options.session?.updateAge
    },
    account: {
      modelName: options.account?.modelName,
      fields: options.account?.fields,
      encryptOAuthTokens: options.account?.encryptOAuthTokens,
      updateAccountOnSignIn: options.account?.updateAccountOnSignIn,
      accountLinking: {
        enabled: options.account?.accountLinking?.enabled,
        trustedProviders: options.account?.accountLinking?.trustedProviders,
        updateUserInfoOnLink: options.account?.accountLinking?.updateUserInfoOnLink,
        allowUnlinkingAll: options.account?.accountLinking?.allowUnlinkingAll
      }
    },
    hooks: {
      after: !!options.hooks?.after,
      before: !!options.hooks?.before
    },
    secondaryStorage: !!options.secondaryStorage,
    advanced: {
      cookiePrefix: !!options.advanced?.cookiePrefix,
      cookies: !!options.advanced?.cookies,
      crossSubDomainCookies: {
        domain: !!options.advanced?.crossSubDomainCookies?.domain,
        enabled: options.advanced?.crossSubDomainCookies?.enabled,
        additionalCookies: options.advanced?.crossSubDomainCookies?.additionalCookies
      },
      database: {
        useNumberId: !!options.advanced?.database?.useNumberId || options.advanced?.database?.generateId === "serial",
        generateId: options.advanced?.database?.generateId,
        defaultFindManyLimit: options.advanced?.database?.defaultFindManyLimit
      },
      useSecureCookies: options.advanced?.useSecureCookies,
      ipAddress: {
        disableIpTracking: options.advanced?.ipAddress?.disableIpTracking,
        ipAddressHeaders: options.advanced?.ipAddress?.ipAddressHeaders
      },
      disableCSRFCheck: options.advanced?.disableCSRFCheck,
      cookieAttributes: {
        expires: options.advanced?.defaultCookieAttributes?.expires,
        secure: options.advanced?.defaultCookieAttributes?.secure,
        sameSite: options.advanced?.defaultCookieAttributes?.sameSite,
        domain: !!options.advanced?.defaultCookieAttributes?.domain,
        path: options.advanced?.defaultCookieAttributes?.path,
        httpOnly: options.advanced?.defaultCookieAttributes?.httpOnly
      }
    },
    trustedOrigins: options.trustedOrigins?.length,
    rateLimit: {
      storage: options.rateLimit?.storage,
      modelName: options.rateLimit?.modelName,
      window: options.rateLimit?.window,
      customStorage: !!options.rateLimit?.customStorage,
      enabled: options.rateLimit?.enabled,
      max: options.rateLimit?.max
    },
    onAPIError: {
      errorURL: options.onAPIError?.errorURL,
      onError: !!options.onAPIError?.onError,
      throw: options.onAPIError?.throw
    },
    logger: {
      disabled: options.logger?.disabled,
      level: options.logger?.level,
      log: !!options.logger?.log
    },
    databaseHooks: {
      user: {
        create: {
          after: !!options.databaseHooks?.user?.create?.after,
          before: !!options.databaseHooks?.user?.create?.before
        },
        update: {
          after: !!options.databaseHooks?.user?.update?.after,
          before: !!options.databaseHooks?.user?.update?.before
        }
      },
      session: {
        create: {
          after: !!options.databaseHooks?.session?.create?.after,
          before: !!options.databaseHooks?.session?.create?.before
        },
        update: {
          after: !!options.databaseHooks?.session?.update?.after,
          before: !!options.databaseHooks?.session?.update?.before
        }
      },
      account: {
        create: {
          after: !!options.databaseHooks?.account?.create?.after,
          before: !!options.databaseHooks?.account?.create?.before
        },
        update: {
          after: !!options.databaseHooks?.account?.update?.after,
          before: !!options.databaseHooks?.account?.update?.before
        }
      },
      verification: {
        create: {
          after: !!options.databaseHooks?.verification?.create?.after,
          before: !!options.databaseHooks?.verification?.create?.before
        },
        update: {
          after: !!options.databaseHooks?.verification?.update?.after,
          before: !!options.databaseHooks?.verification?.update?.before
        }
      }
    }
  };
}
let packageJSONCache;
async function readRootPackageJson() {
  if (packageJSONCache) return packageJSONCache;
  try {
    const cwd = typeof process !== "undefined" && typeof process.cwd === "function" ? process.cwd() : "";
    if (!cwd) return void 0;
    const importRuntime$1 = (m) => Function("mm", "return import(mm)")(m);
    const [{ default: fs }, { default: path }] = await Promise.all([importRuntime$1("fs/promises"), importRuntime$1("path")]);
    const raw = await fs.readFile(path.join(cwd, "package.json"), "utf-8");
    packageJSONCache = JSON.parse(raw);
    return packageJSONCache;
  } catch {
  }
}
async function getPackageVersion(pkg) {
  if (packageJSONCache) return packageJSONCache.dependencies?.[pkg] || packageJSONCache.devDependencies?.[pkg] || packageJSONCache.peerDependencies?.[pkg];
  try {
    const cwd = typeof process !== "undefined" && typeof process.cwd === "function" ? process.cwd() : "";
    if (!cwd) throw new Error("no-cwd");
    const importRuntime$1 = (m) => Function("mm", "return import(mm)")(m);
    const [{ default: fs }, { default: path }] = await Promise.all([importRuntime$1("fs/promises"), importRuntime$1("path")]);
    const pkgJsonPath = path.join(cwd, "node_modules", pkg, "package.json");
    const raw = await fs.readFile(pkgJsonPath, "utf-8");
    return JSON.parse(raw).version || await getVersionFromLocalPackageJson(pkg) || void 0;
  } catch {
  }
  return await getVersionFromLocalPackageJson(pkg);
}
async function getVersionFromLocalPackageJson(pkg) {
  const json2 = await readRootPackageJson();
  if (!json2) return void 0;
  return {
    ...json2.dependencies,
    ...json2.devDependencies,
    ...json2.peerDependencies
  }[pkg];
}
async function getNameFromLocalPackageJson() {
  return (await readRootPackageJson())?.name;
}
const DATABASES = {
  pg: "postgresql",
  mysql: "mysql",
  mariadb: "mariadb",
  sqlite3: "sqlite",
  "better-sqlite3": "sqlite",
  "@prisma/client": "prisma",
  mongoose: "mongodb",
  mongodb: "mongodb",
  "drizzle-orm": "drizzle"
};
async function detectDatabase() {
  for (const [pkg, name2] of Object.entries(DATABASES)) {
    const version2 = await getPackageVersion(pkg);
    if (version2) return {
      name: name2,
      version: version2
    };
  }
}
const FRAMEWORKS = {
  next: "next",
  nuxt: "nuxt",
  "@remix-run/server-runtime": "remix",
  astro: "astro",
  "@sveltejs/kit": "sveltekit",
  "solid-start": "solid-start",
  "tanstack-start": "tanstack-start",
  hono: "hono",
  express: "express",
  elysia: "elysia",
  expo: "expo"
};
async function detectFramework() {
  for (const [pkg, name2] of Object.entries(FRAMEWORKS)) {
    const version2 = await getPackageVersion(pkg);
    if (version2) return {
      name: name2,
      version: version2
    };
  }
}
function detectPackageManager() {
  const userAgent = env.npm_config_user_agent;
  if (!userAgent) return;
  const pmSpec = userAgent.split(" ")[0];
  const separatorPos = pmSpec.lastIndexOf("/");
  const name2 = pmSpec.substring(0, separatorPos);
  return {
    name: name2 === "npminstall" ? "cnpm" : name2,
    version: pmSpec.substring(separatorPos + 1)
  };
}
const importRuntime = (m) => {
  return Function("mm", "return import(mm)")(m);
};
function getVendor() {
  const hasAny = (...keys) => keys.some((k) => Boolean(env[k]));
  if (hasAny("CF_PAGES", "CF_PAGES_URL", "CF_ACCOUNT_ID") || typeof navigator !== "undefined" && navigator.userAgent === "Cloudflare-Workers") return "cloudflare";
  if (hasAny("VERCEL", "VERCEL_URL", "VERCEL_ENV")) return "vercel";
  if (hasAny("NETLIFY", "NETLIFY_URL")) return "netlify";
  if (hasAny("RENDER", "RENDER_URL", "RENDER_INTERNAL_HOSTNAME", "RENDER_SERVICE_ID")) return "render";
  if (hasAny("AWS_LAMBDA_FUNCTION_NAME", "AWS_EXECUTION_ENV", "LAMBDA_TASK_ROOT")) return "aws";
  if (hasAny("GOOGLE_CLOUD_FUNCTION_NAME", "GOOGLE_CLOUD_PROJECT", "GCP_PROJECT", "K_SERVICE")) return "gcp";
  if (hasAny("AZURE_FUNCTION_NAME", "FUNCTIONS_WORKER_RUNTIME", "WEBSITE_INSTANCE_ID", "WEBSITE_SITE_NAME")) return "azure";
  if (hasAny("DENO_DEPLOYMENT_ID", "DENO_REGION")) return "deno-deploy";
  if (hasAny("FLY_APP_NAME", "FLY_REGION", "FLY_ALLOC_ID")) return "fly-io";
  if (hasAny("RAILWAY_STATIC_URL", "RAILWAY_ENVIRONMENT_NAME")) return "railway";
  if (hasAny("DYNO", "HEROKU_APP_NAME")) return "heroku";
  if (hasAny("DO_DEPLOYMENT_ID", "DO_APP_NAME", "DIGITALOCEAN")) return "digitalocean";
  if (hasAny("KOYEB", "KOYEB_DEPLOYMENT_ID", "KOYEB_APP_NAME")) return "koyeb";
  return null;
}
async function detectSystemInfo() {
  try {
    if (getVendor() === "cloudflare") return "cloudflare";
    const os = await importRuntime("os");
    const cpus = os.cpus();
    return {
      deploymentVendor: getVendor(),
      systemPlatform: os.platform(),
      systemRelease: os.release(),
      systemArchitecture: os.arch(),
      cpuCount: cpus.length,
      cpuModel: cpus.length ? cpus[0].model : null,
      cpuSpeed: cpus.length ? cpus[0].speed : null,
      memory: os.totalmem(),
      isWSL: await isWsl(),
      isDocker: await isDocker(),
      isTTY: typeof process !== "undefined" && process.stdout ? process.stdout.isTTY : null
    };
  } catch {
    return {
      systemPlatform: null,
      systemRelease: null,
      systemArchitecture: null,
      cpuCount: null,
      cpuModel: null,
      cpuSpeed: null,
      memory: null,
      isWSL: null,
      isDocker: null,
      isTTY: null
    };
  }
}
let isDockerCached;
async function hasDockerEnv() {
  if (getVendor() === "cloudflare") return false;
  try {
    (await importRuntime("fs")).statSync("/.dockerenv");
    return true;
  } catch {
    return false;
  }
}
async function hasDockerCGroup() {
  if (getVendor() === "cloudflare") return false;
  try {
    return (await importRuntime("fs")).readFileSync("/proc/self/cgroup", "utf8").includes("docker");
  } catch {
    return false;
  }
}
async function isDocker() {
  if (getVendor() === "cloudflare") return false;
  if (isDockerCached === void 0) isDockerCached = await hasDockerEnv() || await hasDockerCGroup();
  return isDockerCached;
}
async function isWsl() {
  try {
    if (getVendor() === "cloudflare") return false;
    if (typeof process === "undefined" || process?.platform !== "linux") return false;
    const fs = await importRuntime("fs");
    if ((await importRuntime("os")).release().toLowerCase().includes("microsoft")) {
      if (await isInsideContainer()) return false;
      return true;
    }
    return fs.readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft") ? !await isInsideContainer() : false;
  } catch {
    return false;
  }
}
let isInsideContainerCached;
const hasContainerEnv = async () => {
  if (getVendor() === "cloudflare") return false;
  try {
    (await importRuntime("fs")).statSync("/run/.containerenv");
    return true;
  } catch {
    return false;
  }
};
async function isInsideContainer() {
  if (isInsideContainerCached === void 0) isInsideContainerCached = await hasContainerEnv() || await isDocker();
  return isInsideContainerCached;
}
function isCI() {
  return env.CI !== "false" && ("BUILD_ID" in env || "BUILD_NUMBER" in env || "CI" in env || "CI_APP_ID" in env || "CI_BUILD_ID" in env || "CI_BUILD_NUMBER" in env || "CI_NAME" in env || "CONTINUOUS_INTEGRATION" in env || "RUN_ID" in env);
}
function detectRuntime() {
  if (typeof Deno !== "undefined") return {
    name: "deno",
    version: Deno?.version?.deno ?? null
  };
  if (typeof Bun !== "undefined") return {
    name: "bun",
    version: Bun?.version ?? null
  };
  if (typeof process !== "undefined" && process?.versions?.node) return {
    name: "node",
    version: process.versions.node ?? null
  };
  return {
    name: "edge",
    version: null
  };
}
function detectEnvironment() {
  return getEnvVar("NODE_ENV") === "production" ? "production" : isCI() ? "ci" : isTest() ? "test" : "development";
}
async function hashToBase64(data) {
  const buffer = await createHash("SHA-256").digest(data);
  return base64$1.encode(buffer);
}
const generateId = (size) => {
  return createRandomStringGenerator("a-z", "A-Z", "0-9")(size);
};
let projectIdCached = null;
async function getProjectId(baseUrl) {
  if (projectIdCached) return projectIdCached;
  const projectName = await getNameFromLocalPackageJson();
  if (projectName) {
    projectIdCached = await hashToBase64(baseUrl ? baseUrl + projectName : projectName);
    return projectIdCached;
  }
  if (baseUrl) {
    projectIdCached = await hashToBase64(baseUrl);
    return projectIdCached;
  }
  projectIdCached = generateId(32);
  return projectIdCached;
}
const noop = async function noop$12() {
};
async function createTelemetry(options, context) {
  const debugEnabled = options.telemetry?.debug || getBooleanEnvVar("BETTER_AUTH_TELEMETRY_DEBUG", false);
  const telemetryEndpoint = ENV.BETTER_AUTH_TELEMETRY_ENDPOINT;
  if (!telemetryEndpoint && !context?.customTrack) return { publish: noop };
  const track = async (event) => {
    if (context?.customTrack) await context.customTrack(event).catch(logger.error);
    else if (telemetryEndpoint) if (debugEnabled) logger.info("telemetry event", JSON.stringify(event, null, 2));
    else await betterFetch(telemetryEndpoint, {
      method: "POST",
      body: event
    }).catch(logger.error);
  };
  const isEnabled = async () => {
    const telemetryEnabled = options.telemetry?.enabled !== void 0 ? options.telemetry.enabled : false;
    return (getBooleanEnvVar("BETTER_AUTH_TELEMETRY", false) || telemetryEnabled) && (context?.skipTestCheck || !isTest());
  };
  const enabled = await isEnabled();
  let anonymousId;
  if (enabled) {
    anonymousId = await getProjectId(options.baseURL);
    track({
      type: "init",
      payload: {
        config: getTelemetryAuthConfig(options, context),
        runtime: detectRuntime(),
        database: await detectDatabase(),
        framework: await detectFramework(),
        environment: detectEnvironment(),
        systemInfo: await detectSystemInfo(),
        packageManager: detectPackageManager()
      },
      anonymousId
    });
  }
  return { publish: async (event) => {
    if (!enabled) return;
    if (!anonymousId) anonymousId = await getProjectId(options.baseURL);
    await track({
      type: event.type,
      payload: event.payload,
      anonymousId
    });
  } };
}
function estimateEntropy(str) {
  const unique2 = new Set(str).size;
  if (unique2 === 0) return 0;
  return Math.log2(Math.pow(unique2, str.length));
}
function validateSecret(secret, logger$1) {
  const isDefaultSecret = secret === DEFAULT_SECRET;
  if (isTest()) return;
  if (isDefaultSecret && isProduction) throw new BetterAuthError("You are using the default secret. Please set `BETTER_AUTH_SECRET` in your environment variables or pass `secret` in your auth config.");
  if (secret.length < 32) logger$1.warn(`[better-auth] Warning: your BETTER_AUTH_SECRET should be at least 32 characters long for adequate security. Generate one with \`npx @better-auth/cli secret\` or \`openssl rand -base64 32\`.`);
  if (estimateEntropy(secret) < 120) logger$1.warn("[better-auth] Warning: your BETTER_AUTH_SECRET appears low-entropy. Use a randomly generated secret for production.");
}
async function createAuthContext(adapter, options, getDatabaseType) {
  if (!options.database) options = defu(options, {
    session: { cookieCache: {
      enabled: true,
      strategy: "jwe",
      refreshCache: true
    } },
    account: {
      storeStateStrategy: "cookie",
      storeAccountCookie: true
    }
  });
  const plugins = options.plugins || [];
  const internalPlugins = getInternalPlugins(options);
  const logger$1 = createLogger(options.logger);
  const baseURL2 = getBaseURL(options.baseURL, options.basePath);
  if (!baseURL2) logger$1.warn(`[better-auth] Base URL could not be determined. Please set a valid base URL using the baseURL config option or the BETTER_AUTH_BASE_URL environment variable. Without this, callbacks and redirects may not work correctly.`);
  if (adapter.id === "memory" && options.advanced?.database?.generateId === false) logger$1.error(`[better-auth] Misconfiguration detected.
You are using the memory DB with generateId: false.
This will cause no id to be generated for any model.
Most of the features of Better Auth will not work correctly.`);
  const secret = options.secret || env.BETTER_AUTH_SECRET || env.AUTH_SECRET || DEFAULT_SECRET;
  validateSecret(secret, logger$1);
  options = {
    ...options,
    secret,
    baseURL: baseURL2 ? new URL(baseURL2).origin : "",
    basePath: options.basePath || "/api/auth",
    plugins: plugins.concat(internalPlugins)
  };
  checkEndpointConflicts(options, logger$1);
  const cookies2 = getCookies(options);
  const tables = getAuthTables(options);
  const providers = Object.entries(options.socialProviders || {}).map(([key, config2]) => {
    if (config2 == null) return null;
    if (config2.enabled === false) return null;
    if (!config2.clientId) logger$1.warn(`Social provider ${key} is missing clientId or clientSecret`);
    const provider = socialProviders[key](config2);
    provider.disableImplicitSignUp = config2.disableImplicitSignUp;
    return provider;
  }).filter((x) => x !== null);
  const generateIdFunc = ({ model, size }) => {
    if (typeof options.advanced?.generateId === "function") return options.advanced.generateId({
      model,
      size
    });
    const dbGenerateId = options?.advanced?.database?.generateId;
    if (typeof dbGenerateId === "function") return dbGenerateId({
      model,
      size
    });
    if (dbGenerateId === "uuid") return crypto.randomUUID();
    if (dbGenerateId === "serial" || dbGenerateId === false) return false;
    return generateId$1(size);
  };
  const { publish } = await createTelemetry(options, {
    adapter: adapter.id,
    database: typeof options.database === "function" ? "adapter" : getDatabaseType(options.database)
  });
  const trustedOrigins = await getTrustedOrigins(options);
  const initOrPromise = runPluginInit({
    appName: options.appName || "Better Auth",
    baseURL: baseURL2 || "",
    version: getBetterAuthVersion(),
    socialProviders: providers,
    options,
    oauthConfig: {
      storeStateStrategy: options.account?.storeStateStrategy || (options.database ? "database" : "cookie"),
      skipStateCookieCheck: !!options.account?.skipStateCookieCheck
    },
    tables,
    trustedOrigins,
    isTrustedOrigin(url, settings) {
      return this.trustedOrigins.some((origin) => matchesOriginPattern(url, origin, settings));
    },
    sessionConfig: {
      updateAge: options.session?.updateAge !== void 0 ? options.session.updateAge : 1440 * 60,
      expiresIn: options.session?.expiresIn || 3600 * 24 * 7,
      freshAge: options.session?.freshAge === void 0 ? 3600 * 24 : options.session.freshAge,
      cookieRefreshCache: (() => {
        const refreshCache = options.session?.cookieCache?.refreshCache;
        const maxAge = options.session?.cookieCache?.maxAge || 300;
        if ((!!options.database || !!options.secondaryStorage) && refreshCache) {
          logger$1.warn("[better-auth] `session.cookieCache.refreshCache` is enabled while `database` or `secondaryStorage` is configured. `refreshCache` is meant for stateless (DB-less) setups. Disabling `refreshCache`  remove it from your config to silence this warning.");
          return false;
        }
        if (refreshCache === false || refreshCache === void 0) return false;
        if (refreshCache === true) return {
          enabled: true,
          updateAge: Math.floor(maxAge * 0.2)
        };
        return {
          enabled: true,
          updateAge: refreshCache.updateAge !== void 0 ? refreshCache.updateAge : Math.floor(maxAge * 0.2)
        };
      })()
    },
    secret,
    rateLimit: {
      ...options.rateLimit,
      enabled: options.rateLimit?.enabled ?? isProduction,
      window: options.rateLimit?.window || 10,
      max: options.rateLimit?.max || 100,
      storage: options.rateLimit?.storage || (options.secondaryStorage ? "secondary-storage" : "memory")
    },
    authCookies: cookies2,
    logger: logger$1,
    generateId: generateIdFunc,
    session: null,
    secondaryStorage: options.secondaryStorage,
    password: {
      hash: options.emailAndPassword?.password?.hash || hashPassword,
      verify: options.emailAndPassword?.password?.verify || verifyPassword$1,
      config: {
        minPasswordLength: options.emailAndPassword?.minPasswordLength || 8,
        maxPasswordLength: options.emailAndPassword?.maxPasswordLength || 128
      },
      checkPassword
    },
    setNewSession(session) {
      this.newSession = session;
    },
    newSession: null,
    adapter,
    internalAdapter: createInternalAdapter(adapter, {
      options,
      logger: logger$1,
      hooks: options.databaseHooks ? [options.databaseHooks] : [],
      generateId: generateIdFunc
    }),
    createAuthCookie: createCookieGetter(options),
    async runMigrations() {
      throw new BetterAuthError("runMigrations will be set by the specific init implementation");
    },
    publishTelemetry: publish,
    skipCSRFCheck: !!options.advanced?.disableCSRFCheck,
    skipOriginCheck: options.advanced?.disableOriginCheck !== void 0 ? options.advanced.disableOriginCheck : isTest() ? true : false,
    runInBackground: options.advanced?.backgroundTasks?.handler ?? ((p) => {
      p.catch(() => {
      });
    }),
    async runInBackgroundOrAwait(promise) {
      try {
        if (options.advanced?.backgroundTasks?.handler) {
          if (promise instanceof Promise) options.advanced.backgroundTasks.handler(promise.catch((e2) => {
            logger$1.error("Failed to run background task:", e2);
          }));
        } else await promise;
      } catch (e2) {
        logger$1.error("Failed to run background task:", e2);
      }
    },
    getPlugin: (id) => options.plugins.find((p) => p.id === id) ?? null
  });
  let context;
  if (isPromise(initOrPromise)) ({ context } = await initOrPromise);
  else ({ context } = initOrPromise);
  if (typeof context.options.emailVerification?.onEmailVerification === "function") context.options.emailVerification.onEmailVerification = deprecate(context.options.emailVerification.onEmailVerification, "Use `afterEmailVerification` instead. This will be removed in 1.5", context.logger);
  return context;
}
const init = async (options) => {
  const adapter = await getAdapter(options);
  const getDatabaseType = (database) => getKyselyDatabaseType(database) || "unknown";
  const ctx = await createAuthContext(adapter, options, getDatabaseType);
  ctx.runMigrations = async function() {
    if (!options.database || "updateMany" in options.database) throw new BetterAuthError("Database is not provided or it's an adapter. Migrations are only supported with a database instance.");
    const { runMigrations } = await getMigrations(options);
    await runMigrations();
  };
  return ctx;
};
const createBetterAuth = (options, initFn) => {
  const authContext = initFn(options);
  const { api } = getEndpoints(authContext, options);
  return {
    handler: async (request) => {
      const ctx = await authContext;
      const basePath = ctx.options.basePath || "/api/auth";
      if (!ctx.options.baseURL) {
        const baseURL2 = getBaseURL(void 0, basePath, request, void 0, ctx.options.advanced?.trustedProxyHeaders);
        if (baseURL2) {
          ctx.baseURL = baseURL2;
          ctx.options.baseURL = getOrigin(ctx.baseURL) || void 0;
        } else throw new BetterAuthError("Could not get base URL from request. Please provide a valid base URL.");
      }
      ctx.trustedOrigins = await getTrustedOrigins(ctx.options, request);
      const { handler: handler2 } = router$1(ctx, options);
      return runWithAdapter(ctx.adapter, () => handler2(request));
    },
    api,
    options,
    $context: authContext,
    $ERROR_CODES: {
      ...options.plugins?.reduce((acc, plugin) => {
        if (plugin.$ERROR_CODES) return {
          ...acc,
          ...plugin.$ERROR_CODES
        };
        return acc;
      }, {}),
      ...BASE_ERROR_CODES
    }
  };
};
const betterAuth = (options) => {
  return createBetterAuth(options, init);
};
const drizzleAdapter = (db, config2) => {
  let lazyOptions = null;
  const createCustomAdapter = (db$1) => ({ getFieldName, options }) => {
    function getSchema2(model) {
      const schema2 = config2.schema || db$1._.fullSchema;
      if (!schema2) throw new BetterAuthError("Drizzle adapter failed to initialize. Schema not found. Please provide a schema object in the adapter options object.");
      const schemaModel = schema2[model];
      if (!schemaModel) throw new BetterAuthError(`[# Drizzle Adapter]: The model "${model}" was not found in the schema object. Please pass the schema directly to the adapter options.`);
      return schemaModel;
    }
    const withReturning = async (model, builder, data, where) => {
      if (config2.provider !== "mysql") return (await builder.returning())[0];
      await builder.execute();
      const schemaModel = getSchema2(model);
      const builderVal = builder.config?.values;
      if (where?.length) {
        const clause = convertWhereClause(where.map((w) => {
          if (data[w.field] !== void 0) return {
            ...w,
            value: data[w.field]
          };
          return w;
        }), model);
        return (await db$1.select().from(schemaModel).where(...clause))[0];
      } else if (builderVal && builderVal[0]?.id?.value) {
        let tId = builderVal[0]?.id?.value;
        if (!tId) tId = (await db$1.select({ id: sql$1`LAST_INSERT_ID()` }).from(schemaModel).orderBy(desc(schemaModel.id)).limit(1))[0].id;
        return (await db$1.select().from(schemaModel).where(eq(schemaModel.id, tId)).limit(1).execute())[0];
      } else if (data.id) return (await db$1.select().from(schemaModel).where(eq(schemaModel.id, data.id)).limit(1).execute())[0];
      else {
        if (!("id" in schemaModel)) throw new BetterAuthError(`The model "${model}" does not have an "id" field. Please use the "id" field as your primary key.`);
        return (await db$1.select().from(schemaModel).orderBy(desc(schemaModel.id)).limit(1).execute())[0];
      }
    };
    function convertWhereClause(where, model) {
      const schemaModel = getSchema2(model);
      if (!where) return [];
      if (where.length === 1) {
        const w = where[0];
        if (!w) return [];
        const field = getFieldName({
          model,
          field: w.field
        });
        if (!schemaModel[field]) throw new BetterAuthError(`The field "${w.field}" does not exist in the schema for the model "${model}". Please update your schema.`);
        if (w.operator === "in") {
          if (!Array.isArray(w.value)) throw new BetterAuthError(`The value for the field "${w.field}" must be an array when using the "in" operator.`);
          return [inArray(schemaModel[field], w.value)];
        }
        if (w.operator === "not_in") {
          if (!Array.isArray(w.value)) throw new BetterAuthError(`The value for the field "${w.field}" must be an array when using the "not_in" operator.`);
          return [notInArray(schemaModel[field], w.value)];
        }
        if (w.operator === "contains") return [like(schemaModel[field], `%${w.value}%`)];
        if (w.operator === "starts_with") return [like(schemaModel[field], `${w.value}%`)];
        if (w.operator === "ends_with") return [like(schemaModel[field], `%${w.value}`)];
        if (w.operator === "lt") return [lt(schemaModel[field], w.value)];
        if (w.operator === "lte") return [lte(schemaModel[field], w.value)];
        if (w.operator === "ne") return [ne(schemaModel[field], w.value)];
        if (w.operator === "gt") return [gt(schemaModel[field], w.value)];
        if (w.operator === "gte") return [gte(schemaModel[field], w.value)];
        return [eq(schemaModel[field], w.value)];
      }
      const andGroup = where.filter((w) => w.connector === "AND" || !w.connector);
      const orGroup = where.filter((w) => w.connector === "OR");
      const andClause = and(...andGroup.map((w) => {
        const field = getFieldName({
          model,
          field: w.field
        });
        if (w.operator === "in") {
          if (!Array.isArray(w.value)) throw new BetterAuthError(`The value for the field "${w.field}" must be an array when using the "in" operator.`);
          return inArray(schemaModel[field], w.value);
        }
        if (w.operator === "not_in") {
          if (!Array.isArray(w.value)) throw new BetterAuthError(`The value for the field "${w.field}" must be an array when using the "not_in" operator.`);
          return notInArray(schemaModel[field], w.value);
        }
        if (w.operator === "contains") return like(schemaModel[field], `%${w.value}%`);
        if (w.operator === "starts_with") return like(schemaModel[field], `${w.value}%`);
        if (w.operator === "ends_with") return like(schemaModel[field], `%${w.value}`);
        if (w.operator === "lt") return lt(schemaModel[field], w.value);
        if (w.operator === "lte") return lte(schemaModel[field], w.value);
        if (w.operator === "gt") return gt(schemaModel[field], w.value);
        if (w.operator === "gte") return gte(schemaModel[field], w.value);
        if (w.operator === "ne") return ne(schemaModel[field], w.value);
        return eq(schemaModel[field], w.value);
      }));
      const orClause = or(...orGroup.map((w) => {
        const field = getFieldName({
          model,
          field: w.field
        });
        if (w.operator === "in") {
          if (!Array.isArray(w.value)) throw new BetterAuthError(`The value for the field "${w.field}" must be an array when using the "in" operator.`);
          return inArray(schemaModel[field], w.value);
        }
        if (w.operator === "not_in") {
          if (!Array.isArray(w.value)) throw new BetterAuthError(`The value for the field "${w.field}" must be an array when using the "not_in" operator.`);
          return notInArray(schemaModel[field], w.value);
        }
        if (w.operator === "contains") return like(schemaModel[field], `%${w.value}%`);
        if (w.operator === "starts_with") return like(schemaModel[field], `${w.value}%`);
        if (w.operator === "ends_with") return like(schemaModel[field], `%${w.value}`);
        if (w.operator === "lt") return lt(schemaModel[field], w.value);
        if (w.operator === "lte") return lte(schemaModel[field], w.value);
        if (w.operator === "gt") return gt(schemaModel[field], w.value);
        if (w.operator === "gte") return gte(schemaModel[field], w.value);
        if (w.operator === "ne") return ne(schemaModel[field], w.value);
        return eq(schemaModel[field], w.value);
      }));
      const clause = [];
      if (andGroup.length) clause.push(andClause);
      if (orGroup.length) clause.push(orClause);
      return clause;
    }
    function checkMissingFields(schema2, model, values) {
      if (!schema2) throw new BetterAuthError("Drizzle adapter failed to initialize. Drizzle Schema not found. Please provide a schema object in the adapter options object.");
      for (const key in values) if (!schema2[key]) throw new BetterAuthError(`The field "${key}" does not exist in the "${model}" Drizzle schema. Please update your drizzle schema or re-generate using "npx @better-auth/cli@latest generate".`);
    }
    return {
      async create({ model, data: values }) {
        const schemaModel = getSchema2(model);
        checkMissingFields(schemaModel, model, values);
        return await withReturning(model, db$1.insert(schemaModel).values(values), values);
      },
      async findOne({ model, where, join: join2 }) {
        const schemaModel = getSchema2(model);
        const clause = convertWhereClause(where, model);
        if (options.experimental?.joins) if (!db$1.query || !db$1.query[model]) {
          logger.error(`[# Drizzle Adapter]: The model "${model}" was not found in the query object. Please update your Drizzle schema to include relations or re-generate using "npx @better-auth/cli@latest generate".`);
          logger.info("Falling back to regular query");
        } else {
          let includes2;
          const pluralJoinResults = [];
          if (join2) {
            includes2 = {};
            const joinEntries = Object.entries(join2);
            for (const [model$1, joinAttr] of joinEntries) {
              const limit = joinAttr.limit ?? options.advanced?.database?.defaultFindManyLimit ?? 100;
              const isUnique = joinAttr.relation === "one-to-one";
              const pluralSuffix = isUnique || config2.usePlural ? "" : "s";
              includes2[`${model$1}${pluralSuffix}`] = isUnique ? true : { limit };
              if (!isUnique) pluralJoinResults.push(`${model$1}${pluralSuffix}`);
            }
          }
          const res$1 = await db$1.query[model].findFirst({
            where: clause[0],
            with: includes2
          });
          if (res$1) for (const pluralJoinResult of pluralJoinResults) {
            const singularKey = !config2.usePlural ? pluralJoinResult.slice(0, -1) : pluralJoinResult;
            res$1[singularKey] = res$1[pluralJoinResult];
            if (pluralJoinResult !== singularKey) delete res$1[pluralJoinResult];
          }
          return res$1;
        }
        const res2 = await db$1.select().from(schemaModel).where(...clause);
        if (!res2.length) return null;
        return res2[0];
      },
      async findMany({ model, where, sortBy, limit, offset: offset2, join: join2 }) {
        const schemaModel = getSchema2(model);
        const clause = where ? convertWhereClause(where, model) : [];
        const sortFn = sortBy?.direction === "desc" ? desc : asc;
        if (options.experimental?.joins) if (!db$1.query[model]) {
          logger.error(`[# Drizzle Adapter]: The model "${model}" was not found in the query object. Please update your Drizzle schema to include relations or re-generate using "npx @better-auth/cli@latest generate".`);
          logger.info("Falling back to regular query");
        } else {
          let includes2;
          const pluralJoinResults = [];
          if (join2) {
            includes2 = {};
            const joinEntries = Object.entries(join2);
            for (const [model$1, joinAttr] of joinEntries) {
              const isUnique = joinAttr.relation === "one-to-one";
              const limit$1 = joinAttr.limit ?? options.advanced?.database?.defaultFindManyLimit ?? 100;
              const pluralSuffix = isUnique || config2.usePlural ? "" : "s";
              includes2[`${model$1}${pluralSuffix}`] = isUnique ? true : { limit: limit$1 };
              if (!isUnique) pluralJoinResults.push(`${model$1}${pluralSuffix}`);
            }
          }
          let orderBy = void 0;
          if (sortBy?.field) orderBy = [sortFn(schemaModel[getFieldName({
            model,
            field: sortBy?.field
          })])];
          const res2 = await db$1.query[model].findMany({
            where: clause[0],
            with: includes2,
            limit: limit ?? 100,
            offset: offset2 ?? 0,
            orderBy
          });
          if (res2) for (const item of res2) for (const pluralJoinResult of pluralJoinResults) {
            const singularKey = !config2.usePlural ? pluralJoinResult.slice(0, -1) : pluralJoinResult;
            if (singularKey === pluralJoinResult) continue;
            item[singularKey] = item[pluralJoinResult];
            delete item[pluralJoinResult];
          }
          return res2;
        }
        let builder = db$1.select().from(schemaModel);
        const effectiveLimit = limit;
        const effectiveOffset = offset2;
        if (typeof effectiveLimit !== "undefined") builder = builder.limit(effectiveLimit);
        if (typeof effectiveOffset !== "undefined") builder = builder.offset(effectiveOffset);
        if (sortBy?.field) builder = builder.orderBy(sortFn(schemaModel[getFieldName({
          model,
          field: sortBy?.field
        })]));
        return await builder.where(...clause);
      },
      async count({ model, where }) {
        const schemaModel = getSchema2(model);
        const clause = where ? convertWhereClause(where, model) : [];
        return (await db$1.select({ count: count() }).from(schemaModel).where(...clause))[0].count;
      },
      async update({ model, where, update: values }) {
        const schemaModel = getSchema2(model);
        const clause = convertWhereClause(where, model);
        return await withReturning(model, db$1.update(schemaModel).set(values).where(...clause), values, where);
      },
      async updateMany({ model, where, update: values }) {
        const schemaModel = getSchema2(model);
        const clause = convertWhereClause(where, model);
        return await db$1.update(schemaModel).set(values).where(...clause);
      },
      async delete({ model, where }) {
        const schemaModel = getSchema2(model);
        const clause = convertWhereClause(where, model);
        return await db$1.delete(schemaModel).where(...clause);
      },
      async deleteMany({ model, where }) {
        const schemaModel = getSchema2(model);
        const clause = convertWhereClause(where, model);
        const res2 = await db$1.delete(schemaModel).where(...clause);
        let count$1 = 0;
        if (res2 && "rowCount" in res2) count$1 = res2.rowCount;
        else if (Array.isArray(res2)) count$1 = res2.length;
        else if (res2 && ("affectedRows" in res2 || "rowsAffected" in res2 || "changes" in res2)) count$1 = res2.affectedRows ?? res2.rowsAffected ?? res2.changes;
        if (typeof count$1 !== "number") logger.error("[Drizzle Adapter] The result of the deleteMany operation is not a number. This is likely a bug in the adapter. Please report this issue to the Better Auth team.", {
          res: res2,
          model,
          where
        });
        return count$1;
      },
      options: config2
    };
  };
  let adapterOptions = null;
  adapterOptions = {
    config: {
      adapterId: "drizzle",
      adapterName: "Drizzle Adapter",
      usePlural: config2.usePlural ?? false,
      debugLogs: config2.debugLogs ?? false,
      supportsUUIDs: config2.provider === "pg" ? true : false,
      supportsJSON: config2.provider === "pg" ? true : false,
      supportsArrays: config2.provider === "pg" ? true : false,
      transaction: config2.transaction ?? false ? (cb) => db.transaction((tx) => {
        return cb(createAdapterFactory({
          config: adapterOptions.config,
          adapter: createCustomAdapter(tx)
        })(lazyOptions));
      }) : false
    },
    adapter: createCustomAdapter(db)
  };
  const adapter = createAdapterFactory(adapterOptions);
  return (options) => {
    lazyOptions = options;
    return adapter(options);
  };
};
var Exception = class extends Error {
  name;
  status;
  constructor(message2, options) {
    super(message2, options);
    const ErrorConstructor = this.constructor;
    this.name = ErrorConstructor.name;
    this.message = message2 || ErrorConstructor.message || "";
    this.status = options?.status || ErrorConstructor.status || 500;
    const code = options?.code || ErrorConstructor.code;
    if (code !== void 0) this.code = code;
    const help = ErrorConstructor.help;
    if (help !== void 0) this.help = help;
    Error.captureStackTrace(this, ErrorConstructor);
  }
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
  toString() {
    if (this.code) return `${this.name} [${this.code}]: ${this.message}`;
    return `${this.name}: ${this.message}`;
  }
};
var RuntimeException = class extends Exception {
  static code = "E_RUNTIME_EXCEPTION";
  static status = 500;
};
function createError(message2, code, status) {
  return class extends Exception {
    static message = message2;
    static code = code;
    static status = status;
    constructor(args, options) {
      super(format$1(message2, ...args || []), options);
      this.name = "Exception";
    }
  };
}
function slash(path) {
  const isExtendedLengthPath = path.startsWith("\\\\?\\");
  if (isExtendedLengthPath) {
    return path;
  }
  return path.replace(/\\/g, "/");
}
var secureJsonParse = { exports: {} };
var hasRequiredSecureJsonParse;
function requireSecureJsonParse() {
  if (hasRequiredSecureJsonParse) return secureJsonParse.exports;
  hasRequiredSecureJsonParse = 1;
  const hasBuffer = typeof Buffer !== "undefined";
  const suspectProtoRx = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/;
  const suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
  function _parse(text2, reviver, options) {
    if (options == null) {
      if (reviver !== null && typeof reviver === "object") {
        options = reviver;
        reviver = void 0;
      }
    }
    if (hasBuffer && Buffer.isBuffer(text2)) {
      text2 = text2.toString();
    }
    if (text2 && text2.charCodeAt(0) === 65279) {
      text2 = text2.slice(1);
    }
    const obj = JSON.parse(text2, reviver);
    if (obj === null || typeof obj !== "object") {
      return obj;
    }
    const protoAction = options && options.protoAction || "error";
    const constructorAction = options && options.constructorAction || "error";
    if (protoAction === "ignore" && constructorAction === "ignore") {
      return obj;
    }
    if (protoAction !== "ignore" && constructorAction !== "ignore") {
      if (suspectProtoRx.test(text2) === false && suspectConstructorRx.test(text2) === false) {
        return obj;
      }
    } else if (protoAction !== "ignore" && constructorAction === "ignore") {
      if (suspectProtoRx.test(text2) === false) {
        return obj;
      }
    } else {
      if (suspectConstructorRx.test(text2) === false) {
        return obj;
      }
    }
    return filter(obj, { protoAction, constructorAction, safe: options && options.safe });
  }
  function filter(obj, { protoAction = "error", constructorAction = "error", safe } = {}) {
    let next2 = [obj];
    while (next2.length) {
      const nodes = next2;
      next2 = [];
      for (const node of nodes) {
        if (protoAction !== "ignore" && Object.prototype.hasOwnProperty.call(node, "__proto__")) {
          if (safe === true) {
            return null;
          } else if (protoAction === "error") {
            throw new SyntaxError("Object contains forbidden prototype property");
          }
          delete node.__proto__;
        }
        if (constructorAction !== "ignore" && Object.prototype.hasOwnProperty.call(node, "constructor") && node.constructor !== null && typeof node.constructor === "object" && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
          if (safe === true) {
            return null;
          } else if (constructorAction === "error") {
            throw new SyntaxError("Object contains forbidden prototype property");
          }
          delete node.constructor;
        }
        for (const key in node) {
          const value = node[key];
          if (value && typeof value === "object") {
            next2.push(value);
          }
        }
      }
    }
    return obj;
  }
  function parse2(text2, reviver, options) {
    const { stackTraceLimit } = Error;
    Error.stackTraceLimit = 0;
    try {
      return _parse(text2, reviver, options);
    } finally {
      Error.stackTraceLimit = stackTraceLimit;
    }
  }
  function safeParse(text2, reviver) {
    const { stackTraceLimit } = Error;
    Error.stackTraceLimit = 0;
    try {
      return _parse(text2, reviver, { safe: true });
    } catch {
      return void 0;
    } finally {
      Error.stackTraceLimit = stackTraceLimit;
    }
  }
  secureJsonParse.exports = parse2;
  secureJsonParse.exports.default = parse2;
  secureJsonParse.exports.parse = parse2;
  secureJsonParse.exports.safeParse = safeParse;
  secureJsonParse.exports.scan = filter;
  return secureJsonParse.exports;
}
requireSecureJsonParse();
var safeStableStringify = { exports: {} };
var hasRequiredSafeStableStringify;
function requireSafeStableStringify() {
  if (hasRequiredSafeStableStringify) return safeStableStringify.exports;
  hasRequiredSafeStableStringify = 1;
  (function(module, exports$1) {
    const { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
    const stringify2 = configure2();
    stringify2.configure = configure2;
    stringify2.stringify = stringify2;
    stringify2.default = stringify2;
    exports$1.stringify = stringify2;
    exports$1.configure = configure2;
    module.exports = stringify2;
    const strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
    function strEscape(str) {
      if (str.length < 5e3 && !strEscapeSequencesRegExp.test(str)) {
        return `"${str}"`;
      }
      return JSON.stringify(str);
    }
    function sort(array, comparator) {
      if (array.length > 200 || comparator) {
        return array.sort(comparator);
      }
      for (let i = 1; i < array.length; i++) {
        const currentValue = array[i];
        let position = i;
        while (position !== 0 && array[position - 1] > currentValue) {
          array[position] = array[position - 1];
          position--;
        }
        array[position] = currentValue;
      }
      return array;
    }
    const typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(
      Object.getPrototypeOf(
        Object.getPrototypeOf(
          new Int8Array()
        )
      ),
      Symbol.toStringTag
    ).get;
    function isTypedArrayWithEntries(value) {
      return typedArrayPrototypeGetSymbolToStringTag.call(value) !== void 0 && value.length !== 0;
    }
    function stringifyTypedArray(array, separator, maximumBreadth) {
      if (array.length < maximumBreadth) {
        maximumBreadth = array.length;
      }
      const whitespace = separator === "," ? "" : " ";
      let res2 = `"0":${whitespace}${array[0]}`;
      for (let i = 1; i < maximumBreadth; i++) {
        res2 += `${separator}"${i}":${whitespace}${array[i]}`;
      }
      return res2;
    }
    function getCircularValueOption(options) {
      if (hasOwnProperty2.call(options, "circularValue")) {
        const circularValue = options.circularValue;
        if (typeof circularValue === "string") {
          return `"${circularValue}"`;
        }
        if (circularValue == null) {
          return circularValue;
        }
        if (circularValue === Error || circularValue === TypeError) {
          return {
            toString() {
              throw new TypeError("Converting circular structure to JSON");
            }
          };
        }
        throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
      }
      return '"[Circular]"';
    }
    function getDeterministicOption(options) {
      let value;
      if (hasOwnProperty2.call(options, "deterministic")) {
        value = options.deterministic;
        if (typeof value !== "boolean" && typeof value !== "function") {
          throw new TypeError('The "deterministic" argument must be of type boolean or comparator function');
        }
      }
      return value === void 0 ? true : value;
    }
    function getBooleanOption(options, key) {
      let value;
      if (hasOwnProperty2.call(options, key)) {
        value = options[key];
        if (typeof value !== "boolean") {
          throw new TypeError(`The "${key}" argument must be of type boolean`);
        }
      }
      return value === void 0 ? true : value;
    }
    function getPositiveIntegerOption(options, key) {
      let value;
      if (hasOwnProperty2.call(options, key)) {
        value = options[key];
        if (typeof value !== "number") {
          throw new TypeError(`The "${key}" argument must be of type number`);
        }
        if (!Number.isInteger(value)) {
          throw new TypeError(`The "${key}" argument must be an integer`);
        }
        if (value < 1) {
          throw new RangeError(`The "${key}" argument must be >= 1`);
        }
      }
      return value === void 0 ? Infinity : value;
    }
    function getItemCount(number) {
      if (number === 1) {
        return "1 item";
      }
      return `${number} items`;
    }
    function getUniqueReplacerSet(replacerArray) {
      const replacerSet = /* @__PURE__ */ new Set();
      for (const value of replacerArray) {
        if (typeof value === "string" || typeof value === "number") {
          replacerSet.add(String(value));
        }
      }
      return replacerSet;
    }
    function getStrictOption(options) {
      if (hasOwnProperty2.call(options, "strict")) {
        const value = options.strict;
        if (typeof value !== "boolean") {
          throw new TypeError('The "strict" argument must be of type boolean');
        }
        if (value) {
          return (value2) => {
            let message2 = `Object can not safely be stringified. Received type ${typeof value2}`;
            if (typeof value2 !== "function") message2 += ` (${value2.toString()})`;
            throw new Error(message2);
          };
        }
      }
    }
    function configure2(options) {
      options = { ...options };
      const fail = getStrictOption(options);
      if (fail) {
        if (options.bigint === void 0) {
          options.bigint = false;
        }
        if (!("circularValue" in options)) {
          options.circularValue = Error;
        }
      }
      const circularValue = getCircularValueOption(options);
      const bigint2 = getBooleanOption(options, "bigint");
      const deterministic = getDeterministicOption(options);
      const comparator = typeof deterministic === "function" ? deterministic : void 0;
      const maximumDepth = getPositiveIntegerOption(options, "maximumDepth");
      const maximumBreadth = getPositiveIntegerOption(options, "maximumBreadth");
      function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
        let value = parent[key];
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        value = replacer.call(parent, key, value);
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res2 = "";
            let join2 = ",";
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res2 += `
${indentation}`;
                join2 = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
                res2 += tmp2 !== void 0 ? tmp2 : "null";
                res2 += join2;
              }
              const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
              res2 += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res2 += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res2 += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res2}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let whitespace = "";
            let separator = "";
            if (spacer !== "") {
              indentation += spacer;
              join2 = `,
${indentation}`;
              whitespace = " ";
            }
            const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (deterministic && !isTypedArrayWithEntries(value)) {
              keys = sort(keys, comparator);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifyFnReplacer(key2, value, stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res2 += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join2;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res2 += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
              separator = join2;
            }
            if (spacer !== "" && separator.length > 1) {
              res2 = `
${indentation}${res2}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res2}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint2) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            let res2 = "";
            let join2 = ",";
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res2 += `
${indentation}`;
                join2 = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
                res2 += tmp2 !== void 0 ? tmp2 : "null";
                res2 += join2;
              }
              const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
              res2 += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res2 += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res2 += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res2}]`;
            }
            stack.push(value);
            let whitespace = "";
            if (spacer !== "") {
              indentation += spacer;
              join2 = `,
${indentation}`;
              whitespace = " ";
            }
            let separator = "";
            for (const key2 of replacer) {
              const tmp = stringifyArrayReplacer(key2, value[key2], stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res2 += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join2;
              }
            }
            if (spacer !== "" && separator.length > 1) {
              res2 = `
${indentation}${res2}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res2}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint2) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyIndent(key, value, stack, spacer, indentation) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifyIndent(key, value, stack, spacer, indentation);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              indentation += spacer;
              let res3 = `
${indentation}`;
              const join3 = `,
${indentation}`;
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyIndent(String(i), value[i], stack, spacer, indentation);
                res3 += tmp2 !== void 0 ? tmp2 : "null";
                res3 += join3;
              }
              const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);
              res3 += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res3 += `${join3}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              res3 += `
${originalIndentation}`;
              stack.pop();
              return `[${res3}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            indentation += spacer;
            const join2 = `,
${indentation}`;
            let res2 = "";
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (isTypedArrayWithEntries(value)) {
              res2 += stringifyTypedArray(value, join2, maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = join2;
            }
            if (deterministic) {
              keys = sort(keys, comparator);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifyIndent(key2, value[key2], stack, spacer, indentation);
              if (tmp !== void 0) {
                res2 += `${separator}${strEscape(key2)}: ${tmp}`;
                separator = join2;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res2 += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
              separator = join2;
            }
            if (separator !== "") {
              res2 = `
${indentation}${res2}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res2}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint2) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifySimple(key, value, stack) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifySimple(key, value, stack);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res2 = "";
            const hasLength = value.length !== void 0;
            if (hasLength && Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifySimple(String(i), value[i], stack);
                res2 += tmp2 !== void 0 ? tmp2 : "null";
                res2 += ",";
              }
              const tmp = stringifySimple(String(i), value[i], stack);
              res2 += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res2 += `,"... ${getItemCount(removedKeys)} not stringified"`;
              }
              stack.pop();
              return `[${res2}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (hasLength && isTypedArrayWithEntries(value)) {
              res2 += stringifyTypedArray(value, ",", maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = ",";
            }
            if (deterministic) {
              keys = sort(keys, comparator);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifySimple(key2, value[key2], stack);
              if (tmp !== void 0) {
                res2 += `${separator}${strEscape(key2)}:${tmp}`;
                separator = ",";
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res2 += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
            }
            stack.pop();
            return `{${res2}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint2) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringify3(value, replacer, space) {
        if (arguments.length > 1) {
          let spacer = "";
          if (typeof space === "number") {
            spacer = " ".repeat(Math.min(space, 10));
          } else if (typeof space === "string") {
            spacer = space.slice(0, 10);
          }
          if (replacer != null) {
            if (typeof replacer === "function") {
              return stringifyFnReplacer("", { "": value }, [], replacer, spacer, "");
            }
            if (Array.isArray(replacer)) {
              return stringifyArrayReplacer("", value, [], getUniqueReplacerSet(replacer), spacer, "");
            }
          }
          if (spacer.length !== 0) {
            return stringifyIndent("", value, [], spacer, "");
          }
        }
        return stringifySimple("", value, []);
      }
      return stringify3;
    }
  })(safeStableStringify, safeStableStringify.exports);
  return safeStableStringify.exports;
}
var safeStableStringifyExports = requireSafeStableStringify();
const cjsModule = /* @__PURE__ */ getDefaultExportFromCjs(safeStableStringifyExports);
const configure = cjsModule.configure;
configure({
  bigint: false,
  circularValue: void 0,
  deterministic: false
});
var __defProp$2 = Object.defineProperty;
var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames$1 = Object.getOwnPropertyNames;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __copyProps$1 = (to, from, except, desc2) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames$1(from))
      if (!__hasOwnProp$1.call(to, key) && key !== except)
        __defProp$2(to, key, { get: () => from[key], enumerable: !(desc2 = __getOwnPropDesc$1(from, key)) || desc2.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps$1(target, mod, "default"), secondTarget);
var main$1 = { exports: {} };
var main = main$1.exports;
var hasRequiredMain;
function requireMain() {
  if (hasRequiredMain) return main$1.exports;
  hasRequiredMain = 1;
  (function(module, exports$1) {
    (function() {
      function t2(t3, e3, n3) {
        switch (n3.length) {
          case 0:
            return t3.call(e3);
          case 1:
            return t3.call(e3, n3[0]);
          case 2:
            return t3.call(e3, n3[0], n3[1]);
          case 3:
            return t3.call(e3, n3[0], n3[1], n3[2]);
        }
        return t3.apply(e3, n3);
      }
      function e2(t3, e3) {
        for (var n3 = -1, r3 = null == t3 ? 0 : t3.length; ++n3 < r3 && false !== e3(t3[n3], n3, t3); ) ;
      }
      function n2(t3, e3) {
        for (var n3 = -1, r3 = null == t3 ? 0 : t3.length, u2 = 0, o3 = []; ++n3 < r3; ) {
          var c3 = t3[n3];
          e3(c3, n3, t3) && (o3[u2++] = c3);
        }
        return o3;
      }
      function r2(t3, e3) {
        for (var n3 = -1, r3 = null == t3 ? 0 : t3.length, u2 = Array(r3); ++n3 < r3; ) u2[n3] = e3(t3[n3], n3, t3);
        return u2;
      }
      function u(t3, e3) {
        for (var n3 = -1, r3 = e3.length, u2 = t3.length; ++n3 < r3; ) t3[u2 + n3] = e3[n3];
        return t3;
      }
      function o2(t3) {
        return function(e3) {
          return t3(e3);
        };
      }
      function c2(t3) {
        var e3 = Object;
        return function(n3) {
          return t3(e3(n3));
        };
      }
      function i() {
      }
      function f(t3) {
        var e3 = -1, n3 = null == t3 ? 0 : t3.length;
        for (this.clear(); ++e3 < n3; ) {
          var r3 = t3[e3];
          this.set(r3[0], r3[1]);
        }
      }
      function a(t3) {
        var e3 = -1, n3 = null == t3 ? 0 : t3.length;
        for (this.clear(); ++e3 < n3; ) {
          var r3 = t3[e3];
          this.set(r3[0], r3[1]);
        }
      }
      function l2(t3) {
        var e3 = -1, n3 = null == t3 ? 0 : t3.length;
        for (this.clear(); ++e3 < n3; ) {
          var r3 = t3[e3];
          this.set(r3[0], r3[1]);
        }
      }
      function s2(t3) {
        this.size = (this.__data__ = new a(t3)).size;
      }
      function b(t3, e3) {
        var n3 = Ye(t3), r3 = !n3 && Xe(t3), u2 = !n3 && !r3 && Ze(t3), o3 = !n3 && !r3 && !u2 && nn(t3);
        if (n3 = n3 || r3 || u2 || o3) {
          for (var r3 = t3.length, c3 = String, i2 = -1, f2 = Array(r3); ++i2 < r3; ) f2[i2] = c3(i2);
          r3 = f2;
        } else r3 = [];
        var a2, c3 = r3.length;
        for (a2 in t3) !e3 && !fe.call(t3, a2) || n3 && ("length" == a2 || u2 && ("offset" == a2 || "parent" == a2) || o3 && ("buffer" == a2 || "byteLength" == a2 || "byteOffset" == a2) || ut(a2, c3)) || r3.push(a2);
        return r3;
      }
      function p(t3, e3, n3) {
        (n3 === Mt || bt(t3[e3], n3)) && (n3 !== Mt || e3 in t3) || d(t3, e3, n3);
      }
      function h(t3, e3, n3) {
        var r3 = t3[e3];
        fe.call(t3, e3) && bt(r3, n3) && (n3 !== Mt || e3 in t3) || d(t3, e3, n3);
      }
      function y(t3, e3) {
        for (var n3 = t3.length; n3--; ) if (bt(t3[n3][0], e3)) return n3;
        return -1;
      }
      function j(t3, e3) {
        return t3 && V2(e3, St(e3), t3);
      }
      function _(t3, e3) {
        return t3 && V2(e3, zt(e3), t3);
      }
      function d(t3, e3, n3) {
        "__proto__" == e3 && we ? we(t3, e3, { configurable: true, enumerable: true, value: n3, writable: true }) : t3[e3] = n3;
      }
      function g(t3, n3, r3, u2, o3, c3) {
        var i2, f2 = 1 & n3, a2 = 2 & n3, l3 = 4 & n3;
        if (r3 && (i2 = o3 ? r3(t3, u2, o3, c3) : r3(t3)), i2 !== Mt) return i2;
        if (!_t(t3)) return t3;
        if (u2 = Ye(t3)) {
          if (i2 = tt(t3), !f2) return T(t3, i2);
        } else {
          var b2 = Je(t3), p2 = "[object Function]" == b2 || "[object GeneratorFunction]" == b2;
          if (Ze(t3)) return R(t3, f2);
          if ("[object Object]" == b2 || "[object Arguments]" == b2 || p2 && !o3) {
            if (i2 = a2 || p2 ? {} : et(t3), !f2) return a2 ? G(t3, _(i2, t3)) : N(t3, j(i2, t3));
          } else {
            if (!Gt[b2]) return o3 ? t3 : {};
            i2 = nt(t3, b2, f2);
          }
        }
        if (c3 || (c3 = new s2()), o3 = c3.get(t3)) return o3;
        if (c3.set(t3, i2), en2(t3)) return t3.forEach(function(e3) {
          i2.add(g(e3, n3, r3, e3, t3, c3));
        }), i2;
        if (tn(t3)) return t3.forEach(function(e3, u3) {
          i2.set(u3, g(e3, n3, r3, u3, t3, c3));
        }), i2;
        var a2 = l3 ? a2 ? Q : K : a2 ? zt : St, y2 = u2 ? Mt : a2(t3);
        return e2(y2 || t3, function(e3, u3) {
          y2 && (u3 = e3, e3 = t3[u3]), h(i2, u3, g(e3, n3, r3, u3, t3, c3));
        }), i2;
      }
      function v(t3, e3, n3, r3, o3) {
        var c3 = -1, i2 = t3.length;
        for (n3 || (n3 = rt), o3 || (o3 = []); ++c3 < i2; ) {
          var f2 = t3[c3];
          n3(f2) ? u(o3, f2) : o3[o3.length] = f2;
        }
        return o3;
      }
      function A(t3, e3) {
        e3 = C(e3, t3);
        for (var n3 = 0, r3 = e3.length; null != t3 && n3 < r3; ) t3 = t3[it(e3[n3++])];
        return n3 && n3 == r3 ? t3 : Mt;
      }
      function m(t3, e3, n3) {
        return e3 = e3(t3), Ye(t3) ? e3 : u(e3, n3(t3));
      }
      function w(t3) {
        if (null == t3) t3 = t3 === Mt ? "[object Undefined]" : "[object Null]";
        else if (me && me in Object(t3)) {
          var e3 = fe.call(t3, me), n3 = t3[me];
          try {
            t3[me] = Mt;
            var r3 = true;
          } catch (t4) {
          }
          var u2 = le.call(t3);
          r3 && (e3 ? t3[me] = n3 : delete t3[me]), t3 = u2;
        } else t3 = le.call(t3);
        return t3;
      }
      function O(t3, e3) {
        return null != t3 && fe.call(t3, e3);
      }
      function S(t3, e3) {
        return null != t3 && e3 in Object(t3);
      }
      function z2(t3) {
        return dt(t3) && "[object Arguments]" == w(t3);
      }
      function x(t3) {
        return dt(t3) && "[object Map]" == Je(t3);
      }
      function k(t3) {
        return dt(t3) && "[object Set]" == Je(t3);
      }
      function F(t3) {
        return dt(t3) && jt(t3.length) && !!Nt[w(t3)];
      }
      function I2(t3) {
        if (!ot(t3)) return ze(t3);
        var e3, n3 = [];
        for (e3 in Object(t3)) fe.call(t3, e3) && "constructor" != e3 && n3.push(e3);
        return n3;
      }
      function M(t3, e3, n3, r3, u2) {
        t3 !== e3 && Ne(e3, function(o3, c3) {
          if (_t(o3)) {
            u2 || (u2 = new s2());
            var i2 = u2, f2 = "__proto__" == c3 ? Mt : t3[c3], a2 = "__proto__" == c3 ? Mt : e3[c3], l3 = i2.get(a2);
            if (l3) p(t3, c3, l3);
            else {
              var l3 = r3 ? r3(f2, a2, c3 + "", t3, e3, i2) : Mt, b2 = l3 === Mt;
              if (b2) {
                var h2 = Ye(a2), y2 = !h2 && Ze(a2), j2 = !h2 && !y2 && nn(a2), l3 = a2;
                h2 || y2 || j2 ? Ye(f2) ? l3 = f2 : ht(f2) ? l3 = T(f2) : y2 ? (b2 = false, l3 = R(a2, true)) : j2 ? (b2 = false, l3 = L(a2, true)) : l3 = [] : gt2(a2) || Xe(a2) ? (l3 = f2, Xe(f2) ? l3 = mt(f2) : (!_t(f2) || n3 && yt(f2)) && (l3 = et(a2))) : b2 = false;
              }
              b2 && (i2.set(a2, l3), M(l3, a2, n3, r3, i2), i2.delete(a2)), p(t3, c3, l3);
            }
          } else i2 = r3 ? r3("__proto__" == c3 ? Mt : t3[c3], o3, c3 + "", t3, e3, u2) : Mt, i2 === Mt && (i2 = o3), p(t3, c3, i2);
        }, zt);
      }
      function E(t3, e3) {
        return U(t3, e3, function(e4, n3) {
          return Ot(t3, n3);
        });
      }
      function U(t3, e3, n3) {
        for (var r3 = -1, u2 = e3.length, o3 = {}; ++r3 < u2; ) {
          var c3 = e3[r3], i2 = A(t3, c3);
          n3(i2, c3) && D(o3, C(c3, t3), i2);
        }
        return o3;
      }
      function P(t3) {
        return Ke(ct(t3, void 0, kt), t3 + "");
      }
      function D(t3, e3, n3) {
        if (!_t(t3)) return t3;
        e3 = C(e3, t3);
        for (var r3 = -1, u2 = e3.length, o3 = u2 - 1, c3 = t3; null != c3 && ++r3 < u2; ) {
          var i2 = it(e3[r3]), f2 = n3;
          if (r3 != o3) {
            var a2 = c3[i2], f2 = Mt;
            f2 === Mt && (f2 = _t(a2) ? a2 : ut(e3[r3 + 1]) ? [] : {});
          }
          h(c3, i2, f2), c3 = c3[i2];
        }
        return t3;
      }
      function $(t3) {
        if (typeof t3 == "string") return t3;
        if (Ye(t3)) return r2(t3, $) + "";
        if (At(t3)) return Te ? Te.call(t3) : "";
        var e3 = t3 + "";
        return "0" == e3 && 1 / t3 == -Infinity ? "-0" : e3;
      }
      function B(t3, e3) {
        e3 = C(e3, t3);
        var n3;
        if (2 > e3.length) n3 = t3;
        else {
          n3 = e3;
          var r3 = 0, u2 = -1, o3 = -1, c3 = n3.length;
          for (0 > r3 && (r3 = -r3 > c3 ? 0 : c3 + r3), u2 = u2 > c3 ? c3 : u2, 0 > u2 && (u2 += c3), c3 = r3 > u2 ? 0 : u2 - r3 >>> 0, r3 >>>= 0, u2 = Array(c3); ++o3 < c3; ) u2[o3] = n3[o3 + r3];
          n3 = A(t3, u2);
        }
        return t3 = n3, null == t3 || delete t3[it(lt2(e3))];
      }
      function C(t3, e3) {
        var n3;
        return Ye(t3) ? n3 = t3 : (Ye(t3) ? n3 = false : (n3 = typeof t3, n3 = !("number" != n3 && "symbol" != n3 && "boolean" != n3 && null != t3 && !At(t3)) || (Pt.test(t3) || !Ut.test(t3) || null != e3 && t3 in Object(e3))), n3 = n3 ? [t3] : Qe(wt(t3))), n3;
      }
      function R(t3, e3) {
        if (e3) return t3.slice();
        var n3 = t3.length, n3 = je ? je(n3) : new t3.constructor(n3);
        return t3.copy(n3), n3;
      }
      function W(t3) {
        var e3 = new t3.constructor(t3.byteLength);
        return new ye(e3).set(new ye(t3)), e3;
      }
      function L(t3, e3) {
        return new t3.constructor(e3 ? W(t3.buffer) : t3.buffer, t3.byteOffset, t3.length);
      }
      function T(t3, e3) {
        var n3 = -1, r3 = t3.length;
        for (e3 || (e3 = Array(r3)); ++n3 < r3; ) e3[n3] = t3[n3];
        return e3;
      }
      function V2(t3, e3, n3) {
        var r3 = !n3;
        n3 || (n3 = {});
        for (var u2 = -1, o3 = e3.length; ++u2 < o3; ) {
          var c3 = e3[u2], i2 = Mt;
          i2 === Mt && (i2 = t3[c3]), r3 ? d(n3, c3, i2) : h(n3, c3, i2);
        }
        return n3;
      }
      function N(t3, e3) {
        return V2(t3, qe(t3), e3);
      }
      function G(t3, e3) {
        return V2(t3, He(t3), e3);
      }
      function q2(t3) {
        return P(function(e3, n3) {
          var r3, u2 = -1, o3 = n3.length, c3 = 1 < o3 ? n3[o3 - 1] : Mt, i2 = 2 < o3 ? n3[2] : Mt, c3 = 3 < t3.length && typeof c3 == "function" ? (o3--, c3) : Mt;
          if (r3 = i2) {
            r3 = n3[0];
            var f2 = n3[1];
            if (_t(i2)) {
              var a2 = typeof f2;
              r3 = !!("number" == a2 ? pt2(i2) && ut(f2, i2.length) : "string" == a2 && f2 in i2) && bt(i2[f2], r3);
            } else r3 = false;
          }
          for (r3 && (c3 = 3 > o3 ? Mt : c3, o3 = 1), e3 = Object(e3); ++u2 < o3; ) (i2 = n3[u2]) && t3(e3, i2, u2, c3);
          return e3;
        });
      }
      function H(t3) {
        return gt2(t3) ? Mt : t3;
      }
      function J(t3) {
        return Ke(ct(t3, Mt, at), t3 + "");
      }
      function K(t3) {
        return m(t3, St, qe);
      }
      function Q(t3) {
        return m(t3, zt, He);
      }
      function X(t3, e3) {
        var n3 = t3.__data__, r3 = typeof e3;
        return ("string" == r3 || "number" == r3 || "symbol" == r3 || "boolean" == r3 ? "__proto__" !== e3 : null === e3) ? n3[typeof e3 == "string" ? "string" : "hash"] : n3.map;
      }
      function Y(t3, e3) {
        var n3 = null == t3 ? Mt : t3[e3];
        return (!_t(n3) || ae && ae in n3 ? 0 : (yt(n3) ? be : Ct).test(ft(n3))) ? n3 : Mt;
      }
      function Z(t3, e3, n3) {
        e3 = C(e3, t3);
        for (var r3 = -1, u2 = e3.length, o3 = false; ++r3 < u2; ) {
          var c3 = it(e3[r3]);
          if (!(o3 = null != t3 && n3(t3, c3))) break;
          t3 = t3[c3];
        }
        return o3 || ++r3 != u2 ? o3 : (u2 = null == t3 ? 0 : t3.length, !!u2 && jt(u2) && ut(c3, u2) && (Ye(t3) || Xe(t3)));
      }
      function tt(t3) {
        var e3 = t3.length, n3 = new t3.constructor(e3);
        return e3 && "string" == typeof t3[0] && fe.call(t3, "index") && (n3.index = t3.index, n3.input = t3.input), n3;
      }
      function et(t3) {
        return typeof t3.constructor != "function" || ot(t3) ? {} : Ve(_e(t3));
      }
      function nt(t3, e3, n3) {
        var r3 = t3.constructor;
        switch (e3) {
          case "[object ArrayBuffer]":
            return W(t3);
          case "[object Boolean]":
          case "[object Date]":
            return new r3(+t3);
          case "[object DataView]":
            return e3 = n3 ? W(t3.buffer) : t3.buffer, new t3.constructor(e3, t3.byteOffset, t3.byteLength);
          case "[object Float32Array]":
          case "[object Float64Array]":
          case "[object Int8Array]":
          case "[object Int16Array]":
          case "[object Int32Array]":
          case "[object Uint8Array]":
          case "[object Uint8ClampedArray]":
          case "[object Uint16Array]":
          case "[object Uint32Array]":
            return L(t3, n3);
          case "[object Map]":
            return new r3();
          case "[object Number]":
          case "[object String]":
            return new r3(t3);
          case "[object RegExp]":
            return e3 = new t3.constructor(t3.source, Bt.exec(t3)), e3.lastIndex = t3.lastIndex, e3;
          case "[object Set]":
            return new r3();
          case "[object Symbol]":
            return Le ? Object(Le.call(t3)) : {};
        }
      }
      function rt(t3) {
        return Ye(t3) || Xe(t3) || !!(Ae && t3 && t3[Ae]);
      }
      function ut(t3, e3) {
        var n3 = typeof t3;
        return e3 = null == e3 ? 9007199254740991 : e3, !!e3 && ("number" == n3 || "symbol" != n3 && Rt.test(t3)) && -1 < t3 && 0 == t3 % 1 && t3 < e3;
      }
      function ot(t3) {
        var e3 = t3 && t3.constructor;
        return t3 === (typeof e3 == "function" && e3.prototype || oe);
      }
      function ct(e3, n3, r3) {
        return n3 = xe(n3 === Mt ? e3.length - 1 : n3, 0), function() {
          for (var u2 = arguments, o3 = -1, c3 = xe(u2.length - n3, 0), i2 = Array(c3); ++o3 < c3; ) i2[o3] = u2[n3 + o3];
          for (o3 = -1, c3 = Array(n3 + 1); ++o3 < n3; ) c3[o3] = u2[o3];
          return c3[n3] = r3(i2), t2(e3, this, c3);
        };
      }
      function it(t3) {
        if (typeof t3 == "string" || At(t3)) return t3;
        var e3 = t3 + "";
        return "0" == e3 && 1 / t3 == -Infinity ? "-0" : e3;
      }
      function ft(t3) {
        if (null != t3) {
          try {
            return ie.call(t3);
          } catch (t4) {
          }
          return t3 + "";
        }
        return "";
      }
      function at(t3) {
        return (null == t3 ? 0 : t3.length) ? v(t3) : [];
      }
      function lt2(t3) {
        var e3 = null == t3 ? 0 : t3.length;
        return e3 ? t3[e3 - 1] : Mt;
      }
      function st(t3, e3) {
        function n3() {
          var r3 = arguments, u2 = e3 ? e3.apply(this, r3) : r3[0], o3 = n3.cache;
          return o3.has(u2) ? o3.get(u2) : (r3 = t3.apply(this, r3), n3.cache = o3.set(u2, r3) || o3, r3);
        }
        if (typeof t3 != "function" || null != e3 && typeof e3 != "function") throw new TypeError("Expected a function");
        return n3.cache = new (st.Cache || l2)(), n3;
      }
      function bt(t3, e3) {
        return t3 === e3 || t3 !== t3 && e3 !== e3;
      }
      function pt2(t3) {
        return null != t3 && jt(t3.length) && !yt(t3);
      }
      function ht(t3) {
        return dt(t3) && pt2(t3);
      }
      function yt(t3) {
        return !!_t(t3) && (t3 = w(t3), "[object Function]" == t3 || "[object GeneratorFunction]" == t3 || "[object AsyncFunction]" == t3 || "[object Proxy]" == t3);
      }
      function jt(t3) {
        return typeof t3 == "number" && -1 < t3 && 0 == t3 % 1 && 9007199254740991 >= t3;
      }
      function _t(t3) {
        var e3 = typeof t3;
        return null != t3 && ("object" == e3 || "function" == e3);
      }
      function dt(t3) {
        return null != t3 && typeof t3 == "object";
      }
      function gt2(t3) {
        return !(!dt(t3) || "[object Object]" != w(t3)) && (t3 = _e(t3), null === t3 || (t3 = fe.call(t3, "constructor") && t3.constructor, typeof t3 == "function" && t3 instanceof t3 && ie.call(t3) == se));
      }
      function vt(t3) {
        return typeof t3 == "string" || !Ye(t3) && dt(t3) && "[object String]" == w(t3);
      }
      function At(t3) {
        return typeof t3 == "symbol" || dt(t3) && "[object Symbol]" == w(t3);
      }
      function mt(t3) {
        return V2(t3, zt(t3));
      }
      function wt(t3) {
        return null == t3 ? "" : $(t3);
      }
      function Ot(t3, e3) {
        return null != t3 && Z(t3, e3, S);
      }
      function St(t3) {
        return pt2(t3) ? b(t3) : I2(t3);
      }
      function zt(t3) {
        if (pt2(t3)) t3 = b(t3, true);
        else if (_t(t3)) {
          var e3, n3 = ot(t3), r3 = [];
          for (e3 in t3) ("constructor" != e3 || !n3 && fe.call(t3, e3)) && r3.push(e3);
          t3 = r3;
        } else {
          if (e3 = [], null != t3) for (n3 in Object(t3)) e3.push(n3);
          t3 = e3;
        }
        return t3;
      }
      function xt(t3) {
        return function() {
          return t3;
        };
      }
      function kt(t3) {
        return t3;
      }
      function Ft() {
        return [];
      }
      function It() {
        return false;
      }
      var Mt, Ut = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Pt = /^\w*$/, Dt = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, $t = /\\(\\)?/g, Bt = /\w*$/, Ct = /^\[object .+?Constructor\]$/, Rt = /^(?:0|[1-9]\d*)$/, Wt = "[\\ufe0e\\ufe0f]?(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|\\ud83c[\\udffb-\\udfff])?(?:\\u200d(?:[^\\ud800-\\udfff]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff])[\\ufe0e\\ufe0f]?(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|\\ud83c[\\udffb-\\udfff])?)*", Lt = "(?:[^\\ud800-\\udfff][\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]?|[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\ud800-\\udfff])", Tt = RegExp("\\ud83c[\\udffb-\\udfff](?=\\ud83c[\\udffb-\\udfff])|" + Lt + Wt, "g"), Vt = RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]"), Nt = {};
      Nt["[object Float32Array]"] = Nt["[object Float64Array]"] = Nt["[object Int8Array]"] = Nt["[object Int16Array]"] = Nt["[object Int32Array]"] = Nt["[object Uint8Array]"] = Nt["[object Uint8ClampedArray]"] = Nt["[object Uint16Array]"] = Nt["[object Uint32Array]"] = true, Nt["[object Arguments]"] = Nt["[object Array]"] = Nt["[object ArrayBuffer]"] = Nt["[object Boolean]"] = Nt["[object DataView]"] = Nt["[object Date]"] = Nt["[object Error]"] = Nt["[object Function]"] = Nt["[object Map]"] = Nt["[object Number]"] = Nt["[object Object]"] = Nt["[object RegExp]"] = Nt["[object Set]"] = Nt["[object String]"] = Nt["[object WeakMap]"] = false;
      var Gt = {};
      Gt["[object Arguments]"] = Gt["[object Array]"] = Gt["[object ArrayBuffer]"] = Gt["[object DataView]"] = Gt["[object Boolean]"] = Gt["[object Date]"] = Gt["[object Float32Array]"] = Gt["[object Float64Array]"] = Gt["[object Int8Array]"] = Gt["[object Int16Array]"] = Gt["[object Int32Array]"] = Gt["[object Map]"] = Gt["[object Number]"] = Gt["[object Object]"] = Gt["[object RegExp]"] = Gt["[object Set]"] = Gt["[object String]"] = Gt["[object Symbol]"] = Gt["[object Uint8Array]"] = Gt["[object Uint8ClampedArray]"] = Gt["[object Uint16Array]"] = Gt["[object Uint32Array]"] = true, Gt["[object Error]"] = Gt["[object Function]"] = Gt["[object WeakMap]"] = false;
      var qt, Ht = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal, Jt = typeof self == "object" && self && self.Object === Object && self, Kt = Ht || Jt || Function("return this")(), Qt = exports$1 && !exports$1.nodeType && exports$1, Xt = Qt && true && module && !module.nodeType && module, Yt = Xt && Xt.exports === Qt, Zt = Yt && Ht.process;
      t: {
        try {
          qt = Zt && Zt.binding && Zt.binding("util");
          break t;
        } catch (t3) {
        }
        qt = void 0;
      }
      var te = qt && qt.isMap, ee = qt && qt.isSet, ne2 = qt && qt.isTypedArray, re = /* @__PURE__ */ (function(t3) {
        return function(e3) {
          return null == e3 ? Mt : e3[t3];
        };
      })("length"), ue = Array.prototype, oe = Object.prototype, ce = Kt["__core-js_shared__"], ie = Function.prototype.toString, fe = oe.hasOwnProperty, ae = (function() {
        var t3 = /[^.]+$/.exec(ce && ce.keys && ce.keys.IE_PROTO || "");
        return t3 ? "Symbol(src)_1." + t3 : "";
      })(), le = oe.toString, se = ie.call(Object), be = RegExp("^" + ie.call(fe).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), pe = Yt ? Kt.Buffer : Mt, he = Kt.Symbol, ye = Kt.Uint8Array, je = pe ? pe.a : Mt, _e = c2(Object.getPrototypeOf), de2 = Object.create, ge = oe.propertyIsEnumerable, ve = ue.splice, Ae = he ? he.isConcatSpreadable : Mt, me = he ? he.toStringTag : Mt, we = (function() {
        try {
          var t3 = Y(Object, "defineProperty");
          return t3({}, "", {}), t3;
        } catch (t4) {
        }
      })(), Oe = Object.getOwnPropertySymbols, Se = pe ? pe.isBuffer : Mt, ze = c2(Object.keys), xe = Math.max, ke = Date.now, Fe = Y(Kt, "DataView"), Ie = Y(Kt, "Map"), Me = Y(Kt, "Promise"), Ee = Y(Kt, "Set"), Ue = Y(Kt, "WeakMap"), Pe = Y(Object, "create"), De = ft(Fe), $e = ft(Ie), Be = ft(Me), Ce = ft(Ee), Re = ft(Ue), We = he ? he.prototype : Mt, Le = We ? We.valueOf : Mt, Te = We ? We.toString : Mt, Ve = /* @__PURE__ */ (function() {
        function t3() {
        }
        return function(e3) {
          return _t(e3) ? de2 ? de2(e3) : (t3.prototype = e3, e3 = new t3(), t3.prototype = Mt, e3) : {};
        };
      })();
      f.prototype.clear = function() {
        this.__data__ = Pe ? Pe(null) : {}, this.size = 0;
      }, f.prototype.delete = function(t3) {
        return t3 = this.has(t3) && delete this.__data__[t3], this.size -= t3 ? 1 : 0, t3;
      }, f.prototype.get = function(t3) {
        var e3 = this.__data__;
        return Pe ? (t3 = e3[t3], "__lodash_hash_undefined__" === t3 ? Mt : t3) : fe.call(e3, t3) ? e3[t3] : Mt;
      }, f.prototype.has = function(t3) {
        var e3 = this.__data__;
        return Pe ? e3[t3] !== Mt : fe.call(e3, t3);
      }, f.prototype.set = function(t3, e3) {
        var n3 = this.__data__;
        return this.size += this.has(t3) ? 0 : 1, n3[t3] = Pe && e3 === Mt ? "__lodash_hash_undefined__" : e3, this;
      }, a.prototype.clear = function() {
        this.__data__ = [], this.size = 0;
      }, a.prototype.delete = function(t3) {
        var e3 = this.__data__;
        return t3 = y(e3, t3), !(0 > t3) && (t3 == e3.length - 1 ? e3.pop() : ve.call(e3, t3, 1), --this.size, true);
      }, a.prototype.get = function(t3) {
        var e3 = this.__data__;
        return t3 = y(e3, t3), 0 > t3 ? Mt : e3[t3][1];
      }, a.prototype.has = function(t3) {
        return -1 < y(this.__data__, t3);
      }, a.prototype.set = function(t3, e3) {
        var n3 = this.__data__, r3 = y(n3, t3);
        return 0 > r3 ? (++this.size, n3.push([t3, e3])) : n3[r3][1] = e3, this;
      }, l2.prototype.clear = function() {
        this.size = 0, this.__data__ = {
          hash: new f(),
          map: new (Ie || a)(),
          string: new f()
        };
      }, l2.prototype.delete = function(t3) {
        return t3 = X(this, t3).delete(t3), this.size -= t3 ? 1 : 0, t3;
      }, l2.prototype.get = function(t3) {
        return X(this, t3).get(t3);
      }, l2.prototype.has = function(t3) {
        return X(this, t3).has(t3);
      }, l2.prototype.set = function(t3, e3) {
        var n3 = X(this, t3), r3 = n3.size;
        return n3.set(t3, e3), this.size += n3.size == r3 ? 0 : 1, this;
      }, s2.prototype.clear = function() {
        this.__data__ = new a(), this.size = 0;
      }, s2.prototype.delete = function(t3) {
        var e3 = this.__data__;
        return t3 = e3.delete(t3), this.size = e3.size, t3;
      }, s2.prototype.get = function(t3) {
        return this.__data__.get(t3);
      }, s2.prototype.has = function(t3) {
        return this.__data__.has(t3);
      }, s2.prototype.set = function(t3, e3) {
        var n3 = this.__data__;
        if (n3 instanceof a) {
          var r3 = n3.__data__;
          if (!Ie || 199 > r3.length) return r3.push([t3, e3]), this.size = ++n3.size, this;
          n3 = this.__data__ = new l2(r3);
        }
        return n3.set(t3, e3), this.size = n3.size, this;
      };
      var Ne = /* @__PURE__ */ (function(t3) {
        return function(e3, n3, r3) {
          var u2 = -1, o3 = Object(e3);
          r3 = r3(e3);
          for (var c3 = r3.length; c3--; ) {
            var i2 = r3[++u2];
            if (false === n3(o3[i2], i2, o3)) break;
          }
          return e3;
        };
      })(), Ge = we ? function(t3, e3) {
        return we(t3, "toString", {
          configurable: true,
          enumerable: false,
          value: xt(e3),
          writable: true
        });
      } : kt, qe = Oe ? function(t3) {
        return null == t3 ? [] : (t3 = Object(t3), n2(Oe(t3), function(e3) {
          return ge.call(t3, e3);
        }));
      } : Ft, He = Oe ? function(t3) {
        for (var e3 = []; t3; ) u(e3, qe(t3)), t3 = _e(t3);
        return e3;
      } : Ft, Je = w;
      (Fe && "[object DataView]" != Je(new Fe(new ArrayBuffer(1))) || Ie && "[object Map]" != Je(new Ie()) || Me && "[object Promise]" != Je(Me.resolve()) || Ee && "[object Set]" != Je(new Ee()) || Ue && "[object WeakMap]" != Je(new Ue())) && (Je = function(t3) {
        var e3 = w(t3);
        if (t3 = (t3 = "[object Object]" == e3 ? t3.constructor : Mt) ? ft(t3) : "") switch (t3) {
          case De:
            return "[object DataView]";
          case $e:
            return "[object Map]";
          case Be:
            return "[object Promise]";
          case Ce:
            return "[object Set]";
          case Re:
            return "[object WeakMap]";
        }
        return e3;
      });
      var Ke = /* @__PURE__ */ (function(t3) {
        var e3 = 0, n3 = 0;
        return function() {
          var r3 = ke(), u2 = 16 - (r3 - n3);
          if (n3 = r3, 0 < u2) {
            if (800 <= ++e3) return arguments[0];
          } else e3 = 0;
          return t3.apply(Mt, arguments);
        };
      })(Ge), Qe = (function(t3) {
        t3 = st(t3, function(t4) {
          return 500 === e3.size && e3.clear(), t4;
        });
        var e3 = t3.cache;
        return t3;
      })(function(t3) {
        var e3 = [];
        return 46 === t3.charCodeAt(0) && e3.push(""), t3.replace(Dt, function(t4, n3, r3, u2) {
          e3.push(r3 ? u2.replace($t, "$1") : n3 || t4);
        }), e3;
      });
      st.Cache = l2;
      var Xe = z2(/* @__PURE__ */ (function() {
        return arguments;
      })()) ? z2 : function(t3) {
        return dt(t3) && fe.call(t3, "callee") && !ge.call(t3, "callee");
      }, Ye = Array.isArray, Ze = Se || It, tn = te ? o2(te) : x, en2 = ee ? o2(ee) : k, nn = ne2 ? o2(ne2) : F, rn = q2(function(t3, e3, n3) {
        M(t3, e3, n3);
      }), un = q2(function(t3, e3, n3, r3) {
        M(t3, e3, n3, r3);
      }), on = J(function(t3, e3) {
        var n3 = {};
        if (null == t3) return n3;
        var u2 = false;
        e3 = r2(e3, function(e4) {
          return e4 = C(e4, t3), u2 || (u2 = 1 < e4.length), e4;
        }), V2(t3, Q(t3), n3), u2 && (n3 = g(n3, 7, H));
        for (var o3 = e3.length; o3--; ) B(n3, e3[o3]);
        return n3;
      }), cn = J(function(t3, e3) {
        return null == t3 ? {} : E(t3, e3);
      });
      i.constant = xt, i.flatten = at, i.keys = St, i.keysIn = zt, i.memoize = st, i.merge = rn, i.mergeWith = un, i.omit = on, i.pick = cn, i.set = function(t3, e3, n3) {
        return null == t3 ? t3 : D(t3, e3, n3);
      }, i.toPath = function(t3) {
        return Ye(t3) ? r2(t3, it) : At(t3) ? [t3] : T(Qe(wt(t3)));
      }, i.toPlainObject = mt, i.unset = function(t3, e3) {
        return null == t3 || B(t3, e3);
      }, i.clone = function(t3) {
        return g(t3, 4);
      }, i.cloneDeep = function(t3) {
        return g(t3, 5);
      }, i.cloneDeepWith = function(t3, e3) {
        return e3 = typeof e3 == "function" ? e3 : Mt, g(t3, 5, e3);
      }, i.cloneWith = function(t3, e3) {
        return e3 = typeof e3 == "function" ? e3 : Mt, g(t3, 4, e3);
      }, i.eq = bt, i.get = function(t3, e3, n3) {
        return t3 = null == t3 ? Mt : A(t3, e3), t3 === Mt ? n3 : t3;
      }, i.has = function(t3, e3) {
        return null != t3 && Z(t3, e3, O);
      }, i.hasIn = Ot, i.identity = kt, i.isArguments = Xe, i.isArray = Ye, i.isArrayLike = pt2, i.isArrayLikeObject = ht, i.isBuffer = Ze, i.isFunction = yt, i.isLength = jt, i.isMap = tn, i.isObject = _t, i.isObjectLike = dt, i.isPlainObject = gt2, i.isSet = en2, i.isString = vt, i.isSymbol = At, i.isTypedArray = nn, i.last = lt2, i.stubArray = Ft, i.stubFalse = It, i.size = function(t3) {
        if (null == t3) return 0;
        if (pt2(t3)) {
          if (vt(t3)) if (Vt.test(t3)) {
            for (var e3 = Tt.lastIndex = 0; Tt.test(t3); ) ++e3;
            t3 = e3;
          } else t3 = re(t3);
          else t3 = t3.length;
          return t3;
        }
        return e3 = Je(t3), "[object Map]" == e3 || "[object Set]" == e3 ? t3.size : I2(t3).length;
      }, i.toString = wt, i.VERSION = "4.17.5", Xt ? ((Xt.exports = i)._ = i, Qt._ = i) : Kt._ = i;
    }).call(main);
  })(main$1, main$1.exports);
  return main$1.exports;
}
requireMain();
var slugify$2 = { exports: {} };
var slugify$1 = slugify$2.exports;
var hasRequiredSlugify;
function requireSlugify() {
  if (hasRequiredSlugify) return slugify$2.exports;
  hasRequiredSlugify = 1;
  (function(module, exports$1) {
    (function(name2, root, factory) {
      {
        module.exports = factory();
        module.exports["default"] = factory();
      }
    })("slugify", slugify$1, function() {
      var charMap = JSON.parse(`{"$":"dollar","%":"percent","&":"and","<":"less",">":"greater","|":"or","":"cent","":"pound","":"currency","":"yen","":"(c)","":"a","":"(r)","":"o","":"A","":"A","":"A","":"A","":"A","":"A","":"AE","":"C","":"E","":"E","":"E","":"E","":"I","":"I","":"I","":"I","":"D","":"N","":"O","":"O","":"O","":"O","":"O","":"O","":"U","":"U","":"U","":"U","":"Y","":"TH","":"ss","":"a","":"a","":"a","":"a","":"a","":"a","":"ae","":"c","":"e","":"e","":"e","":"e","":"i","":"i","":"i","":"i","":"d","":"n","":"o","":"o","":"o","":"o","":"o","":"o","":"u","":"u","":"u","":"u","":"y","":"th","":"y","":"A","":"a","":"A","":"a","":"A","":"a","":"C","":"c","":"C","":"c","":"D","":"d","":"DJ","":"dj","":"E","":"e","":"E","":"e","":"e","":"e","":"E","":"e","":"G","":"g","":"G","":"g","":"I","":"i","":"i","":"i","":"I","":"i","":"I","":"i","":"k","":"k","":"L","":"l","":"L","":"l","":"L","":"l","":"N","":"n","":"N","":"n","":"N","":"n","":"O","":"o","":"O","":"o","":"OE","":"oe","":"R","":"r","":"R","":"r","":"S","":"s","":"S","":"s","":"S","":"s","":"T","":"t","":"T","":"t","":"U","":"u","":"u","":"u","":"U","":"u","":"U","":"u","":"U","":"u","":"W","":"w","":"Y","":"y","":"Y","":"Z","":"z","":"Z","":"z","":"Z","":"z","":"E","":"f","":"O","":"o","":"U","":"u","":"LJ","":"lj","":"NJ","":"nj","":"S","":"s","":"T","":"t","":"e","":"o","":"A","":"E","":"H","":"I","":"O","":"Y","":"W","":"i","":"A","":"B","":"G","":"D","":"E","":"Z","":"H","":"8","":"I","":"K","":"L","":"M","":"N","":"3","":"O","":"P","":"R","":"S","":"T","":"Y","":"F","":"X","":"PS","":"W","":"I","":"Y","":"a","":"e","":"h","":"i","":"y","":"a","":"b","":"g","":"d","":"e","":"z","":"h","":"8","":"i","":"k","":"l","":"m","":"n","":"3","":"o","":"p","":"r","":"s","":"s","":"t","":"y","":"f","":"x","":"ps","":"w","":"i","":"y","":"o","":"y","":"w","":"Yo","":"DJ","":"Ye","":"I","":"Yi","":"J","":"LJ","":"NJ","":"C","":"DZ","":"A","":"B","":"V","":"G","":"D","":"E","":"Zh","":"Z","":"I","":"J","":"K","":"L","":"M","":"N","":"O","":"P","":"R","":"S","":"T","":"U","":"F","":"H","":"C","":"Ch","":"Sh","":"Sh","":"U","":"Y","":"","":"E","":"Yu","":"Ya","":"a","":"b","":"v","":"g","":"d","":"e","":"zh","":"z","":"i","":"j","":"k","":"l","":"m","":"n","":"o","":"p","":"r","":"s","":"t","":"u","":"f","":"h","":"c","":"ch","":"sh","":"sh","":"u","":"y","":"","":"e","":"yu","":"ya","":"yo","":"dj","":"ye","":"i","":"yi","":"j","":"lj","":"nj","":"c","":"u","":"dz","":"G","":"g","":"GH","":"gh","":"KH","":"kh","":"NG","":"ng","":"UE","":"ue","":"U","":"u","":"H","":"h","":"AE","":"ae","":"OE","":"oe","":"A","":"B","":"G","":"D","":"E","":"Z","":"E'","":"Y'","":"T'","":"JH","":"I","":"L","":"X","":"C'","":"K","":"H","":"D'","":"GH","":"TW","":"M","":"Y","":"N","":"SH","":"CH","":"P","":"J","":"R'","":"S","":"V","":"T","":"R","":"C","":"P'","":"Q'","":"O''","":"F","":"EV","":"a","":"aa","":"a","":"u","":"i","":"e","":"a","":"b","":"h","":"t","":"th","":"j","":"h","":"kh","":"d","":"th","":"r","":"z","":"s","":"sh","":"s","":"dh","":"t","":"z","":"a","":"gh","":"f","":"q","":"k","":"l","":"m","":"n","":"h","":"w","":"a","":"y","":"an","":"on","":"en","":"a","":"u","":"e","":"","":"0","":"1","":"2","":"3","":"4","":"5","":"6","":"7","":"8","":"9","":"p","":"ch","":"zh","":"k","":"g","":"y","":"0","":"1","":"2","":"3","":"4","":"5","":"6","":"7","":"8","":"9","":"baht","":"a","":"b","":"g","":"d","":"e","":"v","":"z","":"t","":"i","":"k","":"l","":"m","":"n","":"o","":"p","":"zh","":"r","":"s","":"t","":"u","":"f","":"k","":"gh","":"q","":"sh","":"ch","":"ts","":"dz","":"ts","":"ch","":"kh","":"j","":"h","":"S","":"s","":"W","":"w","":"W","":"w","":"W","":"w","":"SS","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"E","":"e","":"E","":"e","":"E","":"e","":"E","":"e","":"E","":"e","":"E","":"e","":"E","":"e","":"E","":"e","":"I","":"i","":"I","":"i","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"U","":"u","":"U","":"u","":"U","":"u","":"U","":"u","":"U","":"u","":"U","":"u","":"U","":"u","":"Y","":"y","":"Y","":"y","":"Y","":"y","":"Y","":"y","":"-","":"'","":"'","":"\\"","":"\\"","":"\\"","":"+","":"*","":"...","":"ecu","":"cruzeiro","":"french franc","":"lira","":"mill","":"naira","":"peseta","":"rupee","":"won","":"new shequel","":"dong","":"euro","":"kip","":"tugrik","":"drachma","":"penny","":"peso","":"guarani","":"austral","":"hryvnia","":"cedi","":"kazakhstani tenge","":"indian rupee","":"turkish lira","":"russian ruble","":"bitcoin","":"sm","":"tm","":"d","":"delta","":"sum","":"infinity","":"love","":"yuan","":"yen","":"rial","":"laa","":"laa","":"lai","":"la"}`);
      var locales = JSON.parse('{"bg":{"":"Y","":"Ts","":"Sht","":"A","":"Y","":"y","":"ts","":"sht","":"a","":"y"},"de":{"":"AE","":"ae","":"OE","":"oe","":"UE","":"ue","":"ss","%":"prozent","&":"und","|":"oder","":"summe","":"unendlich","":"liebe"},"es":{"%":"por ciento","&":"y","<":"menor que",">":"mayor que","|":"o","":"centavos","":"libras","":"moneda","":"francos","":"suma","":"infinito","":"amor"},"fr":{"%":"pourcent","&":"et","<":"plus petit",">":"plus grand","|":"ou","":"centime","":"livre","":"devise","":"franc","":"somme","":"infini","":"amour"},"pt":{"%":"porcento","&":"e","<":"menor",">":"maior","|":"ou","":"centavo","":"soma","":"libra","":"infinito","":"amor"},"uk":{"":"Y","":"y","":"Y","":"y","":"Ts","":"ts","":"Kh","":"kh","":"Shch","":"shch","":"H","":"h"},"vi":{"":"D","":"d"},"da":{"":"OE","":"oe","":"AA","":"aa","%":"procent","&":"og","|":"eller","$":"dollar","<":"mindre end",">":"strre end"},"nb":{"&":"og","":"AA","":"AE","":"OE","":"aa","":"ae","":"oe"},"it":{"&":"e"},"nl":{"&":"en"},"sv":{"&":"och","":"AA","":"AE","":"OE","":"aa","":"ae","":"oe"}}');
      function replace(string, options) {
        if (typeof string !== "string") {
          throw new Error("slugify: string argument expected");
        }
        options = typeof options === "string" ? { replacement: options } : options || {};
        var locale = locales[options.locale] || {};
        var replacement = options.replacement === void 0 ? "-" : options.replacement;
        var trim2 = options.trim === void 0 ? true : options.trim;
        var slug2 = string.normalize().split("").reduce(function(result2, ch) {
          var appendChar = locale[ch];
          if (appendChar === void 0) appendChar = charMap[ch];
          if (appendChar === void 0) appendChar = ch;
          if (appendChar === replacement) appendChar = " ";
          return result2 + appendChar.replace(options.remove || /[^\w\s$*_+~.()'"!\-:@]+/g, "");
        }, "");
        if (options.strict) {
          slug2 = slug2.replace(/[^A-Za-z0-9\s]/g, "");
        }
        if (trim2) {
          slug2 = slug2.trim();
        }
        slug2 = slug2.replace(/\s+/g, replacement);
        if (options.lower) {
          slug2 = slug2.toLowerCase();
        }
        return slug2;
      }
      replace.extend = function(customMap) {
        Object.assign(charMap, customMap);
      };
      return replace;
    });
  })(slugify$2);
  return slugify$2.exports;
}
var slugifyExports = requireSlugify();
const slugifyPkg = /* @__PURE__ */ getDefaultExportFromCjs(slugifyExports);
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var pluralize$2 = { exports: {} };
var pluralize$1 = pluralize$2.exports;
var hasRequiredPluralize;
function requirePluralize() {
  if (hasRequiredPluralize) return pluralize$2.exports;
  hasRequiredPluralize = 1;
  (function(module, exports$1) {
    (function(root, pluralize2) {
      if (typeof commonjsRequire === "function" && true && true) {
        module.exports = pluralize2();
      } else {
        root.pluralize = pluralize2();
      }
    })(pluralize$1, function() {
      var pluralRules = [];
      var singularRules = [];
      var uncountables = {};
      var irregularPlurals = {};
      var irregularSingles = {};
      function sanitizeRule(rule) {
        if (typeof rule === "string") {
          return new RegExp("^" + rule + "$", "i");
        }
        return rule;
      }
      function restoreCase(word, token2) {
        if (word === token2) return token2;
        if (word === word.toLowerCase()) return token2.toLowerCase();
        if (word === word.toUpperCase()) return token2.toUpperCase();
        if (word[0] === word[0].toUpperCase()) {
          return token2.charAt(0).toUpperCase() + token2.substr(1).toLowerCase();
        }
        return token2.toLowerCase();
      }
      function interpolate2(str, args) {
        return str.replace(/\$(\d{1,2})/g, function(match2, index2) {
          return args[index2] || "";
        });
      }
      function replace(word, rule) {
        return word.replace(rule[0], function(match2, index2) {
          var result2 = interpolate2(rule[1], arguments);
          if (match2 === "") {
            return restoreCase(word[index2 - 1], result2);
          }
          return restoreCase(match2, result2);
        });
      }
      function sanitizeWord(token2, word, rules) {
        if (!token2.length || uncountables.hasOwnProperty(token2)) {
          return word;
        }
        var len = rules.length;
        while (len--) {
          var rule = rules[len];
          if (rule[0].test(word)) return replace(word, rule);
        }
        return word;
      }
      function replaceWord(replaceMap, keepMap, rules) {
        return function(word) {
          var token2 = word.toLowerCase();
          if (keepMap.hasOwnProperty(token2)) {
            return restoreCase(word, token2);
          }
          if (replaceMap.hasOwnProperty(token2)) {
            return restoreCase(word, replaceMap[token2]);
          }
          return sanitizeWord(token2, word, rules);
        };
      }
      function checkWord(replaceMap, keepMap, rules, bool) {
        return function(word) {
          var token2 = word.toLowerCase();
          if (keepMap.hasOwnProperty(token2)) return true;
          if (replaceMap.hasOwnProperty(token2)) return false;
          return sanitizeWord(token2, token2, rules) === token2;
        };
      }
      function pluralize2(word, count2, inclusive) {
        var pluralized = count2 === 1 ? pluralize2.singular(word) : pluralize2.plural(word);
        return (inclusive ? count2 + " " : "") + pluralized;
      }
      pluralize2.plural = replaceWord(
        irregularSingles,
        irregularPlurals,
        pluralRules
      );
      pluralize2.isPlural = checkWord(
        irregularSingles,
        irregularPlurals,
        pluralRules
      );
      pluralize2.singular = replaceWord(
        irregularPlurals,
        irregularSingles,
        singularRules
      );
      pluralize2.isSingular = checkWord(
        irregularPlurals,
        irregularSingles,
        singularRules
      );
      pluralize2.addPluralRule = function(rule, replacement) {
        pluralRules.push([sanitizeRule(rule), replacement]);
      };
      pluralize2.addSingularRule = function(rule, replacement) {
        singularRules.push([sanitizeRule(rule), replacement]);
      };
      pluralize2.addUncountableRule = function(word) {
        if (typeof word === "string") {
          uncountables[word.toLowerCase()] = true;
          return;
        }
        pluralize2.addPluralRule(word, "$0");
        pluralize2.addSingularRule(word, "$0");
      };
      pluralize2.addIrregularRule = function(single, plural2) {
        plural2 = plural2.toLowerCase();
        single = single.toLowerCase();
        irregularSingles[single] = plural2;
        irregularPlurals[plural2] = single;
      };
      [
        // Pronouns.
        ["I", "we"],
        ["me", "us"],
        ["he", "they"],
        ["she", "they"],
        ["them", "them"],
        ["myself", "ourselves"],
        ["yourself", "yourselves"],
        ["itself", "themselves"],
        ["herself", "themselves"],
        ["himself", "themselves"],
        ["themself", "themselves"],
        ["is", "are"],
        ["was", "were"],
        ["has", "have"],
        ["this", "these"],
        ["that", "those"],
        // Words ending in with a consonant and `o`.
        ["echo", "echoes"],
        ["dingo", "dingoes"],
        ["volcano", "volcanoes"],
        ["tornado", "tornadoes"],
        ["torpedo", "torpedoes"],
        // Ends with `us`.
        ["genus", "genera"],
        ["viscus", "viscera"],
        // Ends with `ma`.
        ["stigma", "stigmata"],
        ["stoma", "stomata"],
        ["dogma", "dogmata"],
        ["lemma", "lemmata"],
        ["schema", "schemata"],
        ["anathema", "anathemata"],
        // Other irregular rules.
        ["ox", "oxen"],
        ["axe", "axes"],
        ["die", "dice"],
        ["yes", "yeses"],
        ["foot", "feet"],
        ["eave", "eaves"],
        ["goose", "geese"],
        ["tooth", "teeth"],
        ["quiz", "quizzes"],
        ["human", "humans"],
        ["proof", "proofs"],
        ["carve", "carves"],
        ["valve", "valves"],
        ["looey", "looies"],
        ["thief", "thieves"],
        ["groove", "grooves"],
        ["pickaxe", "pickaxes"],
        ["passerby", "passersby"]
      ].forEach(function(rule) {
        return pluralize2.addIrregularRule(rule[0], rule[1]);
      });
      [
        [/s?$/i, "s"],
        [/[^\u0000-\u007F]$/i, "$0"],
        [/([^aeiou]ese)$/i, "$1"],
        [/(ax|test)is$/i, "$1es"],
        [/(alias|[^aou]us|t[lm]as|gas|ris)$/i, "$1es"],
        [/(e[mn]u)s?$/i, "$1s"],
        [/([^l]ias|[aeiou]las|[ejzr]as|[iu]am)$/i, "$1"],
        [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1i"],
        [/(alumn|alg|vertebr)(?:a|ae)$/i, "$1ae"],
        [/(seraph|cherub)(?:im)?$/i, "$1im"],
        [/(her|at|gr)o$/i, "$1oes"],
        [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|automat|quor)(?:a|um)$/i, "$1a"],
        [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)(?:a|on)$/i, "$1a"],
        [/sis$/i, "ses"],
        [/(?:(kni|wi|li)fe|(ar|l|ea|eo|oa|hoo)f)$/i, "$1$2ves"],
        [/([^aeiouy]|qu)y$/i, "$1ies"],
        [/([^ch][ieo][ln])ey$/i, "$1ies"],
        [/(x|ch|ss|sh|zz)$/i, "$1es"],
        [/(matr|cod|mur|sil|vert|ind|append)(?:ix|ex)$/i, "$1ices"],
        [/\b((?:tit)?m|l)(?:ice|ouse)$/i, "$1ice"],
        [/(pe)(?:rson|ople)$/i, "$1ople"],
        [/(child)(?:ren)?$/i, "$1ren"],
        [/eaux$/i, "$0"],
        [/m[ae]n$/i, "men"],
        ["thou", "you"]
      ].forEach(function(rule) {
        return pluralize2.addPluralRule(rule[0], rule[1]);
      });
      [
        [/s$/i, ""],
        [/(ss)$/i, "$1"],
        [/(wi|kni|(?:after|half|high|low|mid|non|night|[^\w]|^)li)ves$/i, "$1fe"],
        [/(ar|(?:wo|[ae])l|[eo][ao])ves$/i, "$1f"],
        [/ies$/i, "y"],
        [/\b([pl]|zomb|(?:neck|cross)?t|coll|faer|food|gen|goon|group|lass|talk|goal|cut)ies$/i, "$1ie"],
        [/\b(mon|smil)ies$/i, "$1ey"],
        [/\b((?:tit)?m|l)ice$/i, "$1ouse"],
        [/(seraph|cherub)im$/i, "$1"],
        [/(x|ch|ss|sh|zz|tto|go|cho|alias|[^aou]us|t[lm]as|gas|(?:her|at|gr)o|[aeiou]ris)(?:es)?$/i, "$1"],
        [/(analy|diagno|parenthe|progno|synop|the|empha|cri|ne)(?:sis|ses)$/i, "$1sis"],
        [/(movie|twelve|abuse|e[mn]u)s$/i, "$1"],
        [/(test)(?:is|es)$/i, "$1is"],
        [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1us"],
        [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|quor)a$/i, "$1um"],
        [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)a$/i, "$1on"],
        [/(alumn|alg|vertebr)ae$/i, "$1a"],
        [/(cod|mur|sil|vert|ind)ices$/i, "$1ex"],
        [/(matr|append)ices$/i, "$1ix"],
        [/(pe)(rson|ople)$/i, "$1rson"],
        [/(child)ren$/i, "$1"],
        [/(eau)x?$/i, "$1"],
        [/men$/i, "man"]
      ].forEach(function(rule) {
        return pluralize2.addSingularRule(rule[0], rule[1]);
      });
      [
        // Singular words with no plurals.
        "adulthood",
        "advice",
        "agenda",
        "aid",
        "aircraft",
        "alcohol",
        "ammo",
        "analytics",
        "anime",
        "athletics",
        "audio",
        "bison",
        "blood",
        "bream",
        "buffalo",
        "butter",
        "carp",
        "cash",
        "chassis",
        "chess",
        "clothing",
        "cod",
        "commerce",
        "cooperation",
        "corps",
        "debris",
        "diabetes",
        "digestion",
        "elk",
        "energy",
        "equipment",
        "excretion",
        "expertise",
        "firmware",
        "flounder",
        "fun",
        "gallows",
        "garbage",
        "graffiti",
        "hardware",
        "headquarters",
        "health",
        "herpes",
        "highjinks",
        "homework",
        "housework",
        "information",
        "jeans",
        "justice",
        "kudos",
        "labour",
        "literature",
        "machinery",
        "mackerel",
        "mail",
        "media",
        "mews",
        "moose",
        "music",
        "mud",
        "manga",
        "news",
        "only",
        "personnel",
        "pike",
        "plankton",
        "pliers",
        "police",
        "pollution",
        "premises",
        "rain",
        "research",
        "rice",
        "salmon",
        "scissors",
        "series",
        "sewage",
        "shambles",
        "shrimp",
        "software",
        "species",
        "staff",
        "swine",
        "tennis",
        "traffic",
        "transportation",
        "trout",
        "tuna",
        "wealth",
        "welfare",
        "whiting",
        "wildebeest",
        "wildlife",
        "you",
        /pok[e]mon$/i,
        // Regexes.
        /[^aeiou]ese$/i,
        // "chinese", "japanese"
        /deer$/i,
        // "deer", "reindeer"
        /fish$/i,
        // "fish", "blowfish", "angelfish"
        /measles$/i,
        /o[iu]s$/i,
        // "carnivorous"
        /pox$/i,
        // "chickpox", "smallpox"
        /sheep$/i
      ].forEach(pluralize2.addUncountableRule);
      return pluralize2;
    });
  })(pluralize$2);
  return pluralize$2.exports;
}
var pluralizeExports = requirePluralize();
const pluralizePkg = /* @__PURE__ */ getDefaultExportFromCjs(pluralizeExports);
const magicSplit = /^[a-z---]+|[A-Z---][a-z---]+|[a-z---]+|[0-9]+|[A-Z---]+(?![a-z---])/g;
const spaceSplit = /\S+/g;
function getPartsAndIndexes(string, splitRegex) {
  const result2 = { parts: [], prefixes: [] };
  const matches = string.matchAll(splitRegex);
  let lastWordEndIndex = 0;
  for (const match2 of matches) {
    if (typeof match2.index !== "number")
      continue;
    const word = match2[0];
    result2.parts.push(word);
    const prefix = string.slice(lastWordEndIndex, match2.index).trim();
    result2.prefixes.push(prefix);
    lastWordEndIndex = match2.index + word.length;
  }
  const tail = string.slice(lastWordEndIndex).trim();
  if (tail) {
    result2.parts.push("");
    result2.prefixes.push(tail);
  }
  return result2;
}
function splitAndPrefix(string, options) {
  const { keepSpecialCharacters = false, keep, prefix = "" } = options || {};
  const normalString = string.trim().normalize("NFC");
  const hasSpaces = normalString.includes(" ");
  const split = hasSpaces ? spaceSplit : magicSplit;
  const partsAndIndexes = getPartsAndIndexes(normalString, split);
  return partsAndIndexes.parts.map((_part, i) => {
    let foundPrefix = partsAndIndexes.prefixes[i] || "";
    let part = _part;
    if (keepSpecialCharacters === false) {
      if (keep) {
        part = part.normalize("NFD").replace(new RegExp(`[^a-zA-Z0-9${keep.join("")}]`, "g"), "");
      }
      if (!keep) {
        part = part.normalize("NFD").replace(/[^a-zA-Z0-9]/g, "");
        foundPrefix = "";
      }
    }
    if (keep && foundPrefix) {
      foundPrefix = foundPrefix.replace(new RegExp(`[^${keep.join("")}]`, "g"), "");
    }
    if (i === 0) {
      return foundPrefix + part;
    }
    if (!foundPrefix && !part)
      return "";
    if (!hasSpaces) {
      return (foundPrefix || prefix) + part;
    }
    if (!foundPrefix && prefix.match(/\s/)) {
      return " " + part;
    }
    return (foundPrefix || prefix) + part;
  }).filter(Boolean);
}
function capitaliseWord(string) {
  const match2 = string.matchAll(magicSplit).next().value;
  const firstLetterIndex = match2 ? match2.index : 0;
  return string.slice(0, firstLetterIndex + 1).toUpperCase() + string.slice(firstLetterIndex + 1).toLowerCase();
}
function camelCase$1(string, options) {
  return splitAndPrefix(string, options).reduce((result2, word, index2) => {
    return index2 === 0 || !(word[0] || "").match(magicSplit) ? result2 + word.toLowerCase() : result2 + capitaliseWord(word);
  }, "");
}
function pascalCase$1(string, options) {
  return splitAndPrefix(string, options).reduce((result2, word) => {
    return result2 + capitaliseWord(word);
  }, "");
}
function kebabCase(string, options) {
  return splitAndPrefix(string, { ...options, prefix: "-" }).join("").toLowerCase();
}
function snakeCase$1(string, options) {
  return splitAndPrefix(string, { ...options, prefix: "_" }).join("").toLowerCase();
}
function trainCase(string, options) {
  return splitAndPrefix(string, { ...options, prefix: "-" }).map((word) => capitaliseWord(word)).join("");
}
function dotNotation(string, options) {
  return splitAndPrefix(string, { ...options, prefix: "." }).join("");
}
function capitalCase$1(string, options = { keepSpecialCharacters: true }) {
  return splitAndPrefix(string, { ...options, prefix: " " }).reduce((result2, word) => {
    return result2 + capitaliseWord(word);
  }, "");
}
var __create = Object.create;
var __defProp$1 = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJSMin = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __copyProps = (to, from, except, desc2) => {
  if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames(from), i = 0, n2 = keys.length, key; i < n2; i++) {
    key = keys[i];
    if (!__hasOwnProp.call(to, key) && key !== except) __defProp$1(to, key, {
      get: ((k) => from[k]).bind(null, key),
      enumerable: !(desc2 = __getOwnPropDesc(from, key)) || desc2.enumerable
    });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(__defProp$1(target, "default", {
  value: mod,
  enumerable: true
}), mod));
var import_bytes = /* @__PURE__ */ __toESM((/* @__PURE__ */ __commonJSMin(((exports$1, module) => {
  module.exports = bytes$1;
  module.exports.format = format$12;
  module.exports.parse = parse$12;
  var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
  var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
  var map2 = {
    b: 1,
    kb: 1024,
    mb: 1 << 20,
    gb: 1 << 30,
    tb: Math.pow(1024, 4),
    pb: Math.pow(1024, 5)
  };
  var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
  function bytes$1(value, options) {
    if (typeof value === "string") return parse$12(value);
    if (typeof value === "number") return format$12(value, options);
    return null;
  }
  function format$12(value, options) {
    if (!Number.isFinite(value)) return null;
    var mag = Math.abs(value);
    var thousandsSeparator = options && options.thousandsSeparator || "";
    var unitSeparator = options && options.unitSeparator || "";
    var decimalPlaces = options && options.decimalPlaces !== void 0 ? options.decimalPlaces : 2;
    var fixedDecimals = Boolean(options && options.fixedDecimals);
    var unit = options && options.unit || "";
    if (!unit || !map2[unit.toLowerCase()]) if (mag >= map2.pb) unit = "PB";
    else if (mag >= map2.tb) unit = "TB";
    else if (mag >= map2.gb) unit = "GB";
    else if (mag >= map2.mb) unit = "MB";
    else if (mag >= map2.kb) unit = "KB";
    else unit = "B";
    var str = (value / map2[unit.toLowerCase()]).toFixed(decimalPlaces);
    if (!fixedDecimals) str = str.replace(formatDecimalsRegExp, "$1");
    if (thousandsSeparator) str = str.split(".").map(function(s2, i) {
      return i === 0 ? s2.replace(formatThousandsRegExp, thousandsSeparator) : s2;
    }).join(".");
    return str + unitSeparator + unit;
  }
  function parse$12(val) {
    if (typeof val === "number" && !isNaN(val)) return val;
    if (typeof val !== "string") return null;
    var results = parseRegExp.exec(val);
    var floatValue;
    var unit = "b";
    if (!results) {
      floatValue = parseInt(val, 10);
      unit = "b";
    } else {
      floatValue = parseFloat(results[1]);
      unit = results[4].toLowerCase();
    }
    if (isNaN(floatValue)) return null;
    return Math.floor(map2[unit] * floatValue);
  }
})))());
var bytes_default = {
  format(valueInBytes, options) {
    return import_bytes.default.format(valueInBytes, options);
  },
  parse(unit) {
    if (typeof unit === "number") return unit;
    return import_bytes.default.parse(unit);
  }
};
let uuidGenerator = randomUUID;
function uuid(options) {
  return uuidGenerator(options);
}
uuid.use = function uuidUse(generator2) {
  uuidGenerator = generator2;
};
uuid.restore = function uuidRestore() {
  uuidGenerator = randomUUID;
};
var RGX = /^(-?(?:\d+)?\.?\d+) *(m(?:illiseconds?|s(?:ecs?)?))?(s(?:ec(?:onds?|s)?)?)?(m(?:in(?:utes?|s)?)?)?(h(?:ours?|rs?)?)?(d(?:ays?)?)?(w(?:eeks?|ks?)?)?(y(?:ears?|rs?)?)?$/, SEC = 1e3, MIN = SEC * 60, HOUR = MIN * 60, DAY = HOUR * 24, YEAR = DAY * 365.25;
function parse$3(val) {
  var num, arr = val.toLowerCase().match(RGX);
  if (arr != null && (num = parseFloat(arr[1]))) {
    if (arr[3] != null) return num * SEC;
    if (arr[4] != null) return num * MIN;
    if (arr[5] != null) return num * HOUR;
    if (arr[6] != null) return num * DAY;
    if (arr[7] != null) return num * DAY * 7;
    if (arr[8] != null) return num * YEAR;
    return num;
  }
}
function fmt(val, pfx, str, long) {
  var num = (val | 0) === val ? val : ~~(val + 0.5);
  return pfx + num + (long ? " " + str + (num != 1 ? "s" : "") : str[0]);
}
function format(num, long) {
  var pfx = num < 0 ? "-" : "", abs2 = num < 0 ? -num : num;
  if (abs2 < SEC) return num + (long ? " ms" : "ms");
  if (abs2 < MIN) return fmt(abs2 / SEC, pfx, "second", long);
  if (abs2 < HOUR) return fmt(abs2 / MIN, pfx, "minute", long);
  if (abs2 < DAY) return fmt(abs2 / HOUR, pfx, "hour", long);
  if (abs2 < YEAR) return fmt(abs2 / DAY, pfx, "day", long);
  return fmt(abs2 / YEAR, pfx, "year", long);
}
var seconds_default = {
  format(seconds, long) {
    return format(seconds * 1e3, long);
  },
  parse(duration) {
    if (typeof duration === "number") return duration;
    const milliseconds = parse$3(duration);
    if (milliseconds === void 0) throw new Error(`Invalid duration expression "${duration}"`);
    return Math.floor(milliseconds / 1e3);
  }
};
const slug = slugifyPkg;
const defaultGenerator = (size) => {
  const bits = (size + 1) * 6;
  const buffer = randomBytes$1(Math.ceil(bits / 8));
  return Buffer.from(buffer).toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "").slice(0, size);
};
let randomGenerator = defaultGenerator;
function random$1(size) {
  return randomGenerator(size);
}
random$1.use = function randomUse(generator2) {
  randomGenerator = generator2;
};
random$1.restore = function randomRestore() {
  randomGenerator = defaultGenerator;
};
var require_truncatise = /* @__PURE__ */ __commonJSMin(((exports$1, module) => {
  (function(exportTo) {
    var selfClosingTags = [
      "area",
      "base",
      "br",
      "col",
      "embed",
      "hr",
      "img",
      "input",
      "keygen",
      "link",
      "menuitem",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ];
    var truncatise$2 = function(text2, options) {
      var options = options || {}, text2 = (text2 || "").trim(), truncatedText = "", currentState = 0, isEndOfWord = false, currentTag = "", tagStack = [], nextChar = "";
      var charCounter = 0, wordCounter = 0, paragraphCounter = 0;
      var NOT_TAG = 0, TAG_START = 1, TAG_ATTRIBUTES = 2;
      options.TruncateBy = options.TruncateBy === void 0 || typeof options.TruncateBy !== "string" || !options.TruncateBy.match(/(word(s)?|character(s)?|paragraph(s)?)/) ? "words" : options.TruncateBy.toLowerCase();
      options.TruncateLength = options.TruncateLength === void 0 || typeof options.TruncateLength !== "number" ? 50 : options.TruncateLength;
      options.StripHTML = options.StripHTML === void 0 || typeof options.StripHTML !== "boolean" ? false : options.StripHTML;
      options.Strict = options.Strict === void 0 || typeof options.Strict !== "boolean" ? true : options.Strict;
      options.Suffix = options.Suffix === void 0 || typeof options.Suffix !== "string" ? "..." : options.Suffix;
      if (text2 === "" || text2.length <= options.TruncateLength && options.StripHTML === false) return text2;
      if (options.StripHTML) text2 = String(text2).replace(/<br( \/)?>/gi, " ");
      if (options.StripHTML && !options.TruncateBy.match(/(paragraph(s)?)/)) text2 = String(text2).replace(/<!--(.*?)-->/gm, "").replace(/<\/?[^>]+>/gi, "");
      text2 = String(text2).replace(/<\/p>(\r?\n)+<p>/gm, "</p><p>");
      if (options.StripHTML && String(text2).match(/\r?\n\r?\n/)) text2 = String(text2).replace(/((.+)(\r?\n\r?\n|$))/gi, "<p>$2</p>");
      for (var pointer = 0; pointer < text2.length; pointer++) {
        var currentChar = text2[pointer];
        switch (currentChar) {
          case "<":
            if (currentState === NOT_TAG) {
              currentState = TAG_START;
              currentTag = "";
            }
            if (!options.StripHTML) truncatedText += currentChar;
            break;
          case ">":
            if (currentState === TAG_START || currentState === TAG_ATTRIBUTES) {
              currentState = NOT_TAG;
              currentTag = currentTag.toLowerCase();
              if (currentTag === "/p") {
                paragraphCounter++;
                if (options.StripHTML) truncatedText += " ";
              }
              if (selfClosingTags.indexOf(currentTag) === -1 && selfClosingTags.indexOf(currentTag + "/") === -1) if (currentTag.indexOf("/") >= 0) tagStack.pop();
              else tagStack.push(currentTag);
            }
            if (!options.StripHTML) truncatedText += currentChar;
            break;
          case " ":
            if (currentState === TAG_START) currentState = TAG_ATTRIBUTES;
            if (currentState === NOT_TAG) {
              wordCounter++;
              charCounter++;
            }
            if (currentState === NOT_TAG || !options.StripHTML) truncatedText += currentChar;
            break;
          default:
            if (currentState === NOT_TAG) charCounter++;
            if (currentState === TAG_START) currentTag += currentChar;
            if (currentState === NOT_TAG || !options.StripHTML) truncatedText += currentChar;
            break;
        }
        nextChar = text2[pointer + 1] || "";
        isEndOfWord = options.Strict ? true : !currentChar.match(/[a-zA-Z-']/i) || !nextChar.match(/[a-zA-Z-']/i);
        if (options.TruncateBy.match(/word(s)?/i) && options.TruncateLength <= wordCounter) {
          truncatedText = truncatedText.replace(/\s+$/, "");
          break;
        }
        if (options.TruncateBy.match(/character(s)?/i) && options.TruncateLength <= charCounter && isEndOfWord) break;
        if (options.TruncateBy.match(/paragraph(s)?/i) && options.TruncateLength === paragraphCounter) break;
      }
      if (!options.StripHTML && tagStack.length > 0) while (tagStack.length > 0) {
        var tag2 = tagStack.pop();
        if (tag2 !== "!--") truncatedText += "</" + tag2 + ">";
      }
      if (pointer < text2.length - 1) if (truncatedText.match(/<\/p>$/gi)) truncatedText = truncatedText.replace(/(<\/p>)$/gi, options.Suffix + "$1");
      else truncatedText = truncatedText + options.Suffix;
      return truncatedText.trim();
    };
    if (typeof module !== "undefined" && module.exports) return module.exports = truncatise$2;
    exportTo.truncatise = truncatise$2;
  })(exports$1);
}));
var import_truncatise$1 = /* @__PURE__ */ __toESM(require_truncatise());
function excerpt(sentence$1, charactersLimit, options) {
  return (0, import_truncatise$1.default)(sentence$1, {
    TruncateLength: charactersLimit,
    Strict: options && options.completeWords === true ? false : true,
    StripHTML: true,
    TruncateBy: "characters",
    Suffix: options && options.suffix
  });
}
function applyPadding(value, options) {
  if (options.paddingLeft) value = `${options.paddingChar.repeat(options.paddingLeft)}${value}`;
  if (options.paddingRight) value = `${value}${options.paddingChar.repeat(options.paddingRight)}`;
  return value;
}
function justify(columns, options) {
  const normalizedOptions = {
    align: "left",
    indent: " ",
    ...options
  };
  return columns.map((column) => {
    const columnWidth = options.getLength?.(column) ?? column.length;
    if (columnWidth >= normalizedOptions.width) return column;
    if (normalizedOptions.align === "left") return applyPadding(column, {
      paddingChar: normalizedOptions.indent,
      paddingRight: normalizedOptions.width - columnWidth
    });
    return applyPadding(column, {
      paddingChar: normalizedOptions.indent,
      paddingLeft: normalizedOptions.width - columnWidth
    });
  });
}
function ordinal(value) {
  const transformedValue = Math.abs(typeof value === "string" ? Number.parseInt(value) : value);
  if (!Number.isFinite(transformedValue) || Number.isNaN(transformedValue)) throw new Error("Cannot ordinalize invalid or infinite numbers");
  const percent = transformedValue % 100;
  if (percent >= 10 && percent <= 20) return `${value}th`;
  switch (transformedValue % 10) {
    case 1:
      return `${value}st`;
    case 2:
      return `${value}nd`;
    case 3:
      return `${value}rd`;
    default:
      return `${value}th`;
  }
}
var import_truncatise = /* @__PURE__ */ __toESM(require_truncatise());
function truncate(sentence$1, charactersLimit, options) {
  return (0, import_truncatise.default)(sentence$1, {
    TruncateLength: charactersLimit,
    Strict: options && options.completeWords === true ? false : true,
    StripHTML: false,
    TruncateBy: "characters",
    Suffix: options && options.suffix
  });
}
function sentence(values, options) {
  if (values.length === 0) return "";
  if (values.length === 1) return values[0];
  if (values.length === 2) return `${values[0]}${options?.pairSeparator || " and "}${values[1]}`;
  const normalized = Object.assign({
    separator: ", ",
    lastSeparator: ", and "
  }, options);
  return `${values.slice(0, -1).join(normalized.separator)}${normalized.lastSeparator}${values[values.length - 1]}`;
}
function wordWrap(value, options) {
  const width = options.width;
  const indent = options.indent ?? "";
  const newLine = `${options.newLine ?? "\n"}${indent}`;
  let regexString = ".{1," + width + "}";
  regexString += "([\\s]+|$)|[^\\s]+?([\\s]+|$)";
  const re = new RegExp(regexString, "g");
  return (value.match(re) || []).map(function(line2) {
    if (line2.slice(-1) === "\n") line2 = line2.slice(0, line2.length - 1);
    return options.escape ? options.escape(line2) : line2;
  }).join(newLine);
}
var milliseconds_default = {
  format(milliseconds, long) {
    return format(milliseconds, long);
  },
  parse(duration) {
    if (typeof duration === "number") return duration;
    const milliseconds = parse$3(duration);
    if (milliseconds === void 0) throw new Error(`Invalid duration expression "${duration}"`);
    return milliseconds;
  }
};
function htmlEscape(value) {
  return value.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function parseProp(data, key) {
  const tokens = key.split(".");
  while (tokens.length) {
    if (data === null || typeof data !== "object") return;
    const token2 = tokens.shift();
    data = Object.hasOwn(data, token2) ? data[token2] : void 0;
  }
  return data;
}
function interpolate$1(input, data) {
  return input.replace(/(\\)?{{(.*?)}}/g, (_, escapeChar, key) => {
    if (escapeChar) return `{{${key}}}`;
    return parseProp(data, key.trim());
  });
}
function toUnixSlash(path) {
  if (path.startsWith("\\\\?\\")) return path;
  return path.replace(/\\/g, "/");
}
function pluralize(word, count2, inclusive) {
  return pluralizePkg(word, count2, inclusive);
}
pluralize.addPluralRule = pluralizePkg.addPluralRule;
pluralize.addSingularRule = pluralizePkg.addSingularRule;
pluralize.addIrregularRule = pluralizePkg.addIrregularRule;
pluralize.addUncountableRule = pluralizePkg.addUncountableRule;
const plural = pluralizePkg.plural;
const singular = pluralizePkg.singular;
const isPlural = pluralizePkg.isPlural;
const isSingular = pluralizePkg.isSingular;
const NO_CASE_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
const NO_CASE_STRIP_REGEXP = /[^A-Z0-9]+/gi;
const SMALL_WORDS = /\b(?:an?d?|a[st]|because|but|by|en|for|i[fn]|neither|nor|o[fnr]|only|over|per|so|some|tha[tn]|the|to|up|upon|vs?\.?|versus|via|when|with|without|yet)\b/i;
const TOKENS = /[^\s:-]+|./g;
const WHITESPACE = /\s/;
const IS_MANUAL_CASE = /.(?=[A-Z]|\..)/;
const ALPHANUMERIC_PATTERN = /[A-Za-z0-9\u00C0-\u00FF]/;
function titleCase(input) {
  let output = "";
  let result2;
  while ((result2 = TOKENS.exec(input)) !== null) {
    const { 0: token2, index: index2 } = result2;
    if (!IS_MANUAL_CASE.test(token2) && (!SMALL_WORDS.test(token2) || index2 === 0 || index2 + token2.length === input.length) && (input.charAt(index2 + token2.length) !== ":" || WHITESPACE.test(input.charAt(index2 + token2.length + 1)))) {
      output += token2.replace(ALPHANUMERIC_PATTERN, (char2) => char2.toUpperCase());
      continue;
    }
    output += token2;
  }
  return output;
}
function camelCase(value) {
  return camelCase$1(value);
}
function snakeCase(value) {
  return snakeCase$1(value);
}
function dashCase(value, options) {
  if (options && options.capitalize) return trainCase(value);
  return kebabCase(value);
}
function pascalCase(value) {
  return pascalCase$1(value);
}
function capitalCase(value) {
  return capitalCase$1(value);
}
function sentenceCase(value) {
  return noCase(value, (input, index2) => {
    const result2 = input.toLowerCase();
    if (index2 === 0) return input.charAt(0).toUpperCase() + input.substring(1);
    return result2;
  });
}
function dotCase(value, options) {
  const transformedValue = dotNotation(value);
  if (options && options.lowerCase) return transformedValue.toLowerCase();
  return transformedValue;
}
function noCase(value, transform2) {
  let result2 = NO_CASE_SPLIT_REGEXP.reduce((input, regex) => input.replace(regex, "$1\0$2"), value);
  result2 = result2.replace(NO_CASE_STRIP_REGEXP, "\0");
  let start = 0;
  let end = result2.length;
  while (result2.charAt(start) === "\0") start++;
  while (result2.charAt(end - 1) === "\0") end--;
  return result2.slice(start, end).split("\0").map(transform2 || ((input) => input.toLowerCase())).join(" ");
}
function condenseWhitespace(value) {
  return value.trim().replace(/\s{2,}/g, " ");
}
var string_default = {
  excerpt,
  truncate,
  slug,
  interpolate: interpolate$1,
  plural,
  pluralize,
  singular,
  isPlural,
  isSingular,
  camelCase,
  capitalCase,
  dashCase,
  dotCase,
  noCase,
  pascalCase,
  sentenceCase,
  snakeCase,
  titleCase,
  random: random$1,
  sentence,
  condenseWhitespace,
  wordWrap,
  seconds: seconds_default,
  milliseconds: milliseconds_default,
  bytes: bytes_default,
  ordinal,
  htmlEscape,
  justify,
  uuid,
  toUnixSlash
};
var ObjectBuilder = class {
  #ignoreNull;
  values;
  constructor(initialValue, ignoreNull) {
    this.values = initialValue;
    this.#ignoreNull = ignoreNull === true ? true : false;
  }
  add(key, value) {
    if (value === void 0) {
      return this;
    }
    if (this.#ignoreNull === true && value === null) {
      return this;
    }
    this.values[key] = value;
    return this;
  }
  /**
   * Remove key from the object
   */
  remove(key) {
    delete this.values[key];
    return this;
  }
  /**
   * Find if a value exists
   */
  has(key) {
    return this.get(key) !== void 0;
  }
  /**
   * Get the existing value for a given key
   */
  get(key) {
    return this.values[key];
  }
  /**
   * Get the underlying constructed object
   */
  toObject() {
    return this.values;
  }
};
const object_builder_star = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ObjectBuilder
}, Symbol.toStringTag, { value: "Module" }));
var object_builder_exports = {};
__reExport(object_builder_exports, object_builder_star);
object_builder_exports.ObjectBuilder;
var main_default = string_default;
var __defProp = Object.defineProperty;
var __export = (target, all2) => {
  for (var name2 in all2)
    __defProp(target, name2, { get: all2[name2], enumerable: true });
};
var errors_exports = {};
__export(errors_exports, {
  E_CANNOT_CHECK_FILE_EXISTENCE: () => E_CANNOT_CHECK_FILE_EXISTENCE,
  E_CANNOT_COPY_FILE: () => E_CANNOT_COPY_FILE,
  E_CANNOT_DELETE_DIRECTORY: () => E_CANNOT_DELETE_DIRECTORY,
  E_CANNOT_DELETE_FILE: () => E_CANNOT_DELETE_FILE,
  E_CANNOT_GENERATE_URL: () => E_CANNOT_GENERATE_URL,
  E_CANNOT_GET_METADATA: () => E_CANNOT_GET_METADATA,
  E_CANNOT_MOVE_FILE: () => E_CANNOT_MOVE_FILE,
  E_CANNOT_READ_FILE: () => E_CANNOT_READ_FILE,
  E_CANNOT_SET_VISIBILITY: () => E_CANNOT_SET_VISIBILITY,
  E_CANNOT_WRITE_FILE: () => E_CANNOT_WRITE_FILE,
  E_INVALID_KEY: () => E_INVALID_KEY,
  E_PATH_TRAVERSAL_DETECTED: () => E_PATH_TRAVERSAL_DETECTED,
  E_UNALLOWED_CHARACTERS: () => E_UNALLOWED_CHARACTERS
});
var E_CANNOT_WRITE_FILE = createError(
  'Cannot write file at location "%s"',
  "E_CANNOT_WRITE_FILE"
);
var E_CANNOT_READ_FILE = createError(
  'Cannot read file from location "%s"',
  "E_CANNOT_READ_FILE"
);
var E_CANNOT_DELETE_FILE = createError(
  'Cannot delete file at location "%s"',
  "E_CANNOT_DELETE_FILE"
);
var E_CANNOT_DELETE_DIRECTORY = createError(
  'Cannot delete directory at location "%s"',
  "E_CANNOT_DELETE_DIRECTORY"
);
var E_CANNOT_COPY_FILE = createError(
  'Cannot copy file from "%s" to "%s"',
  "E_CANNOT_COPY_FILE"
);
var E_CANNOT_MOVE_FILE = createError(
  'Cannot move file from "%s" to "%s"',
  "E_CANNOT_MOVE_FILE"
);
var E_CANNOT_CHECK_FILE_EXISTENCE = createError(
  'Unable to check existence for file at location "%s"',
  "E_CANNOT_CHECK_FILE_EXISTENCE"
);
var E_CANNOT_GET_METADATA = createError(
  'Unable to retrieve metadata of file at location "%s"',
  "E_CANNOT_GET_METADATA"
);
var E_CANNOT_SET_VISIBILITY = createError(
  'Unable to set visibility for file at location "%s"',
  "E_CANNOT_SET_VISIBILITY"
);
var E_CANNOT_GENERATE_URL = createError(
  'Cannot generate URL for file at location "%s"',
  "E_CANNOT_GENERATE_URL"
);
var E_UNALLOWED_CHARACTERS = createError(
  'The key "%s" has unallowed characters',
  "E_UNALLOWED_CHARACTERS"
);
var E_INVALID_KEY = createError(
  'Invalid key "%s". After normalization results in an empty string',
  "E_INVALID_KEY"
);
var E_PATH_TRAVERSAL_DETECTED = createError(
  'Path traversal segment detected in key "%s"',
  "E_PATH_TRAVERSAL_DETECTED"
);
var KeyNormalizer = class _KeyNormalizer {
  /**
   * The set of allowed characters. Key free to re-assign a new
   * value
   */
  static allowedCharacterSet = /^[A-Za-z0-9-_!\/\.\s]*$/;
  /**
   * Normalizes the key by condensing whitespaces, using unix
   * slashes, and replacing consecutive slashes with one
   * slash ("/").
   */
  #preNormalize(key) {
    let normalizedKey = main_default.condenseWhitespace(key);
    return slash(normalizedKey).replace(/\/{2,}/g, "/").replace(/\.{3,}\//g, "../");
  }
  /**
   * Validates the key to check for unallowed characters
   */
  #validateCharacterSet(key, originalKey) {
    if (!_KeyNormalizer.allowedCharacterSet.test(key)) {
      throw new E_UNALLOWED_CHARACTERS([originalKey]);
    }
  }
  /**
   * Checks for path traversel in key
   */
  #checkForPathTraversal(key, originalKey) {
    const tokens = key.split("/");
    for (let token2 of tokens) {
      if (token2 === "..") {
        throw new E_PATH_TRAVERSAL_DETECTED([originalKey]);
      }
    }
  }
  /**
   * Further normalizing the key after validating it. Here we remove
   * starting and ending path expressions like "." and "/" from
   * the key.
   */
  #postNormalize(key) {
    let normalizedKey = normalize$1(key);
    return normalizedKey.replace(/^\/|\/$/g, "").replace(/^\.|\.$/g, "");
  }
  /**
   * Normalize the key
   */
  normalize(key) {
    let normalizedKey = this.#preNormalize(key);
    this.#validateCharacterSet(normalizedKey, key);
    this.#checkForPathTraversal(normalizedKey, key);
    normalizedKey = this.#postNormalize(normalizedKey);
    if (normalizedKey.trim() === "") {
      throw new E_INVALID_KEY([key]);
    }
    return normalizedKey;
  }
};
var DriveFile = class {
  /**
   * The driver to use for performing read-only operations
   */
  #driver;
  /**
   * Known metadata from the snapshot or from the files listing
   * API
   */
  #metaData;
  /**
   * The normalizer is used to normalize and validate keys
   */
  #normalizer = new KeyNormalizer();
  /**
   * Reference to the normalized file key
   */
  key;
  /**
   * The basename of the file. Extracted from the key
   */
  name;
  /**
   * Flags to know if the object is a file or a directory
   */
  isFile = true;
  isDirectory = false;
  constructor(key, driver, metaData) {
    this.#driver = driver;
    this.#metaData = metaData;
    this.key = this.#normalizer.normalize(key);
    this.name = basename(this.key);
  }
  /**
   * Check if the file exists. This method cannot check existence
   * of directories.
   */
  async exists() {
    try {
      return await this.#driver.exists(this.key);
    } catch (error2) {
      throw new E_CANNOT_CHECK_FILE_EXISTENCE([this.key], { cause: error2 });
    }
  }
  /**
   * Returns file contents as a UTF-8 string. Use "getArrayBuffer" method
   * if you need more control over the file contents decoding.
   */
  async get() {
    try {
      return await this.#driver.get(this.key);
    } catch (error2) {
      throw new E_CANNOT_READ_FILE([this.key], { cause: error2 });
    }
  }
  /**
   * Returns file contents as a Readable stream.
   */
  async getStream() {
    try {
      return await this.#driver.getStream(this.key);
    } catch (error2) {
      throw new E_CANNOT_READ_FILE([this.key], { cause: error2 });
    }
  }
  /**
   * Returns file contents as a Uint8Array.
   */
  async getBytes() {
    try {
      return await this.#driver.getBytes(this.key);
    } catch (error2) {
      throw new E_CANNOT_READ_FILE([this.key], { cause: error2 });
    }
  }
  /**
   * @deprecated
   * @see {@link DriveFile.getBytes}
   */
  async getArrayBuffer() {
    process.emitWarning(
      'getArrayBuffer() method has been deprecated. Instead use "getBytes"',
      "DeprecationWarning"
    );
    return this.getBytes();
  }
  /**
   * Returns metadata of the given file.
   */
  async getMetaData() {
    if (this.#metaData) {
      return this.#metaData;
    }
    try {
      return await this.#driver.getMetaData(this.key);
    } catch (error2) {
      throw new E_CANNOT_GET_METADATA([this.key], { cause: error2 });
    }
  }
  /**
   * Returns the visibility of the file
   */
  async getVisibility() {
    try {
      return await this.#driver.getVisibility(this.key);
    } catch (error2) {
      throw new E_CANNOT_GET_METADATA([this.key], { cause: error2 });
    }
  }
  /**
   * Returns the public URL of the file
   */
  async getUrl() {
    try {
      return await this.#driver.getUrl(this.key);
    } catch (error2) {
      throw new E_CANNOT_GENERATE_URL([this.key], { cause: error2 });
    }
  }
  /**
   * Returns a signed/temporary URL of the file
   */
  async getSignedUrl(options) {
    try {
      return await this.#driver.getSignedUrl(this.key, options);
    } catch (error2) {
      throw new E_CANNOT_GENERATE_URL([this.key], { cause: error2 });
    }
  }
  /**
   * Returns a signed/temporary URL that can be used to directly upload
   * the file contents to the storage.
   */
  async getSignedUploadUrl(options) {
    try {
      return await this.#driver.getSignedUploadUrl(this.key, options);
    } catch (error2) {
      throw new E_CANNOT_GENERATE_URL([this.key], { cause: error2 });
    }
  }
  /**
   * Returns a snapshot of the file. The snapshot could be persisted
   * within any database storage and later you can create a file
   * instance from it using the "disk.fromSnapshot" method.
   */
  async toSnapshot() {
    const metaData = await this.getMetaData();
    return {
      key: this.key,
      name: this.name,
      contentLength: metaData.contentLength,
      lastModified: metaData.lastModified.toString(),
      etag: metaData.etag,
      contentType: metaData.contentType
    };
  }
};
var DriveDirectory = class {
  constructor(prefix) {
    this.prefix = prefix;
    this.name = basename(this.prefix);
  }
  isFile = false;
  isDirectory = true;
  name;
};
var etag_1;
var hasRequiredEtag;
function requireEtag() {
  if (hasRequiredEtag) return etag_1;
  hasRequiredEtag = 1;
  etag_1 = etag2;
  var crypto2 = require$$0$5;
  var Stats = require$$1$2.Stats;
  var toString = Object.prototype.toString;
  function entitytag(entity) {
    if (entity.length === 0) {
      return '"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk"';
    }
    var hash = crypto2.createHash("sha1").update(entity, "utf8").digest("base64").substring(0, 27);
    var len = typeof entity === "string" ? Buffer.byteLength(entity, "utf8") : entity.length;
    return '"' + len.toString(16) + "-" + hash + '"';
  }
  function etag2(entity, options) {
    if (entity == null) {
      throw new TypeError("argument entity is required");
    }
    var isStats = isstats(entity);
    var weak = options && typeof options.weak === "boolean" ? options.weak : isStats;
    if (!isStats && typeof entity !== "string" && !Buffer.isBuffer(entity)) {
      throw new TypeError("argument entity must be string, Buffer, or fs.Stats");
    }
    var tag2 = isStats ? stattag(entity) : entitytag(entity);
    return weak ? "W/" + tag2 : tag2;
  }
  function isstats(obj) {
    if (typeof Stats === "function" && obj instanceof Stats) {
      return true;
    }
    return obj && typeof obj === "object" && "ctime" in obj && toString.call(obj.ctime) === "[object Date]" && "mtime" in obj && toString.call(obj.mtime) === "[object Date]" && "ino" in obj && typeof obj.ino === "number" && "size" in obj && typeof obj.size === "number";
  }
  function stattag(stat) {
    var mtime = stat.mtime.getTime().toString(16);
    var size = stat.size.toString(16);
    return '"' + size + "-" + mtime + '"';
  }
  return etag_1;
}
var etagExports = requireEtag();
const etag = /* @__PURE__ */ getDefaultExportFromCjs(etagExports);
var mimeTypes$1 = {};
const require$$0$4 = {
  "application/1d-interleaved-parityfec": { "source": "iana" },
  "application/3gpdash-qoe-report+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/3gpp-ims+xml": { "source": "iana", "compressible": true },
  "application/3gpphal+json": { "source": "iana", "compressible": true },
  "application/3gpphalforms+json": { "source": "iana", "compressible": true },
  "application/a2l": { "source": "iana" },
  "application/ace+cbor": { "source": "iana" },
  "application/ace+json": { "source": "iana", "compressible": true },
  "application/ace-groupcomm+cbor": { "source": "iana" },
  "application/ace-trl+cbor": { "source": "iana" },
  "application/activemessage": { "source": "iana" },
  "application/activity+json": { "source": "iana", "compressible": true },
  "application/aif+cbor": { "source": "iana" },
  "application/aif+json": { "source": "iana", "compressible": true },
  "application/alto-cdni+json": { "source": "iana", "compressible": true },
  "application/alto-cdnifilter+json": { "source": "iana", "compressible": true },
  "application/alto-costmap+json": { "source": "iana", "compressible": true },
  "application/alto-costmapfilter+json": { "source": "iana", "compressible": true },
  "application/alto-directory+json": { "source": "iana", "compressible": true },
  "application/alto-endpointcost+json": { "source": "iana", "compressible": true },
  "application/alto-endpointcostparams+json": { "source": "iana", "compressible": true },
  "application/alto-endpointprop+json": { "source": "iana", "compressible": true },
  "application/alto-endpointpropparams+json": { "source": "iana", "compressible": true },
  "application/alto-error+json": { "source": "iana", "compressible": true },
  "application/alto-networkmap+json": { "source": "iana", "compressible": true },
  "application/alto-networkmapfilter+json": { "source": "iana", "compressible": true },
  "application/alto-propmap+json": { "source": "iana", "compressible": true },
  "application/alto-propmapparams+json": { "source": "iana", "compressible": true },
  "application/alto-tips+json": { "source": "iana", "compressible": true },
  "application/alto-tipsparams+json": { "source": "iana", "compressible": true },
  "application/alto-updatestreamcontrol+json": { "source": "iana", "compressible": true },
  "application/alto-updatestreamparams+json": { "source": "iana", "compressible": true },
  "application/aml": { "source": "iana" },
  "application/andrew-inset": { "source": "iana", "extensions": ["ez"] },
  "application/appinstaller": { "compressible": false, "extensions": ["appinstaller"] },
  "application/applefile": { "source": "iana" },
  "application/applixware": { "source": "apache", "extensions": ["aw"] },
  "application/appx": { "compressible": false, "extensions": ["appx"] },
  "application/appxbundle": { "compressible": false, "extensions": ["appxbundle"] },
  "application/at+jwt": { "source": "iana" },
  "application/atf": { "source": "iana" },
  "application/atfx": { "source": "iana" },
  "application/atom+xml": { "source": "iana", "compressible": true, "extensions": ["atom"] },
  "application/atomcat+xml": { "source": "iana", "compressible": true, "extensions": ["atomcat"] },
  "application/atomdeleted+xml": { "source": "iana", "compressible": true, "extensions": ["atomdeleted"] },
  "application/atomicmail": { "source": "iana" },
  "application/atomsvc+xml": { "source": "iana", "compressible": true, "extensions": ["atomsvc"] },
  "application/atsc-dwd+xml": { "source": "iana", "compressible": true, "extensions": ["dwd"] },
  "application/atsc-dynamic-event-message": { "source": "iana" },
  "application/atsc-held+xml": { "source": "iana", "compressible": true, "extensions": ["held"] },
  "application/atsc-rdt+json": { "source": "iana", "compressible": true },
  "application/atsc-rsat+xml": { "source": "iana", "compressible": true, "extensions": ["rsat"] },
  "application/atxml": { "source": "iana" },
  "application/auth-policy+xml": { "source": "iana", "compressible": true },
  "application/automationml-aml+xml": { "source": "iana", "compressible": true, "extensions": ["aml"] },
  "application/automationml-amlx+zip": { "source": "iana", "compressible": false, "extensions": ["amlx"] },
  "application/bacnet-xdd+zip": { "source": "iana", "compressible": false },
  "application/batch-smtp": { "source": "iana" },
  "application/bdoc": { "compressible": false, "extensions": ["bdoc"] },
  "application/beep+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/bufr": { "source": "iana" },
  "application/c2pa": { "source": "iana" },
  "application/calendar+json": { "source": "iana", "compressible": true },
  "application/calendar+xml": { "source": "iana", "compressible": true, "extensions": ["xcs"] },
  "application/call-completion": { "source": "iana" },
  "application/cals-1840": { "source": "iana" },
  "application/captive+json": { "source": "iana", "compressible": true },
  "application/cbor": { "source": "iana" },
  "application/cbor-seq": { "source": "iana" },
  "application/cccex": { "source": "iana" },
  "application/ccmp+xml": { "source": "iana", "compressible": true },
  "application/ccxml+xml": { "source": "iana", "compressible": true, "extensions": ["ccxml"] },
  "application/cda+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/cdfx+xml": { "source": "iana", "compressible": true, "extensions": ["cdfx"] },
  "application/cdmi-capability": { "source": "iana", "extensions": ["cdmia"] },
  "application/cdmi-container": { "source": "iana", "extensions": ["cdmic"] },
  "application/cdmi-domain": { "source": "iana", "extensions": ["cdmid"] },
  "application/cdmi-object": { "source": "iana", "extensions": ["cdmio"] },
  "application/cdmi-queue": { "source": "iana", "extensions": ["cdmiq"] },
  "application/cdni": { "source": "iana" },
  "application/ce+cbor": { "source": "iana" },
  "application/cea": { "source": "iana" },
  "application/cea-2018+xml": { "source": "iana", "compressible": true },
  "application/cellml+xml": { "source": "iana", "compressible": true },
  "application/cfw": { "source": "iana" },
  "application/cid-edhoc+cbor-seq": { "source": "iana" },
  "application/city+json": { "source": "iana", "compressible": true },
  "application/city+json-seq": { "source": "iana" },
  "application/clr": { "source": "iana" },
  "application/clue+xml": { "source": "iana", "compressible": true },
  "application/clue_info+xml": { "source": "iana", "compressible": true },
  "application/cms": { "source": "iana" },
  "application/cnrp+xml": { "source": "iana", "compressible": true },
  "application/coap-eap": { "source": "iana" },
  "application/coap-group+json": { "source": "iana", "compressible": true },
  "application/coap-payload": { "source": "iana" },
  "application/commonground": { "source": "iana" },
  "application/concise-problem-details+cbor": { "source": "iana" },
  "application/conference-info+xml": { "source": "iana", "compressible": true },
  "application/cose": { "source": "iana" },
  "application/cose-key": { "source": "iana" },
  "application/cose-key-set": { "source": "iana" },
  "application/cose-x509": { "source": "iana" },
  "application/cpl+xml": { "source": "iana", "compressible": true, "extensions": ["cpl"] },
  "application/csrattrs": { "source": "iana" },
  "application/csta+xml": { "source": "iana", "compressible": true },
  "application/cstadata+xml": { "source": "iana", "compressible": true },
  "application/csvm+json": { "source": "iana", "compressible": true },
  "application/cu-seeme": { "source": "apache", "extensions": ["cu"] },
  "application/cwl": { "source": "iana", "extensions": ["cwl"] },
  "application/cwl+json": { "source": "iana", "compressible": true },
  "application/cwl+yaml": { "source": "iana" },
  "application/cwt": { "source": "iana" },
  "application/cybercash": { "source": "iana" },
  "application/dart": { "compressible": true },
  "application/dash+xml": { "source": "iana", "compressible": true, "extensions": ["mpd"] },
  "application/dash-patch+xml": { "source": "iana", "compressible": true, "extensions": ["mpp"] },
  "application/dashdelta": { "source": "iana" },
  "application/davmount+xml": { "source": "iana", "compressible": true, "extensions": ["davmount"] },
  "application/dca-rft": { "source": "iana" },
  "application/dcd": { "source": "iana" },
  "application/dec-dx": { "source": "iana" },
  "application/dialog-info+xml": { "source": "iana", "compressible": true },
  "application/dicom": { "source": "iana", "extensions": ["dcm"] },
  "application/dicom+json": { "source": "iana", "compressible": true },
  "application/dicom+xml": { "source": "iana", "compressible": true },
  "application/dii": { "source": "iana" },
  "application/dit": { "source": "iana" },
  "application/dns": { "source": "iana" },
  "application/dns+json": { "source": "iana", "compressible": true },
  "application/dns-message": { "source": "iana" },
  "application/docbook+xml": { "source": "apache", "compressible": true, "extensions": ["dbk"] },
  "application/dots+cbor": { "source": "iana" },
  "application/dpop+jwt": { "source": "iana" },
  "application/dskpp+xml": { "source": "iana", "compressible": true },
  "application/dssc+der": { "source": "iana", "extensions": ["dssc"] },
  "application/dssc+xml": { "source": "iana", "compressible": true, "extensions": ["xdssc"] },
  "application/dvcs": { "source": "iana" },
  "application/eat+cwt": { "source": "iana" },
  "application/eat+jwt": { "source": "iana" },
  "application/eat-bun+cbor": { "source": "iana" },
  "application/eat-bun+json": { "source": "iana", "compressible": true },
  "application/eat-ucs+cbor": { "source": "iana" },
  "application/eat-ucs+json": { "source": "iana", "compressible": true },
  "application/ecmascript": { "source": "apache", "compressible": true, "extensions": ["ecma"] },
  "application/edhoc+cbor-seq": { "source": "iana" },
  "application/edi-consent": { "source": "iana" },
  "application/edi-x12": { "source": "iana", "compressible": false },
  "application/edifact": { "source": "iana", "compressible": false },
  "application/efi": { "source": "iana" },
  "application/elm+json": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/elm+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.cap+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/emergencycalldata.comment+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.control+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.deviceinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.ecall.msd": { "source": "iana" },
  "application/emergencycalldata.legacyesn+json": { "source": "iana", "compressible": true },
  "application/emergencycalldata.providerinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.serviceinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.subscriberinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.veds+xml": { "source": "iana", "compressible": true },
  "application/emma+xml": { "source": "iana", "compressible": true, "extensions": ["emma"] },
  "application/emotionml+xml": { "source": "iana", "compressible": true, "extensions": ["emotionml"] },
  "application/encaprtp": { "source": "iana" },
  "application/entity-statement+jwt": { "source": "iana" },
  "application/epp+xml": { "source": "iana", "compressible": true },
  "application/epub+zip": { "source": "iana", "compressible": false, "extensions": ["epub"] },
  "application/eshop": { "source": "iana" },
  "application/exi": { "source": "iana", "extensions": ["exi"] },
  "application/expect-ct-report+json": { "source": "iana", "compressible": true },
  "application/express": { "source": "iana", "extensions": ["exp"] },
  "application/fastinfoset": { "source": "iana" },
  "application/fastsoap": { "source": "iana" },
  "application/fdf": { "source": "iana", "extensions": ["fdf"] },
  "application/fdt+xml": { "source": "iana", "compressible": true, "extensions": ["fdt"] },
  "application/fhir+json": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/fhir+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/fido.trusted-apps+json": { "compressible": true },
  "application/fits": { "source": "iana" },
  "application/flexfec": { "source": "iana" },
  "application/font-sfnt": { "source": "iana" },
  "application/font-tdpfr": { "source": "iana", "extensions": ["pfr"] },
  "application/font-woff": { "source": "iana", "compressible": false },
  "application/framework-attributes+xml": { "source": "iana", "compressible": true },
  "application/geo+json": { "source": "iana", "compressible": true, "extensions": ["geojson"] },
  "application/geo+json-seq": { "source": "iana" },
  "application/geopackage+sqlite3": { "source": "iana" },
  "application/geopose+json": { "source": "iana", "compressible": true },
  "application/geoxacml+json": { "source": "iana", "compressible": true },
  "application/geoxacml+xml": { "source": "iana", "compressible": true },
  "application/gltf-buffer": { "source": "iana" },
  "application/gml+xml": { "source": "iana", "compressible": true, "extensions": ["gml"] },
  "application/gnap-binding-jws": { "source": "iana" },
  "application/gnap-binding-jwsd": { "source": "iana" },
  "application/gnap-binding-rotation-jws": { "source": "iana" },
  "application/gnap-binding-rotation-jwsd": { "source": "iana" },
  "application/gpx+xml": { "source": "apache", "compressible": true, "extensions": ["gpx"] },
  "application/grib": { "source": "iana" },
  "application/gxf": { "source": "apache", "extensions": ["gxf"] },
  "application/gzip": { "source": "iana", "compressible": false, "extensions": ["gz"] },
  "application/h224": { "source": "iana" },
  "application/held+xml": { "source": "iana", "compressible": true },
  "application/hjson": { "extensions": ["hjson"] },
  "application/hl7v2+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/http": { "source": "iana" },
  "application/hyperstudio": { "source": "iana", "extensions": ["stk"] },
  "application/ibe-key-request+xml": { "source": "iana", "compressible": true },
  "application/ibe-pkg-reply+xml": { "source": "iana", "compressible": true },
  "application/ibe-pp-data": { "source": "iana" },
  "application/iges": { "source": "iana" },
  "application/im-iscomposing+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/index": { "source": "iana" },
  "application/index.cmd": { "source": "iana" },
  "application/index.obj": { "source": "iana" },
  "application/index.response": { "source": "iana" },
  "application/index.vnd": { "source": "iana" },
  "application/inkml+xml": { "source": "iana", "compressible": true, "extensions": ["ink", "inkml"] },
  "application/iotp": { "source": "iana" },
  "application/ipfix": { "source": "iana", "extensions": ["ipfix"] },
  "application/ipp": { "source": "iana" },
  "application/isup": { "source": "iana" },
  "application/its+xml": { "source": "iana", "compressible": true, "extensions": ["its"] },
  "application/java-archive": { "source": "iana", "compressible": false, "extensions": ["jar", "war", "ear"] },
  "application/java-serialized-object": { "source": "apache", "compressible": false, "extensions": ["ser"] },
  "application/java-vm": { "source": "apache", "compressible": false, "extensions": ["class"] },
  "application/javascript": { "source": "apache", "charset": "UTF-8", "compressible": true, "extensions": ["js"] },
  "application/jf2feed+json": { "source": "iana", "compressible": true },
  "application/jose": { "source": "iana" },
  "application/jose+json": { "source": "iana", "compressible": true },
  "application/jrd+json": { "source": "iana", "compressible": true },
  "application/jscalendar+json": { "source": "iana", "compressible": true },
  "application/jscontact+json": { "source": "iana", "compressible": true },
  "application/json": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["json", "map"] },
  "application/json-patch+json": { "source": "iana", "compressible": true },
  "application/json-seq": { "source": "iana" },
  "application/json5": { "extensions": ["json5"] },
  "application/jsonml+json": { "source": "apache", "compressible": true, "extensions": ["jsonml"] },
  "application/jsonpath": { "source": "iana" },
  "application/jwk+json": { "source": "iana", "compressible": true },
  "application/jwk-set+json": { "source": "iana", "compressible": true },
  "application/jwk-set+jwt": { "source": "iana" },
  "application/jwt": { "source": "iana" },
  "application/kpml-request+xml": { "source": "iana", "compressible": true },
  "application/kpml-response+xml": { "source": "iana", "compressible": true },
  "application/ld+json": { "source": "iana", "compressible": true, "extensions": ["jsonld"] },
  "application/lgr+xml": { "source": "iana", "compressible": true, "extensions": ["lgr"] },
  "application/link-format": { "source": "iana" },
  "application/linkset": { "source": "iana" },
  "application/linkset+json": { "source": "iana", "compressible": true },
  "application/load-control+xml": { "source": "iana", "compressible": true },
  "application/logout+jwt": { "source": "iana" },
  "application/lost+xml": { "source": "iana", "compressible": true, "extensions": ["lostxml"] },
  "application/lostsync+xml": { "source": "iana", "compressible": true },
  "application/lpf+zip": { "source": "iana", "compressible": false },
  "application/lxf": { "source": "iana" },
  "application/mac-binhex40": { "source": "iana", "extensions": ["hqx"] },
  "application/mac-compactpro": { "source": "apache", "extensions": ["cpt"] },
  "application/macwriteii": { "source": "iana" },
  "application/mads+xml": { "source": "iana", "compressible": true, "extensions": ["mads"] },
  "application/manifest+json": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["webmanifest"] },
  "application/marc": { "source": "iana", "extensions": ["mrc"] },
  "application/marcxml+xml": { "source": "iana", "compressible": true, "extensions": ["mrcx"] },
  "application/mathematica": { "source": "iana", "extensions": ["ma", "nb", "mb"] },
  "application/mathml+xml": { "source": "iana", "compressible": true, "extensions": ["mathml"] },
  "application/mathml-content+xml": { "source": "iana", "compressible": true },
  "application/mathml-presentation+xml": { "source": "iana", "compressible": true },
  "application/mbms-associated-procedure-description+xml": { "source": "iana", "compressible": true },
  "application/mbms-deregister+xml": { "source": "iana", "compressible": true },
  "application/mbms-envelope+xml": { "source": "iana", "compressible": true },
  "application/mbms-msk+xml": { "source": "iana", "compressible": true },
  "application/mbms-msk-response+xml": { "source": "iana", "compressible": true },
  "application/mbms-protection-description+xml": { "source": "iana", "compressible": true },
  "application/mbms-reception-report+xml": { "source": "iana", "compressible": true },
  "application/mbms-register+xml": { "source": "iana", "compressible": true },
  "application/mbms-register-response+xml": { "source": "iana", "compressible": true },
  "application/mbms-schedule+xml": { "source": "iana", "compressible": true },
  "application/mbms-user-service-description+xml": { "source": "iana", "compressible": true },
  "application/mbox": { "source": "iana", "extensions": ["mbox"] },
  "application/media-policy-dataset+xml": { "source": "iana", "compressible": true, "extensions": ["mpf"] },
  "application/media_control+xml": { "source": "iana", "compressible": true },
  "application/mediaservercontrol+xml": { "source": "iana", "compressible": true, "extensions": ["mscml"] },
  "application/merge-patch+json": { "source": "iana", "compressible": true },
  "application/metalink+xml": { "source": "apache", "compressible": true, "extensions": ["metalink"] },
  "application/metalink4+xml": { "source": "iana", "compressible": true, "extensions": ["meta4"] },
  "application/mets+xml": { "source": "iana", "compressible": true, "extensions": ["mets"] },
  "application/mf4": { "source": "iana" },
  "application/mikey": { "source": "iana" },
  "application/mipc": { "source": "iana" },
  "application/missing-blocks+cbor-seq": { "source": "iana" },
  "application/mmt-aei+xml": { "source": "iana", "compressible": true, "extensions": ["maei"] },
  "application/mmt-usd+xml": { "source": "iana", "compressible": true, "extensions": ["musd"] },
  "application/mods+xml": { "source": "iana", "compressible": true, "extensions": ["mods"] },
  "application/moss-keys": { "source": "iana" },
  "application/moss-signature": { "source": "iana" },
  "application/mosskey-data": { "source": "iana" },
  "application/mosskey-request": { "source": "iana" },
  "application/mp21": { "source": "iana", "extensions": ["m21", "mp21"] },
  "application/mp4": { "source": "iana", "extensions": ["mp4", "mpg4", "mp4s", "m4p"] },
  "application/mpeg4-generic": { "source": "iana" },
  "application/mpeg4-iod": { "source": "iana" },
  "application/mpeg4-iod-xmt": { "source": "iana" },
  "application/mrb-consumer+xml": { "source": "iana", "compressible": true },
  "application/mrb-publish+xml": { "source": "iana", "compressible": true },
  "application/msc-ivr+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/msc-mixer+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/msix": { "compressible": false, "extensions": ["msix"] },
  "application/msixbundle": { "compressible": false, "extensions": ["msixbundle"] },
  "application/msword": { "source": "iana", "compressible": false, "extensions": ["doc", "dot"] },
  "application/mud+json": { "source": "iana", "compressible": true },
  "application/multipart-core": { "source": "iana" },
  "application/mxf": { "source": "iana", "extensions": ["mxf"] },
  "application/n-quads": { "source": "iana", "extensions": ["nq"] },
  "application/n-triples": { "source": "iana", "extensions": ["nt"] },
  "application/nasdata": { "source": "iana" },
  "application/news-checkgroups": { "source": "iana", "charset": "US-ASCII" },
  "application/news-groupinfo": { "source": "iana", "charset": "US-ASCII" },
  "application/news-transmission": { "source": "iana" },
  "application/nlsml+xml": { "source": "iana", "compressible": true },
  "application/node": { "source": "iana", "extensions": ["cjs"] },
  "application/nss": { "source": "iana" },
  "application/oauth-authz-req+jwt": { "source": "iana" },
  "application/oblivious-dns-message": { "source": "iana" },
  "application/ocsp-request": { "source": "iana" },
  "application/ocsp-response": { "source": "iana" },
  "application/octet-stream": { "source": "iana", "compressible": true, "extensions": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"] },
  "application/oda": { "source": "iana", "extensions": ["oda"] },
  "application/odm+xml": { "source": "iana", "compressible": true },
  "application/odx": { "source": "iana" },
  "application/oebps-package+xml": { "source": "iana", "compressible": true, "extensions": ["opf"] },
  "application/ogg": { "source": "iana", "compressible": false, "extensions": ["ogx"] },
  "application/ohttp-keys": { "source": "iana" },
  "application/omdoc+xml": { "source": "apache", "compressible": true, "extensions": ["omdoc"] },
  "application/onenote": { "source": "apache", "extensions": ["onetoc", "onetoc2", "onetmp", "onepkg", "one", "onea"] },
  "application/opc-nodeset+xml": { "source": "iana", "compressible": true },
  "application/oscore": { "source": "iana" },
  "application/oxps": { "source": "iana", "extensions": ["oxps"] },
  "application/p21": { "source": "iana" },
  "application/p21+zip": { "source": "iana", "compressible": false },
  "application/p2p-overlay+xml": { "source": "iana", "compressible": true, "extensions": ["relo"] },
  "application/parityfec": { "source": "iana" },
  "application/passport": { "source": "iana" },
  "application/patch-ops-error+xml": { "source": "iana", "compressible": true, "extensions": ["xer"] },
  "application/pdf": { "source": "iana", "compressible": false, "extensions": ["pdf"] },
  "application/pdx": { "source": "iana" },
  "application/pem-certificate-chain": { "source": "iana" },
  "application/pgp-encrypted": { "source": "iana", "compressible": false, "extensions": ["pgp"] },
  "application/pgp-keys": { "source": "iana", "extensions": ["asc"] },
  "application/pgp-signature": { "source": "iana", "extensions": ["sig", "asc"] },
  "application/pics-rules": { "source": "apache", "extensions": ["prf"] },
  "application/pidf+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/pidf-diff+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/pkcs10": { "source": "iana", "extensions": ["p10"] },
  "application/pkcs12": { "source": "iana" },
  "application/pkcs7-mime": { "source": "iana", "extensions": ["p7m", "p7c"] },
  "application/pkcs7-signature": { "source": "iana", "extensions": ["p7s"] },
  "application/pkcs8": { "source": "iana", "extensions": ["p8"] },
  "application/pkcs8-encrypted": { "source": "iana" },
  "application/pkix-attr-cert": { "source": "iana", "extensions": ["ac"] },
  "application/pkix-cert": { "source": "iana", "extensions": ["cer"] },
  "application/pkix-crl": { "source": "iana", "extensions": ["crl"] },
  "application/pkix-pkipath": { "source": "iana", "extensions": ["pkipath"] },
  "application/pkixcmp": { "source": "iana", "extensions": ["pki"] },
  "application/pls+xml": { "source": "iana", "compressible": true, "extensions": ["pls"] },
  "application/poc-settings+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/postscript": { "source": "iana", "compressible": true, "extensions": ["ai", "eps", "ps"] },
  "application/ppsp-tracker+json": { "source": "iana", "compressible": true },
  "application/private-token-issuer-directory": { "source": "iana" },
  "application/private-token-request": { "source": "iana" },
  "application/private-token-response": { "source": "iana" },
  "application/problem+json": { "source": "iana", "compressible": true },
  "application/problem+xml": { "source": "iana", "compressible": true },
  "application/provenance+xml": { "source": "iana", "compressible": true, "extensions": ["provx"] },
  "application/provided-claims+jwt": { "source": "iana" },
  "application/prs.alvestrand.titrax-sheet": { "source": "iana" },
  "application/prs.cww": { "source": "iana", "extensions": ["cww"] },
  "application/prs.cyn": { "source": "iana", "charset": "7-BIT" },
  "application/prs.hpub+zip": { "source": "iana", "compressible": false },
  "application/prs.implied-document+xml": { "source": "iana", "compressible": true },
  "application/prs.implied-executable": { "source": "iana" },
  "application/prs.implied-object+json": { "source": "iana", "compressible": true },
  "application/prs.implied-object+json-seq": { "source": "iana" },
  "application/prs.implied-object+yaml": { "source": "iana" },
  "application/prs.implied-structure": { "source": "iana" },
  "application/prs.mayfile": { "source": "iana" },
  "application/prs.nprend": { "source": "iana" },
  "application/prs.plucker": { "source": "iana" },
  "application/prs.rdf-xml-crypt": { "source": "iana" },
  "application/prs.vcfbzip2": { "source": "iana" },
  "application/prs.xsf+xml": { "source": "iana", "compressible": true, "extensions": ["xsf"] },
  "application/pskc+xml": { "source": "iana", "compressible": true, "extensions": ["pskcxml"] },
  "application/pvd+json": { "source": "iana", "compressible": true },
  "application/qsig": { "source": "iana" },
  "application/raml+yaml": { "compressible": true, "extensions": ["raml"] },
  "application/raptorfec": { "source": "iana" },
  "application/rdap+json": { "source": "iana", "compressible": true },
  "application/rdf+xml": { "source": "iana", "compressible": true, "extensions": ["rdf", "owl"] },
  "application/reginfo+xml": { "source": "iana", "compressible": true, "extensions": ["rif"] },
  "application/relax-ng-compact-syntax": { "source": "iana", "extensions": ["rnc"] },
  "application/remote-printing": { "source": "apache" },
  "application/reputon+json": { "source": "iana", "compressible": true },
  "application/resolve-response+jwt": { "source": "iana" },
  "application/resource-lists+xml": { "source": "iana", "compressible": true, "extensions": ["rl"] },
  "application/resource-lists-diff+xml": { "source": "iana", "compressible": true, "extensions": ["rld"] },
  "application/rfc+xml": { "source": "iana", "compressible": true },
  "application/riscos": { "source": "iana" },
  "application/rlmi+xml": { "source": "iana", "compressible": true },
  "application/rls-services+xml": { "source": "iana", "compressible": true, "extensions": ["rs"] },
  "application/route-apd+xml": { "source": "iana", "compressible": true, "extensions": ["rapd"] },
  "application/route-s-tsid+xml": { "source": "iana", "compressible": true, "extensions": ["sls"] },
  "application/route-usd+xml": { "source": "iana", "compressible": true, "extensions": ["rusd"] },
  "application/rpki-checklist": { "source": "iana" },
  "application/rpki-ghostbusters": { "source": "iana", "extensions": ["gbr"] },
  "application/rpki-manifest": { "source": "iana", "extensions": ["mft"] },
  "application/rpki-publication": { "source": "iana" },
  "application/rpki-roa": { "source": "iana", "extensions": ["roa"] },
  "application/rpki-signed-tal": { "source": "iana" },
  "application/rpki-updown": { "source": "iana" },
  "application/rsd+xml": { "source": "apache", "compressible": true, "extensions": ["rsd"] },
  "application/rss+xml": { "source": "apache", "compressible": true, "extensions": ["rss"] },
  "application/rtf": { "source": "iana", "compressible": true, "extensions": ["rtf"] },
  "application/rtploopback": { "source": "iana" },
  "application/rtx": { "source": "iana" },
  "application/samlassertion+xml": { "source": "iana", "compressible": true },
  "application/samlmetadata+xml": { "source": "iana", "compressible": true },
  "application/sarif+json": { "source": "iana", "compressible": true },
  "application/sarif-external-properties+json": { "source": "iana", "compressible": true },
  "application/sbe": { "source": "iana" },
  "application/sbml+xml": { "source": "iana", "compressible": true, "extensions": ["sbml"] },
  "application/scaip+xml": { "source": "iana", "compressible": true },
  "application/scim+json": { "source": "iana", "compressible": true },
  "application/scvp-cv-request": { "source": "iana", "extensions": ["scq"] },
  "application/scvp-cv-response": { "source": "iana", "extensions": ["scs"] },
  "application/scvp-vp-request": { "source": "iana", "extensions": ["spq"] },
  "application/scvp-vp-response": { "source": "iana", "extensions": ["spp"] },
  "application/sdp": { "source": "iana", "extensions": ["sdp"] },
  "application/secevent+jwt": { "source": "iana" },
  "application/senml+cbor": { "source": "iana" },
  "application/senml+json": { "source": "iana", "compressible": true },
  "application/senml+xml": { "source": "iana", "compressible": true, "extensions": ["senmlx"] },
  "application/senml-etch+cbor": { "source": "iana" },
  "application/senml-etch+json": { "source": "iana", "compressible": true },
  "application/senml-exi": { "source": "iana" },
  "application/sensml+cbor": { "source": "iana" },
  "application/sensml+json": { "source": "iana", "compressible": true },
  "application/sensml+xml": { "source": "iana", "compressible": true, "extensions": ["sensmlx"] },
  "application/sensml-exi": { "source": "iana" },
  "application/sep+xml": { "source": "iana", "compressible": true },
  "application/sep-exi": { "source": "iana" },
  "application/session-info": { "source": "iana" },
  "application/set-payment": { "source": "iana" },
  "application/set-payment-initiation": { "source": "iana", "extensions": ["setpay"] },
  "application/set-registration": { "source": "iana" },
  "application/set-registration-initiation": { "source": "iana", "extensions": ["setreg"] },
  "application/sgml": { "source": "iana" },
  "application/sgml-open-catalog": { "source": "iana" },
  "application/shf+xml": { "source": "iana", "compressible": true, "extensions": ["shf"] },
  "application/sieve": { "source": "iana", "extensions": ["siv", "sieve"] },
  "application/simple-filter+xml": { "source": "iana", "compressible": true },
  "application/simple-message-summary": { "source": "iana" },
  "application/simplesymbolcontainer": { "source": "iana" },
  "application/sipc": { "source": "iana" },
  "application/slate": { "source": "iana" },
  "application/smil": { "source": "apache" },
  "application/smil+xml": { "source": "iana", "compressible": true, "extensions": ["smi", "smil"] },
  "application/smpte336m": { "source": "iana" },
  "application/soap+fastinfoset": { "source": "iana" },
  "application/soap+xml": { "source": "iana", "compressible": true },
  "application/sparql-query": { "source": "iana", "extensions": ["rq"] },
  "application/sparql-results+xml": { "source": "iana", "compressible": true, "extensions": ["srx"] },
  "application/spdx+json": { "source": "iana", "compressible": true },
  "application/spirits-event+xml": { "source": "iana", "compressible": true },
  "application/sql": { "source": "iana", "extensions": ["sql"] },
  "application/srgs": { "source": "iana", "extensions": ["gram"] },
  "application/srgs+xml": { "source": "iana", "compressible": true, "extensions": ["grxml"] },
  "application/sru+xml": { "source": "iana", "compressible": true, "extensions": ["sru"] },
  "application/ssdl+xml": { "source": "apache", "compressible": true, "extensions": ["ssdl"] },
  "application/sslkeylogfile": { "source": "iana" },
  "application/ssml+xml": { "source": "iana", "compressible": true, "extensions": ["ssml"] },
  "application/st2110-41": { "source": "iana" },
  "application/stix+json": { "source": "iana", "compressible": true },
  "application/stratum": { "source": "iana" },
  "application/swid+cbor": { "source": "iana" },
  "application/swid+xml": { "source": "iana", "compressible": true, "extensions": ["swidtag"] },
  "application/tamp-apex-update": { "source": "iana" },
  "application/tamp-apex-update-confirm": { "source": "iana" },
  "application/tamp-community-update": { "source": "iana" },
  "application/tamp-community-update-confirm": { "source": "iana" },
  "application/tamp-error": { "source": "iana" },
  "application/tamp-sequence-adjust": { "source": "iana" },
  "application/tamp-sequence-adjust-confirm": { "source": "iana" },
  "application/tamp-status-query": { "source": "iana" },
  "application/tamp-status-response": { "source": "iana" },
  "application/tamp-update": { "source": "iana" },
  "application/tamp-update-confirm": { "source": "iana" },
  "application/tar": { "compressible": true },
  "application/taxii+json": { "source": "iana", "compressible": true },
  "application/td+json": { "source": "iana", "compressible": true },
  "application/tei+xml": { "source": "iana", "compressible": true, "extensions": ["tei", "teicorpus"] },
  "application/tetra_isi": { "source": "iana" },
  "application/thraud+xml": { "source": "iana", "compressible": true, "extensions": ["tfi"] },
  "application/timestamp-query": { "source": "iana" },
  "application/timestamp-reply": { "source": "iana" },
  "application/timestamped-data": { "source": "iana", "extensions": ["tsd"] },
  "application/tlsrpt+gzip": { "source": "iana" },
  "application/tlsrpt+json": { "source": "iana", "compressible": true },
  "application/tm+json": { "source": "iana", "compressible": true },
  "application/tnauthlist": { "source": "iana" },
  "application/toc+cbor": { "source": "iana" },
  "application/token-introspection+jwt": { "source": "iana" },
  "application/toml": { "source": "iana", "compressible": true, "extensions": ["toml"] },
  "application/trickle-ice-sdpfrag": { "source": "iana" },
  "application/trig": { "source": "iana", "extensions": ["trig"] },
  "application/trust-chain+json": { "source": "iana", "compressible": true },
  "application/trust-mark+jwt": { "source": "iana" },
  "application/trust-mark-delegation+jwt": { "source": "iana" },
  "application/ttml+xml": { "source": "iana", "compressible": true, "extensions": ["ttml"] },
  "application/tve-trigger": { "source": "iana" },
  "application/tzif": { "source": "iana" },
  "application/tzif-leap": { "source": "iana" },
  "application/ubjson": { "compressible": false, "extensions": ["ubj"] },
  "application/uccs+cbor": { "source": "iana" },
  "application/ujcs+json": { "source": "iana", "compressible": true },
  "application/ulpfec": { "source": "iana" },
  "application/urc-grpsheet+xml": { "source": "iana", "compressible": true },
  "application/urc-ressheet+xml": { "source": "iana", "compressible": true, "extensions": ["rsheet"] },
  "application/urc-targetdesc+xml": { "source": "iana", "compressible": true, "extensions": ["td"] },
  "application/urc-uisocketdesc+xml": { "source": "iana", "compressible": true },
  "application/vc": { "source": "iana" },
  "application/vc+cose": { "source": "iana" },
  "application/vc+jwt": { "source": "iana" },
  "application/vcard+json": { "source": "iana", "compressible": true },
  "application/vcard+xml": { "source": "iana", "compressible": true },
  "application/vemmi": { "source": "iana" },
  "application/vividence.scriptfile": { "source": "apache" },
  "application/vnd.1000minds.decision-model+xml": { "source": "iana", "compressible": true, "extensions": ["1km"] },
  "application/vnd.1ob": { "source": "iana" },
  "application/vnd.3gpp-prose+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp-prose-pc3a+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp-prose-pc3ach+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp-prose-pc3ch+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp-prose-pc8+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp-v2x-local-service-information": { "source": "iana" },
  "application/vnd.3gpp.5gnas": { "source": "iana" },
  "application/vnd.3gpp.5gsa2x": { "source": "iana" },
  "application/vnd.3gpp.5gsa2x-local-service-information": { "source": "iana" },
  "application/vnd.3gpp.5gsv2x": { "source": "iana" },
  "application/vnd.3gpp.5gsv2x-local-service-information": { "source": "iana" },
  "application/vnd.3gpp.access-transfer-events+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.bsf+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.crs+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.current-location-discovery+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.gmop+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.gtpc": { "source": "iana" },
  "application/vnd.3gpp.interworking-data": { "source": "iana" },
  "application/vnd.3gpp.lpp": { "source": "iana" },
  "application/vnd.3gpp.mc-signalling-ear": { "source": "iana" },
  "application/vnd.3gpp.mcdata-affiliation-command+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-msgstore-ctrl-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-payload": { "source": "iana" },
  "application/vnd.3gpp.mcdata-regroup+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-service-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-signalling": { "source": "iana" },
  "application/vnd.3gpp.mcdata-ue-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-user-profile+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-affiliation-command+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-floor-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-location-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-regroup+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-service-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-signed+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-ue-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-ue-init-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-user-profile+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-affiliation-command+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-location-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-regroup+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-service-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-transmission-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-ue-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-user-profile+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mid-call+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.ngap": { "source": "iana" },
  "application/vnd.3gpp.pfcp": { "source": "iana" },
  "application/vnd.3gpp.pic-bw-large": { "source": "iana", "extensions": ["plb"] },
  "application/vnd.3gpp.pic-bw-small": { "source": "iana", "extensions": ["psb"] },
  "application/vnd.3gpp.pic-bw-var": { "source": "iana", "extensions": ["pvb"] },
  "application/vnd.3gpp.pinapp-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.s1ap": { "source": "iana" },
  "application/vnd.3gpp.seal-group-doc+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.seal-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.seal-location-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.seal-mbms-usage-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.seal-network-qos-management-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.seal-ue-config-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.seal-unicast-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.seal-user-profile-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.sms": { "source": "iana" },
  "application/vnd.3gpp.sms+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.srvcc-ext+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.srvcc-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.state-and-event-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.ussd+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.v2x": { "source": "iana" },
  "application/vnd.3gpp.vae-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp2.bcmcsinfo+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp2.sms": { "source": "iana" },
  "application/vnd.3gpp2.tcap": { "source": "iana", "extensions": ["tcap"] },
  "application/vnd.3lightssoftware.imagescal": { "source": "iana" },
  "application/vnd.3m.post-it-notes": { "source": "iana", "extensions": ["pwn"] },
  "application/vnd.accpac.simply.aso": { "source": "iana", "extensions": ["aso"] },
  "application/vnd.accpac.simply.imp": { "source": "iana", "extensions": ["imp"] },
  "application/vnd.acm.addressxfer+json": { "source": "iana", "compressible": true },
  "application/vnd.acm.chatbot+json": { "source": "iana", "compressible": true },
  "application/vnd.acucobol": { "source": "iana", "extensions": ["acu"] },
  "application/vnd.acucorp": { "source": "iana", "extensions": ["atc", "acutc"] },
  "application/vnd.adobe.air-application-installer-package+zip": { "source": "apache", "compressible": false, "extensions": ["air"] },
  "application/vnd.adobe.flash.movie": { "source": "iana" },
  "application/vnd.adobe.formscentral.fcdt": { "source": "iana", "extensions": ["fcdt"] },
  "application/vnd.adobe.fxp": { "source": "iana", "extensions": ["fxp", "fxpl"] },
  "application/vnd.adobe.partial-upload": { "source": "iana" },
  "application/vnd.adobe.xdp+xml": { "source": "iana", "compressible": true, "extensions": ["xdp"] },
  "application/vnd.adobe.xfdf": { "source": "apache", "extensions": ["xfdf"] },
  "application/vnd.aether.imp": { "source": "iana" },
  "application/vnd.afpc.afplinedata": { "source": "iana" },
  "application/vnd.afpc.afplinedata-pagedef": { "source": "iana" },
  "application/vnd.afpc.cmoca-cmresource": { "source": "iana" },
  "application/vnd.afpc.foca-charset": { "source": "iana" },
  "application/vnd.afpc.foca-codedfont": { "source": "iana" },
  "application/vnd.afpc.foca-codepage": { "source": "iana" },
  "application/vnd.afpc.modca": { "source": "iana" },
  "application/vnd.afpc.modca-cmtable": { "source": "iana" },
  "application/vnd.afpc.modca-formdef": { "source": "iana" },
  "application/vnd.afpc.modca-mediummap": { "source": "iana" },
  "application/vnd.afpc.modca-objectcontainer": { "source": "iana" },
  "application/vnd.afpc.modca-overlay": { "source": "iana" },
  "application/vnd.afpc.modca-pagesegment": { "source": "iana" },
  "application/vnd.age": { "source": "iana", "extensions": ["age"] },
  "application/vnd.ah-barcode": { "source": "apache" },
  "application/vnd.ahead.space": { "source": "iana", "extensions": ["ahead"] },
  "application/vnd.airzip.filesecure.azf": { "source": "iana", "extensions": ["azf"] },
  "application/vnd.airzip.filesecure.azs": { "source": "iana", "extensions": ["azs"] },
  "application/vnd.amadeus+json": { "source": "iana", "compressible": true },
  "application/vnd.amazon.ebook": { "source": "apache", "extensions": ["azw"] },
  "application/vnd.amazon.mobi8-ebook": { "source": "iana" },
  "application/vnd.americandynamics.acc": { "source": "iana", "extensions": ["acc"] },
  "application/vnd.amiga.ami": { "source": "iana", "extensions": ["ami"] },
  "application/vnd.amundsen.maze+xml": { "source": "iana", "compressible": true },
  "application/vnd.android.ota": { "source": "iana" },
  "application/vnd.android.package-archive": { "source": "apache", "compressible": false, "extensions": ["apk"] },
  "application/vnd.anki": { "source": "iana" },
  "application/vnd.anser-web-certificate-issue-initiation": { "source": "iana", "extensions": ["cii"] },
  "application/vnd.anser-web-funds-transfer-initiation": { "source": "apache", "extensions": ["fti"] },
  "application/vnd.antix.game-component": { "source": "iana", "extensions": ["atx"] },
  "application/vnd.apache.arrow.file": { "source": "iana" },
  "application/vnd.apache.arrow.stream": { "source": "iana" },
  "application/vnd.apache.parquet": { "source": "iana" },
  "application/vnd.apache.thrift.binary": { "source": "iana" },
  "application/vnd.apache.thrift.compact": { "source": "iana" },
  "application/vnd.apache.thrift.json": { "source": "iana" },
  "application/vnd.apexlang": { "source": "iana" },
  "application/vnd.api+json": { "source": "iana", "compressible": true },
  "application/vnd.aplextor.warrp+json": { "source": "iana", "compressible": true },
  "application/vnd.apothekende.reservation+json": { "source": "iana", "compressible": true },
  "application/vnd.apple.installer+xml": { "source": "iana", "compressible": true, "extensions": ["mpkg"] },
  "application/vnd.apple.keynote": { "source": "iana", "extensions": ["key"] },
  "application/vnd.apple.mpegurl": { "source": "iana", "extensions": ["m3u8"] },
  "application/vnd.apple.numbers": { "source": "iana", "extensions": ["numbers"] },
  "application/vnd.apple.pages": { "source": "iana", "extensions": ["pages"] },
  "application/vnd.apple.pkpass": { "compressible": false, "extensions": ["pkpass"] },
  "application/vnd.arastra.swi": { "source": "apache" },
  "application/vnd.aristanetworks.swi": { "source": "iana", "extensions": ["swi"] },
  "application/vnd.artisan+json": { "source": "iana", "compressible": true },
  "application/vnd.artsquare": { "source": "iana" },
  "application/vnd.astraea-software.iota": { "source": "iana", "extensions": ["iota"] },
  "application/vnd.audiograph": { "source": "iana", "extensions": ["aep"] },
  "application/vnd.autodesk.fbx": { "extensions": ["fbx"] },
  "application/vnd.autopackage": { "source": "iana" },
  "application/vnd.avalon+json": { "source": "iana", "compressible": true },
  "application/vnd.avistar+xml": { "source": "iana", "compressible": true },
  "application/vnd.balsamiq.bmml+xml": { "source": "iana", "compressible": true, "extensions": ["bmml"] },
  "application/vnd.balsamiq.bmpr": { "source": "iana" },
  "application/vnd.banana-accounting": { "source": "iana" },
  "application/vnd.bbf.usp.error": { "source": "iana" },
  "application/vnd.bbf.usp.msg": { "source": "iana" },
  "application/vnd.bbf.usp.msg+json": { "source": "iana", "compressible": true },
  "application/vnd.bekitzur-stech+json": { "source": "iana", "compressible": true },
  "application/vnd.belightsoft.lhzd+zip": { "source": "iana", "compressible": false },
  "application/vnd.belightsoft.lhzl+zip": { "source": "iana", "compressible": false },
  "application/vnd.bint.med-content": { "source": "iana" },
  "application/vnd.biopax.rdf+xml": { "source": "iana", "compressible": true },
  "application/vnd.blink-idb-value-wrapper": { "source": "iana" },
  "application/vnd.blueice.multipass": { "source": "iana", "extensions": ["mpm"] },
  "application/vnd.bluetooth.ep.oob": { "source": "iana" },
  "application/vnd.bluetooth.le.oob": { "source": "iana" },
  "application/vnd.bmi": { "source": "iana", "extensions": ["bmi"] },
  "application/vnd.bpf": { "source": "iana" },
  "application/vnd.bpf3": { "source": "iana" },
  "application/vnd.businessobjects": { "source": "iana", "extensions": ["rep"] },
  "application/vnd.byu.uapi+json": { "source": "iana", "compressible": true },
  "application/vnd.bzip3": { "source": "iana" },
  "application/vnd.c3voc.schedule+xml": { "source": "iana", "compressible": true },
  "application/vnd.cab-jscript": { "source": "iana" },
  "application/vnd.canon-cpdl": { "source": "iana" },
  "application/vnd.canon-lips": { "source": "iana" },
  "application/vnd.capasystems-pg+json": { "source": "iana", "compressible": true },
  "application/vnd.cendio.thinlinc.clientconf": { "source": "iana" },
  "application/vnd.century-systems.tcp_stream": { "source": "iana" },
  "application/vnd.chemdraw+xml": { "source": "iana", "compressible": true, "extensions": ["cdxml"] },
  "application/vnd.chess-pgn": { "source": "iana" },
  "application/vnd.chipnuts.karaoke-mmd": { "source": "iana", "extensions": ["mmd"] },
  "application/vnd.ciedi": { "source": "iana" },
  "application/vnd.cinderella": { "source": "iana", "extensions": ["cdy"] },
  "application/vnd.cirpack.isdn-ext": { "source": "iana" },
  "application/vnd.citationstyles.style+xml": { "source": "iana", "compressible": true, "extensions": ["csl"] },
  "application/vnd.claymore": { "source": "iana", "extensions": ["cla"] },
  "application/vnd.cloanto.rp9": { "source": "iana", "extensions": ["rp9"] },
  "application/vnd.clonk.c4group": { "source": "iana", "extensions": ["c4g", "c4d", "c4f", "c4p", "c4u"] },
  "application/vnd.cluetrust.cartomobile-config": { "source": "iana", "extensions": ["c11amc"] },
  "application/vnd.cluetrust.cartomobile-config-pkg": { "source": "iana", "extensions": ["c11amz"] },
  "application/vnd.cncf.helm.chart.content.v1.tar+gzip": { "source": "iana" },
  "application/vnd.cncf.helm.chart.provenance.v1.prov": { "source": "iana" },
  "application/vnd.cncf.helm.config.v1+json": { "source": "iana", "compressible": true },
  "application/vnd.coffeescript": { "source": "iana" },
  "application/vnd.collabio.xodocuments.document": { "source": "iana" },
  "application/vnd.collabio.xodocuments.document-template": { "source": "iana" },
  "application/vnd.collabio.xodocuments.presentation": { "source": "iana" },
  "application/vnd.collabio.xodocuments.presentation-template": { "source": "iana" },
  "application/vnd.collabio.xodocuments.spreadsheet": { "source": "iana" },
  "application/vnd.collabio.xodocuments.spreadsheet-template": { "source": "iana" },
  "application/vnd.collection+json": { "source": "iana", "compressible": true },
  "application/vnd.collection.doc+json": { "source": "iana", "compressible": true },
  "application/vnd.collection.next+json": { "source": "iana", "compressible": true },
  "application/vnd.comicbook+zip": { "source": "iana", "compressible": false },
  "application/vnd.comicbook-rar": { "source": "iana" },
  "application/vnd.commerce-battelle": { "source": "iana" },
  "application/vnd.commonspace": { "source": "iana", "extensions": ["csp"] },
  "application/vnd.contact.cmsg": { "source": "iana", "extensions": ["cdbcmsg"] },
  "application/vnd.coreos.ignition+json": { "source": "iana", "compressible": true },
  "application/vnd.cosmocaller": { "source": "iana", "extensions": ["cmc"] },
  "application/vnd.crick.clicker": { "source": "iana", "extensions": ["clkx"] },
  "application/vnd.crick.clicker.keyboard": { "source": "iana", "extensions": ["clkk"] },
  "application/vnd.crick.clicker.palette": { "source": "iana", "extensions": ["clkp"] },
  "application/vnd.crick.clicker.template": { "source": "iana", "extensions": ["clkt"] },
  "application/vnd.crick.clicker.wordbank": { "source": "iana", "extensions": ["clkw"] },
  "application/vnd.criticaltools.wbs+xml": { "source": "iana", "compressible": true, "extensions": ["wbs"] },
  "application/vnd.cryptii.pipe+json": { "source": "iana", "compressible": true },
  "application/vnd.crypto-shade-file": { "source": "iana" },
  "application/vnd.cryptomator.encrypted": { "source": "iana" },
  "application/vnd.cryptomator.vault": { "source": "iana" },
  "application/vnd.ctc-posml": { "source": "iana", "extensions": ["pml"] },
  "application/vnd.ctct.ws+xml": { "source": "iana", "compressible": true },
  "application/vnd.cups-pdf": { "source": "iana" },
  "application/vnd.cups-postscript": { "source": "iana" },
  "application/vnd.cups-ppd": { "source": "iana", "extensions": ["ppd"] },
  "application/vnd.cups-raster": { "source": "iana" },
  "application/vnd.cups-raw": { "source": "iana" },
  "application/vnd.curl": { "source": "iana" },
  "application/vnd.curl.car": { "source": "apache", "extensions": ["car"] },
  "application/vnd.curl.pcurl": { "source": "apache", "extensions": ["pcurl"] },
  "application/vnd.cyan.dean.root+xml": { "source": "iana", "compressible": true },
  "application/vnd.cybank": { "source": "iana" },
  "application/vnd.cyclonedx+json": { "source": "iana", "compressible": true },
  "application/vnd.cyclonedx+xml": { "source": "iana", "compressible": true },
  "application/vnd.d2l.coursepackage1p0+zip": { "source": "iana", "compressible": false },
  "application/vnd.d3m-dataset": { "source": "iana" },
  "application/vnd.d3m-problem": { "source": "iana" },
  "application/vnd.dart": { "source": "iana", "compressible": true, "extensions": ["dart"] },
  "application/vnd.data-vision.rdz": { "source": "iana", "extensions": ["rdz"] },
  "application/vnd.datalog": { "source": "iana" },
  "application/vnd.datapackage+json": { "source": "iana", "compressible": true },
  "application/vnd.dataresource+json": { "source": "iana", "compressible": true },
  "application/vnd.dbf": { "source": "iana", "extensions": ["dbf"] },
  "application/vnd.dcmp+xml": { "source": "iana", "compressible": true, "extensions": ["dcmp"] },
  "application/vnd.debian.binary-package": { "source": "iana" },
  "application/vnd.dece.data": { "source": "iana", "extensions": ["uvf", "uvvf", "uvd", "uvvd"] },
  "application/vnd.dece.ttml+xml": { "source": "iana", "compressible": true, "extensions": ["uvt", "uvvt"] },
  "application/vnd.dece.unspecified": { "source": "iana", "extensions": ["uvx", "uvvx"] },
  "application/vnd.dece.zip": { "source": "iana", "extensions": ["uvz", "uvvz"] },
  "application/vnd.denovo.fcselayout-link": { "source": "iana", "extensions": ["fe_launch"] },
  "application/vnd.desmume.movie": { "source": "iana" },
  "application/vnd.dir-bi.plate-dl-nosuffix": { "source": "iana" },
  "application/vnd.dm.delegation+xml": { "source": "iana", "compressible": true },
  "application/vnd.dna": { "source": "iana", "extensions": ["dna"] },
  "application/vnd.document+json": { "source": "iana", "compressible": true },
  "application/vnd.dolby.mlp": { "source": "apache", "extensions": ["mlp"] },
  "application/vnd.dolby.mobile.1": { "source": "iana" },
  "application/vnd.dolby.mobile.2": { "source": "iana" },
  "application/vnd.doremir.scorecloud-binary-document": { "source": "iana" },
  "application/vnd.dpgraph": { "source": "iana", "extensions": ["dpg"] },
  "application/vnd.dreamfactory": { "source": "iana", "extensions": ["dfac"] },
  "application/vnd.drive+json": { "source": "iana", "compressible": true },
  "application/vnd.ds-keypoint": { "source": "apache", "extensions": ["kpxx"] },
  "application/vnd.dtg.local": { "source": "iana" },
  "application/vnd.dtg.local.flash": { "source": "iana" },
  "application/vnd.dtg.local.html": { "source": "iana" },
  "application/vnd.dvb.ait": { "source": "iana", "extensions": ["ait"] },
  "application/vnd.dvb.dvbisl+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.dvbj": { "source": "iana" },
  "application/vnd.dvb.esgcontainer": { "source": "iana" },
  "application/vnd.dvb.ipdcdftnotifaccess": { "source": "iana" },
  "application/vnd.dvb.ipdcesgaccess": { "source": "iana" },
  "application/vnd.dvb.ipdcesgaccess2": { "source": "iana" },
  "application/vnd.dvb.ipdcesgpdd": { "source": "iana" },
  "application/vnd.dvb.ipdcroaming": { "source": "iana" },
  "application/vnd.dvb.iptv.alfec-base": { "source": "iana" },
  "application/vnd.dvb.iptv.alfec-enhancement": { "source": "iana" },
  "application/vnd.dvb.notif-aggregate-root+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-container+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-generic+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-ia-msglist+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-ia-registration-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-ia-registration-response+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-init+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.pfr": { "source": "iana" },
  "application/vnd.dvb.service": { "source": "iana", "extensions": ["svc"] },
  "application/vnd.dxr": { "source": "iana" },
  "application/vnd.dynageo": { "source": "iana", "extensions": ["geo"] },
  "application/vnd.dzr": { "source": "iana" },
  "application/vnd.easykaraoke.cdgdownload": { "source": "iana" },
  "application/vnd.ecdis-update": { "source": "iana" },
  "application/vnd.ecip.rlp": { "source": "iana" },
  "application/vnd.eclipse.ditto+json": { "source": "iana", "compressible": true },
  "application/vnd.ecowin.chart": { "source": "iana", "extensions": ["mag"] },
  "application/vnd.ecowin.filerequest": { "source": "iana" },
  "application/vnd.ecowin.fileupdate": { "source": "iana" },
  "application/vnd.ecowin.series": { "source": "iana" },
  "application/vnd.ecowin.seriesrequest": { "source": "iana" },
  "application/vnd.ecowin.seriesupdate": { "source": "iana" },
  "application/vnd.efi.img": { "source": "iana" },
  "application/vnd.efi.iso": { "source": "iana" },
  "application/vnd.eln+zip": { "source": "iana", "compressible": false },
  "application/vnd.emclient.accessrequest+xml": { "source": "iana", "compressible": true },
  "application/vnd.enliven": { "source": "iana", "extensions": ["nml"] },
  "application/vnd.enphase.envoy": { "source": "iana" },
  "application/vnd.eprints.data+xml": { "source": "iana", "compressible": true },
  "application/vnd.epson.esf": { "source": "iana", "extensions": ["esf"] },
  "application/vnd.epson.msf": { "source": "iana", "extensions": ["msf"] },
  "application/vnd.epson.quickanime": { "source": "iana", "extensions": ["qam"] },
  "application/vnd.epson.salt": { "source": "iana", "extensions": ["slt"] },
  "application/vnd.epson.ssf": { "source": "iana", "extensions": ["ssf"] },
  "application/vnd.ericsson.quickcall": { "source": "iana" },
  "application/vnd.erofs": { "source": "iana" },
  "application/vnd.espass-espass+zip": { "source": "iana", "compressible": false },
  "application/vnd.eszigno3+xml": { "source": "iana", "compressible": true, "extensions": ["es3", "et3"] },
  "application/vnd.etsi.aoc+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.asic-e+zip": { "source": "iana", "compressible": false },
  "application/vnd.etsi.asic-s+zip": { "source": "iana", "compressible": false },
  "application/vnd.etsi.cug+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvcommand+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvdiscovery+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsad-bc+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsad-cod+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsad-npvr+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvservice+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsync+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvueprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.mcid+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.mheg5": { "source": "iana" },
  "application/vnd.etsi.overload-control-policy-dataset+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.pstn+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.sci+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.simservs+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.timestamp-token": { "source": "iana" },
  "application/vnd.etsi.tsl+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.tsl.der": { "source": "iana" },
  "application/vnd.eu.kasparian.car+json": { "source": "iana", "compressible": true },
  "application/vnd.eudora.data": { "source": "iana" },
  "application/vnd.evolv.ecig.profile": { "source": "iana" },
  "application/vnd.evolv.ecig.settings": { "source": "iana" },
  "application/vnd.evolv.ecig.theme": { "source": "iana" },
  "application/vnd.exstream-empower+zip": { "source": "iana", "compressible": false },
  "application/vnd.exstream-package": { "source": "iana" },
  "application/vnd.ezpix-album": { "source": "iana", "extensions": ["ez2"] },
  "application/vnd.ezpix-package": { "source": "iana", "extensions": ["ez3"] },
  "application/vnd.f-secure.mobile": { "source": "iana" },
  "application/vnd.familysearch.gedcom+zip": { "source": "iana", "compressible": false },
  "application/vnd.fastcopy-disk-image": { "source": "iana" },
  "application/vnd.fdf": { "source": "apache", "extensions": ["fdf"] },
  "application/vnd.fdsn.mseed": { "source": "iana", "extensions": ["mseed"] },
  "application/vnd.fdsn.seed": { "source": "iana", "extensions": ["seed", "dataless"] },
  "application/vnd.fdsn.stationxml+xml": { "source": "iana", "charset": "XML-BASED", "compressible": true },
  "application/vnd.ffsns": { "source": "iana" },
  "application/vnd.ficlab.flb+zip": { "source": "iana", "compressible": false },
  "application/vnd.filmit.zfc": { "source": "iana" },
  "application/vnd.fints": { "source": "iana" },
  "application/vnd.firemonkeys.cloudcell": { "source": "iana" },
  "application/vnd.flographit": { "source": "iana", "extensions": ["gph"] },
  "application/vnd.fluxtime.clip": { "source": "iana", "extensions": ["ftc"] },
  "application/vnd.font-fontforge-sfd": { "source": "iana" },
  "application/vnd.framemaker": { "source": "iana", "extensions": ["fm", "frame", "maker", "book"] },
  "application/vnd.freelog.comic": { "source": "iana" },
  "application/vnd.frogans.fnc": { "source": "apache", "extensions": ["fnc"] },
  "application/vnd.frogans.ltf": { "source": "apache", "extensions": ["ltf"] },
  "application/vnd.fsc.weblaunch": { "source": "iana", "extensions": ["fsc"] },
  "application/vnd.fujifilm.fb.docuworks": { "source": "iana" },
  "application/vnd.fujifilm.fb.docuworks.binder": { "source": "iana" },
  "application/vnd.fujifilm.fb.docuworks.container": { "source": "iana" },
  "application/vnd.fujifilm.fb.jfi+xml": { "source": "iana", "compressible": true },
  "application/vnd.fujitsu.oasys": { "source": "iana", "extensions": ["oas"] },
  "application/vnd.fujitsu.oasys2": { "source": "iana", "extensions": ["oa2"] },
  "application/vnd.fujitsu.oasys3": { "source": "iana", "extensions": ["oa3"] },
  "application/vnd.fujitsu.oasysgp": { "source": "iana", "extensions": ["fg5"] },
  "application/vnd.fujitsu.oasysprs": { "source": "iana", "extensions": ["bh2"] },
  "application/vnd.fujixerox.art-ex": { "source": "iana" },
  "application/vnd.fujixerox.art4": { "source": "iana" },
  "application/vnd.fujixerox.ddd": { "source": "iana", "extensions": ["ddd"] },
  "application/vnd.fujixerox.docuworks": { "source": "iana", "extensions": ["xdw"] },
  "application/vnd.fujixerox.docuworks.binder": { "source": "iana", "extensions": ["xbd"] },
  "application/vnd.fujixerox.docuworks.container": { "source": "iana" },
  "application/vnd.fujixerox.hbpl": { "source": "iana" },
  "application/vnd.fut-misnet": { "source": "iana" },
  "application/vnd.futoin+cbor": { "source": "iana" },
  "application/vnd.futoin+json": { "source": "iana", "compressible": true },
  "application/vnd.fuzzysheet": { "source": "iana", "extensions": ["fzs"] },
  "application/vnd.ga4gh.passport+jwt": { "source": "iana" },
  "application/vnd.genomatix.tuxedo": { "source": "iana", "extensions": ["txd"] },
  "application/vnd.genozip": { "source": "iana" },
  "application/vnd.gentics.grd+json": { "source": "iana", "compressible": true },
  "application/vnd.gentoo.catmetadata+xml": { "source": "iana", "compressible": true },
  "application/vnd.gentoo.ebuild": { "source": "iana" },
  "application/vnd.gentoo.eclass": { "source": "iana" },
  "application/vnd.gentoo.gpkg": { "source": "iana" },
  "application/vnd.gentoo.manifest": { "source": "iana" },
  "application/vnd.gentoo.pkgmetadata+xml": { "source": "iana", "compressible": true },
  "application/vnd.gentoo.xpak": { "source": "iana" },
  "application/vnd.geo+json": { "source": "apache", "compressible": true },
  "application/vnd.geocube+xml": { "source": "apache", "compressible": true },
  "application/vnd.geogebra.file": { "source": "iana", "extensions": ["ggb"] },
  "application/vnd.geogebra.pinboard": { "source": "iana" },
  "application/vnd.geogebra.slides": { "source": "iana", "extensions": ["ggs"] },
  "application/vnd.geogebra.tool": { "source": "iana", "extensions": ["ggt"] },
  "application/vnd.geometry-explorer": { "source": "iana", "extensions": ["gex", "gre"] },
  "application/vnd.geonext": { "source": "iana", "extensions": ["gxt"] },
  "application/vnd.geoplan": { "source": "iana", "extensions": ["g2w"] },
  "application/vnd.geospace": { "source": "iana", "extensions": ["g3w"] },
  "application/vnd.gerber": { "source": "iana" },
  "application/vnd.globalplatform.card-content-mgt": { "source": "iana" },
  "application/vnd.globalplatform.card-content-mgt-response": { "source": "iana" },
  "application/vnd.gmx": { "source": "iana", "extensions": ["gmx"] },
  "application/vnd.gnu.taler.exchange+json": { "source": "iana", "compressible": true },
  "application/vnd.gnu.taler.merchant+json": { "source": "iana", "compressible": true },
  "application/vnd.google-apps.audio": {},
  "application/vnd.google-apps.document": { "compressible": false, "extensions": ["gdoc"] },
  "application/vnd.google-apps.drawing": { "compressible": false, "extensions": ["gdraw"] },
  "application/vnd.google-apps.drive-sdk": { "compressible": false },
  "application/vnd.google-apps.file": {},
  "application/vnd.google-apps.folder": { "compressible": false },
  "application/vnd.google-apps.form": { "compressible": false, "extensions": ["gform"] },
  "application/vnd.google-apps.fusiontable": {},
  "application/vnd.google-apps.jam": { "compressible": false, "extensions": ["gjam"] },
  "application/vnd.google-apps.mail-layout": {},
  "application/vnd.google-apps.map": { "compressible": false, "extensions": ["gmap"] },
  "application/vnd.google-apps.photo": {},
  "application/vnd.google-apps.presentation": { "compressible": false, "extensions": ["gslides"] },
  "application/vnd.google-apps.script": { "compressible": false, "extensions": ["gscript"] },
  "application/vnd.google-apps.shortcut": {},
  "application/vnd.google-apps.site": { "compressible": false, "extensions": ["gsite"] },
  "application/vnd.google-apps.spreadsheet": { "compressible": false, "extensions": ["gsheet"] },
  "application/vnd.google-apps.unknown": {},
  "application/vnd.google-apps.video": {},
  "application/vnd.google-earth.kml+xml": { "source": "iana", "compressible": true, "extensions": ["kml"] },
  "application/vnd.google-earth.kmz": { "source": "iana", "compressible": false, "extensions": ["kmz"] },
  "application/vnd.gov.sk.e-form+xml": { "source": "apache", "compressible": true },
  "application/vnd.gov.sk.e-form+zip": { "source": "iana", "compressible": false },
  "application/vnd.gov.sk.xmldatacontainer+xml": { "source": "iana", "compressible": true, "extensions": ["xdcf"] },
  "application/vnd.gpxsee.map+xml": { "source": "iana", "compressible": true },
  "application/vnd.grafeq": { "source": "iana", "extensions": ["gqf", "gqs"] },
  "application/vnd.gridmp": { "source": "iana" },
  "application/vnd.groove-account": { "source": "iana", "extensions": ["gac"] },
  "application/vnd.groove-help": { "source": "iana", "extensions": ["ghf"] },
  "application/vnd.groove-identity-message": { "source": "iana", "extensions": ["gim"] },
  "application/vnd.groove-injector": { "source": "iana", "extensions": ["grv"] },
  "application/vnd.groove-tool-message": { "source": "iana", "extensions": ["gtm"] },
  "application/vnd.groove-tool-template": { "source": "iana", "extensions": ["tpl"] },
  "application/vnd.groove-vcard": { "source": "iana", "extensions": ["vcg"] },
  "application/vnd.hal+json": { "source": "iana", "compressible": true },
  "application/vnd.hal+xml": { "source": "iana", "compressible": true, "extensions": ["hal"] },
  "application/vnd.handheld-entertainment+xml": { "source": "iana", "compressible": true, "extensions": ["zmm"] },
  "application/vnd.hbci": { "source": "iana", "extensions": ["hbci"] },
  "application/vnd.hc+json": { "source": "iana", "compressible": true },
  "application/vnd.hcl-bireports": { "source": "iana" },
  "application/vnd.hdt": { "source": "iana" },
  "application/vnd.heroku+json": { "source": "iana", "compressible": true },
  "application/vnd.hhe.lesson-player": { "source": "iana", "extensions": ["les"] },
  "application/vnd.hp-hpgl": { "source": "iana", "extensions": ["hpgl"] },
  "application/vnd.hp-hpid": { "source": "iana", "extensions": ["hpid"] },
  "application/vnd.hp-hps": { "source": "iana", "extensions": ["hps"] },
  "application/vnd.hp-jlyt": { "source": "iana", "extensions": ["jlt"] },
  "application/vnd.hp-pcl": { "source": "iana", "extensions": ["pcl"] },
  "application/vnd.hp-pclxl": { "source": "iana", "extensions": ["pclxl"] },
  "application/vnd.hsl": { "source": "iana" },
  "application/vnd.httphone": { "source": "iana" },
  "application/vnd.hydrostatix.sof-data": { "source": "iana", "extensions": ["sfd-hdstx"] },
  "application/vnd.hyper+json": { "source": "iana", "compressible": true },
  "application/vnd.hyper-item+json": { "source": "iana", "compressible": true },
  "application/vnd.hyperdrive+json": { "source": "iana", "compressible": true },
  "application/vnd.hzn-3d-crossword": { "source": "iana" },
  "application/vnd.ibm.afplinedata": { "source": "apache" },
  "application/vnd.ibm.electronic-media": { "source": "iana" },
  "application/vnd.ibm.minipay": { "source": "iana", "extensions": ["mpy"] },
  "application/vnd.ibm.modcap": { "source": "apache", "extensions": ["afp", "listafp", "list3820"] },
  "application/vnd.ibm.rights-management": { "source": "iana", "extensions": ["irm"] },
  "application/vnd.ibm.secure-container": { "source": "iana", "extensions": ["sc"] },
  "application/vnd.iccprofile": { "source": "iana", "extensions": ["icc", "icm"] },
  "application/vnd.ieee.1905": { "source": "iana" },
  "application/vnd.igloader": { "source": "iana", "extensions": ["igl"] },
  "application/vnd.imagemeter.folder+zip": { "source": "iana", "compressible": false },
  "application/vnd.imagemeter.image+zip": { "source": "iana", "compressible": false },
  "application/vnd.immervision-ivp": { "source": "iana", "extensions": ["ivp"] },
  "application/vnd.immervision-ivu": { "source": "iana", "extensions": ["ivu"] },
  "application/vnd.ims.imsccv1p1": { "source": "iana" },
  "application/vnd.ims.imsccv1p2": { "source": "iana" },
  "application/vnd.ims.imsccv1p3": { "source": "iana" },
  "application/vnd.ims.lis.v2.result+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolconsumerprofile+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolproxy+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolproxy.id+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolsettings+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolsettings.simple+json": { "source": "iana", "compressible": true },
  "application/vnd.informedcontrol.rms+xml": { "source": "iana", "compressible": true },
  "application/vnd.informix-visionary": { "source": "apache" },
  "application/vnd.infotech.project": { "source": "iana" },
  "application/vnd.infotech.project+xml": { "source": "iana", "compressible": true },
  "application/vnd.innopath.wamp.notification": { "source": "iana" },
  "application/vnd.insors.igm": { "source": "iana", "extensions": ["igm"] },
  "application/vnd.intercon.formnet": { "source": "iana", "extensions": ["xpw", "xpx"] },
  "application/vnd.intergeo": { "source": "iana", "extensions": ["i2g"] },
  "application/vnd.intertrust.digibox": { "source": "iana" },
  "application/vnd.intertrust.nncp": { "source": "iana" },
  "application/vnd.intu.qbo": { "source": "iana", "extensions": ["qbo"] },
  "application/vnd.intu.qfx": { "source": "iana", "extensions": ["qfx"] },
  "application/vnd.ipfs.ipns-record": { "source": "iana" },
  "application/vnd.ipld.car": { "source": "iana" },
  "application/vnd.ipld.dag-cbor": { "source": "iana" },
  "application/vnd.ipld.dag-json": { "source": "iana" },
  "application/vnd.ipld.raw": { "source": "iana" },
  "application/vnd.iptc.g2.catalogitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.conceptitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.knowledgeitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.newsitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.newsmessage+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.packageitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.planningitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.ipunplugged.rcprofile": { "source": "iana", "extensions": ["rcprofile"] },
  "application/vnd.irepository.package+xml": { "source": "iana", "compressible": true, "extensions": ["irp"] },
  "application/vnd.is-xpr": { "source": "iana", "extensions": ["xpr"] },
  "application/vnd.isac.fcs": { "source": "iana", "extensions": ["fcs"] },
  "application/vnd.iso11783-10+zip": { "source": "iana", "compressible": false },
  "application/vnd.jam": { "source": "iana", "extensions": ["jam"] },
  "application/vnd.japannet-directory-service": { "source": "iana" },
  "application/vnd.japannet-jpnstore-wakeup": { "source": "iana" },
  "application/vnd.japannet-payment-wakeup": { "source": "iana" },
  "application/vnd.japannet-registration": { "source": "iana" },
  "application/vnd.japannet-registration-wakeup": { "source": "iana" },
  "application/vnd.japannet-setstore-wakeup": { "source": "iana" },
  "application/vnd.japannet-verification": { "source": "iana" },
  "application/vnd.japannet-verification-wakeup": { "source": "iana" },
  "application/vnd.jcp.javame.midlet-rms": { "source": "iana", "extensions": ["rms"] },
  "application/vnd.jisp": { "source": "iana", "extensions": ["jisp"] },
  "application/vnd.joost.joda-archive": { "source": "iana", "extensions": ["joda"] },
  "application/vnd.jsk.isdn-ngn": { "source": "iana" },
  "application/vnd.kahootz": { "source": "iana", "extensions": ["ktz", "ktr"] },
  "application/vnd.kde.karbon": { "source": "iana", "extensions": ["karbon"] },
  "application/vnd.kde.kchart": { "source": "iana", "extensions": ["chrt"] },
  "application/vnd.kde.kformula": { "source": "iana", "extensions": ["kfo"] },
  "application/vnd.kde.kivio": { "source": "iana", "extensions": ["flw"] },
  "application/vnd.kde.kontour": { "source": "iana", "extensions": ["kon"] },
  "application/vnd.kde.kpresenter": { "source": "iana", "extensions": ["kpr", "kpt"] },
  "application/vnd.kde.kspread": { "source": "iana", "extensions": ["ksp"] },
  "application/vnd.kde.kword": { "source": "iana", "extensions": ["kwd", "kwt"] },
  "application/vnd.kdl": { "source": "iana" },
  "application/vnd.kenameaapp": { "source": "iana", "extensions": ["htke"] },
  "application/vnd.keyman.kmp+zip": { "source": "iana", "compressible": false },
  "application/vnd.keyman.kmx": { "source": "iana" },
  "application/vnd.kidspiration": { "source": "iana", "extensions": ["kia"] },
  "application/vnd.kinar": { "source": "iana", "extensions": ["kne", "knp"] },
  "application/vnd.koan": { "source": "iana", "extensions": ["skp", "skd", "skt", "skm"] },
  "application/vnd.kodak-descriptor": { "source": "iana", "extensions": ["sse"] },
  "application/vnd.las": { "source": "iana" },
  "application/vnd.las.las+json": { "source": "iana", "compressible": true },
  "application/vnd.las.las+xml": { "source": "iana", "compressible": true, "extensions": ["lasxml"] },
  "application/vnd.laszip": { "source": "iana" },
  "application/vnd.ldev.productlicensing": { "source": "iana" },
  "application/vnd.leap+json": { "source": "iana", "compressible": true },
  "application/vnd.liberty-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.llamagraphics.life-balance.desktop": { "source": "iana", "extensions": ["lbd"] },
  "application/vnd.llamagraphics.life-balance.exchange+xml": { "source": "iana", "compressible": true, "extensions": ["lbe"] },
  "application/vnd.logipipe.circuit+zip": { "source": "iana", "compressible": false },
  "application/vnd.loom": { "source": "iana" },
  "application/vnd.lotus-1-2-3": { "source": "iana", "extensions": ["123"] },
  "application/vnd.lotus-approach": { "source": "iana", "extensions": ["apr"] },
  "application/vnd.lotus-freelance": { "source": "iana", "extensions": ["pre"] },
  "application/vnd.lotus-notes": { "source": "iana", "extensions": ["nsf"] },
  "application/vnd.lotus-organizer": { "source": "iana", "extensions": ["org"] },
  "application/vnd.lotus-screencam": { "source": "iana", "extensions": ["scm"] },
  "application/vnd.lotus-wordpro": { "source": "iana", "extensions": ["lwp"] },
  "application/vnd.macports.portpkg": { "source": "iana", "extensions": ["portpkg"] },
  "application/vnd.mapbox-vector-tile": { "source": "iana", "extensions": ["mvt"] },
  "application/vnd.marlin.drm.actiontoken+xml": { "source": "iana", "compressible": true },
  "application/vnd.marlin.drm.conftoken+xml": { "source": "iana", "compressible": true },
  "application/vnd.marlin.drm.license+xml": { "source": "iana", "compressible": true },
  "application/vnd.marlin.drm.mdcf": { "source": "iana" },
  "application/vnd.mason+json": { "source": "iana", "compressible": true },
  "application/vnd.maxar.archive.3tz+zip": { "source": "iana", "compressible": false },
  "application/vnd.maxmind.maxmind-db": { "source": "iana" },
  "application/vnd.mcd": { "source": "iana", "extensions": ["mcd"] },
  "application/vnd.mdl": { "source": "iana" },
  "application/vnd.mdl-mbsdf": { "source": "iana" },
  "application/vnd.medcalcdata": { "source": "iana", "extensions": ["mc1"] },
  "application/vnd.mediastation.cdkey": { "source": "iana", "extensions": ["cdkey"] },
  "application/vnd.medicalholodeck.recordxr": { "source": "iana" },
  "application/vnd.meridian-slingshot": { "source": "iana" },
  "application/vnd.mermaid": { "source": "iana" },
  "application/vnd.mfer": { "source": "iana", "extensions": ["mwf"] },
  "application/vnd.mfmp": { "source": "iana", "extensions": ["mfm"] },
  "application/vnd.micro+json": { "source": "iana", "compressible": true },
  "application/vnd.micrografx.flo": { "source": "iana", "extensions": ["flo"] },
  "application/vnd.micrografx.igx": { "source": "iana", "extensions": ["igx"] },
  "application/vnd.microsoft.portable-executable": { "source": "iana" },
  "application/vnd.microsoft.windows.thumbnail-cache": { "source": "iana" },
  "application/vnd.miele+json": { "source": "iana", "compressible": true },
  "application/vnd.mif": { "source": "iana", "extensions": ["mif"] },
  "application/vnd.minisoft-hp3000-save": { "source": "iana" },
  "application/vnd.mitsubishi.misty-guard.trustweb": { "source": "iana" },
  "application/vnd.mobius.daf": { "source": "iana", "extensions": ["daf"] },
  "application/vnd.mobius.dis": { "source": "iana", "extensions": ["dis"] },
  "application/vnd.mobius.mbk": { "source": "iana", "extensions": ["mbk"] },
  "application/vnd.mobius.mqy": { "source": "iana", "extensions": ["mqy"] },
  "application/vnd.mobius.msl": { "source": "iana", "extensions": ["msl"] },
  "application/vnd.mobius.plc": { "source": "iana", "extensions": ["plc"] },
  "application/vnd.mobius.txf": { "source": "iana", "extensions": ["txf"] },
  "application/vnd.modl": { "source": "iana" },
  "application/vnd.mophun.application": { "source": "iana", "extensions": ["mpn"] },
  "application/vnd.mophun.certificate": { "source": "iana", "extensions": ["mpc"] },
  "application/vnd.motorola.flexsuite": { "source": "iana" },
  "application/vnd.motorola.flexsuite.adsi": { "source": "iana" },
  "application/vnd.motorola.flexsuite.fis": { "source": "iana" },
  "application/vnd.motorola.flexsuite.gotap": { "source": "iana" },
  "application/vnd.motorola.flexsuite.kmr": { "source": "iana" },
  "application/vnd.motorola.flexsuite.ttc": { "source": "iana" },
  "application/vnd.motorola.flexsuite.wem": { "source": "iana" },
  "application/vnd.motorola.iprm": { "source": "iana" },
  "application/vnd.mozilla.xul+xml": { "source": "iana", "compressible": true, "extensions": ["xul"] },
  "application/vnd.ms-3mfdocument": { "source": "iana" },
  "application/vnd.ms-artgalry": { "source": "iana", "extensions": ["cil"] },
  "application/vnd.ms-asf": { "source": "iana" },
  "application/vnd.ms-cab-compressed": { "source": "iana", "extensions": ["cab"] },
  "application/vnd.ms-color.iccprofile": { "source": "apache" },
  "application/vnd.ms-excel": { "source": "iana", "compressible": false, "extensions": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"] },
  "application/vnd.ms-excel.addin.macroenabled.12": { "source": "iana", "extensions": ["xlam"] },
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": { "source": "iana", "extensions": ["xlsb"] },
  "application/vnd.ms-excel.sheet.macroenabled.12": { "source": "iana", "extensions": ["xlsm"] },
  "application/vnd.ms-excel.template.macroenabled.12": { "source": "iana", "extensions": ["xltm"] },
  "application/vnd.ms-fontobject": { "source": "iana", "compressible": true, "extensions": ["eot"] },
  "application/vnd.ms-htmlhelp": { "source": "iana", "extensions": ["chm"] },
  "application/vnd.ms-ims": { "source": "iana", "extensions": ["ims"] },
  "application/vnd.ms-lrm": { "source": "iana", "extensions": ["lrm"] },
  "application/vnd.ms-office.activex+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-officetheme": { "source": "iana", "extensions": ["thmx"] },
  "application/vnd.ms-opentype": { "source": "apache", "compressible": true },
  "application/vnd.ms-outlook": { "compressible": false, "extensions": ["msg"] },
  "application/vnd.ms-package.obfuscated-opentype": { "source": "apache" },
  "application/vnd.ms-pki.seccat": { "source": "apache", "extensions": ["cat"] },
  "application/vnd.ms-pki.stl": { "source": "apache", "extensions": ["stl"] },
  "application/vnd.ms-playready.initiator+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-powerpoint": { "source": "iana", "compressible": false, "extensions": ["ppt", "pps", "pot"] },
  "application/vnd.ms-powerpoint.addin.macroenabled.12": { "source": "iana", "extensions": ["ppam"] },
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": { "source": "iana", "extensions": ["pptm"] },
  "application/vnd.ms-powerpoint.slide.macroenabled.12": { "source": "iana", "extensions": ["sldm"] },
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": { "source": "iana", "extensions": ["ppsm"] },
  "application/vnd.ms-powerpoint.template.macroenabled.12": { "source": "iana", "extensions": ["potm"] },
  "application/vnd.ms-printdevicecapabilities+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-printing.printticket+xml": { "source": "apache", "compressible": true },
  "application/vnd.ms-printschematicket+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-project": { "source": "iana", "extensions": ["mpp", "mpt"] },
  "application/vnd.ms-tnef": { "source": "iana" },
  "application/vnd.ms-visio.viewer": { "extensions": ["vdx"] },
  "application/vnd.ms-windows.devicepairing": { "source": "iana" },
  "application/vnd.ms-windows.nwprinting.oob": { "source": "iana" },
  "application/vnd.ms-windows.printerpairing": { "source": "iana" },
  "application/vnd.ms-windows.wsd.oob": { "source": "iana" },
  "application/vnd.ms-wmdrm.lic-chlg-req": { "source": "iana" },
  "application/vnd.ms-wmdrm.lic-resp": { "source": "iana" },
  "application/vnd.ms-wmdrm.meter-chlg-req": { "source": "iana" },
  "application/vnd.ms-wmdrm.meter-resp": { "source": "iana" },
  "application/vnd.ms-word.document.macroenabled.12": { "source": "iana", "extensions": ["docm"] },
  "application/vnd.ms-word.template.macroenabled.12": { "source": "iana", "extensions": ["dotm"] },
  "application/vnd.ms-works": { "source": "iana", "extensions": ["wps", "wks", "wcm", "wdb"] },
  "application/vnd.ms-wpl": { "source": "iana", "extensions": ["wpl"] },
  "application/vnd.ms-xpsdocument": { "source": "iana", "compressible": false, "extensions": ["xps"] },
  "application/vnd.msa-disk-image": { "source": "iana" },
  "application/vnd.mseq": { "source": "iana", "extensions": ["mseq"] },
  "application/vnd.msgpack": { "source": "iana" },
  "application/vnd.msign": { "source": "iana" },
  "application/vnd.multiad.creator": { "source": "iana" },
  "application/vnd.multiad.creator.cif": { "source": "iana" },
  "application/vnd.music-niff": { "source": "iana" },
  "application/vnd.musician": { "source": "iana", "extensions": ["mus"] },
  "application/vnd.muvee.style": { "source": "iana", "extensions": ["msty"] },
  "application/vnd.mynfc": { "source": "iana", "extensions": ["taglet"] },
  "application/vnd.nacamar.ybrid+json": { "source": "iana", "compressible": true },
  "application/vnd.nato.bindingdataobject+cbor": { "source": "iana" },
  "application/vnd.nato.bindingdataobject+json": { "source": "iana", "compressible": true },
  "application/vnd.nato.bindingdataobject+xml": { "source": "iana", "compressible": true, "extensions": ["bdo"] },
  "application/vnd.nato.openxmlformats-package.iepd+zip": { "source": "iana", "compressible": false },
  "application/vnd.ncd.control": { "source": "iana" },
  "application/vnd.ncd.reference": { "source": "iana" },
  "application/vnd.nearst.inv+json": { "source": "iana", "compressible": true },
  "application/vnd.nebumind.line": { "source": "iana" },
  "application/vnd.nervana": { "source": "iana" },
  "application/vnd.netfpx": { "source": "iana" },
  "application/vnd.neurolanguage.nlu": { "source": "iana", "extensions": ["nlu"] },
  "application/vnd.nimn": { "source": "iana" },
  "application/vnd.nintendo.nitro.rom": { "source": "iana" },
  "application/vnd.nintendo.snes.rom": { "source": "iana" },
  "application/vnd.nitf": { "source": "iana", "extensions": ["ntf", "nitf"] },
  "application/vnd.noblenet-directory": { "source": "iana", "extensions": ["nnd"] },
  "application/vnd.noblenet-sealer": { "source": "iana", "extensions": ["nns"] },
  "application/vnd.noblenet-web": { "source": "iana", "extensions": ["nnw"] },
  "application/vnd.nokia.catalogs": { "source": "iana" },
  "application/vnd.nokia.conml+wbxml": { "source": "iana" },
  "application/vnd.nokia.conml+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.iptv.config+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.isds-radio-presets": { "source": "iana" },
  "application/vnd.nokia.landmark+wbxml": { "source": "iana" },
  "application/vnd.nokia.landmark+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.landmarkcollection+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.n-gage.ac+xml": { "source": "iana", "compressible": true, "extensions": ["ac"] },
  "application/vnd.nokia.n-gage.data": { "source": "iana", "extensions": ["ngdat"] },
  "application/vnd.nokia.n-gage.symbian.install": { "source": "apache", "extensions": ["n-gage"] },
  "application/vnd.nokia.ncd": { "source": "iana" },
  "application/vnd.nokia.pcd+wbxml": { "source": "iana" },
  "application/vnd.nokia.pcd+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.radio-preset": { "source": "iana", "extensions": ["rpst"] },
  "application/vnd.nokia.radio-presets": { "source": "iana", "extensions": ["rpss"] },
  "application/vnd.novadigm.edm": { "source": "iana", "extensions": ["edm"] },
  "application/vnd.novadigm.edx": { "source": "iana", "extensions": ["edx"] },
  "application/vnd.novadigm.ext": { "source": "iana", "extensions": ["ext"] },
  "application/vnd.ntt-local.content-share": { "source": "iana" },
  "application/vnd.ntt-local.file-transfer": { "source": "iana" },
  "application/vnd.ntt-local.ogw_remote-access": { "source": "iana" },
  "application/vnd.ntt-local.sip-ta_remote": { "source": "iana" },
  "application/vnd.ntt-local.sip-ta_tcp_stream": { "source": "iana" },
  "application/vnd.oai.workflows": { "source": "iana" },
  "application/vnd.oai.workflows+json": { "source": "iana", "compressible": true },
  "application/vnd.oai.workflows+yaml": { "source": "iana" },
  "application/vnd.oasis.opendocument.base": { "source": "iana" },
  "application/vnd.oasis.opendocument.chart": { "source": "iana", "extensions": ["odc"] },
  "application/vnd.oasis.opendocument.chart-template": { "source": "iana", "extensions": ["otc"] },
  "application/vnd.oasis.opendocument.database": { "source": "apache", "extensions": ["odb"] },
  "application/vnd.oasis.opendocument.formula": { "source": "iana", "extensions": ["odf"] },
  "application/vnd.oasis.opendocument.formula-template": { "source": "iana", "extensions": ["odft"] },
  "application/vnd.oasis.opendocument.graphics": { "source": "iana", "compressible": false, "extensions": ["odg"] },
  "application/vnd.oasis.opendocument.graphics-template": { "source": "iana", "extensions": ["otg"] },
  "application/vnd.oasis.opendocument.image": { "source": "iana", "extensions": ["odi"] },
  "application/vnd.oasis.opendocument.image-template": { "source": "iana", "extensions": ["oti"] },
  "application/vnd.oasis.opendocument.presentation": { "source": "iana", "compressible": false, "extensions": ["odp"] },
  "application/vnd.oasis.opendocument.presentation-template": { "source": "iana", "extensions": ["otp"] },
  "application/vnd.oasis.opendocument.spreadsheet": { "source": "iana", "compressible": false, "extensions": ["ods"] },
  "application/vnd.oasis.opendocument.spreadsheet-template": { "source": "iana", "extensions": ["ots"] },
  "application/vnd.oasis.opendocument.text": { "source": "iana", "compressible": false, "extensions": ["odt"] },
  "application/vnd.oasis.opendocument.text-master": { "source": "iana", "extensions": ["odm"] },
  "application/vnd.oasis.opendocument.text-master-template": { "source": "iana" },
  "application/vnd.oasis.opendocument.text-template": { "source": "iana", "extensions": ["ott"] },
  "application/vnd.oasis.opendocument.text-web": { "source": "iana", "extensions": ["oth"] },
  "application/vnd.obn": { "source": "iana" },
  "application/vnd.ocf+cbor": { "source": "iana" },
  "application/vnd.oci.image.manifest.v1+json": { "source": "iana", "compressible": true },
  "application/vnd.oftn.l10n+json": { "source": "iana", "compressible": true },
  "application/vnd.oipf.contentaccessdownload+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.contentaccessstreaming+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.cspg-hexbinary": { "source": "iana" },
  "application/vnd.oipf.dae.svg+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.dae.xhtml+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.mippvcontrolmessage+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.pae.gem": { "source": "iana" },
  "application/vnd.oipf.spdiscovery+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.spdlist+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.ueprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.userprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.olpc-sugar": { "source": "iana", "extensions": ["xo"] },
  "application/vnd.oma-scws-config": { "source": "iana" },
  "application/vnd.oma-scws-http-request": { "source": "iana" },
  "application/vnd.oma-scws-http-response": { "source": "iana" },
  "application/vnd.oma.bcast.associated-procedure-parameter+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.drm-trigger+xml": { "source": "apache", "compressible": true },
  "application/vnd.oma.bcast.imd+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.ltkm": { "source": "iana" },
  "application/vnd.oma.bcast.notification+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.provisioningtrigger": { "source": "iana" },
  "application/vnd.oma.bcast.sgboot": { "source": "iana" },
  "application/vnd.oma.bcast.sgdd+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.sgdu": { "source": "iana" },
  "application/vnd.oma.bcast.simple-symbol-container": { "source": "iana" },
  "application/vnd.oma.bcast.smartcard-trigger+xml": { "source": "apache", "compressible": true },
  "application/vnd.oma.bcast.sprov+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.stkm": { "source": "iana" },
  "application/vnd.oma.cab-address-book+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-feature-handler+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-pcc+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-subs-invite+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-user-prefs+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.dcd": { "source": "iana" },
  "application/vnd.oma.dcdc": { "source": "iana" },
  "application/vnd.oma.dd2+xml": { "source": "iana", "compressible": true, "extensions": ["dd2"] },
  "application/vnd.oma.drm.risd+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.group-usage-list+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.lwm2m+cbor": { "source": "iana" },
  "application/vnd.oma.lwm2m+json": { "source": "iana", "compressible": true },
  "application/vnd.oma.lwm2m+tlv": { "source": "iana" },
  "application/vnd.oma.pal+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.detailed-progress-report+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.final-report+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.groups+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.invocation-descriptor+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.optimized-progress-report+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.push": { "source": "iana" },
  "application/vnd.oma.scidm.messages+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.xcap-directory+xml": { "source": "iana", "compressible": true },
  "application/vnd.omads-email+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.omads-file+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.omads-folder+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.omaloc-supl-init": { "source": "iana" },
  "application/vnd.onepager": { "source": "iana" },
  "application/vnd.onepagertamp": { "source": "iana" },
  "application/vnd.onepagertamx": { "source": "iana" },
  "application/vnd.onepagertat": { "source": "iana" },
  "application/vnd.onepagertatp": { "source": "iana" },
  "application/vnd.onepagertatx": { "source": "iana" },
  "application/vnd.onvif.metadata": { "source": "iana" },
  "application/vnd.openblox.game+xml": { "source": "iana", "compressible": true, "extensions": ["obgx"] },
  "application/vnd.openblox.game-binary": { "source": "iana" },
  "application/vnd.openeye.oeb": { "source": "iana" },
  "application/vnd.openofficeorg.extension": { "source": "apache", "extensions": ["oxt"] },
  "application/vnd.openstreetmap.data+xml": { "source": "iana", "compressible": true, "extensions": ["osm"] },
  "application/vnd.opentimestamps.ots": { "source": "iana" },
  "application/vnd.openvpi.dspx+json": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawing+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": { "source": "iana", "compressible": false, "extensions": ["pptx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slide": { "source": "iana", "extensions": ["sldx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": { "source": "iana", "extensions": ["ppsx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.template": { "source": "iana", "extensions": ["potx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": { "source": "iana", "compressible": false, "extensions": ["xlsx"] },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": { "source": "iana", "extensions": ["xltx"] },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.theme+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.themeoverride+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.vmldrawing": { "source": "iana" },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": { "source": "iana", "compressible": false, "extensions": ["docx"] },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": { "source": "iana", "extensions": ["dotx"] },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-package.core-properties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-package.relationships+xml": { "source": "iana", "compressible": true },
  "application/vnd.oracle.resource+json": { "source": "iana", "compressible": true },
  "application/vnd.orange.indata": { "source": "iana" },
  "application/vnd.osa.netdeploy": { "source": "iana" },
  "application/vnd.osgeo.mapguide.package": { "source": "iana", "extensions": ["mgp"] },
  "application/vnd.osgi.bundle": { "source": "iana" },
  "application/vnd.osgi.dp": { "source": "iana", "extensions": ["dp"] },
  "application/vnd.osgi.subsystem": { "source": "iana", "extensions": ["esa"] },
  "application/vnd.otps.ct-kip+xml": { "source": "iana", "compressible": true },
  "application/vnd.oxli.countgraph": { "source": "iana" },
  "application/vnd.pagerduty+json": { "source": "iana", "compressible": true },
  "application/vnd.palm": { "source": "iana", "extensions": ["pdb", "pqa", "oprc"] },
  "application/vnd.panoply": { "source": "iana" },
  "application/vnd.paos.xml": { "source": "iana" },
  "application/vnd.patentdive": { "source": "iana" },
  "application/vnd.patientecommsdoc": { "source": "iana" },
  "application/vnd.pawaafile": { "source": "iana", "extensions": ["paw"] },
  "application/vnd.pcos": { "source": "iana" },
  "application/vnd.pg.format": { "source": "iana", "extensions": ["str"] },
  "application/vnd.pg.osasli": { "source": "iana", "extensions": ["ei6"] },
  "application/vnd.piaccess.application-licence": { "source": "iana" },
  "application/vnd.picsel": { "source": "iana", "extensions": ["efif"] },
  "application/vnd.pmi.widget": { "source": "iana", "extensions": ["wg"] },
  "application/vnd.poc.group-advertisement+xml": { "source": "iana", "compressible": true },
  "application/vnd.pocketlearn": { "source": "iana", "extensions": ["plf"] },
  "application/vnd.powerbuilder6": { "source": "iana", "extensions": ["pbd"] },
  "application/vnd.powerbuilder6-s": { "source": "iana" },
  "application/vnd.powerbuilder7": { "source": "iana" },
  "application/vnd.powerbuilder7-s": { "source": "iana" },
  "application/vnd.powerbuilder75": { "source": "iana" },
  "application/vnd.powerbuilder75-s": { "source": "iana" },
  "application/vnd.preminet": { "source": "iana" },
  "application/vnd.previewsystems.box": { "source": "iana", "extensions": ["box"] },
  "application/vnd.procrate.brushset": { "extensions": ["brushset"] },
  "application/vnd.procreate.brush": { "extensions": ["brush"] },
  "application/vnd.procreate.dream": { "extensions": ["drm"] },
  "application/vnd.proteus.magazine": { "source": "iana", "extensions": ["mgz"] },
  "application/vnd.psfs": { "source": "iana" },
  "application/vnd.pt.mundusmundi": { "source": "iana" },
  "application/vnd.publishare-delta-tree": { "source": "iana", "extensions": ["qps"] },
  "application/vnd.pvi.ptid1": { "source": "iana", "extensions": ["ptid"] },
  "application/vnd.pwg-multiplexed": { "source": "iana" },
  "application/vnd.pwg-xhtml-print+xml": { "source": "iana", "compressible": true, "extensions": ["xhtm"] },
  "application/vnd.qualcomm.brew-app-res": { "source": "iana" },
  "application/vnd.quarantainenet": { "source": "iana" },
  "application/vnd.quark.quarkxpress": { "source": "iana", "extensions": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"] },
  "application/vnd.quobject-quoxdocument": { "source": "iana" },
  "application/vnd.radisys.moml+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-conf+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-conn+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-dialog+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-stream+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-conf+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-base+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-fax-detect+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-group+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-speech+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-transform+xml": { "source": "iana", "compressible": true },
  "application/vnd.rainstor.data": { "source": "iana" },
  "application/vnd.rapid": { "source": "iana" },
  "application/vnd.rar": { "source": "iana", "extensions": ["rar"] },
  "application/vnd.realvnc.bed": { "source": "iana", "extensions": ["bed"] },
  "application/vnd.recordare.musicxml": { "source": "iana", "extensions": ["mxl"] },
  "application/vnd.recordare.musicxml+xml": { "source": "iana", "compressible": true, "extensions": ["musicxml"] },
  "application/vnd.relpipe": { "source": "iana" },
  "application/vnd.renlearn.rlprint": { "source": "iana" },
  "application/vnd.resilient.logic": { "source": "iana" },
  "application/vnd.restful+json": { "source": "iana", "compressible": true },
  "application/vnd.rig.cryptonote": { "source": "iana", "extensions": ["cryptonote"] },
  "application/vnd.rim.cod": { "source": "apache", "extensions": ["cod"] },
  "application/vnd.rn-realmedia": { "source": "apache", "extensions": ["rm"] },
  "application/vnd.rn-realmedia-vbr": { "source": "apache", "extensions": ["rmvb"] },
  "application/vnd.route66.link66+xml": { "source": "iana", "compressible": true, "extensions": ["link66"] },
  "application/vnd.rs-274x": { "source": "iana" },
  "application/vnd.ruckus.download": { "source": "iana" },
  "application/vnd.s3sms": { "source": "iana" },
  "application/vnd.sailingtracker.track": { "source": "iana", "extensions": ["st"] },
  "application/vnd.sar": { "source": "iana" },
  "application/vnd.sbm.cid": { "source": "iana" },
  "application/vnd.sbm.mid2": { "source": "iana" },
  "application/vnd.scribus": { "source": "iana" },
  "application/vnd.sealed.3df": { "source": "iana" },
  "application/vnd.sealed.csf": { "source": "iana" },
  "application/vnd.sealed.doc": { "source": "iana" },
  "application/vnd.sealed.eml": { "source": "iana" },
  "application/vnd.sealed.mht": { "source": "iana" },
  "application/vnd.sealed.net": { "source": "iana" },
  "application/vnd.sealed.ppt": { "source": "iana" },
  "application/vnd.sealed.tiff": { "source": "iana" },
  "application/vnd.sealed.xls": { "source": "iana" },
  "application/vnd.sealedmedia.softseal.html": { "source": "iana" },
  "application/vnd.sealedmedia.softseal.pdf": { "source": "iana" },
  "application/vnd.seemail": { "source": "iana", "extensions": ["see"] },
  "application/vnd.seis+json": { "source": "iana", "compressible": true },
  "application/vnd.sema": { "source": "iana", "extensions": ["sema"] },
  "application/vnd.semd": { "source": "iana", "extensions": ["semd"] },
  "application/vnd.semf": { "source": "iana", "extensions": ["semf"] },
  "application/vnd.shade-save-file": { "source": "iana" },
  "application/vnd.shana.informed.formdata": { "source": "iana", "extensions": ["ifm"] },
  "application/vnd.shana.informed.formtemplate": { "source": "iana", "extensions": ["itp"] },
  "application/vnd.shana.informed.interchange": { "source": "iana", "extensions": ["iif"] },
  "application/vnd.shana.informed.package": { "source": "iana", "extensions": ["ipk"] },
  "application/vnd.shootproof+json": { "source": "iana", "compressible": true },
  "application/vnd.shopkick+json": { "source": "iana", "compressible": true },
  "application/vnd.shp": { "source": "iana" },
  "application/vnd.shx": { "source": "iana" },
  "application/vnd.sigrok.session": { "source": "iana" },
  "application/vnd.simtech-mindmapper": { "source": "iana", "extensions": ["twd", "twds"] },
  "application/vnd.siren+json": { "source": "iana", "compressible": true },
  "application/vnd.sketchometry": { "source": "iana" },
  "application/vnd.smaf": { "source": "iana", "extensions": ["mmf"] },
  "application/vnd.smart.notebook": { "source": "iana" },
  "application/vnd.smart.teacher": { "source": "iana", "extensions": ["teacher"] },
  "application/vnd.smintio.portals.archive": { "source": "iana" },
  "application/vnd.snesdev-page-table": { "source": "iana" },
  "application/vnd.software602.filler.form+xml": { "source": "iana", "compressible": true, "extensions": ["fo"] },
  "application/vnd.software602.filler.form-xml-zip": { "source": "iana" },
  "application/vnd.solent.sdkm+xml": { "source": "iana", "compressible": true, "extensions": ["sdkm", "sdkd"] },
  "application/vnd.spotfire.dxp": { "source": "iana", "extensions": ["dxp"] },
  "application/vnd.spotfire.sfs": { "source": "iana", "extensions": ["sfs"] },
  "application/vnd.sqlite3": { "source": "iana" },
  "application/vnd.sss-cod": { "source": "iana" },
  "application/vnd.sss-dtf": { "source": "iana" },
  "application/vnd.sss-ntf": { "source": "iana" },
  "application/vnd.stardivision.calc": { "source": "apache", "extensions": ["sdc"] },
  "application/vnd.stardivision.draw": { "source": "apache", "extensions": ["sda"] },
  "application/vnd.stardivision.impress": { "source": "apache", "extensions": ["sdd"] },
  "application/vnd.stardivision.math": { "source": "apache", "extensions": ["smf"] },
  "application/vnd.stardivision.writer": { "source": "apache", "extensions": ["sdw", "vor"] },
  "application/vnd.stardivision.writer-global": { "source": "apache", "extensions": ["sgl"] },
  "application/vnd.stepmania.package": { "source": "iana", "extensions": ["smzip"] },
  "application/vnd.stepmania.stepchart": { "source": "iana", "extensions": ["sm"] },
  "application/vnd.street-stream": { "source": "iana" },
  "application/vnd.sun.wadl+xml": { "source": "iana", "compressible": true, "extensions": ["wadl"] },
  "application/vnd.sun.xml.calc": { "source": "apache", "extensions": ["sxc"] },
  "application/vnd.sun.xml.calc.template": { "source": "apache", "extensions": ["stc"] },
  "application/vnd.sun.xml.draw": { "source": "apache", "extensions": ["sxd"] },
  "application/vnd.sun.xml.draw.template": { "source": "apache", "extensions": ["std"] },
  "application/vnd.sun.xml.impress": { "source": "apache", "extensions": ["sxi"] },
  "application/vnd.sun.xml.impress.template": { "source": "apache", "extensions": ["sti"] },
  "application/vnd.sun.xml.math": { "source": "apache", "extensions": ["sxm"] },
  "application/vnd.sun.xml.writer": { "source": "apache", "extensions": ["sxw"] },
  "application/vnd.sun.xml.writer.global": { "source": "apache", "extensions": ["sxg"] },
  "application/vnd.sun.xml.writer.template": { "source": "apache", "extensions": ["stw"] },
  "application/vnd.sus-calendar": { "source": "iana", "extensions": ["sus", "susp"] },
  "application/vnd.svd": { "source": "iana", "extensions": ["svd"] },
  "application/vnd.swiftview-ics": { "source": "iana" },
  "application/vnd.sybyl.mol2": { "source": "iana" },
  "application/vnd.sycle+xml": { "source": "iana", "compressible": true },
  "application/vnd.syft+json": { "source": "iana", "compressible": true },
  "application/vnd.symbian.install": { "source": "apache", "extensions": ["sis", "sisx"] },
  "application/vnd.syncml+xml": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["xsm"] },
  "application/vnd.syncml.dm+wbxml": { "source": "iana", "charset": "UTF-8", "extensions": ["bdm"] },
  "application/vnd.syncml.dm+xml": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["xdm"] },
  "application/vnd.syncml.dm.notification": { "source": "iana" },
  "application/vnd.syncml.dmddf+wbxml": { "source": "iana" },
  "application/vnd.syncml.dmddf+xml": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["ddf"] },
  "application/vnd.syncml.dmtnds+wbxml": { "source": "iana" },
  "application/vnd.syncml.dmtnds+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.syncml.ds.notification": { "source": "iana" },
  "application/vnd.tableschema+json": { "source": "iana", "compressible": true },
  "application/vnd.tao.intent-module-archive": { "source": "iana", "extensions": ["tao"] },
  "application/vnd.tcpdump.pcap": { "source": "iana", "extensions": ["pcap", "cap", "dmp"] },
  "application/vnd.think-cell.ppttc+json": { "source": "iana", "compressible": true },
  "application/vnd.tmd.mediaflex.api+xml": { "source": "iana", "compressible": true },
  "application/vnd.tml": { "source": "iana" },
  "application/vnd.tmobile-livetv": { "source": "iana", "extensions": ["tmo"] },
  "application/vnd.tri.onesource": { "source": "iana" },
  "application/vnd.trid.tpt": { "source": "iana", "extensions": ["tpt"] },
  "application/vnd.triscape.mxs": { "source": "iana", "extensions": ["mxs"] },
  "application/vnd.trueapp": { "source": "iana", "extensions": ["tra"] },
  "application/vnd.truedoc": { "source": "iana" },
  "application/vnd.ubisoft.webplayer": { "source": "iana" },
  "application/vnd.ufdl": { "source": "iana", "extensions": ["ufd", "ufdl"] },
  "application/vnd.uic.osdm+json": { "source": "iana", "compressible": true },
  "application/vnd.uiq.theme": { "source": "iana", "extensions": ["utz"] },
  "application/vnd.umajin": { "source": "iana", "extensions": ["umj"] },
  "application/vnd.unity": { "source": "iana", "extensions": ["unityweb"] },
  "application/vnd.uoml+xml": { "source": "iana", "compressible": true, "extensions": ["uoml", "uo"] },
  "application/vnd.uplanet.alert": { "source": "iana" },
  "application/vnd.uplanet.alert-wbxml": { "source": "iana" },
  "application/vnd.uplanet.bearer-choice": { "source": "iana" },
  "application/vnd.uplanet.bearer-choice-wbxml": { "source": "iana" },
  "application/vnd.uplanet.cacheop": { "source": "iana" },
  "application/vnd.uplanet.cacheop-wbxml": { "source": "iana" },
  "application/vnd.uplanet.channel": { "source": "iana" },
  "application/vnd.uplanet.channel-wbxml": { "source": "iana" },
  "application/vnd.uplanet.list": { "source": "iana" },
  "application/vnd.uplanet.list-wbxml": { "source": "iana" },
  "application/vnd.uplanet.listcmd": { "source": "iana" },
  "application/vnd.uplanet.listcmd-wbxml": { "source": "iana" },
  "application/vnd.uplanet.signal": { "source": "iana" },
  "application/vnd.uri-map": { "source": "iana" },
  "application/vnd.valve.source.material": { "source": "iana" },
  "application/vnd.vcx": { "source": "iana", "extensions": ["vcx"] },
  "application/vnd.vd-study": { "source": "iana" },
  "application/vnd.vectorworks": { "source": "iana" },
  "application/vnd.vel+json": { "source": "iana", "compressible": true },
  "application/vnd.veraison.tsm-report+cbor": { "source": "iana" },
  "application/vnd.veraison.tsm-report+json": { "source": "iana", "compressible": true },
  "application/vnd.verimatrix.vcas": { "source": "iana" },
  "application/vnd.veritone.aion+json": { "source": "iana", "compressible": true },
  "application/vnd.veryant.thin": { "source": "iana" },
  "application/vnd.ves.encrypted": { "source": "iana" },
  "application/vnd.vidsoft.vidconference": { "source": "iana" },
  "application/vnd.visio": { "source": "iana", "extensions": ["vsd", "vst", "vss", "vsw", "vsdx", "vtx"] },
  "application/vnd.visionary": { "source": "iana", "extensions": ["vis"] },
  "application/vnd.vividence.scriptfile": { "source": "iana" },
  "application/vnd.vocalshaper.vsp4": { "source": "iana" },
  "application/vnd.vsf": { "source": "iana", "extensions": ["vsf"] },
  "application/vnd.wap.sic": { "source": "iana" },
  "application/vnd.wap.slc": { "source": "iana" },
  "application/vnd.wap.wbxml": { "source": "iana", "charset": "UTF-8", "extensions": ["wbxml"] },
  "application/vnd.wap.wmlc": { "source": "iana", "extensions": ["wmlc"] },
  "application/vnd.wap.wmlscriptc": { "source": "iana", "extensions": ["wmlsc"] },
  "application/vnd.wasmflow.wafl": { "source": "iana" },
  "application/vnd.webturbo": { "source": "iana", "extensions": ["wtb"] },
  "application/vnd.wfa.dpp": { "source": "iana" },
  "application/vnd.wfa.p2p": { "source": "iana" },
  "application/vnd.wfa.wsc": { "source": "iana" },
  "application/vnd.windows.devicepairing": { "source": "iana" },
  "application/vnd.wmc": { "source": "iana" },
  "application/vnd.wmf.bootstrap": { "source": "iana" },
  "application/vnd.wolfram.mathematica": { "source": "iana" },
  "application/vnd.wolfram.mathematica.package": { "source": "iana" },
  "application/vnd.wolfram.player": { "source": "iana", "extensions": ["nbp"] },
  "application/vnd.wordlift": { "source": "iana" },
  "application/vnd.wordperfect": { "source": "iana", "extensions": ["wpd"] },
  "application/vnd.wqd": { "source": "iana", "extensions": ["wqd"] },
  "application/vnd.wrq-hp3000-labelled": { "source": "iana" },
  "application/vnd.wt.stf": { "source": "iana", "extensions": ["stf"] },
  "application/vnd.wv.csp+wbxml": { "source": "iana" },
  "application/vnd.wv.csp+xml": { "source": "iana", "compressible": true },
  "application/vnd.wv.ssp+xml": { "source": "iana", "compressible": true },
  "application/vnd.xacml+json": { "source": "iana", "compressible": true },
  "application/vnd.xara": { "source": "iana", "extensions": ["xar"] },
  "application/vnd.xarin.cpj": { "source": "iana" },
  "application/vnd.xecrets-encrypted": { "source": "iana" },
  "application/vnd.xfdl": { "source": "iana", "extensions": ["xfdl"] },
  "application/vnd.xfdl.webform": { "source": "iana" },
  "application/vnd.xmi+xml": { "source": "iana", "compressible": true },
  "application/vnd.xmpie.cpkg": { "source": "iana" },
  "application/vnd.xmpie.dpkg": { "source": "iana" },
  "application/vnd.xmpie.plan": { "source": "iana" },
  "application/vnd.xmpie.ppkg": { "source": "iana" },
  "application/vnd.xmpie.xlim": { "source": "iana" },
  "application/vnd.yamaha.hv-dic": { "source": "iana", "extensions": ["hvd"] },
  "application/vnd.yamaha.hv-script": { "source": "iana", "extensions": ["hvs"] },
  "application/vnd.yamaha.hv-voice": { "source": "iana", "extensions": ["hvp"] },
  "application/vnd.yamaha.openscoreformat": { "source": "iana", "extensions": ["osf"] },
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": { "source": "iana", "compressible": true, "extensions": ["osfpvg"] },
  "application/vnd.yamaha.remote-setup": { "source": "iana" },
  "application/vnd.yamaha.smaf-audio": { "source": "iana", "extensions": ["saf"] },
  "application/vnd.yamaha.smaf-phrase": { "source": "iana", "extensions": ["spf"] },
  "application/vnd.yamaha.through-ngn": { "source": "iana" },
  "application/vnd.yamaha.tunnel-udpencap": { "source": "iana" },
  "application/vnd.yaoweme": { "source": "iana" },
  "application/vnd.yellowriver-custom-menu": { "source": "iana", "extensions": ["cmp"] },
  "application/vnd.zul": { "source": "iana", "extensions": ["zir", "zirz"] },
  "application/vnd.zzazz.deck+xml": { "source": "iana", "compressible": true, "extensions": ["zaz"] },
  "application/voicexml+xml": { "source": "iana", "compressible": true, "extensions": ["vxml"] },
  "application/voucher-cms+json": { "source": "iana", "compressible": true },
  "application/voucher-jws+json": { "source": "iana", "compressible": true },
  "application/vp": { "source": "iana" },
  "application/vp+cose": { "source": "iana" },
  "application/vp+jwt": { "source": "iana" },
  "application/vq-rtcpxr": { "source": "iana" },
  "application/wasm": { "source": "iana", "compressible": true, "extensions": ["wasm"] },
  "application/watcherinfo+xml": { "source": "iana", "compressible": true, "extensions": ["wif"] },
  "application/webpush-options+json": { "source": "iana", "compressible": true },
  "application/whoispp-query": { "source": "iana" },
  "application/whoispp-response": { "source": "iana" },
  "application/widget": { "source": "iana", "extensions": ["wgt"] },
  "application/winhlp": { "source": "apache", "extensions": ["hlp"] },
  "application/wita": { "source": "iana" },
  "application/wordperfect5.1": { "source": "iana" },
  "application/wsdl+xml": { "source": "iana", "compressible": true, "extensions": ["wsdl"] },
  "application/wspolicy+xml": { "source": "iana", "compressible": true, "extensions": ["wspolicy"] },
  "application/x-7z-compressed": { "source": "apache", "compressible": false, "extensions": ["7z"] },
  "application/x-abiword": { "source": "apache", "extensions": ["abw"] },
  "application/x-ace-compressed": { "source": "apache", "extensions": ["ace"] },
  "application/x-amf": { "source": "apache" },
  "application/x-apple-diskimage": { "source": "apache", "extensions": ["dmg"] },
  "application/x-arj": { "compressible": false, "extensions": ["arj"] },
  "application/x-authorware-bin": { "source": "apache", "extensions": ["aab", "x32", "u32", "vox"] },
  "application/x-authorware-map": { "source": "apache", "extensions": ["aam"] },
  "application/x-authorware-seg": { "source": "apache", "extensions": ["aas"] },
  "application/x-bcpio": { "source": "apache", "extensions": ["bcpio"] },
  "application/x-bdoc": { "compressible": false, "extensions": ["bdoc"] },
  "application/x-bittorrent": { "source": "apache", "extensions": ["torrent"] },
  "application/x-blender": { "extensions": ["blend"] },
  "application/x-blorb": { "source": "apache", "extensions": ["blb", "blorb"] },
  "application/x-bzip": { "source": "apache", "compressible": false, "extensions": ["bz"] },
  "application/x-bzip2": { "source": "apache", "compressible": false, "extensions": ["bz2", "boz"] },
  "application/x-cbr": { "source": "apache", "extensions": ["cbr", "cba", "cbt", "cbz", "cb7"] },
  "application/x-cdlink": { "source": "apache", "extensions": ["vcd"] },
  "application/x-cfs-compressed": { "source": "apache", "extensions": ["cfs"] },
  "application/x-chat": { "source": "apache", "extensions": ["chat"] },
  "application/x-chess-pgn": { "source": "apache", "extensions": ["pgn"] },
  "application/x-chrome-extension": { "extensions": ["crx"] },
  "application/x-cocoa": { "source": "nginx", "extensions": ["cco"] },
  "application/x-compress": { "source": "apache" },
  "application/x-compressed": { "extensions": ["rar"] },
  "application/x-conference": { "source": "apache", "extensions": ["nsc"] },
  "application/x-cpio": { "source": "apache", "extensions": ["cpio"] },
  "application/x-csh": { "source": "apache", "extensions": ["csh"] },
  "application/x-deb": { "compressible": false },
  "application/x-debian-package": { "source": "apache", "extensions": ["deb", "udeb"] },
  "application/x-dgc-compressed": { "source": "apache", "extensions": ["dgc"] },
  "application/x-director": { "source": "apache", "extensions": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"] },
  "application/x-doom": { "source": "apache", "extensions": ["wad"] },
  "application/x-dtbncx+xml": { "source": "apache", "compressible": true, "extensions": ["ncx"] },
  "application/x-dtbook+xml": { "source": "apache", "compressible": true, "extensions": ["dtb"] },
  "application/x-dtbresource+xml": { "source": "apache", "compressible": true, "extensions": ["res"] },
  "application/x-dvi": { "source": "apache", "compressible": false, "extensions": ["dvi"] },
  "application/x-envoy": { "source": "apache", "extensions": ["evy"] },
  "application/x-eva": { "source": "apache", "extensions": ["eva"] },
  "application/x-font-bdf": { "source": "apache", "extensions": ["bdf"] },
  "application/x-font-dos": { "source": "apache" },
  "application/x-font-framemaker": { "source": "apache" },
  "application/x-font-ghostscript": { "source": "apache", "extensions": ["gsf"] },
  "application/x-font-libgrx": { "source": "apache" },
  "application/x-font-linux-psf": { "source": "apache", "extensions": ["psf"] },
  "application/x-font-pcf": { "source": "apache", "extensions": ["pcf"] },
  "application/x-font-snf": { "source": "apache", "extensions": ["snf"] },
  "application/x-font-speedo": { "source": "apache" },
  "application/x-font-sunos-news": { "source": "apache" },
  "application/x-font-type1": { "source": "apache", "extensions": ["pfa", "pfb", "pfm", "afm"] },
  "application/x-font-vfont": { "source": "apache" },
  "application/x-freearc": { "source": "apache", "extensions": ["arc"] },
  "application/x-futuresplash": { "source": "apache", "extensions": ["spl"] },
  "application/x-gca-compressed": { "source": "apache", "extensions": ["gca"] },
  "application/x-glulx": { "source": "apache", "extensions": ["ulx"] },
  "application/x-gnumeric": { "source": "apache", "extensions": ["gnumeric"] },
  "application/x-gramps-xml": { "source": "apache", "extensions": ["gramps"] },
  "application/x-gtar": { "source": "apache", "extensions": ["gtar"] },
  "application/x-gzip": { "source": "apache" },
  "application/x-hdf": { "source": "apache", "extensions": ["hdf"] },
  "application/x-httpd-php": { "compressible": true, "extensions": ["php"] },
  "application/x-install-instructions": { "source": "apache", "extensions": ["install"] },
  "application/x-ipynb+json": { "compressible": true, "extensions": ["ipynb"] },
  "application/x-iso9660-image": { "source": "apache", "extensions": ["iso"] },
  "application/x-iwork-keynote-sffkey": { "extensions": ["key"] },
  "application/x-iwork-numbers-sffnumbers": { "extensions": ["numbers"] },
  "application/x-iwork-pages-sffpages": { "extensions": ["pages"] },
  "application/x-java-archive-diff": { "source": "nginx", "extensions": ["jardiff"] },
  "application/x-java-jnlp-file": { "source": "apache", "compressible": false, "extensions": ["jnlp"] },
  "application/x-javascript": { "compressible": true },
  "application/x-keepass2": { "extensions": ["kdbx"] },
  "application/x-latex": { "source": "apache", "compressible": false, "extensions": ["latex"] },
  "application/x-lua-bytecode": { "extensions": ["luac"] },
  "application/x-lzh-compressed": { "source": "apache", "extensions": ["lzh", "lha"] },
  "application/x-makeself": { "source": "nginx", "extensions": ["run"] },
  "application/x-mie": { "source": "apache", "extensions": ["mie"] },
  "application/x-mobipocket-ebook": { "source": "apache", "extensions": ["prc", "mobi"] },
  "application/x-mpegurl": { "compressible": false },
  "application/x-ms-application": { "source": "apache", "extensions": ["application"] },
  "application/x-ms-shortcut": { "source": "apache", "extensions": ["lnk"] },
  "application/x-ms-wmd": { "source": "apache", "extensions": ["wmd"] },
  "application/x-ms-wmz": { "source": "apache", "extensions": ["wmz"] },
  "application/x-ms-xbap": { "source": "apache", "extensions": ["xbap"] },
  "application/x-msaccess": { "source": "apache", "extensions": ["mdb"] },
  "application/x-msbinder": { "source": "apache", "extensions": ["obd"] },
  "application/x-mscardfile": { "source": "apache", "extensions": ["crd"] },
  "application/x-msclip": { "source": "apache", "extensions": ["clp"] },
  "application/x-msdos-program": { "extensions": ["exe"] },
  "application/x-msdownload": { "source": "apache", "extensions": ["exe", "dll", "com", "bat", "msi"] },
  "application/x-msmediaview": { "source": "apache", "extensions": ["mvb", "m13", "m14"] },
  "application/x-msmetafile": { "source": "apache", "extensions": ["wmf", "wmz", "emf", "emz"] },
  "application/x-msmoney": { "source": "apache", "extensions": ["mny"] },
  "application/x-mspublisher": { "source": "apache", "extensions": ["pub"] },
  "application/x-msschedule": { "source": "apache", "extensions": ["scd"] },
  "application/x-msterminal": { "source": "apache", "extensions": ["trm"] },
  "application/x-mswrite": { "source": "apache", "extensions": ["wri"] },
  "application/x-netcdf": { "source": "apache", "extensions": ["nc", "cdf"] },
  "application/x-ns-proxy-autoconfig": { "compressible": true, "extensions": ["pac"] },
  "application/x-nzb": { "source": "apache", "extensions": ["nzb"] },
  "application/x-perl": { "source": "nginx", "extensions": ["pl", "pm"] },
  "application/x-pilot": { "source": "nginx", "extensions": ["prc", "pdb"] },
  "application/x-pkcs12": { "source": "apache", "compressible": false, "extensions": ["p12", "pfx"] },
  "application/x-pkcs7-certificates": { "source": "apache", "extensions": ["p7b", "spc"] },
  "application/x-pkcs7-certreqresp": { "source": "apache", "extensions": ["p7r"] },
  "application/x-pki-message": { "source": "iana" },
  "application/x-rar-compressed": { "source": "apache", "compressible": false, "extensions": ["rar"] },
  "application/x-redhat-package-manager": { "source": "nginx", "extensions": ["rpm"] },
  "application/x-research-info-systems": { "source": "apache", "extensions": ["ris"] },
  "application/x-sea": { "source": "nginx", "extensions": ["sea"] },
  "application/x-sh": { "source": "apache", "compressible": true, "extensions": ["sh"] },
  "application/x-shar": { "source": "apache", "extensions": ["shar"] },
  "application/x-shockwave-flash": { "source": "apache", "compressible": false, "extensions": ["swf"] },
  "application/x-silverlight-app": { "source": "apache", "extensions": ["xap"] },
  "application/x-sql": { "source": "apache", "extensions": ["sql"] },
  "application/x-stuffit": { "source": "apache", "compressible": false, "extensions": ["sit"] },
  "application/x-stuffitx": { "source": "apache", "extensions": ["sitx"] },
  "application/x-subrip": { "source": "apache", "extensions": ["srt"] },
  "application/x-sv4cpio": { "source": "apache", "extensions": ["sv4cpio"] },
  "application/x-sv4crc": { "source": "apache", "extensions": ["sv4crc"] },
  "application/x-t3vm-image": { "source": "apache", "extensions": ["t3"] },
  "application/x-tads": { "source": "apache", "extensions": ["gam"] },
  "application/x-tar": { "source": "apache", "compressible": true, "extensions": ["tar"] },
  "application/x-tcl": { "source": "apache", "extensions": ["tcl", "tk"] },
  "application/x-tex": { "source": "apache", "extensions": ["tex"] },
  "application/x-tex-tfm": { "source": "apache", "extensions": ["tfm"] },
  "application/x-texinfo": { "source": "apache", "extensions": ["texinfo", "texi"] },
  "application/x-tgif": { "source": "apache", "extensions": ["obj"] },
  "application/x-ustar": { "source": "apache", "extensions": ["ustar"] },
  "application/x-virtualbox-hdd": { "compressible": true, "extensions": ["hdd"] },
  "application/x-virtualbox-ova": { "compressible": true, "extensions": ["ova"] },
  "application/x-virtualbox-ovf": { "compressible": true, "extensions": ["ovf"] },
  "application/x-virtualbox-vbox": { "compressible": true, "extensions": ["vbox"] },
  "application/x-virtualbox-vbox-extpack": { "compressible": false, "extensions": ["vbox-extpack"] },
  "application/x-virtualbox-vdi": { "compressible": true, "extensions": ["vdi"] },
  "application/x-virtualbox-vhd": { "compressible": true, "extensions": ["vhd"] },
  "application/x-virtualbox-vmdk": { "compressible": true, "extensions": ["vmdk"] },
  "application/x-wais-source": { "source": "apache", "extensions": ["src"] },
  "application/x-web-app-manifest+json": { "compressible": true, "extensions": ["webapp"] },
  "application/x-www-form-urlencoded": { "source": "iana", "compressible": true },
  "application/x-x509-ca-cert": { "source": "iana", "extensions": ["der", "crt", "pem"] },
  "application/x-x509-ca-ra-cert": { "source": "iana" },
  "application/x-x509-next-ca-cert": { "source": "iana" },
  "application/x-xfig": { "source": "apache", "extensions": ["fig"] },
  "application/x-xliff+xml": { "source": "apache", "compressible": true, "extensions": ["xlf"] },
  "application/x-xpinstall": { "source": "apache", "compressible": false, "extensions": ["xpi"] },
  "application/x-xz": { "source": "apache", "extensions": ["xz"] },
  "application/x-zip-compressed": { "extensions": ["zip"] },
  "application/x-zmachine": { "source": "apache", "extensions": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"] },
  "application/x400-bp": { "source": "iana" },
  "application/xacml+xml": { "source": "iana", "compressible": true },
  "application/xaml+xml": { "source": "apache", "compressible": true, "extensions": ["xaml"] },
  "application/xcap-att+xml": { "source": "iana", "compressible": true, "extensions": ["xav"] },
  "application/xcap-caps+xml": { "source": "iana", "compressible": true, "extensions": ["xca"] },
  "application/xcap-diff+xml": { "source": "iana", "compressible": true, "extensions": ["xdf"] },
  "application/xcap-el+xml": { "source": "iana", "compressible": true, "extensions": ["xel"] },
  "application/xcap-error+xml": { "source": "iana", "compressible": true },
  "application/xcap-ns+xml": { "source": "iana", "compressible": true, "extensions": ["xns"] },
  "application/xcon-conference-info+xml": { "source": "iana", "compressible": true },
  "application/xcon-conference-info-diff+xml": { "source": "iana", "compressible": true },
  "application/xenc+xml": { "source": "iana", "compressible": true, "extensions": ["xenc"] },
  "application/xfdf": { "source": "iana", "extensions": ["xfdf"] },
  "application/xhtml+xml": { "source": "iana", "compressible": true, "extensions": ["xhtml", "xht"] },
  "application/xhtml-voice+xml": { "source": "apache", "compressible": true },
  "application/xliff+xml": { "source": "iana", "compressible": true, "extensions": ["xlf"] },
  "application/xml": { "source": "iana", "compressible": true, "extensions": ["xml", "xsl", "xsd", "rng"] },
  "application/xml-dtd": { "source": "iana", "compressible": true, "extensions": ["dtd"] },
  "application/xml-external-parsed-entity": { "source": "iana" },
  "application/xml-patch+xml": { "source": "iana", "compressible": true },
  "application/xmpp+xml": { "source": "iana", "compressible": true },
  "application/xop+xml": { "source": "iana", "compressible": true, "extensions": ["xop"] },
  "application/xproc+xml": { "source": "apache", "compressible": true, "extensions": ["xpl"] },
  "application/xslt+xml": { "source": "iana", "compressible": true, "extensions": ["xsl", "xslt"] },
  "application/xspf+xml": { "source": "apache", "compressible": true, "extensions": ["xspf"] },
  "application/xv+xml": { "source": "iana", "compressible": true, "extensions": ["mxml", "xhvml", "xvml", "xvm"] },
  "application/yaml": { "source": "iana" },
  "application/yang": { "source": "iana", "extensions": ["yang"] },
  "application/yang-data+cbor": { "source": "iana" },
  "application/yang-data+json": { "source": "iana", "compressible": true },
  "application/yang-data+xml": { "source": "iana", "compressible": true },
  "application/yang-patch+json": { "source": "iana", "compressible": true },
  "application/yang-patch+xml": { "source": "iana", "compressible": true },
  "application/yang-sid+json": { "source": "iana", "compressible": true },
  "application/yin+xml": { "source": "iana", "compressible": true, "extensions": ["yin"] },
  "application/zip": { "source": "iana", "compressible": false, "extensions": ["zip"] },
  "application/zip+dotlottie": { "extensions": ["lottie"] },
  "application/zlib": { "source": "iana" },
  "application/zstd": { "source": "iana" },
  "audio/1d-interleaved-parityfec": { "source": "iana" },
  "audio/32kadpcm": { "source": "iana" },
  "audio/3gpp": { "source": "iana", "compressible": false, "extensions": ["3gpp"] },
  "audio/3gpp2": { "source": "iana" },
  "audio/aac": { "source": "iana", "extensions": ["adts", "aac"] },
  "audio/ac3": { "source": "iana" },
  "audio/adpcm": { "source": "apache", "extensions": ["adp"] },
  "audio/amr": { "source": "iana", "extensions": ["amr"] },
  "audio/amr-wb": { "source": "iana" },
  "audio/amr-wb+": { "source": "iana" },
  "audio/aptx": { "source": "iana" },
  "audio/asc": { "source": "iana" },
  "audio/atrac-advanced-lossless": { "source": "iana" },
  "audio/atrac-x": { "source": "iana" },
  "audio/atrac3": { "source": "iana" },
  "audio/basic": { "source": "iana", "compressible": false, "extensions": ["au", "snd"] },
  "audio/bv16": { "source": "iana" },
  "audio/bv32": { "source": "iana" },
  "audio/clearmode": { "source": "iana" },
  "audio/cn": { "source": "iana" },
  "audio/dat12": { "source": "iana" },
  "audio/dls": { "source": "iana" },
  "audio/dsr-es201108": { "source": "iana" },
  "audio/dsr-es202050": { "source": "iana" },
  "audio/dsr-es202211": { "source": "iana" },
  "audio/dsr-es202212": { "source": "iana" },
  "audio/dv": { "source": "iana" },
  "audio/dvi4": { "source": "iana" },
  "audio/eac3": { "source": "iana" },
  "audio/encaprtp": { "source": "iana" },
  "audio/evrc": { "source": "iana" },
  "audio/evrc-qcp": { "source": "iana" },
  "audio/evrc0": { "source": "iana" },
  "audio/evrc1": { "source": "iana" },
  "audio/evrcb": { "source": "iana" },
  "audio/evrcb0": { "source": "iana" },
  "audio/evrcb1": { "source": "iana" },
  "audio/evrcnw": { "source": "iana" },
  "audio/evrcnw0": { "source": "iana" },
  "audio/evrcnw1": { "source": "iana" },
  "audio/evrcwb": { "source": "iana" },
  "audio/evrcwb0": { "source": "iana" },
  "audio/evrcwb1": { "source": "iana" },
  "audio/evs": { "source": "iana" },
  "audio/flac": { "source": "iana" },
  "audio/flexfec": { "source": "iana" },
  "audio/fwdred": { "source": "iana" },
  "audio/g711-0": { "source": "iana" },
  "audio/g719": { "source": "iana" },
  "audio/g722": { "source": "iana" },
  "audio/g7221": { "source": "iana" },
  "audio/g723": { "source": "iana" },
  "audio/g726-16": { "source": "iana" },
  "audio/g726-24": { "source": "iana" },
  "audio/g726-32": { "source": "iana" },
  "audio/g726-40": { "source": "iana" },
  "audio/g728": { "source": "iana" },
  "audio/g729": { "source": "iana" },
  "audio/g7291": { "source": "iana" },
  "audio/g729d": { "source": "iana" },
  "audio/g729e": { "source": "iana" },
  "audio/gsm": { "source": "iana" },
  "audio/gsm-efr": { "source": "iana" },
  "audio/gsm-hr-08": { "source": "iana" },
  "audio/ilbc": { "source": "iana" },
  "audio/ip-mr_v2.5": { "source": "iana" },
  "audio/isac": { "source": "apache" },
  "audio/l16": { "source": "iana" },
  "audio/l20": { "source": "iana" },
  "audio/l24": { "source": "iana", "compressible": false },
  "audio/l8": { "source": "iana" },
  "audio/lpc": { "source": "iana" },
  "audio/matroska": { "source": "iana" },
  "audio/melp": { "source": "iana" },
  "audio/melp1200": { "source": "iana" },
  "audio/melp2400": { "source": "iana" },
  "audio/melp600": { "source": "iana" },
  "audio/mhas": { "source": "iana" },
  "audio/midi": { "source": "apache", "extensions": ["mid", "midi", "kar", "rmi"] },
  "audio/midi-clip": { "source": "iana" },
  "audio/mobile-xmf": { "source": "iana", "extensions": ["mxmf"] },
  "audio/mp3": { "compressible": false, "extensions": ["mp3"] },
  "audio/mp4": { "source": "iana", "compressible": false, "extensions": ["m4a", "mp4a", "m4b"] },
  "audio/mp4a-latm": { "source": "iana" },
  "audio/mpa": { "source": "iana" },
  "audio/mpa-robust": { "source": "iana" },
  "audio/mpeg": { "source": "iana", "compressible": false, "extensions": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"] },
  "audio/mpeg4-generic": { "source": "iana" },
  "audio/musepack": { "source": "apache" },
  "audio/ogg": { "source": "iana", "compressible": false, "extensions": ["oga", "ogg", "spx", "opus"] },
  "audio/opus": { "source": "iana" },
  "audio/parityfec": { "source": "iana" },
  "audio/pcma": { "source": "iana" },
  "audio/pcma-wb": { "source": "iana" },
  "audio/pcmu": { "source": "iana" },
  "audio/pcmu-wb": { "source": "iana" },
  "audio/prs.sid": { "source": "iana" },
  "audio/qcelp": { "source": "iana" },
  "audio/raptorfec": { "source": "iana" },
  "audio/red": { "source": "iana" },
  "audio/rtp-enc-aescm128": { "source": "iana" },
  "audio/rtp-midi": { "source": "iana" },
  "audio/rtploopback": { "source": "iana" },
  "audio/rtx": { "source": "iana" },
  "audio/s3m": { "source": "apache", "extensions": ["s3m"] },
  "audio/scip": { "source": "iana" },
  "audio/silk": { "source": "apache", "extensions": ["sil"] },
  "audio/smv": { "source": "iana" },
  "audio/smv-qcp": { "source": "iana" },
  "audio/smv0": { "source": "iana" },
  "audio/sofa": { "source": "iana" },
  "audio/sp-midi": { "source": "iana" },
  "audio/speex": { "source": "iana" },
  "audio/t140c": { "source": "iana" },
  "audio/t38": { "source": "iana" },
  "audio/telephone-event": { "source": "iana" },
  "audio/tetra_acelp": { "source": "iana" },
  "audio/tetra_acelp_bb": { "source": "iana" },
  "audio/tone": { "source": "iana" },
  "audio/tsvcis": { "source": "iana" },
  "audio/uemclip": { "source": "iana" },
  "audio/ulpfec": { "source": "iana" },
  "audio/usac": { "source": "iana" },
  "audio/vdvi": { "source": "iana" },
  "audio/vmr-wb": { "source": "iana" },
  "audio/vnd.3gpp.iufp": { "source": "iana" },
  "audio/vnd.4sb": { "source": "iana" },
  "audio/vnd.audiokoz": { "source": "iana" },
  "audio/vnd.celp": { "source": "iana" },
  "audio/vnd.cisco.nse": { "source": "iana" },
  "audio/vnd.cmles.radio-events": { "source": "iana" },
  "audio/vnd.cns.anp1": { "source": "iana" },
  "audio/vnd.cns.inf1": { "source": "iana" },
  "audio/vnd.dece.audio": { "source": "iana", "extensions": ["uva", "uvva"] },
  "audio/vnd.digital-winds": { "source": "iana", "extensions": ["eol"] },
  "audio/vnd.dlna.adts": { "source": "iana" },
  "audio/vnd.dolby.heaac.1": { "source": "iana" },
  "audio/vnd.dolby.heaac.2": { "source": "iana" },
  "audio/vnd.dolby.mlp": { "source": "iana" },
  "audio/vnd.dolby.mps": { "source": "iana" },
  "audio/vnd.dolby.pl2": { "source": "iana" },
  "audio/vnd.dolby.pl2x": { "source": "iana" },
  "audio/vnd.dolby.pl2z": { "source": "iana" },
  "audio/vnd.dolby.pulse.1": { "source": "iana" },
  "audio/vnd.dra": { "source": "iana", "extensions": ["dra"] },
  "audio/vnd.dts": { "source": "iana", "extensions": ["dts"] },
  "audio/vnd.dts.hd": { "source": "iana", "extensions": ["dtshd"] },
  "audio/vnd.dts.uhd": { "source": "iana" },
  "audio/vnd.dvb.file": { "source": "iana" },
  "audio/vnd.everad.plj": { "source": "iana" },
  "audio/vnd.hns.audio": { "source": "iana" },
  "audio/vnd.lucent.voice": { "source": "iana", "extensions": ["lvp"] },
  "audio/vnd.ms-playready.media.pya": { "source": "iana", "extensions": ["pya"] },
  "audio/vnd.nokia.mobile-xmf": { "source": "iana" },
  "audio/vnd.nortel.vbk": { "source": "iana" },
  "audio/vnd.nuera.ecelp4800": { "source": "iana", "extensions": ["ecelp4800"] },
  "audio/vnd.nuera.ecelp7470": { "source": "iana", "extensions": ["ecelp7470"] },
  "audio/vnd.nuera.ecelp9600": { "source": "iana", "extensions": ["ecelp9600"] },
  "audio/vnd.octel.sbc": { "source": "iana" },
  "audio/vnd.presonus.multitrack": { "source": "iana" },
  "audio/vnd.qcelp": { "source": "apache" },
  "audio/vnd.rhetorex.32kadpcm": { "source": "iana" },
  "audio/vnd.rip": { "source": "iana", "extensions": ["rip"] },
  "audio/vnd.rn-realaudio": { "compressible": false },
  "audio/vnd.sealedmedia.softseal.mpeg": { "source": "iana" },
  "audio/vnd.vmx.cvsd": { "source": "iana" },
  "audio/vnd.wave": { "compressible": false },
  "audio/vorbis": { "source": "iana", "compressible": false },
  "audio/vorbis-config": { "source": "iana" },
  "audio/wav": { "compressible": false, "extensions": ["wav"] },
  "audio/wave": { "compressible": false, "extensions": ["wav"] },
  "audio/webm": { "source": "apache", "compressible": false, "extensions": ["weba"] },
  "audio/x-aac": { "source": "apache", "compressible": false, "extensions": ["aac"] },
  "audio/x-aiff": { "source": "apache", "extensions": ["aif", "aiff", "aifc"] },
  "audio/x-caf": { "source": "apache", "compressible": false, "extensions": ["caf"] },
  "audio/x-flac": { "source": "apache", "extensions": ["flac"] },
  "audio/x-m4a": { "source": "nginx", "extensions": ["m4a"] },
  "audio/x-matroska": { "source": "apache", "extensions": ["mka"] },
  "audio/x-mpegurl": { "source": "apache", "extensions": ["m3u"] },
  "audio/x-ms-wax": { "source": "apache", "extensions": ["wax"] },
  "audio/x-ms-wma": { "source": "apache", "extensions": ["wma"] },
  "audio/x-pn-realaudio": { "source": "apache", "extensions": ["ram", "ra"] },
  "audio/x-pn-realaudio-plugin": { "source": "apache", "extensions": ["rmp"] },
  "audio/x-realaudio": { "source": "nginx", "extensions": ["ra"] },
  "audio/x-tta": { "source": "apache" },
  "audio/x-wav": { "source": "apache", "extensions": ["wav"] },
  "audio/xm": { "source": "apache", "extensions": ["xm"] },
  "chemical/x-cdx": { "source": "apache", "extensions": ["cdx"] },
  "chemical/x-cif": { "source": "apache", "extensions": ["cif"] },
  "chemical/x-cmdf": { "source": "apache", "extensions": ["cmdf"] },
  "chemical/x-cml": { "source": "apache", "extensions": ["cml"] },
  "chemical/x-csml": { "source": "apache", "extensions": ["csml"] },
  "chemical/x-pdb": { "source": "apache" },
  "chemical/x-xyz": { "source": "apache", "extensions": ["xyz"] },
  "font/collection": { "source": "iana", "extensions": ["ttc"] },
  "font/otf": { "source": "iana", "compressible": true, "extensions": ["otf"] },
  "font/sfnt": { "source": "iana" },
  "font/ttf": { "source": "iana", "compressible": true, "extensions": ["ttf"] },
  "font/woff": { "source": "iana", "extensions": ["woff"] },
  "font/woff2": { "source": "iana", "extensions": ["woff2"] },
  "image/aces": { "source": "iana", "extensions": ["exr"] },
  "image/apng": { "source": "iana", "compressible": false, "extensions": ["apng"] },
  "image/avci": { "source": "iana", "extensions": ["avci"] },
  "image/avcs": { "source": "iana", "extensions": ["avcs"] },
  "image/avif": { "source": "iana", "compressible": false, "extensions": ["avif"] },
  "image/bmp": { "source": "iana", "compressible": true, "extensions": ["bmp", "dib"] },
  "image/cgm": { "source": "iana", "extensions": ["cgm"] },
  "image/dicom-rle": { "source": "iana", "extensions": ["drle"] },
  "image/dpx": { "source": "iana", "extensions": ["dpx"] },
  "image/emf": { "source": "iana", "extensions": ["emf"] },
  "image/fits": { "source": "iana", "extensions": ["fits"] },
  "image/g3fax": { "source": "iana", "extensions": ["g3"] },
  "image/gif": { "source": "iana", "compressible": false, "extensions": ["gif"] },
  "image/heic": { "source": "iana", "extensions": ["heic"] },
  "image/heic-sequence": { "source": "iana", "extensions": ["heics"] },
  "image/heif": { "source": "iana", "extensions": ["heif"] },
  "image/heif-sequence": { "source": "iana", "extensions": ["heifs"] },
  "image/hej2k": { "source": "iana", "extensions": ["hej2"] },
  "image/ief": { "source": "iana", "extensions": ["ief"] },
  "image/j2c": { "source": "iana" },
  "image/jaii": { "source": "iana", "extensions": ["jaii"] },
  "image/jais": { "source": "iana", "extensions": ["jais"] },
  "image/jls": { "source": "iana", "extensions": ["jls"] },
  "image/jp2": { "source": "iana", "compressible": false, "extensions": ["jp2", "jpg2"] },
  "image/jpeg": { "source": "iana", "compressible": false, "extensions": ["jpg", "jpeg", "jpe"] },
  "image/jph": { "source": "iana", "extensions": ["jph"] },
  "image/jphc": { "source": "iana", "extensions": ["jhc"] },
  "image/jpm": { "source": "iana", "compressible": false, "extensions": ["jpm", "jpgm"] },
  "image/jpx": { "source": "iana", "compressible": false, "extensions": ["jpx", "jpf"] },
  "image/jxl": { "source": "iana", "extensions": ["jxl"] },
  "image/jxr": { "source": "iana", "extensions": ["jxr"] },
  "image/jxra": { "source": "iana", "extensions": ["jxra"] },
  "image/jxrs": { "source": "iana", "extensions": ["jxrs"] },
  "image/jxs": { "source": "iana", "extensions": ["jxs"] },
  "image/jxsc": { "source": "iana", "extensions": ["jxsc"] },
  "image/jxsi": { "source": "iana", "extensions": ["jxsi"] },
  "image/jxss": { "source": "iana", "extensions": ["jxss"] },
  "image/ktx": { "source": "iana", "extensions": ["ktx"] },
  "image/ktx2": { "source": "iana", "extensions": ["ktx2"] },
  "image/naplps": { "source": "iana" },
  "image/pjpeg": { "compressible": false, "extensions": ["jfif"] },
  "image/png": { "source": "iana", "compressible": false, "extensions": ["png"] },
  "image/prs.btif": { "source": "iana", "extensions": ["btif", "btf"] },
  "image/prs.pti": { "source": "iana", "extensions": ["pti"] },
  "image/pwg-raster": { "source": "iana" },
  "image/sgi": { "source": "apache", "extensions": ["sgi"] },
  "image/svg+xml": { "source": "iana", "compressible": true, "extensions": ["svg", "svgz"] },
  "image/t38": { "source": "iana", "extensions": ["t38"] },
  "image/tiff": { "source": "iana", "compressible": false, "extensions": ["tif", "tiff"] },
  "image/tiff-fx": { "source": "iana", "extensions": ["tfx"] },
  "image/vnd.adobe.photoshop": { "source": "iana", "compressible": true, "extensions": ["psd"] },
  "image/vnd.airzip.accelerator.azv": { "source": "iana", "extensions": ["azv"] },
  "image/vnd.clip": { "source": "iana" },
  "image/vnd.cns.inf2": { "source": "iana" },
  "image/vnd.dece.graphic": { "source": "iana", "extensions": ["uvi", "uvvi", "uvg", "uvvg"] },
  "image/vnd.djvu": { "source": "iana", "extensions": ["djvu", "djv"] },
  "image/vnd.dvb.subtitle": { "source": "iana", "extensions": ["sub"] },
  "image/vnd.dwg": { "source": "iana", "extensions": ["dwg"] },
  "image/vnd.dxf": { "source": "iana", "extensions": ["dxf"] },
  "image/vnd.fastbidsheet": { "source": "iana", "extensions": ["fbs"] },
  "image/vnd.fpx": { "source": "iana", "extensions": ["fpx"] },
  "image/vnd.fst": { "source": "iana", "extensions": ["fst"] },
  "image/vnd.fujixerox.edmics-mmr": { "source": "iana", "extensions": ["mmr"] },
  "image/vnd.fujixerox.edmics-rlc": { "source": "iana", "extensions": ["rlc"] },
  "image/vnd.globalgraphics.pgb": { "source": "iana" },
  "image/vnd.microsoft.icon": { "source": "iana", "compressible": true, "extensions": ["ico"] },
  "image/vnd.mix": { "source": "iana" },
  "image/vnd.mozilla.apng": { "source": "iana" },
  "image/vnd.ms-dds": { "compressible": true, "extensions": ["dds"] },
  "image/vnd.ms-modi": { "source": "iana", "extensions": ["mdi"] },
  "image/vnd.ms-photo": { "source": "apache", "extensions": ["wdp"] },
  "image/vnd.net-fpx": { "source": "iana", "extensions": ["npx"] },
  "image/vnd.pco.b16": { "source": "iana", "extensions": ["b16"] },
  "image/vnd.radiance": { "source": "iana" },
  "image/vnd.sealed.png": { "source": "iana" },
  "image/vnd.sealedmedia.softseal.gif": { "source": "iana" },
  "image/vnd.sealedmedia.softseal.jpg": { "source": "iana" },
  "image/vnd.svf": { "source": "iana" },
  "image/vnd.tencent.tap": { "source": "iana", "extensions": ["tap"] },
  "image/vnd.valve.source.texture": { "source": "iana", "extensions": ["vtf"] },
  "image/vnd.wap.wbmp": { "source": "iana", "extensions": ["wbmp"] },
  "image/vnd.xiff": { "source": "iana", "extensions": ["xif"] },
  "image/vnd.zbrush.pcx": { "source": "iana", "extensions": ["pcx"] },
  "image/webp": { "source": "iana", "extensions": ["webp"] },
  "image/wmf": { "source": "iana", "extensions": ["wmf"] },
  "image/x-3ds": { "source": "apache", "extensions": ["3ds"] },
  "image/x-adobe-dng": { "extensions": ["dng"] },
  "image/x-cmu-raster": { "source": "apache", "extensions": ["ras"] },
  "image/x-cmx": { "source": "apache", "extensions": ["cmx"] },
  "image/x-emf": { "source": "iana" },
  "image/x-freehand": { "source": "apache", "extensions": ["fh", "fhc", "fh4", "fh5", "fh7"] },
  "image/x-icon": { "source": "apache", "compressible": true, "extensions": ["ico"] },
  "image/x-jng": { "source": "nginx", "extensions": ["jng"] },
  "image/x-mrsid-image": { "source": "apache", "extensions": ["sid"] },
  "image/x-ms-bmp": { "source": "nginx", "compressible": true, "extensions": ["bmp"] },
  "image/x-pcx": { "source": "apache", "extensions": ["pcx"] },
  "image/x-pict": { "source": "apache", "extensions": ["pic", "pct"] },
  "image/x-portable-anymap": { "source": "apache", "extensions": ["pnm"] },
  "image/x-portable-bitmap": { "source": "apache", "extensions": ["pbm"] },
  "image/x-portable-graymap": { "source": "apache", "extensions": ["pgm"] },
  "image/x-portable-pixmap": { "source": "apache", "extensions": ["ppm"] },
  "image/x-rgb": { "source": "apache", "extensions": ["rgb"] },
  "image/x-tga": { "source": "apache", "extensions": ["tga"] },
  "image/x-wmf": { "source": "iana" },
  "image/x-xbitmap": { "source": "apache", "extensions": ["xbm"] },
  "image/x-xcf": { "compressible": false },
  "image/x-xpixmap": { "source": "apache", "extensions": ["xpm"] },
  "image/x-xwindowdump": { "source": "apache", "extensions": ["xwd"] },
  "message/bhttp": { "source": "iana" },
  "message/cpim": { "source": "iana" },
  "message/delivery-status": { "source": "iana" },
  "message/disposition-notification": { "source": "iana", "extensions": ["disposition-notification"] },
  "message/external-body": { "source": "iana" },
  "message/feedback-report": { "source": "iana" },
  "message/global": { "source": "iana", "extensions": ["u8msg"] },
  "message/global-delivery-status": { "source": "iana", "extensions": ["u8dsn"] },
  "message/global-disposition-notification": { "source": "iana", "extensions": ["u8mdn"] },
  "message/global-headers": { "source": "iana", "extensions": ["u8hdr"] },
  "message/http": { "source": "iana", "compressible": false },
  "message/imdn+xml": { "source": "iana", "compressible": true },
  "message/mls": { "source": "iana" },
  "message/news": { "source": "apache" },
  "message/ohttp-req": { "source": "iana" },
  "message/ohttp-res": { "source": "iana" },
  "message/partial": { "source": "iana", "compressible": false },
  "message/rfc822": { "source": "iana", "compressible": true, "extensions": ["eml", "mime", "mht", "mhtml"] },
  "message/s-http": { "source": "apache" },
  "message/sip": { "source": "iana" },
  "message/sipfrag": { "source": "iana" },
  "message/tracking-status": { "source": "iana" },
  "message/vnd.si.simp": { "source": "apache" },
  "message/vnd.wfa.wsc": { "source": "iana", "extensions": ["wsc"] },
  "model/3mf": { "source": "iana", "extensions": ["3mf"] },
  "model/e57": { "source": "iana" },
  "model/gltf+json": { "source": "iana", "compressible": true, "extensions": ["gltf"] },
  "model/gltf-binary": { "source": "iana", "compressible": true, "extensions": ["glb"] },
  "model/iges": { "source": "iana", "compressible": false, "extensions": ["igs", "iges"] },
  "model/jt": { "source": "iana", "extensions": ["jt"] },
  "model/mesh": { "source": "iana", "compressible": false, "extensions": ["msh", "mesh", "silo"] },
  "model/mtl": { "source": "iana", "extensions": ["mtl"] },
  "model/obj": { "source": "iana", "extensions": ["obj"] },
  "model/prc": { "source": "iana", "extensions": ["prc"] },
  "model/step": { "source": "iana", "extensions": ["step", "stp", "stpnc", "p21", "210"] },
  "model/step+xml": { "source": "iana", "compressible": true, "extensions": ["stpx"] },
  "model/step+zip": { "source": "iana", "compressible": false, "extensions": ["stpz"] },
  "model/step-xml+zip": { "source": "iana", "compressible": false, "extensions": ["stpxz"] },
  "model/stl": { "source": "iana", "extensions": ["stl"] },
  "model/u3d": { "source": "iana", "extensions": ["u3d"] },
  "model/vnd.bary": { "source": "iana", "extensions": ["bary"] },
  "model/vnd.cld": { "source": "iana", "extensions": ["cld"] },
  "model/vnd.collada+xml": { "source": "iana", "compressible": true, "extensions": ["dae"] },
  "model/vnd.dwf": { "source": "iana", "extensions": ["dwf"] },
  "model/vnd.flatland.3dml": { "source": "iana" },
  "model/vnd.gdl": { "source": "iana", "extensions": ["gdl"] },
  "model/vnd.gs-gdl": { "source": "apache" },
  "model/vnd.gs.gdl": { "source": "iana" },
  "model/vnd.gtw": { "source": "iana", "extensions": ["gtw"] },
  "model/vnd.moml+xml": { "source": "iana", "compressible": true },
  "model/vnd.mts": { "source": "iana", "extensions": ["mts"] },
  "model/vnd.opengex": { "source": "iana", "extensions": ["ogex"] },
  "model/vnd.parasolid.transmit.binary": { "source": "iana", "extensions": ["x_b"] },
  "model/vnd.parasolid.transmit.text": { "source": "iana", "extensions": ["x_t"] },
  "model/vnd.pytha.pyox": { "source": "iana", "extensions": ["pyo", "pyox"] },
  "model/vnd.rosette.annotated-data-model": { "source": "iana" },
  "model/vnd.sap.vds": { "source": "iana", "extensions": ["vds"] },
  "model/vnd.usda": { "source": "iana", "extensions": ["usda"] },
  "model/vnd.usdz+zip": { "source": "iana", "compressible": false, "extensions": ["usdz"] },
  "model/vnd.valve.source.compiled-map": { "source": "iana", "extensions": ["bsp"] },
  "model/vnd.vtu": { "source": "iana", "extensions": ["vtu"] },
  "model/vrml": { "source": "iana", "compressible": false, "extensions": ["wrl", "vrml"] },
  "model/x3d+binary": { "source": "apache", "compressible": false, "extensions": ["x3db", "x3dbz"] },
  "model/x3d+fastinfoset": { "source": "iana", "extensions": ["x3db"] },
  "model/x3d+vrml": { "source": "apache", "compressible": false, "extensions": ["x3dv", "x3dvz"] },
  "model/x3d+xml": { "source": "iana", "compressible": true, "extensions": ["x3d", "x3dz"] },
  "model/x3d-vrml": { "source": "iana", "extensions": ["x3dv"] },
  "multipart/alternative": { "source": "iana", "compressible": false },
  "multipart/appledouble": { "source": "iana" },
  "multipart/byteranges": { "source": "iana" },
  "multipart/digest": { "source": "iana" },
  "multipart/encrypted": { "source": "iana", "compressible": false },
  "multipart/form-data": { "source": "iana", "compressible": false },
  "multipart/header-set": { "source": "iana" },
  "multipart/mixed": { "source": "iana" },
  "multipart/multilingual": { "source": "iana" },
  "multipart/parallel": { "source": "iana" },
  "multipart/related": { "source": "iana", "compressible": false },
  "multipart/report": { "source": "iana" },
  "multipart/signed": { "source": "iana", "compressible": false },
  "multipart/vnd.bint.med-plus": { "source": "iana" },
  "multipart/voice-message": { "source": "iana" },
  "multipart/x-mixed-replace": { "source": "iana" },
  "text/1d-interleaved-parityfec": { "source": "iana" },
  "text/cache-manifest": { "source": "iana", "compressible": true, "extensions": ["appcache", "manifest"] },
  "text/calendar": { "source": "iana", "extensions": ["ics", "ifb"] },
  "text/calender": { "compressible": true },
  "text/cmd": { "compressible": true },
  "text/coffeescript": { "extensions": ["coffee", "litcoffee"] },
  "text/cql": { "source": "iana" },
  "text/cql-expression": { "source": "iana" },
  "text/cql-identifier": { "source": "iana" },
  "text/css": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["css"] },
  "text/csv": { "source": "iana", "compressible": true, "extensions": ["csv"] },
  "text/csv-schema": { "source": "iana" },
  "text/directory": { "source": "iana" },
  "text/dns": { "source": "iana" },
  "text/ecmascript": { "source": "apache" },
  "text/encaprtp": { "source": "iana" },
  "text/enriched": { "source": "iana" },
  "text/fhirpath": { "source": "iana" },
  "text/flexfec": { "source": "iana" },
  "text/fwdred": { "source": "iana" },
  "text/gff3": { "source": "iana" },
  "text/grammar-ref-list": { "source": "iana" },
  "text/hl7v2": { "source": "iana" },
  "text/html": { "source": "iana", "compressible": true, "extensions": ["html", "htm", "shtml"] },
  "text/jade": { "extensions": ["jade"] },
  "text/javascript": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["js", "mjs"] },
  "text/jcr-cnd": { "source": "iana" },
  "text/jsx": { "compressible": true, "extensions": ["jsx"] },
  "text/less": { "compressible": true, "extensions": ["less"] },
  "text/markdown": { "source": "iana", "compressible": true, "extensions": ["md", "markdown"] },
  "text/mathml": { "source": "nginx", "extensions": ["mml"] },
  "text/mdx": { "compressible": true, "extensions": ["mdx"] },
  "text/mizar": { "source": "iana" },
  "text/n3": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["n3"] },
  "text/parameters": { "source": "iana", "charset": "UTF-8" },
  "text/parityfec": { "source": "iana" },
  "text/plain": { "source": "iana", "compressible": true, "extensions": ["txt", "text", "conf", "def", "list", "log", "in", "ini"] },
  "text/provenance-notation": { "source": "iana", "charset": "UTF-8" },
  "text/prs.fallenstein.rst": { "source": "iana" },
  "text/prs.lines.tag": { "source": "iana", "extensions": ["dsc"] },
  "text/prs.prop.logic": { "source": "iana" },
  "text/prs.texi": { "source": "iana" },
  "text/raptorfec": { "source": "iana" },
  "text/red": { "source": "iana" },
  "text/rfc822-headers": { "source": "iana" },
  "text/richtext": { "source": "iana", "compressible": true, "extensions": ["rtx"] },
  "text/rtf": { "source": "iana", "compressible": true, "extensions": ["rtf"] },
  "text/rtp-enc-aescm128": { "source": "iana" },
  "text/rtploopback": { "source": "iana" },
  "text/rtx": { "source": "iana" },
  "text/sgml": { "source": "iana", "extensions": ["sgml", "sgm"] },
  "text/shaclc": { "source": "iana" },
  "text/shex": { "source": "iana", "extensions": ["shex"] },
  "text/slim": { "extensions": ["slim", "slm"] },
  "text/spdx": { "source": "iana", "extensions": ["spdx"] },
  "text/strings": { "source": "iana" },
  "text/stylus": { "extensions": ["stylus", "styl"] },
  "text/t140": { "source": "iana" },
  "text/tab-separated-values": { "source": "iana", "compressible": true, "extensions": ["tsv"] },
  "text/troff": { "source": "iana", "extensions": ["t", "tr", "roff", "man", "me", "ms"] },
  "text/turtle": { "source": "iana", "charset": "UTF-8", "extensions": ["ttl"] },
  "text/ulpfec": { "source": "iana" },
  "text/uri-list": { "source": "iana", "compressible": true, "extensions": ["uri", "uris", "urls"] },
  "text/vcard": { "source": "iana", "compressible": true, "extensions": ["vcard"] },
  "text/vnd.a": { "source": "iana" },
  "text/vnd.abc": { "source": "iana" },
  "text/vnd.ascii-art": { "source": "iana" },
  "text/vnd.curl": { "source": "iana", "extensions": ["curl"] },
  "text/vnd.curl.dcurl": { "source": "apache", "extensions": ["dcurl"] },
  "text/vnd.curl.mcurl": { "source": "apache", "extensions": ["mcurl"] },
  "text/vnd.curl.scurl": { "source": "apache", "extensions": ["scurl"] },
  "text/vnd.debian.copyright": { "source": "iana", "charset": "UTF-8" },
  "text/vnd.dmclientscript": { "source": "iana" },
  "text/vnd.dvb.subtitle": { "source": "iana", "extensions": ["sub"] },
  "text/vnd.esmertec.theme-descriptor": { "source": "iana", "charset": "UTF-8" },
  "text/vnd.exchangeable": { "source": "iana" },
  "text/vnd.familysearch.gedcom": { "source": "iana", "extensions": ["ged"] },
  "text/vnd.ficlab.flt": { "source": "iana" },
  "text/vnd.fly": { "source": "iana", "extensions": ["fly"] },
  "text/vnd.fmi.flexstor": { "source": "iana", "extensions": ["flx"] },
  "text/vnd.gml": { "source": "iana" },
  "text/vnd.graphviz": { "source": "iana", "extensions": ["gv"] },
  "text/vnd.hans": { "source": "iana" },
  "text/vnd.hgl": { "source": "iana" },
  "text/vnd.in3d.3dml": { "source": "iana", "extensions": ["3dml"] },
  "text/vnd.in3d.spot": { "source": "iana", "extensions": ["spot"] },
  "text/vnd.iptc.newsml": { "source": "iana" },
  "text/vnd.iptc.nitf": { "source": "iana" },
  "text/vnd.latex-z": { "source": "iana" },
  "text/vnd.motorola.reflex": { "source": "iana" },
  "text/vnd.ms-mediapackage": { "source": "iana" },
  "text/vnd.net2phone.commcenter.command": { "source": "iana" },
  "text/vnd.radisys.msml-basic-layout": { "source": "iana" },
  "text/vnd.senx.warpscript": { "source": "iana" },
  "text/vnd.si.uricatalogue": { "source": "apache" },
  "text/vnd.sosi": { "source": "iana" },
  "text/vnd.sun.j2me.app-descriptor": { "source": "iana", "charset": "UTF-8", "extensions": ["jad"] },
  "text/vnd.trolltech.linguist": { "source": "iana", "charset": "UTF-8" },
  "text/vnd.vcf": { "source": "iana" },
  "text/vnd.wap.si": { "source": "iana" },
  "text/vnd.wap.sl": { "source": "iana" },
  "text/vnd.wap.wml": { "source": "iana", "extensions": ["wml"] },
  "text/vnd.wap.wmlscript": { "source": "iana", "extensions": ["wmls"] },
  "text/vnd.zoo.kcl": { "source": "iana" },
  "text/vtt": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["vtt"] },
  "text/wgsl": { "source": "iana", "extensions": ["wgsl"] },
  "text/x-asm": { "source": "apache", "extensions": ["s", "asm"] },
  "text/x-c": { "source": "apache", "extensions": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"] },
  "text/x-component": { "source": "nginx", "extensions": ["htc"] },
  "text/x-fortran": { "source": "apache", "extensions": ["f", "for", "f77", "f90"] },
  "text/x-gwt-rpc": { "compressible": true },
  "text/x-handlebars-template": { "extensions": ["hbs"] },
  "text/x-java-source": { "source": "apache", "extensions": ["java"] },
  "text/x-jquery-tmpl": { "compressible": true },
  "text/x-lua": { "extensions": ["lua"] },
  "text/x-markdown": { "compressible": true, "extensions": ["mkd"] },
  "text/x-nfo": { "source": "apache", "extensions": ["nfo"] },
  "text/x-opml": { "source": "apache", "extensions": ["opml"] },
  "text/x-org": { "compressible": true, "extensions": ["org"] },
  "text/x-pascal": { "source": "apache", "extensions": ["p", "pas"] },
  "text/x-processing": { "compressible": true, "extensions": ["pde"] },
  "text/x-sass": { "extensions": ["sass"] },
  "text/x-scss": { "extensions": ["scss"] },
  "text/x-setext": { "source": "apache", "extensions": ["etx"] },
  "text/x-sfv": { "source": "apache", "extensions": ["sfv"] },
  "text/x-suse-ymp": { "compressible": true, "extensions": ["ymp"] },
  "text/x-uuencode": { "source": "apache", "extensions": ["uu"] },
  "text/x-vcalendar": { "source": "apache", "extensions": ["vcs"] },
  "text/x-vcard": { "source": "apache", "extensions": ["vcf"] },
  "text/xml": { "source": "iana", "compressible": true, "extensions": ["xml"] },
  "text/xml-external-parsed-entity": { "source": "iana" },
  "text/yaml": { "compressible": true, "extensions": ["yaml", "yml"] },
  "video/1d-interleaved-parityfec": { "source": "iana" },
  "video/3gpp": { "source": "iana", "extensions": ["3gp", "3gpp"] },
  "video/3gpp-tt": { "source": "iana" },
  "video/3gpp2": { "source": "iana", "extensions": ["3g2"] },
  "video/av1": { "source": "iana" },
  "video/bmpeg": { "source": "iana" },
  "video/bt656": { "source": "iana" },
  "video/celb": { "source": "iana" },
  "video/dv": { "source": "iana" },
  "video/encaprtp": { "source": "iana" },
  "video/evc": { "source": "iana" },
  "video/ffv1": { "source": "iana" },
  "video/flexfec": { "source": "iana" },
  "video/h261": { "source": "iana", "extensions": ["h261"] },
  "video/h263": { "source": "iana", "extensions": ["h263"] },
  "video/h263-1998": { "source": "iana" },
  "video/h263-2000": { "source": "iana" },
  "video/h264": { "source": "iana", "extensions": ["h264"] },
  "video/h264-rcdo": { "source": "iana" },
  "video/h264-svc": { "source": "iana" },
  "video/h265": { "source": "iana" },
  "video/h266": { "source": "iana" },
  "video/iso.segment": { "source": "iana", "extensions": ["m4s"] },
  "video/jpeg": { "source": "iana", "extensions": ["jpgv"] },
  "video/jpeg2000": { "source": "iana" },
  "video/jpm": { "source": "apache", "extensions": ["jpm", "jpgm"] },
  "video/jxsv": { "source": "iana" },
  "video/lottie+json": { "source": "iana", "compressible": true },
  "video/matroska": { "source": "iana" },
  "video/matroska-3d": { "source": "iana" },
  "video/mj2": { "source": "iana", "extensions": ["mj2", "mjp2"] },
  "video/mp1s": { "source": "iana" },
  "video/mp2p": { "source": "iana" },
  "video/mp2t": { "source": "iana", "extensions": ["ts", "m2t", "m2ts", "mts"] },
  "video/mp4": { "source": "iana", "compressible": false, "extensions": ["mp4", "mp4v", "mpg4"] },
  "video/mp4v-es": { "source": "iana" },
  "video/mpeg": { "source": "iana", "compressible": false, "extensions": ["mpeg", "mpg", "mpe", "m1v", "m2v"] },
  "video/mpeg4-generic": { "source": "iana" },
  "video/mpv": { "source": "iana" },
  "video/nv": { "source": "iana" },
  "video/ogg": { "source": "iana", "compressible": false, "extensions": ["ogv"] },
  "video/parityfec": { "source": "iana" },
  "video/pointer": { "source": "iana" },
  "video/quicktime": { "source": "iana", "compressible": false, "extensions": ["qt", "mov"] },
  "video/raptorfec": { "source": "iana" },
  "video/raw": { "source": "iana" },
  "video/rtp-enc-aescm128": { "source": "iana" },
  "video/rtploopback": { "source": "iana" },
  "video/rtx": { "source": "iana" },
  "video/scip": { "source": "iana" },
  "video/smpte291": { "source": "iana" },
  "video/smpte292m": { "source": "iana" },
  "video/ulpfec": { "source": "iana" },
  "video/vc1": { "source": "iana" },
  "video/vc2": { "source": "iana" },
  "video/vnd.cctv": { "source": "iana" },
  "video/vnd.dece.hd": { "source": "iana", "extensions": ["uvh", "uvvh"] },
  "video/vnd.dece.mobile": { "source": "iana", "extensions": ["uvm", "uvvm"] },
  "video/vnd.dece.mp4": { "source": "iana" },
  "video/vnd.dece.pd": { "source": "iana", "extensions": ["uvp", "uvvp"] },
  "video/vnd.dece.sd": { "source": "iana", "extensions": ["uvs", "uvvs"] },
  "video/vnd.dece.video": { "source": "iana", "extensions": ["uvv", "uvvv"] },
  "video/vnd.directv.mpeg": { "source": "iana" },
  "video/vnd.directv.mpeg-tts": { "source": "iana" },
  "video/vnd.dlna.mpeg-tts": { "source": "iana" },
  "video/vnd.dvb.file": { "source": "iana", "extensions": ["dvb"] },
  "video/vnd.fvt": { "source": "iana", "extensions": ["fvt"] },
  "video/vnd.hns.video": { "source": "iana" },
  "video/vnd.iptvforum.1dparityfec-1010": { "source": "iana" },
  "video/vnd.iptvforum.1dparityfec-2005": { "source": "iana" },
  "video/vnd.iptvforum.2dparityfec-1010": { "source": "iana" },
  "video/vnd.iptvforum.2dparityfec-2005": { "source": "iana" },
  "video/vnd.iptvforum.ttsavc": { "source": "iana" },
  "video/vnd.iptvforum.ttsmpeg2": { "source": "iana" },
  "video/vnd.motorola.video": { "source": "iana" },
  "video/vnd.motorola.videop": { "source": "iana" },
  "video/vnd.mpegurl": { "source": "iana", "extensions": ["mxu", "m4u"] },
  "video/vnd.ms-playready.media.pyv": { "source": "iana", "extensions": ["pyv"] },
  "video/vnd.nokia.interleaved-multimedia": { "source": "iana" },
  "video/vnd.nokia.mp4vr": { "source": "iana" },
  "video/vnd.nokia.videovoip": { "source": "iana" },
  "video/vnd.objectvideo": { "source": "iana" },
  "video/vnd.planar": { "source": "iana" },
  "video/vnd.radgamettools.bink": { "source": "iana" },
  "video/vnd.radgamettools.smacker": { "source": "apache" },
  "video/vnd.sealed.mpeg1": { "source": "iana" },
  "video/vnd.sealed.mpeg4": { "source": "iana" },
  "video/vnd.sealed.swf": { "source": "iana" },
  "video/vnd.sealedmedia.softseal.mov": { "source": "iana" },
  "video/vnd.uvvu.mp4": { "source": "iana", "extensions": ["uvu", "uvvu"] },
  "video/vnd.vivo": { "source": "iana", "extensions": ["viv"] },
  "video/vnd.youtube.yt": { "source": "iana" },
  "video/vp8": { "source": "iana" },
  "video/vp9": { "source": "iana" },
  "video/webm": { "source": "apache", "compressible": false, "extensions": ["webm"] },
  "video/x-f4v": { "source": "apache", "extensions": ["f4v"] },
  "video/x-fli": { "source": "apache", "extensions": ["fli"] },
  "video/x-flv": { "source": "apache", "compressible": false, "extensions": ["flv"] },
  "video/x-m4v": { "source": "apache", "extensions": ["m4v"] },
  "video/x-matroska": { "source": "apache", "compressible": false, "extensions": ["mkv", "mk3d", "mks"] },
  "video/x-mng": { "source": "apache", "extensions": ["mng"] },
  "video/x-ms-asf": { "source": "apache", "extensions": ["asf", "asx"] },
  "video/x-ms-vob": { "source": "apache", "extensions": ["vob"] },
  "video/x-ms-wm": { "source": "apache", "extensions": ["wm"] },
  "video/x-ms-wmv": { "source": "apache", "compressible": false, "extensions": ["wmv"] },
  "video/x-ms-wmx": { "source": "apache", "extensions": ["wmx"] },
  "video/x-ms-wvx": { "source": "apache", "extensions": ["wvx"] },
  "video/x-msvideo": { "source": "apache", "extensions": ["avi"] },
  "video/x-sgi-movie": { "source": "apache", "extensions": ["movie"] },
  "video/x-smv": { "source": "apache", "extensions": ["smv"] },
  "x-conference/x-cooltalk": { "source": "apache", "extensions": ["ice"] },
  "x-shader/x-fragment": { "compressible": true },
  "x-shader/x-vertex": { "compressible": true }
};
var mimeDb;
var hasRequiredMimeDb;
function requireMimeDb() {
  if (hasRequiredMimeDb) return mimeDb;
  hasRequiredMimeDb = 1;
  mimeDb = require$$0$4;
  return mimeDb;
}
var mimeScore;
var hasRequiredMimeScore;
function requireMimeScore() {
  if (hasRequiredMimeScore) return mimeScore;
  hasRequiredMimeScore = 1;
  var FACET_SCORES = {
    "prs.": 100,
    "x-": 200,
    "x.": 300,
    "vnd.": 400,
    default: 900
  };
  var SOURCE_SCORES = {
    nginx: 10,
    apache: 20,
    iana: 40,
    default: 30
    // definitions added by `jshttp/mime-db` project?
  };
  var TYPE_SCORES = {
    // prefer application/xml over text/xml
    // prefer application/rtf over text/rtf
    application: 1,
    // prefer font/woff over application/font-woff
    font: 2,
    // prefer video/mp4 over audio/mp4 over application/mp4
    // See https://www.rfc-editor.org/rfc/rfc4337.html#section-2
    audio: 2,
    video: 3,
    default: 0
  };
  mimeScore = function mimeScore2(mimeType, source = "default") {
    if (mimeType === "application/octet-stream") {
      return 0;
    }
    const [type2, subtype] = mimeType.split("/");
    const facet = subtype.replace(/(\.|x-).*/, "$1");
    const facetScore = FACET_SCORES[facet] || FACET_SCORES.default;
    const sourceScore = SOURCE_SCORES[source] || SOURCE_SCORES.default;
    const typeScore = TYPE_SCORES[type2] || TYPE_SCORES.default;
    const lengthScore = 1 - mimeType.length / 100;
    return facetScore + sourceScore + typeScore + lengthScore;
  };
  return mimeScore;
}
var hasRequiredMimeTypes$1;
function requireMimeTypes$1() {
  if (hasRequiredMimeTypes$1) return mimeTypes$1;
  hasRequiredMimeTypes$1 = 1;
  (function(exports$1) {
    var db = requireMimeDb();
    var extname = require$$0$6.extname;
    var mimeScore2 = requireMimeScore();
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports$1.charset = charset;
    exports$1.charsets = { lookup: charset };
    exports$1.contentType = contentType;
    exports$1.extension = extension;
    exports$1.extensions = /* @__PURE__ */ Object.create(null);
    exports$1.lookup = lookup;
    exports$1.types = /* @__PURE__ */ Object.create(null);
    exports$1._extensionConflicts = [];
    populateMaps(exports$1.extensions, exports$1.types);
    function charset(type2) {
      if (!type2 || typeof type2 !== "string") {
        return false;
      }
      var match2 = EXTRACT_TYPE_REGEXP.exec(type2);
      var mime = match2 && db[match2[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match2 && TEXT_TYPE_REGEXP.test(match2[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports$1.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports$1.charset(mime);
        if (charset2) mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type2) {
      if (!type2 || typeof type2 !== "string") {
        return false;
      }
      var match2 = EXTRACT_TYPE_REGEXP.exec(type2);
      var exts = match2 && exports$1.extensions[match2[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path) {
      if (!path || typeof path !== "string") {
        return false;
      }
      var extension2 = extname("x." + path).toLowerCase().slice(1);
      if (!extension2) {
        return false;
      }
      return exports$1.types[extension2] || false;
    }
    function populateMaps(extensions, types2) {
      Object.keys(db).forEach(function forEachMimeType(type2) {
        var mime = db[type2];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type2] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          types2[extension2] = _preferredType(extension2, types2[extension2], type2);
          const legacyType = _preferredTypeLegacy(
            extension2,
            types2[extension2],
            type2
          );
          if (legacyType !== types2[extension2]) {
            exports$1._extensionConflicts.push([extension2, legacyType, types2[extension2]]);
          }
        }
      });
    }
    function _preferredType(ext, type0, type1) {
      var score0 = type0 ? mimeScore2(type0, db[type0].source) : 0;
      var score1 = type1 ? mimeScore2(type1, db[type1].source) : 0;
      return score0 > score1 ? type0 : type1;
    }
    function _preferredTypeLegacy(ext, type0, type1) {
      var SOURCE_RANK = ["nginx", "apache", void 0, "iana"];
      var score0 = type0 ? SOURCE_RANK.indexOf(db[type0].source) : 0;
      var score1 = type1 ? SOURCE_RANK.indexOf(db[type1].source) : 0;
      if (exports$1.types[extension] !== "application/octet-stream" && (score0 > score1 || score0 === score1 && exports$1.types[extension]?.slice(0, 12) === "application/")) {
        return type0;
      }
      return score0 > score1 ? type0 : type1;
    }
  })(mimeTypes$1);
  return mimeTypes$1;
}
var mimeTypesExports = requireMimeTypes$1();
const mimeTypes = /* @__PURE__ */ getDefaultExportFromCjs(mimeTypesExports);
const MAX_TASK_TIMEOUT = 6e4;
const MAX_TASK_DELAY = 100;
const MAX_CONCURRENCY = 1e3;
function debug(message2) {
  if (globalThis?.process?.env.DEBUG === "@hwc/retry") {
    console.debug(message2);
  }
}
function isTimeToRetry(task, maxDelay) {
  const timeSinceLastAttempt = Date.now() - task.lastAttempt;
  const timeSinceStart = Math.max(task.lastAttempt - task.timestamp, 1);
  const desiredDelay = Math.min(timeSinceStart * 1.2, maxDelay);
  return timeSinceLastAttempt >= desiredDelay;
}
function isTimeToBail(task, timeout) {
  return task.age > timeout;
}
function createPromise() {
  if (Promise.withResolvers) {
    return Promise.withResolvers();
  }
  let resolve2, reject;
  const promise = new Promise((res2, rej) => {
    resolve2 = res2;
    reject = rej;
  });
  if (resolve2 === void 0 || reject === void 0) {
    throw new Error("Promise executor did not initialize resolve or reject.");
  }
  return { promise, resolve: resolve2, reject };
}
class RetryTask {
  /**
   * The unique ID for the task.
   * @type {string}
   */
  id = Math.random().toString(36).slice(2);
  /**
   * The function to call.
   * @type {Function}
   */
  fn;
  /**
   * The error that was thrown.
   * @type {Error}
   */
  error;
  /**
   * The timestamp of the task.
   * @type {number}
   */
  timestamp = Date.now();
  /**
   * The timestamp of the last attempt.
   * @type {number}
   */
  lastAttempt = this.timestamp;
  /**
   * The resolve function for the promise.
   * @type {Function}
   */
  resolve;
  /**
   * The reject function for the promise.
   * @type {Function}
   */
  reject;
  /**
   * The AbortSignal to monitor for cancellation.
   * @type {AbortSignal|undefined}
   */
  signal;
  /**
   * Creates a new instance.
   * @param {Function} fn The function to call.
   * @param {Error} error The error that was thrown.
   * @param {Function} resolve The resolve function for the promise.
   * @param {Function} reject The reject function for the promise.
   * @param {AbortSignal|undefined} signal The AbortSignal to monitor for cancellation.
   */
  constructor(fn2, error2, resolve2, reject, signal) {
    this.fn = fn2;
    this.error = error2;
    this.timestamp = Date.now();
    this.lastAttempt = Date.now();
    this.resolve = resolve2;
    this.reject = reject;
    this.signal = signal;
  }
  /**
   * Gets the age of the task.
   * @returns {number} The age of the task in milliseconds.
   * @readonly
   */
  get age() {
    return Date.now() - this.timestamp;
  }
}
class Retrier {
  /**
   * Represents the queue for processing tasks.
   * @type {Array<RetryTask>}
   */
  #retrying = [];
  /**
   * Represents the queue for pending tasks.
   * @type {Array<Function>}
   */
  #pending = [];
  /**
   * The number of tasks currently being processed.
   * @type {number}
   */
  #working = 0;
  /**
   * The timeout for the queue.
   * @type {number}
   */
  #timeout;
  /**
   * The maximum delay for the queue.
   * @type {number}
   */
  #maxDelay;
  /**
   * The setTimeout() timer ID.
   * @type {NodeJS.Timeout|undefined}
   */
  #timerId;
  /**
   * The function to call.
   * @type {Function}
   */
  #check;
  /**
   * The maximum number of concurrent tasks.
   * @type {number}
   */
  #concurrency;
  /**
   * Creates a new instance.
   * @param {Function} check The function to call.
   * @param {object} [options] The options for the instance.
   * @param {number} [options.timeout] The timeout for the queue.
   * @param {number} [options.maxDelay] The maximum delay for the queue.
   * @param {number} [options.concurrency] The maximum number of concurrent tasks.
   */
  constructor(check2, { timeout = MAX_TASK_TIMEOUT, maxDelay = MAX_TASK_DELAY, concurrency = MAX_CONCURRENCY } = {}) {
    if (typeof check2 !== "function") {
      throw new Error("Missing function to check errors");
    }
    this.#check = check2;
    this.#timeout = timeout;
    this.#maxDelay = maxDelay;
    this.#concurrency = concurrency;
  }
  /**
   * Gets the number of tasks waiting to be retried.
   * @returns {number} The number of tasks in the retry queue.
   */
  get retrying() {
    return this.#retrying.length;
  }
  /**
   * Gets the number of tasks waiting to be processed in the pending queue.
   * @returns {number} The number of tasks in the pending queue.
   */
  get pending() {
    return this.#pending.length;
  }
  /**
   * Gets the number of tasks currently being processed.
   * @returns {number} The number of tasks currently being processed.
   */
  get working() {
    return this.#working;
  }
  /**
   * Calls the function and retries if it fails.
   * @param {Function} fn The function to call.
   * @param {Object} options The options for the job.
   * @param {AbortSignal} [options.signal] The AbortSignal to monitor for cancellation.
   * @param {Promise<any>} options.promise The promise to return when the function settles.
   * @param {Function} options.resolve The resolve function for the promise.
   * @param {Function} options.reject The reject function for the promise.
   * @returns {Promise<any>} A promise that resolves when the function is
   * called successfully.
   */
  #call(fn2, { signal, promise, resolve: resolve2, reject }) {
    let result2;
    try {
      result2 = fn2();
    } catch (error2) {
      reject(new Error(`Synchronous error: ${error2.message}`, { cause: error2 }));
      return promise;
    }
    if (!result2 || typeof result2.then !== "function") {
      reject(new Error("Result is not a promise."));
      return promise;
    }
    this.#working++;
    promise.finally(() => {
      this.#working--;
      this.#processPending();
    }).catch(() => {
    });
    Promise.resolve(result2).then((value) => {
      debug("Function called successfully without retry.");
      resolve2(value);
    }).catch((error2) => {
      if (!this.#check(error2)) {
        reject(error2);
        return;
      }
      const task = new RetryTask(fn2, error2, resolve2, reject, signal);
      debug(`Function failed, queuing for retry with task ${task.id}.`);
      this.#retrying.push(task);
      signal?.addEventListener("abort", () => {
        debug(`Task ${task.id} was aborted due to AbortSignal.`);
        reject(signal.reason);
      });
      this.#processQueue();
    });
    return promise;
  }
  /**
   * Adds a new retry job to the queue.
   * @template {(...args: unknown[]) => Promise<unknown>} Func
   * @template {Awaited<ReturnType<Func>>} RetVal
   * @param {Func} fn The function to call.
   * @param {object} [options] The options for the job.
   * @param {AbortSignal} [options.signal] The AbortSignal to monitor for cancellation.
   * @returns {Promise<RetVal>} A promise that resolves when the queue is processed.
   */
  retry(fn2, { signal } = {}) {
    signal?.throwIfAborted();
    const { promise, resolve: resolve2, reject } = createPromise();
    this.#pending.push(() => this.#call(fn2, { signal, promise, resolve: resolve2, reject }));
    this.#processPending();
    return promise;
  }
  /**
   * Processes the pending queue and the retry queue.
   * @returns {void}
   */
  #processAll() {
    if (this.pending) {
      this.#processPending();
    }
    if (this.retrying) {
      this.#processQueue();
    }
  }
  /**
   * Processes the pending queue to see which tasks can be started.
   * @returns {void}
   */
  #processPending() {
    debug(`Processing pending tasks: ${this.pending} pending, ${this.working} working.`);
    const available = this.#concurrency - this.working;
    if (available <= 0) {
      return;
    }
    const count2 = Math.min(this.pending, available);
    for (let i = 0; i < count2; i++) {
      const task = this.#pending.shift();
      task?.();
    }
    debug(`Processed pending tasks: ${this.pending} pending, ${this.working} working.`);
  }
  /**
   * Processes the queue.
   * @returns {void}
   */
  #processQueue() {
    clearTimeout(this.#timerId);
    this.#timerId = void 0;
    debug(`Processing retry queue: ${this.retrying} retrying, ${this.working} working.`);
    const processAgain = () => {
      this.#timerId = setTimeout(() => this.#processAll(), 0);
    };
    const task = this.#retrying.shift();
    if (!task) {
      debug("Queue is empty, exiting.");
      if (this.pending) {
        processAgain();
      }
      return;
    }
    if (isTimeToBail(task, this.#timeout)) {
      debug(`Task ${task.id} was abandoned due to timeout.`);
      task.reject(task.error);
      processAgain();
      return;
    }
    if (!isTimeToRetry(task, this.#maxDelay)) {
      debug(`Task ${task.id} is not ready to retry, skipping.`);
      this.#retrying.push(task);
      processAgain();
      return;
    }
    task.lastAttempt = Date.now();
    Promise.resolve(task.fn()).then((result2) => {
      debug(`Task ${task.id} succeeded after ${task.age}ms.`);
      task.resolve(result2);
    }).catch((error2) => {
      if (!this.#check(error2)) {
        debug(`Task ${task.id} failed with non-retryable error: ${error2.message}.`);
        task.reject(error2);
        return;
      }
      task.lastAttempt = Date.now();
      this.#retrying.push(task);
      debug(`Task ${task.id} failed, requeueing to try again.`);
    }).finally(() => {
      this.#processAll();
    });
  }
}
var debug_default$1 = debuglog("flydrive:fs");
var RETRY_ERROR_CODES = /* @__PURE__ */ new Set(["ENFILE", "EMFILE"]);
var FSDriver = class {
  constructor(options) {
    this.options = options;
    this.#rootUrl = typeof options.location === "string" ? options.location : fileURLToPath(options.location);
    debug_default$1("driver config %O", options);
  }
  /**
   * The root directory for the driver
   */
  #rootUrl;
  /**
   * Retrier is used to retry file system operations
   * when certain errors are raised.
   */
  #retrier = new Retrier(
    (error2) => error2.code && RETRY_ERROR_CODES.has(error2.code)
  );
  /**
   * Reads the file for the provided path
   */
  #read(key) {
    const location = join(this.#rootUrl, key);
    return this.#retrier.retry(() => fsp.readFile(location));
  }
  /**
   * Reads dir and ignores non-existing errors
   */
  async #readDir(location, recursive) {
    try {
      return await fsp.readdir(location, {
        recursive,
        withFileTypes: true
      });
    } catch (error2) {
      if (error2.code !== "ENOENT") {
        throw error2;
      }
      return [];
    }
  }
  /**
   * Generic implementation to write a file
   */
  #write(key, contents, options) {
    const location = join(this.#rootUrl, key);
    return this.#retrier.retry(async () => {
      await fsp.mkdir(dirname(location), { recursive: true });
      await fsp.writeFile(location, contents, options);
    });
  }
  /**
   * Synchronously check if a file exists
   */
  existsSync(key) {
    debug_default$1("checking if file exists %s:%s", this.#rootUrl, key);
    const location = join(this.#rootUrl, key);
    return existsSync(location);
  }
  /**
   * Returns a boolean indicating if the file exists or not.
   */
  async exists(key) {
    debug_default$1("checking if file exists %s:%s", this.#rootUrl, key);
    const location = join(this.#rootUrl, key);
    try {
      const object = await fsp.stat(location);
      return object.isFile();
    } catch (error2) {
      if (error2.code === "ENOENT") {
        return false;
      }
      throw error2;
    }
  }
  /**
   * Returns the contents of the file as a UTF-8 string. An
   * exception is thrown when the file is missing.
   */
  async get(key) {
    debug_default$1("reading file contents %s:%s", this.#rootUrl, key);
    return this.#read(key).then((value) => value.toString("utf-8"));
  }
  /**
   * Returns the contents of the file as a stream. An
   * exception is thrown when the file is missing.
   */
  async getStream(key) {
    debug_default$1("reading file contents as a stream %s:%s", this.#rootUrl, key);
    const location = join(this.#rootUrl, key);
    return createReadStream(location);
  }
  /**
   * Returns the contents of the file as an Uint8Array. An
   * exception is thrown when the file is missing.
   */
  async getBytes(key) {
    debug_default$1("reading file contents as array buffer %s:%s", this.#rootUrl, key);
    return this.#read(key).then((value) => new Uint8Array(value.buffer));
  }
  /**
   * Returns the metadata of a file.
   */
  async getMetaData(key) {
    debug_default$1("fetching file metadata %s:%s", this.#rootUrl, key);
    const location = join(this.#rootUrl, key);
    const stats = await fsp.stat(location);
    if (stats.isDirectory()) {
      throw new RuntimeException(`Cannot get metadata of a directory "${key}"`);
    }
    return {
      contentLength: stats.size,
      contentType: mimeTypes.lookup(key) || void 0,
      etag: etag(stats),
      lastModified: stats.mtime
    };
  }
  /**
   * Returns the file visibility from the pre-defined config
   * value
   */
  async getVisibility(_) {
    return this.options.visibility;
  }
  /**
   * Returns the public URL of the file. This method does not check
   * if the file exists or not.
   */
  async getUrl(key) {
    const location = join(this.#rootUrl, key);
    const generateURL = this.options.urlBuilder?.generateURL;
    if (generateURL) {
      debug_default$1("generating public URL %s:%s", this.#rootUrl, key);
      return generateURL(key, location);
    }
    throw new RuntimeException('Cannot generate URL. The "fs" driver does not support it');
  }
  /**
   * Returns the signed/temporary URL of the file. By default, the signed URLs
   * expire in 30mins, but a custom expiry can be defined using
   * "options.expiresIn" property.
   */
  async getSignedUrl(key, options) {
    const location = join(this.#rootUrl, key);
    const normalizedOptions = Object.assign(
      {
        expiresIn: "30 mins"
      },
      options
    );
    const generateSignedURL = this.options.urlBuilder?.generateSignedURL;
    if (generateSignedURL) {
      debug_default$1("generating signed URL %s:%s", this.#rootUrl, key);
      return generateSignedURL(key, location, normalizedOptions);
    }
    throw new RuntimeException('Cannot generate signed URL. The "fs" driver does not support it');
  }
  /**
   * Returns the signed/temporary URL that can be used to directly upload the file.
   * By default, the signed URLs expire in 30mins, but a custom expiry can be
   * defined using "options.expiresIn" property.
   */
  async getSignedUploadUrl(key, options) {
    const location = join(this.#rootUrl, key);
    const normalizedOptions = Object.assign(
      {
        expiresIn: "30 mins"
      },
      options
    );
    const generateSignedUploadURL = this.options.urlBuilder?.generateSignedUploadURL;
    if (generateSignedUploadURL) {
      debug_default$1("generating signed upload URL %s:%s", this.#rootUrl, key);
      return generateSignedUploadURL(key, location, normalizedOptions);
    }
    throw new RuntimeException(
      'Cannot generate signed upload URL. The "fs" driver does not support it'
    );
  }
  /**
   * Results in noop, since the local filesystem cannot have per
   * object visibility.
   */
  async setVisibility(_, __) {
  }
  /**
   * Writes a file to the destination with the provided contents.
   *
   * - Missing directories will be created recursively.
   * - Existing file will be overwritten.
   */
  put(key, contents, options) {
    debug_default$1("creating/updating file %s:%s", this.#rootUrl, key);
    return this.#write(key, contents, { signal: options?.signal });
  }
  /**
   * Writes a file to the destination with the provided contents
   * as a readable stream.
   *
   * - Missing directories will be created recursively.
   * - Existing file will be overwritten.
   */
  putStream(key, contents, options) {
    debug_default$1("creating/updating file using readable stream %s:%s", this.#rootUrl, key);
    return new Promise((resolve2, reject) => {
      contents.once("error", (error2) => reject(error2));
      return this.#write(key, contents, { signal: options?.signal }).then(resolve2).catch(reject);
    });
  }
  /**
   * Copies the source file to the destination. Both paths must
   * be within the root location.
   */
  copy(source, destination) {
    debug_default$1("copying file from %s to %s", source, destination);
    const sourceLocation = join(this.#rootUrl, source);
    const destinationLocation = join(this.#rootUrl, destination);
    return this.#retrier.retry(async () => {
      await fsp.mkdir(dirname(destinationLocation), { recursive: true });
      await fsp.copyFile(sourceLocation, destinationLocation);
    });
  }
  /**
   * Moves the source file to the destination. Both paths must
   * be within the root location.
   */
  move(source, destination) {
    debug_default$1("moving file from %s to %s", source, destination);
    const sourceLocation = join(this.#rootUrl, source);
    const destinationLocation = join(this.#rootUrl, destination);
    return this.#retrier.retry(async () => {
      await fsp.mkdir(dirname(destinationLocation), { recursive: true });
      await fsp.copyFile(sourceLocation, destinationLocation);
      await fsp.unlink(sourceLocation);
    });
  }
  /**
   * Deletes a file within the root location of the filesystem.
   * Attempting to delete a non-existing file will result in
   * a noop.
   */
  delete(key) {
    debug_default$1("deleting file %s:%s", this.#rootUrl, key);
    const location = join(this.#rootUrl, key);
    return this.#retrier.retry(async () => {
      try {
        await fsp.unlink(location);
      } catch (error2) {
        if (error2.code !== "ENOENT") {
          throw error2;
        }
      }
    });
  }
  /**
   * Deletes the files and directories matching the provided
   * prefix. The method is same as running "rm -rf" unix
   * command
   */
  deleteAll(prefix) {
    debug_default$1("deleting all files in folder %s:%s", this.#rootUrl, prefix);
    const location = join(this.#rootUrl, prefix);
    return this.#retrier.retry(async () => {
      return fsp.rm(location, { recursive: true, force: true });
    });
  }
  /**
   * Synchronously delete all files from the root location
   */
  clearSync() {
    rmSync(this.#rootUrl, { recursive: true, force: true });
  }
  /**
   * Returns a list of files. The pagination properties are ignored
   * by the fs driver, since it does not support pagination.
   */
  async listAll(prefix, options) {
    const self2 = this;
    const location = join(this.#rootUrl, prefix);
    const { recursive } = Object.assign({ recursive: false }, options);
    debug_default$1("listing files from folder %s:%s %O", this.#rootUrl, prefix, options);
    const files = await this.#readDir(location, recursive);
    function* filesGenerator() {
      for (const file of files) {
        const relativeName = slash(
          relative(self2.#rootUrl, join(file.parentPath ?? file.path, file.name))
        );
        if (file.isFile()) {
          yield new DriveFile(relativeName, self2);
        } else if (!recursive) {
          yield new DriveDirectory(relativeName);
        }
      }
    }
    return {
      paginationToken: void 0,
      objects: {
        [Symbol.iterator]: filesGenerator
      }
    };
  }
};
var Disk = class {
  constructor(driver) {
    this.driver = driver;
  }
  /**
   * The normalizer is used to normalize and validate keys
   */
  #normalizer = new KeyNormalizer();
  /**
   * Creates a new instance of the DriveFile. It can be used
   * to lazily fetch file contents or convert it into a
   * snapshot for persistence
   */
  file(key) {
    return new DriveFile(key, this.driver);
  }
  /**
   * Creates a new instance of the DriveFile from the snapshot.
   */
  fromSnapshot(snapshot) {
    return new DriveFile(snapshot.key, this.driver, {
      contentLength: snapshot.contentLength,
      etag: snapshot.etag,
      lastModified: new Date(snapshot.lastModified),
      contentType: snapshot.contentType
    });
  }
  /**
   * Check if the file exists. This method cannot check existence
   * of directories.
   */
  exists(key) {
    return this.file(key).exists();
  }
  /**
   * Returns file contents as a UTF-8 string. Use "getArrayBuffer" method
   * if you need more control over the file contents decoding.
   */
  get(key) {
    return this.file(key).get();
  }
  /**
   * Returns file contents as a Readable stream.
   */
  getStream(key) {
    return this.file(key).getStream();
  }
  /**
   * Returns file contents as a Uint8Array.
   */
  getBytes(key) {
    return this.file(key).getBytes();
  }
  /**
   * @deprecated
   * @see {@link Disk.getBytes}
   */
  getArrayBuffer(key) {
    return this.file(key).getArrayBuffer();
  }
  /**
   * Returns metadata of the given file.
   */
  getMetaData(key) {
    return this.file(key).getMetaData();
  }
  /**
   * Returns the visibility of the file
   */
  getVisibility(key) {
    return this.file(key).getVisibility();
  }
  /**
   * Returns the public URL of the file
   */
  getUrl(key) {
    return this.file(key).getUrl();
  }
  /**
   * Returns a signed/temporary URL of the file
   */
  getSignedUrl(key, options) {
    return this.file(key).getSignedUrl(options);
  }
  /**
   * Returns a signed/temporary URL that can be used to directly upload
   * the file contents to the storage.
   */
  getSignedUploadUrl(key, options) {
    return this.file(key).getSignedUploadUrl(options);
  }
  /**
   * Update the visibility of the file
   */
  async setVisibility(key, visibility) {
    key = this.#normalizer.normalize(key);
    try {
      return await this.driver.setVisibility(key, visibility);
    } catch (error2) {
      throw new E_CANNOT_SET_VISIBILITY([key], { cause: error2 });
    }
  }
  /**
   * Create new file or update an existing file. In case of an error,
   * the "E_CANNOT_WRITE_FILE" exception is thrown
   */
  async put(key, contents, options) {
    key = this.#normalizer.normalize(key);
    try {
      return await this.driver.put(key, contents, options);
    } catch (error2) {
      throw new E_CANNOT_WRITE_FILE([key], { cause: error2 });
    }
  }
  /**
   * Create new file or update an existing file using a Readable Stream
   * In case of an error, the "E_CANNOT_WRITE_FILE" exception is thrown
   */
  async putStream(key, contents, options) {
    key = this.#normalizer.normalize(key);
    try {
      return await this.driver.putStream(key, contents, options);
    } catch (error2) {
      throw new E_CANNOT_WRITE_FILE([key], { cause: error2 });
    }
  }
  /**
   * Copies file from the "source" to the "destination" within the
   * same bucket or the root location of local filesystem.
   *
   * Use "copyFromFs" method to copy files from local filesystem to
   * a cloud provider
   */
  async copy(source, destination, options) {
    source = this.#normalizer.normalize(source);
    destination = this.#normalizer.normalize(destination);
    try {
      return await this.driver.copy(source, destination, options);
    } catch (error2) {
      throw new E_CANNOT_COPY_FILE([source, destination], { cause: error2 });
    }
  }
  /**
   * Copies file from the local filesystem to the cloud provider.
   */
  copyFromFs(source, destination, options) {
    return this.putStream(destination, createReadStream(source), options);
  }
  /**
   * Moves file from the "source" to the "destination" within the
   * same bucket or the root location of local filesystem.
   *
   * Use "moveFromFs" method to move files from local filesystem to
   * a cloud provider
   */
  async move(source, destination, options) {
    source = this.#normalizer.normalize(source);
    destination = this.#normalizer.normalize(destination);
    try {
      return await this.driver.move(source, destination, options);
    } catch (error2) {
      throw new E_CANNOT_MOVE_FILE([source, destination], { cause: error2 });
    }
  }
  /**
   * Moves file from the local filesystem to the cloud provider.
   */
  async moveFromFs(source, destination, options) {
    await this.putStream(destination, createReadStream(source), options);
    await unlink(source);
  }
  /**
   * Deletes a file for the given key. Use "deleteAll" method to delete
   * files for a matching folder prefix.
   */
  async delete(key) {
    key = this.#normalizer.normalize(key);
    try {
      return await this.driver.delete(key);
    } catch (error2) {
      throw new E_CANNOT_DELETE_FILE([key], { cause: error2 });
    }
  }
  /**
   * Delete all files matching the given prefix. In case of "fs" driver,
   * the mentioned folder will be deleted.
   */
  async deleteAll(prefix) {
    prefix = prefix && prefix !== "/" ? this.#normalizer.normalize(prefix) : "/";
    try {
      return await this.driver.deleteAll(prefix);
    } catch (error2) {
      throw new E_CANNOT_DELETE_DIRECTORY([prefix], { cause: error2 });
    }
  }
  /**
   * Returns a list of objects which includes and files and directories.
   * In case of "recursive" listing, no directories are returned.
   */
  listAll(prefix, options) {
    prefix = prefix && prefix !== "/" ? this.#normalizer.normalize(prefix) : "/";
    return this.driver.listAll(prefix, options);
  }
};
var debug_default = debuglog("flydrive:core");
var FakeDisk = class extends Disk {
  constructor(disk, fakesConfig) {
    super(
      new FSDriver({
        location: typeof fakesConfig.location === "string" ? join(fakesConfig.location, disk) : new URL(disk, fakesConfig.location),
        visibility: "public",
        urlBuilder: fakesConfig.urlBuilder
      })
    );
    this.disk = disk;
  }
  /**
   * Assert the expected file(s) exists. Otherwise an assertion
   * error is thrown
   */
  assertExists(paths2) {
    const pathsToVerify = Array.isArray(paths2) ? paths2 : [paths2];
    for (let filePath of pathsToVerify) {
      if (!this.driver.existsSync(filePath)) {
        throw new AssertionError({
          message: `Expected "${filePath}" to exist, but file not found.`
        });
      }
    }
  }
  /**
   * Assert the expected file(s) to not exist. Otherwise an assertion
   * error is thrown
   */
  assertMissing(paths2) {
    const pathsToVerify = Array.isArray(paths2) ? paths2 : [paths2];
    for (let filePath of pathsToVerify) {
      if (this.driver.existsSync(filePath)) {
        throw new AssertionError({
          message: `Expected "${filePath}" to be missing, but file exists`
        });
      }
    }
  }
  /**
   * Clear storage
   */
  clear() {
    this.driver.clearSync();
  }
};
var DriveManager = class {
  /**
   * Registered config
   */
  #config;
  /**
   * A collection of cached service. We re-use disk instances for a
   * service, since there isn't any need to reconstruct them
   * everytime.
   */
  #cachedServices = /* @__PURE__ */ new Map();
  /**
   * A collection of fakes created for the services.
   */
  #fakes = /* @__PURE__ */ new Map();
  constructor(config2) {
    this.#config = config2;
    debug_default("driver manager config %O", config2);
  }
  /**
   * Returns an instance of a Disk for the given service. By default
   * use the "default" service from config
   */
  use(service) {
    const serviceToUse = service || this.#config.default;
    const fake = this.#fakes.get(serviceToUse);
    if (fake) {
      debug_default("returning fake for service %s", serviceToUse);
      return fake;
    }
    const cachedDisk = this.#cachedServices.get(serviceToUse);
    if (cachedDisk) {
      debug_default("use cached disk instance for service %s", serviceToUse);
      return cachedDisk;
    }
    const disk = new Disk(this.#config.services[serviceToUse]());
    debug_default("creating disk instance for service %s", serviceToUse);
    this.#cachedServices.set(serviceToUse, disk);
    return disk;
  }
  /**
   * Deploy fake for a given service. The "use" method for the same service
   * will now return an instance of the "FakeDisk" class and not the
   * real implementation.
   */
  fake(service) {
    const serviceToUse = service || this.#config.default;
    if (!this.#config.fakes) {
      throw new RuntimeException(
        'Cannot use "drive.fake". Make sure to define fakes configuration when creating DriveManager instance'
      );
    }
    this.restore(serviceToUse);
    debug_default("creating fake for service %s", serviceToUse);
    const fake = new FakeDisk(serviceToUse, this.#config.fakes);
    this.#fakes.set(serviceToUse, fake);
    return fake;
  }
  /**
   * Restore fake for a given service
   */
  restore(service) {
    const serviceToUse = service || this.#config.default;
    const fake = this.#fakes.get(serviceToUse);
    if (fake) {
      debug_default("restoring fake for service %s", serviceToUse);
      fake.clear();
      this.#fakes.delete(serviceToUse);
    }
  }
};
class QuestpieAPI {
  constructor(cms2) {
    this.cms = cms2;
  }
  createJsonFunctionCaller(definition) {
    return async (input, context) => {
      return executeJsonFunction(this.cms, definition, input, context);
    };
  }
  createCollectionFunctions(functions, crud) {
    const output = {};
    for (const [name2, definition] of Object.entries(functions)) {
      if (definition.mode === "raw") continue;
      if (name2 in crud) {
        throw new Error(
          `Function "${name2}" collides with collection CRUD method.`
        );
      }
      output[name2] = this.createJsonFunctionCaller(definition);
    }
    return output;
  }
  createGlobalFunctions(functions, crud) {
    const output = {};
    for (const [name2, definition] of Object.entries(functions)) {
      if (definition.mode === "raw") continue;
      if (name2 in crud) {
        throw new Error(`Function "${name2}" collides with global CRUD method.`);
      }
      output[name2] = this.createJsonFunctionCaller(definition);
    }
    return output;
  }
  /**
   * Access collections CRUD operations
   * @example
   * await cms.api.collections.users.create({ email: '...' }, context)
   * await cms.api.collections.posts.find({ where: { status: 'published' } })
   */
  get collections() {
    const collectionsProxy = {};
    const collectionsObj = this.cms.getCollections();
    for (const [name2, collection] of Object.entries(collectionsObj)) {
      Object.defineProperty(collectionsProxy, name2, {
        get: () => {
          const crud = collection.generateCRUD(this.cms.db, this.cms);
          const functions = this.createCollectionFunctions(
            collection.state.functions || {},
            crud
          );
          return {
            ...crud,
            ...functions
          };
        },
        enumerable: true
      });
    }
    return collectionsProxy;
  }
  get globals() {
    const globalsProxy = {};
    const globalsObj = this.cms.getGlobals();
    for (const [name2, global2] of Object.entries(globalsObj)) {
      Object.defineProperty(globalsProxy, name2, {
        get: () => {
          const crud = global2.generateCRUD(this.cms.db, this.cms);
          const functions = this.createGlobalFunctions(
            global2.state.functions || {},
            crud
          );
          return {
            ...crud,
            ...functions
          };
        },
        enumerable: true
      });
    }
    return globalsProxy;
  }
}
class OperationSnapshotManager {
  /**
   * Generate operations by comparing two snapshots
   * Works with beta API's ddl array structure
   */
  generateOperations(oldSnapshot, newSnapshot, migrationId) {
    const operations = [];
    const timestamp2 = (/* @__PURE__ */ new Date()).toISOString();
    const oldDdl = oldSnapshot.ddl || [];
    const newDdl = newSnapshot.ddl || [];
    const oldDdlMap = /* @__PURE__ */ new Map();
    for (const entity of oldDdl) {
      const key = this.getEntityKey(entity);
      oldDdlMap.set(key, entity);
    }
    const newDdlMap = /* @__PURE__ */ new Map();
    for (const entity of newDdl) {
      const key = this.getEntityKey(entity);
      newDdlMap.set(key, entity);
    }
    for (const [key, oldEntity] of oldDdlMap) {
      if (!newDdlMap.has(key)) {
        operations.push({
          type: "remove",
          path: `ddl.${this.encodeKey(key)}`,
          timestamp: timestamp2,
          migrationId
        });
      }
    }
    for (const [key, newEntity] of newDdlMap) {
      const currentPath = `ddl.${this.encodeKey(key)}`;
      if (!oldDdlMap.has(key)) {
        operations.push({
          type: "set",
          path: currentPath,
          value: newEntity,
          timestamp: timestamp2,
          migrationId
        });
      } else {
        const oldEntity = oldDdlMap.get(key);
        if (!this.deepEqual(oldEntity, newEntity)) {
          operations.push({
            type: "set",
            path: currentPath,
            value: newEntity,
            timestamp: timestamp2,
            migrationId
          });
        }
      }
    }
    return operations;
  }
  /**
   * Get unique key for a DDL entity
   * Combines entityType with identifying fields
   */
  getEntityKey(entity) {
    const type2 = entity.entityType;
    const schema2 = entity.schema || "public";
    switch (type2) {
      case "tables":
        return `table:${schema2}.${entity.name}`;
      case "columns":
        return `column:${schema2}.${entity.table}.${entity.name}`;
      case "pks":
        return `pk:${schema2}.${entity.table}.${entity.name}`;
      case "fks":
        return `fk:${schema2}.${entity.table}.${entity.name}`;
      case "indexes":
        return `index:${schema2}.${entity.table}.${entity.name}`;
      case "enums":
        return `enum:${schema2}.${entity.name}`;
      case "schemas":
        return `schema:${entity.name}`;
      case "sequences":
        return `sequence:${schema2}.${entity.name}`;
      case "policies":
        return `policy:${schema2}.${entity.table}.${entity.name}`;
      case "roles":
        return `role:${entity.name}`;
      case "views":
        return `view:${schema2}.${entity.name}`;
      case "uniqueConstraints":
        return `unique:${schema2}.${entity.table}.${entity.name}`;
      case "checkConstraints":
        return `check:${schema2}.${entity.table}.${entity.name}`;
      default:
        return `${type2}:${JSON.stringify(entity)}`;
    }
  }
  /**
   * Build a snapshot from a series of operations
   */
  buildSnapshotFromOperations(operations, baseSnapshot) {
    const snapshot = baseSnapshot || this.getDefaultSnapshot();
    const sortedOperations = operations.sort(
      (a, b) => a.timestamp.localeCompare(b.timestamp)
    );
    const ddlMap = /* @__PURE__ */ new Map();
    if (snapshot.ddl) {
      for (const entity of snapshot.ddl) {
        const key = this.getEntityKey(entity);
        ddlMap.set(key, entity);
      }
    }
    for (const operation of sortedOperations) {
      if (operation.path.startsWith("ddl.")) {
        const key = this.decodeKey(operation.path.substring(4));
        if (operation.type === "set") {
          ddlMap.set(key, operation.value);
        } else if (operation.type === "remove") {
          ddlMap.delete(key);
        }
      }
    }
    snapshot.ddl = Array.from(ddlMap.values());
    return snapshot;
  }
  /**
   * Deduplicate operations (remove redundant operations)
   */
  deduplicateOperations(operations) {
    const operationMap = /* @__PURE__ */ new Map();
    const sortedOperations = operations.sort(
      (a, b) => a.timestamp.localeCompare(b.timestamp)
    );
    for (const operation of sortedOperations) {
      const key = operation.path;
      const existingOperation = operationMap.get(key);
      if (!existingOperation) {
        operationMap.set(key, operation);
      } else if (operation.type === "remove") {
        operationMap.set(key, operation);
      } else if (operation.type === "set" && existingOperation.type === "remove") {
        operationMap.set(key, operation);
      } else if (operation.type === "set" && existingOperation.type === "set") {
        operationMap.set(key, operation);
      }
    }
    return Array.from(operationMap.values()).sort(
      (a, b) => a.timestamp.localeCompare(b.timestamp)
    );
  }
  deepEqual(a, b) {
    try {
      return JSON.stringify(this.normalizeObject(a)) === JSON.stringify(this.normalizeObject(b));
    } catch {
      return false;
    }
  }
  /**
   * Normalize object structure to ensure consistent comparison
   * Sorts object keys and handles arrays consistently
   */
  normalizeObject(obj) {
    if (obj === null || obj === void 0) {
      return obj;
    }
    if (Array.isArray(obj)) {
      return obj.map((item) => this.normalizeObject(item));
    }
    if (typeof obj === "object") {
      const normalized = {};
      const sortedKeys = Object.keys(obj).sort();
      for (const key of sortedKeys) {
        normalized[key] = this.normalizeObject(obj[key]);
      }
      return normalized;
    }
    return obj;
  }
  /**
   * Encode dots in key names to avoid conflicts with path separators
   * Replaces '.' with '__DOT__' in key names
   */
  encodeKey(key) {
    return key.replace(/\./g, "__DOT__").replace(/:/g, "__COLON__");
  }
  /**
   * Decode dots in key names back to original form
   * Replaces '__DOT__' with '.' in key names
   */
  decodeKey(key) {
    return key.replace(/__DOT__/g, ".").replace(/__COLON__/g, ":");
  }
  getDefaultSnapshot() {
    return {
      id: "00000000-0000-0000-0000-000000000000",
      dialect: "postgres",
      prevIds: [],
      version: "8",
      ddl: [],
      renames: []
    };
  }
}
class DrizzleMigrationGenerator {
  operationManager = new OperationSnapshotManager();
  async generateMigration(options) {
    const { generateDrizzleJson, generateMigration } = await import("drizzle-kit/api-postgres");
    if (!existsSync$1(options.migrationDir)) {
      mkdirSync(options.migrationDir, { recursive: true });
    }
    const snapshotsDir = join$1(options.migrationDir, "snapshots");
    if (!existsSync$1(snapshotsDir)) {
      mkdirSync(snapshotsDir, { recursive: true });
    }
    const fileName = options.fileBaseName;
    const filePath = join$1(options.migrationDir, fileName);
    const previousSnapshot = await this.getPreviousSnapshot(
      options.migrationDir,
      options.cumulativeSnapshot
    );
    const newSnapshot = await generateDrizzleJson(
      options.schema,
      previousSnapshot.id,
      void 0,
      // schemaFilter
      void 0
      // casing
    );
    const operations = this.operationManager.generateOperations(
      previousSnapshot,
      newSnapshot,
      options.migrationName
    );
    console.log(`Found ${operations.length} operations`);
    if (operations.length === 0) {
      console.log(
        "  No schema changes detected, skipping migration generation (No operations)"
      );
      return {
        fileName,
        filePath,
        snapshot: previousSnapshot,
        skipped: true
      };
    }
    const sqlStatementsUp = await generateMigration(
      previousSnapshot,
      newSnapshot
    );
    const sqlStatementsDown = await generateMigration(
      newSnapshot,
      previousSnapshot
    );
    const processedSqlUp = this.addIfExistsToConstraintDrops(sqlStatementsUp);
    const processedSqlDown = this.addIfExistsToConstraintDrops(sqlStatementsDown);
    if (processedSqlUp.length === 0 && processedSqlDown.length === 0) {
      console.log(
        "  No SQL changes detected, skipping migration generation (No SQL statements)"
      );
      return {
        fileName,
        filePath,
        snapshot: previousSnapshot,
        skipped: true
      };
    }
    const operationSnapshot = {
      operations,
      metadata: {
        migrationId: options.migrationName,
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        prevId: previousSnapshot.id
      }
    };
    const snapshotPath = join$1(snapshotsDir, `${fileName}.json`);
    writeFileSync(snapshotPath, JSON.stringify(operationSnapshot, null, 2));
    const migrationContent = this.generateMigrationTemplate({
      migrationName: options.migrationName,
      upSQL: processedSqlUp.length ? processedSqlUp : void 0,
      downSQL: processedSqlDown.length ? processedSqlDown : void 0,
      snapshotFileName: fileName
    });
    writeFileSync(`${filePath}.ts`, migrationContent);
    this.updateMigrationsIndex(
      options.migrationDir,
      fileName,
      options.migrationName
    );
    console.info(` Generated migration: ${fileName}.ts`);
    console.info(` Operations: ${operations.length} (embedded in migration)`);
    return {
      fileName,
      filePath,
      snapshot: newSnapshot,
      skipped: false
    };
  }
  /**
   * Update or create the migrations index.ts file
   * If the file already exists and contains the migration, it won't be modified
   * Otherwise, the new migration is appended to preserve existing structure
   */
  updateMigrationsIndex(migrationDir, fileName, migrationName) {
    const indexPath = join$1(migrationDir, "index.ts");
    if (existsSync$1(indexPath)) {
      const existingContent = readFileSync(indexPath, "utf8");
      if (existingContent.includes(migrationName)) {
        return;
      }
      const updatedContent = this.appendMigrationToIndex(
        existingContent,
        fileName,
        migrationName
      );
      writeFileSync(indexPath, updatedContent);
    } else {
      const indexContent = this.generateNewIndex(migrationDir);
      writeFileSync(indexPath, indexContent);
    }
  }
  /**
   * Append a new migration to existing index.ts content
   * Preserves existing formatting, imports, and export order
   */
  appendMigrationToIndex(existingContent, fileName, migrationName) {
    const newImport = `import { ${migrationName} } from "./${fileName}.js";`;
    const importRegex = /^import .+ from .+;?\s*$/gm;
    let lastImportMatch = null;
    for (const match2 of existingContent.matchAll(importRegex)) {
      lastImportMatch = match2;
    }
    let contentWithImport;
    if (lastImportMatch) {
      const insertPos = lastImportMatch.index + lastImportMatch[0].length;
      contentWithImport = existingContent.slice(0, insertPos) + "\n" + newImport + existingContent.slice(insertPos);
    } else {
      contentWithImport = existingContent.replace(
        /(import type \{ Migration \} from .+;\n?)/,
        `$1${newImport}
`
      );
    }
    const arrayRegex = /(export const migrations:\s*Migration\[\]\s*=\s*\[)([\s\S]*?)(\];)/;
    const arrayMatch = contentWithImport.match(arrayRegex);
    if (arrayMatch) {
      const [_fullMatch, arrayStart, arrayContent, arrayEnd] = arrayMatch;
      const trimmedContent = arrayContent.trim();
      const indentMatch = arrayContent.match(/\n(\s+)/);
      const indent = indentMatch ? indentMatch[1] : "	";
      let newArrayContent;
      if (trimmedContent) {
        const contentWithComma = trimmedContent.endsWith(",") ? trimmedContent : `${trimmedContent},`;
        newArrayContent = `
${indent}${contentWithComma}
${indent}${migrationName},
`;
      } else {
        newArrayContent = `
${indent}${migrationName},
`;
      }
      contentWithImport = contentWithImport.replace(
        arrayRegex,
        `${arrayStart}${newArrayContent}${arrayEnd}`
      );
    }
    return contentWithImport;
  }
  /**
   * Generate a new index.ts from scratch by scanning migration files
   */
  generateNewIndex(migrationDir) {
    const { readdirSync } = require("node:fs");
    const migrationFiles = readdirSync(migrationDir).filter((file) => file.endsWith(".ts") && file !== "index.ts").sort();
    const imports = [];
    const exports$1 = [];
    for (const file of migrationFiles) {
      const baseName = file.replace(".ts", "");
      const varMatch = baseName.match(/\d+_(.+)$/);
      if (varMatch) {
        const varName = this.toCamelCase(varMatch[1] || baseName);
        const timestamp2 = baseName.match(/^(\d+)_/)?.[1] || "";
        const migrationVarName = `${varName}${timestamp2}`;
        imports.push(`import { ${migrationVarName} } from "./${baseName}.js";`);
        exports$1.push(migrationVarName);
      }
    }
    return `import type { Migration } from "questpie";
${imports.join("\n")}

export const migrations: Migration[] = [
	${exports$1.join(",\n	")},
];
`;
  }
  toCamelCase(str) {
    return str.split("_").map(
      (word, index2) => index2 === 0 ? word.toLowerCase() : word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
    ).join("");
  }
  /**
   * Get cumulative snapshot from migrations loaded via .migrations([...])
   * This is the preferred method as it uses the migrations that are actually imported
   */
  getCumulativeSnapshotFromMigrations(migrations) {
    if (!migrations || migrations.length === 0) {
      return this.getDefaultSnapshot();
    }
    const allOperations = [];
    for (const migration of migrations) {
      if (migration.snapshot?.operations) {
        allOperations.push(...migration.snapshot.operations);
      }
    }
    if (allOperations.length === 0) {
      return this.getDefaultSnapshot();
    }
    const deduplicatedOperations = this.operationManager.deduplicateOperations(allOperations);
    return this.operationManager.buildSnapshotFromOperations(
      deduplicatedOperations
    );
  }
  /**
   * Get cumulative snapshot from all previous operation snapshots in file system
   * @deprecated Use getCumulativeSnapshotFromMigrations instead
   */
  async getCumulativeSnapshot(migrationDir) {
    const snapshotsDir = join$1(migrationDir, "snapshots");
    if (!existsSync$1(snapshotsDir)) {
      return this.getDefaultSnapshot();
    }
    const { readdirSync } = await import("node:fs");
    const operationFiles = readdirSync(snapshotsDir).filter((file) => file.endsWith(".json")).sort((a, b) => {
      const tsA = this.extractTimestamp(a);
      const tsB = this.extractTimestamp(b);
      return tsA.localeCompare(tsB);
    });
    if (operationFiles.length === 0) {
      return this.getDefaultSnapshot();
    }
    const allOperations = [];
    for (const operationFile of operationFiles) {
      const operationPath = join$1(snapshotsDir, operationFile);
      try {
        const operationSnapshot = JSON.parse(
          readFileSync(operationPath, "utf8")
        );
        allOperations.push(...operationSnapshot.operations);
      } catch (error2) {
        console.warn(
          `  Failed to parse operation snapshot ${operationFile}: ${error2}`
        );
      }
    }
    const deduplicatedOperations = this.operationManager.deduplicateOperations(allOperations);
    return this.operationManager.buildSnapshotFromOperations(
      deduplicatedOperations
    );
  }
  async getPreviousSnapshot(migrationDir, cumulativeSnapshot) {
    if (cumulativeSnapshot) {
      return cumulativeSnapshot;
    }
    return this.getCumulativeSnapshot(migrationDir);
  }
  generateMigrationTemplate(options) {
    const {
      migrationName,
      upSQL = [],
      downSQL = [],
      snapshotFileName
    } = options;
    const generateStatements = (statements) => {
      if (statements.length === 0) return "// No schema changes";
      return statements.filter((stmt) => stmt.trim()).map((stmt) => `await db.execute(sql\`${stmt.trim()}\`)`).join("\n		");
    };
    return `import type { Migration, OperationSnapshot } from "questpie"
import { sql } from "drizzle-orm"
import snapshotJson from "./snapshots/${snapshotFileName}.json"

const snapshot = snapshotJson as OperationSnapshot

export const ${migrationName}: Migration = {
	id: "${migrationName}",
	async up({ db }) {
		${generateStatements(upSQL)}
	},
	async down({ db }) {
		${generateStatements(downSQL)}
	},
	snapshot,
}
`;
  }
  getDefaultSnapshot() {
    return {
      id: "00000000-0000-0000-0000-000000000000",
      dialect: "postgres",
      prevIds: [],
      version: "8",
      ddl: [],
      renames: []
    };
  }
  extractTimestamp(filename) {
    const match2 = filename.match(/^(\d{8,}T\d+)_/);
    if (match2?.[1]) {
      return match2[1];
    }
    return "00000000T000000";
  }
  addIfExistsToConstraintDrops(sqlStatements) {
    return sqlStatements.map((statement) => {
      if (statement.includes("DROP CONSTRAINT") && !statement.includes("IF EXISTS")) {
        return statement.replace(
          /ALTER TABLE "([^"]+)" DROP CONSTRAINT "([^"]+)"/g,
          'ALTER TABLE "$1" DROP CONSTRAINT IF EXISTS "$2"'
        );
      }
      return statement;
    });
  }
}
class MigrationRunner {
  db;
  tableName = "questpie_migrations";
  silent;
  constructor(db, options = {}) {
    this.db = db;
    this.silent = options.silent ?? this.readSilentEnv();
  }
  readSilentEnv() {
    const value = process.env.QUESTPIE_MIGRATIONS_SILENT;
    const isTestEnv = process.env.NODE_ENV === "test";
    if (isTestEnv) {
      return true;
    }
    if (!value) {
      return false;
    }
    return ["1", "true", "yes"].includes(value.toLowerCase());
  }
  log(message2) {
    if (!this.silent) {
      console.log(message2);
    }
  }
  warn(message2) {
    if (!this.silent) {
      console.warn(message2);
    }
  }
  /**
   * Ensure migrations table exists
   */
  async ensureMigrationsTable() {
    await this.db.execute(
      sql$1.raw(`
			CREATE TABLE IF NOT EXISTS ${this.tableName} (
				id TEXT PRIMARY KEY,
				name TEXT NOT NULL,
				batch INTEGER NOT NULL,
				executed_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
			)
		`)
    );
  }
  /**
   * Run all pending migrations
   */
  async runMigrationsUp(migrations, options = {}) {
    await this.ensureMigrationsTable();
    const executed = await this.getExecutedMigrations();
    const executedIds = new Set(executed.map((m) => m.id));
    const pending = migrations.filter((m) => !executedIds.has(m.id));
    if (pending.length === 0) {
      this.log(" No pending migrations");
      return;
    }
    this.log(` Running ${pending.length} pending migrations...`);
    const currentBatch = await this.getCurrentBatch();
    const nextBatch = currentBatch + 1;
    for (const migration of pending) {
      if (options.targetMigration && migration.id === options.targetMigration) {
        this.log(` Reached target migration: ${migration.id}, stopping here`);
        break;
      }
      this.log(`  Running migration: ${migration.id}`);
      try {
        await this.db.transaction(async (tx) => {
          await migration.up({ db: tx });
          await tx.execute(
            sql$1.raw(
              `INSERT INTO ${this.tableName} (id, name, batch) VALUES ('${migration.id}', '${migration.id}', ${nextBatch})`
            )
          );
        });
        this.log(` Migration completed: ${migration.id}`);
      } catch (error2) {
        console.error(` Migration failed: ${migration.id}`, error2);
        throw error2;
      }
      if (options.targetMigration && migration.id === options.targetMigration) {
        break;
      }
    }
    this.log(" All migrations completed successfully");
  }
  /**
   * Rollback the last batch of migrations
   */
  async rollbackLastBatch(migrations) {
    await this.ensureMigrationsTable();
    const currentBatch = await this.getCurrentBatch();
    if (currentBatch === 0) {
      this.log("  No migrations to rollback");
      return;
    }
    await this.rollbackBatch(migrations, currentBatch);
  }
  /**
   * Rollback a specific batch of migrations
   */
  async rollbackBatch(migrations, batch) {
    await this.ensureMigrationsTable();
    const batchMigrations = await this.getMigrationsByBatch(batch);
    if (batchMigrations.length === 0) {
      this.log(`  No migrations found in batch ${batch}`);
      return;
    }
    this.log(
      ` Rolling back ${batchMigrations.length} migrations from batch ${batch}...`
    );
    for (let i = batchMigrations.length - 1; i >= 0; i--) {
      const record = batchMigrations[i];
      const migration = migrations.find((m) => m.id === record.id);
      if (!migration) {
        this.warn(`  Migration definition not found: ${record.id}, skipping`);
        continue;
      }
      this.log(`  Rolling back migration: ${migration.id}`);
      try {
        await this.db.transaction(async (tx) => {
          await migration.down({ db: tx });
          await tx.execute(
            sql$1.raw(
              `DELETE FROM ${this.tableName} WHERE id = '${migration.id}'`
            )
          );
        });
        this.log(` Rollback completed: ${migration.id}`);
      } catch (error2) {
        console.error(` Rollback failed: ${migration.id}`, error2);
        throw error2;
      }
    }
    this.log(" All migrations rolled back successfully");
  }
  /**
   * Rollback to a specific migration (inclusive)
   */
  async rollbackToMigration(migrations, targetId) {
    await this.ensureMigrationsTable();
    const executed = await this.getExecutedMigrations();
    const targetIndex = executed.findIndex((m) => m.id === targetId);
    if (targetIndex === -1) {
      throw new Error(`Migration not found: ${targetId}`);
    }
    const toRollback = executed.slice(targetIndex).reverse();
    this.log(
      ` Rolling back ${toRollback.length} migrations to ${targetId}...`
    );
    for (const record of toRollback) {
      const migration = migrations.find((m) => m.id === record.id);
      if (!migration) {
        this.warn(`  Migration definition not found: ${record.id}, skipping`);
        continue;
      }
      this.log(`  Rolling back migration: ${migration.id}`);
      try {
        await this.db.transaction(async (tx) => {
          await migration.down({ db: tx });
          await tx.execute(
            sql$1.raw(
              `DELETE FROM ${this.tableName} WHERE id = '${migration.id}'`
            )
          );
        });
        this.log(` Rollback completed: ${migration.id}`);
      } catch (error2) {
        console.error(` Rollback failed: ${migration.id}`, error2);
        throw error2;
      }
    }
    this.log(" Rollback completed successfully");
  }
  /**
   * Reset all migrations (rollback everything)
   */
  async reset(migrations) {
    await this.ensureMigrationsTable();
    const executed = await this.getExecutedMigrations();
    if (executed.length === 0) {
      this.log("  No migrations to reset");
      return;
    }
    this.log(` Resetting ${executed.length} migrations...`);
    for (let i = executed.length - 1; i >= 0; i--) {
      const record = executed[i];
      const migration = migrations.find((m) => m.id === record.id);
      if (!migration) {
        this.warn(`  Migration definition not found: ${record.id}, skipping`);
        continue;
      }
      this.log(`  Rolling back migration: ${migration.id}`);
      try {
        await this.db.transaction(async (tx) => {
          await migration.down({ db: tx });
          await tx.execute(
            sql$1.raw(
              `DELETE FROM ${this.tableName} WHERE id = '${migration.id}'`
            )
          );
        });
        this.log(` Rollback completed: ${migration.id}`);
      } catch (error2) {
        console.error(` Rollback failed: ${migration.id}`, error2);
        throw error2;
      }
    }
    this.log(" All migrations reset successfully");
  }
  /**
   * Fresh migrations (reset + run all)
   */
  async fresh(migrations) {
    await this.reset(migrations);
    await this.runMigrationsUp(migrations);
  }
  /**
   * Get migration status
   */
  async status(migrations) {
    await this.ensureMigrationsTable();
    const executed = await this.getExecutedMigrations();
    const executedIds = new Set(executed.map((m) => m.id));
    const pending = migrations.filter((m) => !executedIds.has(m.id)).map((m) => ({ id: m.id, name: m.id }));
    const currentBatch = await this.getCurrentBatch();
    this.log("\n Migration Status:\n");
    this.log(`Current batch: ${currentBatch}`);
    this.log(`Executed: ${executed.length}`);
    this.log(`Pending: ${pending.length}
`);
    if (executed.length > 0) {
      this.log(" Executed migrations:");
      for (const record of executed) {
        this.log(
          `  - ${record.name} (batch ${record.batch}, ${record.executedAt})`
        );
      }
      this.log("");
    }
    if (pending.length > 0) {
      this.log(" Pending migrations:");
      for (const p of pending) {
        this.log(`  - ${p.name}`);
      }
      this.log("");
    }
    return {
      pending,
      executed,
      currentBatch
    };
  }
  /**
   * Get all executed migrations
   */
  async getExecutedMigrations() {
    const result2 = await this.db.execute(
      sql$1.raw(
        `SELECT id, name, batch, executed_at FROM ${this.tableName} ORDER BY executed_at ASC`
      )
    );
    return (result2.rows || result2 || []).map((row) => ({
      id: row.id,
      name: row.name,
      batch: row.batch,
      executedAt: new Date(row.executed_at)
    }));
  }
  /**
   * Get migrations by batch number
   */
  async getMigrationsByBatch(batch) {
    const result2 = await this.db.execute(
      sql$1.raw(
        `SELECT id, name, batch, executed_at FROM ${this.tableName} WHERE batch = ${batch} ORDER BY executed_at ASC`
      )
    );
    return (result2.rows || result2 || []).map((row) => ({
      id: row.id,
      name: row.name,
      batch: row.batch,
      executedAt: new Date(row.executed_at)
    }));
  }
  /**
   * Get current batch number
   */
  async getCurrentBatch() {
    const result2 = await this.db.execute(
      sql$1.raw(`SELECT MAX(batch) as max_batch FROM ${this.tableName}`)
    );
    const rows = result2.rows || result2 || [];
    const maxBatch = rows[0]?.max_batch;
    return maxBatch ? Number.parseInt(maxBatch, 10) : 0;
  }
}
class QuestpieMigrationsAPI {
  constructor(cms2) {
    this.cms = cms2;
    this.runner = new MigrationRunner(this.cms.db);
  }
  runner;
  /**
   * Generate a new migration
   */
  async generate(options = {}) {
    const generator2 = new DrizzleMigrationGenerator();
    const migrationDir = this.cms.config.migrations?.directory || "./migrations";
    const timestamp2 = (/* @__PURE__ */ new Date()).toISOString().replace(/[-:T]/g, "").replace(/\..+/, "").slice(0, 14);
    const randomName = options.name || this.generateRandomMigrationName();
    const fileBaseName = `${timestamp2}_${randomName}`;
    const camelCaseName = toCamelCase(randomName);
    const migrationVariableName = `${camelCaseName}${timestamp2}`;
    return generator2.generateMigration({
      migrationName: migrationVariableName,
      fileBaseName,
      schema: this.cms.getSchema(),
      migrationDir
    });
  }
  /**
   * Run pending migrations
   *
   * Automatically:
   * 1. Runs search adapter extensions first (pg_trgm, vector, etc.)
   * 2. Runs Drizzle migrations (tables, basic indexes)
   * 3. Runs search adapter migrations (FTS indexes, trigram indexes)
   */
  async up(options = {}) {
    const extResult = await this.ensureExtensions();
    if (extResult.applied.length > 0 && !this.runner.silent) {
      console.log(` Created extensions: ${extResult.applied.length}`);
      for (const ext of extResult.applied) {
        console.log(`    ${ext}`);
      }
    }
    if (extResult.skipped.length > 0 && !this.runner.silent) {
      console.log(`  Extensions already exist: ${extResult.skipped.length}`);
    }
    const migrations = this.cms.config.migrations?.migrations || [];
    await this.runner.runMigrationsUp(migrations, options);
    await this.search();
  }
  /**
   * Ensure required PostgreSQL extensions are created.
   *
   * Runs CREATE EXTENSION statements from the search adapter before migrations.
   * These statements are idempotent (IF NOT EXISTS) so safe to run multiple times.
   *
   * @example
   * ```ts
   * // Run extensions only (useful for CI/CD)
   * await cms.migrations.ensureExtensions();
   * ```
   */
  async ensureExtensions() {
    const applied = [];
    const skipped = [];
    const adapter = this.cms.search?.getAdapter();
    if (!adapter?.getExtensions) {
      return { applied, skipped };
    }
    const extensions = adapter.getExtensions();
    for (const ext of extensions) {
      try {
        await this.cms.db.execute(sql$1.raw(ext));
        applied.push(ext);
      } catch (error2) {
        const msg = error2?.message?.toLowerCase() || "";
        if (msg.includes("already exists") || msg.includes("extension") || msg.includes("could not open extension") || msg.includes("permission denied")) {
          skipped.push(ext);
        } else {
          throw error2;
        }
      }
    }
    return { applied, skipped };
  }
  /**
   * Rollback last batch of migrations
   */
  async down() {
    const migrations = this.cms.config.migrations?.migrations || [];
    await this.runner.rollbackLastBatch(migrations);
  }
  /**
   * Rollback to a specific migration
   */
  async downTo(migrationId) {
    const migrations = this.cms.config.migrations?.migrations || [];
    await this.runner.rollbackToMigration(migrations, migrationId);
  }
  /**
   * Reset all migrations (rollback everything)
   */
  async reset() {
    const migrations = this.cms.config.migrations?.migrations || [];
    await this.runner.reset(migrations);
  }
  /**
   * Fresh migrations (reset + run all)
   */
  async fresh() {
    const migrations = this.cms.config.migrations?.migrations || [];
    await this.runner.fresh(migrations);
  }
  /**
   * Get migration status
   */
  async status() {
    const migrations = this.cms.config.migrations?.migrations || [];
    return this.runner.status(migrations);
  }
  /**
   * Run search adapter migrations
   *
   * This applies the search index table, FTS index, and optionally trigram/vector indexes
   * based on the configured search adapter.
   *
   * @example
   * ```ts
   * // Run search migrations
   * await cms.migrations.search();
   * ```
   */
  async search() {
    const adapter = this.cms.search.getAdapter();
    const migrations = adapter.getMigrations();
    const applied = [];
    const skipped = [];
    for (const migration of migrations) {
      try {
        const statements = this.splitSqlStatements(migration.up);
        for (const statement of statements) {
          await this.cms.db.execute(sql$1.raw(statement));
        }
        applied.push(migration.name);
      } catch (error2) {
        const msg = error2?.message?.toLowerCase() || "";
        if (msg.includes("already exists") || msg.includes("duplicate") || msg.includes("relation") && msg.includes("exists")) {
          skipped.push(migration.name);
        } else {
          if (msg.includes("extension") || msg.includes("could not open extension")) {
            console.warn(
              `[Search Migration] Skipping ${migration.name}: ${error2.message}`
            );
            skipped.push(migration.name);
          } else {
            throw error2;
          }
        }
      }
    }
    return { applied, skipped };
  }
  /**
   * Rollback search adapter migrations
   *
   * @example
   * ```ts
   * // Rollback search migrations
   * await cms.migrations.searchDown();
   * ```
   */
  async searchDown() {
    const adapter = this.cms.search.getAdapter();
    const migrations = adapter.getMigrations();
    const applied = [];
    for (let i = migrations.length - 1; i >= 0; i--) {
      const migration = migrations[i];
      try {
        const statements = this.splitSqlStatements(migration.down);
        for (const statement of statements) {
          await this.cms.db.execute(sql$1.raw(statement));
        }
        applied.push(migration.name);
      } catch (error2) {
        const msg = error2?.message?.toLowerCase() || "";
        if (!msg.includes("does not exist")) {
          console.warn(
            `[Search Migration] Warning rolling back ${migration.name}: ${error2.message}`
          );
        }
      }
    }
    return { applied };
  }
  generateRandomMigrationName() {
    const adjectives = [
      "happy",
      "bright",
      "swift",
      "bold",
      "calm",
      "eager",
      "fancy",
      "gentle",
      "jolly",
      "kind",
      "lucky",
      "merry",
      "nice",
      "proud",
      "quick"
    ];
    const colors = [
      "red",
      "blue",
      "green",
      "yellow",
      "purple",
      "orange",
      "pink",
      "crimson",
      "azure",
      "emerald",
      "amber",
      "violet",
      "indigo",
      "scarlet",
      "teal"
    ];
    const animals = [
      "zebra",
      "panda",
      "tiger",
      "eagle",
      "dolphin",
      "falcon",
      "phoenix",
      "dragon",
      "griffin",
      "unicorn",
      "lion",
      "wolf",
      "otter",
      "koala",
      "lemur"
    ];
    const randomItem = (arr) => arr[Math.floor(Math.random() * arr.length)];
    return `${randomItem(adjectives)}_${randomItem(colors)}_${randomItem(animals)}`;
  }
  /**
   * Split SQL string into individual statements.
   * This is needed because PGLite doesn't allow multiple commands in a prepared statement.
   */
  splitSqlStatements(sqlString) {
    return sqlString.split(";").map((s2) => s2.trim()).filter((s2) => s2.length > 0);
  }
}
function mergeFieldsForValidation(tableName, mainFields, localizedFields) {
  const mergedFields = {
    ...mainFields,
    ...localizedFields
  };
  return pgTable(`${tableName}_validation`, mergedFields);
}
function createGlobalValidationSchema(tableName, mainFields, localizedFields, _options) {
  const validationTable = mergeFieldsForValidation(
    tableName,
    mainFields,
    localizedFields
  );
  const updateSchema = createUpdateSchema(validationTable, {
    exclude: {}
  });
  return {
    updateSchema
  };
}
class GlobalCRUDGenerator {
  constructor(state, table, i18nTable, versionsTable, i18nVersionsTable, db, getVirtuals, getVirtualsForVersions, cms2) {
    this.state = state;
    this.table = table;
    this.i18nTable = i18nTable;
    this.versionsTable = versionsTable;
    this.i18nVersionsTable = i18nVersionsTable;
    this.db = db;
    this.getVirtuals = getVirtuals;
    this.getVirtualsForVersions = getVirtualsForVersions;
    this.cms = cms2;
  }
  generate() {
    const crud = {
      get: this.wrapGetWithCMSContext(this.createGet()),
      update: this.wrapUpdateWithCMSContext(this.createUpdate()),
      findVersions: this.wrapWithCMSContext(this.createFindVersions()),
      revertToVersion: this.wrapWithCMSContext(this.createRevertToVersion())
    };
    return crud;
  }
  getDb(context) {
    return getDb(this.db, context);
  }
  /**
   * Normalize context with defaults
   * Delegates to shared normalizeContext utility
   */
  normalizeContext(context = {}) {
    return normalizeContext(context);
  }
  getFieldAccessRules() {
    const globalAccess = this.state.access;
    return globalAccess?.fields;
  }
  async runFieldInputHooks(data, operation, context, db, originalDocument) {
    return applyFieldInputHooks({
      data,
      fieldDefinitions: this.state.fieldDefinitions,
      collectionName: this.state.name,
      operation,
      context,
      db,
      originalDocument
    });
  }
  async runFieldOutputHooks(data, operation, context, db, originalDocument) {
    await applyFieldOutputHooks({
      data,
      fieldDefinitions: this.state.fieldDefinitions,
      collectionName: this.state.name,
      operation,
      context,
      db,
      originalDocument
    });
  }
  /**
   * Append a realtime change event
   * Delegates to shared appendRealtimeChange utility
   */
  async appendRealtimeChange(params, context, db) {
    return appendRealtimeChange(
      params,
      context,
      db,
      this.cms,
      this.state.name,
      "global"
    );
  }
  /**
   * Notify realtime subscribers of a change
   * Delegates to shared notifyRealtimeChange utility
   */
  async notifyRealtimeChange(change) {
    return notifyRealtimeChange(change, this.cms);
  }
  /**
   * Wrapper for get() method: (options?, context?)
   */
  wrapGetWithCMSContext(fn2) {
    return (...args) => {
      if (args.length > 0) {
        args[args.length - 1];
      }
      return fn2(...args);
    };
  }
  /**
   * Wrapper for update() method: (data, context?, options?)
   */
  wrapUpdateWithCMSContext(fn2) {
    return fn2;
  }
  /**
   * Generic wrapper for other methods where context is always last
   */
  wrapWithCMSContext(fn2) {
    return fn2;
  }
  buildSelectQuery(db, context, columns) {
    const useI18n = !!this.i18nTable;
    const needsFallback = useI18n && context.localeFallback !== false && context.locale !== context.defaultLocale;
    const i18nCurrentTable = useI18n ? alias(this.i18nTable, "i18n_current") : null;
    const i18nFallbackTable = needsFallback ? alias(this.i18nTable, "i18n_fallback") : null;
    const selectObj = this.buildSelectObject(
      context,
      columns,
      i18nCurrentTable,
      i18nFallbackTable
    );
    let query2 = db.select(selectObj).from(this.table);
    if (useI18n && i18nCurrentTable) {
      query2 = query2.leftJoin(
        i18nCurrentTable,
        and(
          eq(i18nCurrentTable.parentId, this.table.id),
          eq(i18nCurrentTable.locale, context.locale)
        )
      );
      if (needsFallback && i18nFallbackTable) {
        query2 = query2.leftJoin(
          i18nFallbackTable,
          and(
            eq(i18nFallbackTable.parentId, this.table.id),
            eq(i18nFallbackTable.locale, context.defaultLocale)
          )
        );
      }
    }
    return { query: query2, useI18n, needsFallback };
  }
  /**
   * Resolve the scope ID from context using the scoped resolver
   */
  resolveScopeId(context) {
    const scopeResolver = this.state.options.scoped;
    if (!scopeResolver) return void 0;
    return scopeResolver(context);
  }
  async getCurrentRow(db, context) {
    const scopeId = context ? this.resolveScopeId(context) : void 0;
    const isScoped = this.state.options.scoped !== void 0;
    let query2 = db.select().from(this.table);
    if (isScoped) {
      if (scopeId) {
        query2 = query2.where(eq(this.table.scopeId, scopeId));
      } else {
        query2 = query2.where(sql$1`${this.table.scopeId} IS NULL`);
      }
    }
    const rows = await query2.limit(1);
    return rows[0] || null;
  }
  createGet() {
    return async (options = {}, context = {}) => {
      const db = this.getDb(context);
      const normalized = this.normalizeContext(context);
      const isScoped = this.state.options.scoped !== void 0;
      const scopeId = isScoped ? this.resolveScopeId(normalized) : void 0;
      const canRead = await this.enforceAccessControl(
        "read",
        normalized,
        null,
        options
      );
      if (!canRead) {
        throw ApiError.forbidden({
          operation: "read",
          resource: this.state.name,
          reason: "User does not have permission to read global settings"
        });
      }
      await this.executeHooks(
        this.state.hooks?.beforeRead,
        this.createHookContext({ data: null, context: normalized, db })
      );
      const { query: query2, useI18n, needsFallback } = this.buildSelectQuery(
        db,
        normalized,
        options.columns
      );
      let scopedQuery = query2;
      if (isScoped) {
        if (scopeId) {
          scopedQuery = query2.where(eq(this.table.scopeId, scopeId));
        } else {
          scopedQuery = query2.where(
            sql$1`${this.table.scopeId} IS NULL`
          );
        }
      }
      let rows = await scopedQuery.limit(1);
      if (useI18n && rows.length > 0 && this.state.localized.length > 0) {
        rows = mergeI18nRows(rows, {
          localizedFields: this.state.localized,
          hasFallback: needsFallback
        });
      }
      let row = rows[0] || null;
      if (!row) {
        row = await withTransaction(db, async (tx) => {
          const insertValues = {};
          if (isScoped) {
            insertValues.scopeId = scopeId ?? null;
          }
          const [inserted] = await tx.insert(this.table).values(insertValues).returning();
          if (!inserted) {
            throw ApiError.internal("Failed to auto-create global record");
          }
          await this.createVersion(tx, inserted, "create", normalized);
          const {
            query: createdQuery,
            useI18n: createdUseI18n,
            needsFallback: createdNeedsFallback
          } = this.buildSelectQuery(tx, normalized, options.columns);
          let createdRows = await createdQuery.where(eq(this.table.id, inserted.id)).limit(1);
          if (createdUseI18n && createdRows.length > 0 && this.state.localized.length > 0) {
            createdRows = mergeI18nRows(createdRows, {
              localizedFields: this.state.localized,
              hasFallback: createdNeedsFallback
            });
          }
          return createdRows[0] || inserted;
        });
      }
      if (row && options.with && this.cms) {
        await this.resolveRelations([row], options.with, normalized);
      }
      if (row) {
        await this.filterFieldsForRead(row, normalized);
        await this.runFieldOutputHooks(row, "read", normalized, db);
      }
      if (row && this.state.hooks?.afterRead) {
        await this.executeHooks(
          this.state.hooks.afterRead,
          this.createHookContext({ data: row, context: normalized, db })
        );
      }
      return row;
    };
  }
  /**
   * Separate nested relation operations from regular fields
   * Delegates to extracted separateNestedRelations utility
   */
  separateNestedRelationsInternal(input) {
    const relationNames = this.state.relations ? new Set(Object.keys(this.state.relations)) : /* @__PURE__ */ new Set();
    return separateNestedRelations(input, relationNames);
  }
  /**
   * Process nested relation operations (create, connect, connectOrCreate)
   * Delegates to extracted processNestedRelations utility
   */
  async processNestedRelationsInternal(parentRecord, nestedRelations, context, tx) {
    if (!this.cms || !this.state.relations) return;
    await processNestedRelations({
      parentRecord,
      nestedRelations,
      relations: this.state.relations,
      cms: this.cms,
      context,
      tx,
      resolveFieldKey: (state, column, table) => this.resolveFieldKey(state, column, table)
    });
  }
  createUpdate() {
    return async (data, context = {}, options = {}) => {
      const db = this.getDb(context);
      const normalized = this.normalizeContext(context);
      const isScoped = this.state.options.scoped !== void 0;
      const scopeId = isScoped ? this.resolveScopeId(normalized) : void 0;
      const existing = await this.getCurrentRow(db, normalized);
      const canUpdate = await this.enforceAccessControl(
        "update",
        normalized,
        existing,
        data
      );
      if (!canUpdate)
        throw ApiError.forbidden({
          operation: "update",
          resource: this.state.name,
          reason: "User does not have permission to update global settings"
        });
      await this.executeHooks(
        this.state.hooks?.beforeUpdate,
        this.createHookContext({
          data: existing,
          input: data,
          context: normalized,
          db
        })
      );
      let { regularFields, nestedRelations } = this.separateNestedRelationsInternal(data);
      await this.validateFieldWriteAccess(
        regularFields,
        normalized,
        existing ? "update" : "create",
        existing
      );
      regularFields = await this.runFieldInputHooks(
        regularFields,
        existing ? "update" : "create",
        normalized,
        db,
        existing
      );
      await this.executeHooks(
        this.state.hooks?.beforeChange,
        this.createHookContext({
          data: existing,
          input: regularFields,
          context: normalized,
          db
        })
      );
      let changeEvent = null;
      const updatedRecord = await withTransaction(db, async (tx) => {
        const { localized, nonLocalized } = this.splitLocalizedFields(regularFields);
        let updatedId = existing?.id;
        if (existing) {
          if (Object.keys(nonLocalized).length > 0) {
            await tx.update(this.table).set({
              ...nonLocalized,
              ...this.state.options.timestamps !== false ? { updatedAt: /* @__PURE__ */ new Date() } : {}
            }).where(eq(this.table.id, existing.id));
          }
        } else {
          const insertValues = {
            ...nonLocalized,
            ...isScoped ? { scopeId: scopeId ?? null } : {}
          };
          const [inserted] = await tx.insert(this.table).values(insertValues).returning();
          updatedId = inserted?.id;
        }
        if (this.i18nTable && normalized.locale && Object.keys(localized).length > 0) {
          await tx.insert(this.i18nTable).values({
            parentId: updatedId,
            locale: normalized.locale,
            ...localized
          }).onConflictDoUpdate({
            target: [
              this.i18nTable.parentId,
              this.i18nTable.locale
            ],
            set: localized
          });
        }
        const baseRows = updatedId ? await tx.select().from(this.table).where(eq(this.table.id, updatedId)).limit(1) : [];
        const baseRecord = baseRows[0] || null;
        let updatedRecord2 = baseRecord;
        if (updatedId) {
          const {
            query: refreshQuery,
            useI18n: refreshUseI18n,
            needsFallback: refreshNeedsFallback
          } = this.buildSelectQuery(tx, normalized);
          let refreshedRows = await refreshQuery.where(eq(this.table.id, updatedId)).limit(1);
          if (refreshUseI18n && refreshedRows.length > 0 && this.state.localized.length > 0) {
            refreshedRows = mergeI18nRows(refreshedRows, {
              localizedFields: this.state.localized,
              hasFallback: refreshNeedsFallback
            });
          }
          updatedRecord2 = refreshedRows[0] || baseRecord;
        }
        if (!baseRecord) {
          throw ApiError.internal("Global record not found after update");
        }
        if (Object.keys(nestedRelations).length > 0) {
          await this.processNestedRelationsInternal(
            baseRecord,
            nestedRelations,
            normalized,
            tx
          );
        }
        await this.createVersion(
          tx,
          baseRecord,
          existing ? "update" : "create",
          normalized
        );
        await this.executeHooks(
          this.state.hooks?.afterUpdate,
          this.createHookContext({
            data: updatedRecord2,
            input: data,
            context: normalized,
            db: tx
          })
        );
        await this.executeHooks(
          this.state.hooks?.afterChange,
          this.createHookContext({
            data: updatedRecord2,
            input: data,
            context: normalized,
            db: tx
          })
        );
        changeEvent = await this.appendRealtimeChange(
          {
            operation: existing ? "update" : "create",
            recordId: baseRecord.id
          },
          normalized,
          tx
        );
        return updatedRecord2;
      });
      if (updatedRecord && options.with && this.cms) {
        await this.resolveRelations([updatedRecord], options.with, normalized);
      }
      if (updatedRecord) {
        await this.runFieldOutputHooks(
          updatedRecord,
          existing ? "update" : "create",
          normalized,
          db,
          existing ?? void 0
        );
      }
      await this.notifyRealtimeChange(changeEvent);
      return updatedRecord;
    };
  }
  createFindVersions() {
    return async (options = {}, context = {}) => {
      const db = this.getDb(context);
      const normalized = this.normalizeContext(context);
      if (!this.versionsTable) return [];
      const canRead = await this.enforceAccessControl(
        "read",
        normalized,
        null,
        options
      );
      if (!canRead)
        throw ApiError.forbidden({
          operation: "read",
          resource: `${this.state.name} versions`,
          reason: "User does not have permission to read version history"
        });
      const parentId = options.id ?? (await this.getCurrentRow(db))?.id;
      if (!parentId) return [];
      let query2 = db.select(this.buildVersionsSelectObject(normalized)).from(this.versionsTable).where(eq(this.versionsTable.id, parentId)).orderBy(sql$1`${this.versionsTable.versionNumber} ASC`);
      if (this.i18nVersionsTable && normalized.locale) {
        query2 = query2.leftJoin(
          this.i18nVersionsTable,
          and(
            eq(
              this.i18nVersionsTable.parentId,
              this.versionsTable.id
            ),
            eq(
              this.i18nVersionsTable.versionNumber,
              this.versionsTable.versionNumber
            ),
            eq(this.i18nVersionsTable.locale, normalized.locale)
          )
        );
      }
      if (options.limit) query2 = query2.limit(options.limit);
      if (options.offset) query2 = query2.offset(options.offset);
      return await query2;
    };
  }
  createRevertToVersion() {
    return async (options, context = {}) => {
      const db = this.getDb(context);
      const normalized = this.normalizeContext(context);
      if (!this.versionsTable) throw ApiError.notImplemented("Versioning");
      const hasVersionId = typeof options.versionId === "string";
      const hasVersion = typeof options.version === "number";
      if (!hasVersionId && !hasVersion) {
        throw ApiError.badRequest("Version or versionId required");
      }
      const parentId = options.id ?? (await this.getCurrentRow(db))?.id;
      if (!parentId) {
        throw ApiError.notFound("Global record", "");
      }
      const versionRows = await db.select().from(this.versionsTable).where(
        hasVersionId ? and(
          eq(this.versionsTable.id, parentId),
          eq(this.versionsTable.versionId, options.versionId)
        ) : and(
          eq(this.versionsTable.id, parentId),
          eq(this.versionsTable.versionNumber, options.version)
        )
      ).limit(1);
      const version2 = versionRows[0];
      if (!version2)
        throw ApiError.notFound(
          "Version",
          options.versionId || String(options.version)
        );
      const existing = await this.getCurrentRow(db);
      if (!existing) throw ApiError.notFound("Global record", "");
      const nonLocalized = {};
      for (const [name2] of Object.entries(this.state.fields)) {
        if (this.state.localized.includes(name2)) continue;
        nonLocalized[name2] = version2[name2];
      }
      const localizedForContext = {};
      if (this.i18nVersionsTable && normalized.locale) {
        const localeRows = await db.select().from(this.i18nVersionsTable).where(
          and(
            eq(this.i18nVersionsTable.parentId, parentId),
            eq(
              this.i18nVersionsTable.versionNumber,
              version2.versionNumber
            ),
            eq(this.i18nVersionsTable.locale, normalized.locale)
          )
        ).limit(1);
        const localeRow = localeRows[0];
        if (localeRow) {
          for (const fieldName of this.state.localized) {
            localizedForContext[fieldName] = localeRow[fieldName];
          }
        }
      }
      const restoreData = { ...nonLocalized, ...localizedForContext };
      const restoreWithFieldHooks = await this.runFieldInputHooks(
        restoreData,
        "update",
        normalized,
        db,
        existing
      );
      const { localized: restoreLocalized, nonLocalized: restoreNonLocalized } = this.splitLocalizedFields(restoreWithFieldHooks);
      const canUpdate = await this.enforceAccessControl(
        "update",
        normalized,
        existing,
        restoreWithFieldHooks
      );
      if (!canUpdate)
        throw ApiError.forbidden({
          operation: "update",
          resource: this.state.name,
          reason: "User does not have permission to revert to this version"
        });
      await this.executeHooks(
        this.state.hooks?.beforeUpdate,
        this.createHookContext({
          data: existing,
          input: restoreWithFieldHooks,
          context: normalized,
          db
        })
      );
      await this.executeHooks(
        this.state.hooks?.beforeChange,
        this.createHookContext({
          data: existing,
          input: restoreWithFieldHooks,
          context: normalized,
          db
        })
      );
      return withTransaction(db, async (tx) => {
        if (Object.keys(restoreNonLocalized).length > 0) {
          await tx.update(this.table).set({
            ...restoreNonLocalized,
            ...this.state.options.timestamps !== false ? { updatedAt: /* @__PURE__ */ new Date() } : {}
          }).where(eq(this.table.id, parentId));
        }
        if (this.i18nTable && this.i18nVersionsTable) {
          await tx.delete(this.i18nTable).where(eq(this.i18nTable.parentId, parentId));
          const localeRows = await tx.select().from(this.i18nVersionsTable).where(
            and(
              eq(this.i18nVersionsTable.parentId, parentId),
              eq(
                this.i18nVersionsTable.versionNumber,
                version2.versionNumber
              )
            )
          );
          if (localeRows.length > 0) {
            const insertRows = localeRows.map((row) => {
              const {
                id: _id,
                parentId: _parentId,
                versionNumber: _versionNumber,
                locale,
                ...localizedFields
              } = row;
              return {
                parentId,
                locale,
                ...localizedFields
              };
            });
            await tx.insert(this.i18nTable).values(insertRows);
          }
          if (normalized.locale && Object.keys(restoreLocalized).length > 0) {
            await tx.insert(this.i18nTable).values({
              parentId,
              locale: normalized.locale,
              ...restoreLocalized
            }).onConflictDoUpdate({
              target: [
                this.i18nTable.parentId,
                this.i18nTable.locale
              ],
              set: restoreLocalized
            });
          }
        }
        const baseRows = await tx.select().from(this.table).where(eq(this.table.id, parentId)).limit(1);
        const baseRecord = baseRows[0] || null;
        const {
          query: refreshQuery,
          useI18n: refreshUseI18n,
          needsFallback: refreshNeedsFallback
        } = this.buildSelectQuery(tx, normalized);
        let refreshedRows = await refreshQuery.where(eq(this.table.id, parentId)).limit(1);
        if (refreshUseI18n && refreshedRows.length > 0 && this.state.localized.length > 0) {
          refreshedRows = mergeI18nRows(refreshedRows, {
            localizedFields: this.state.localized,
            hasFallback: refreshNeedsFallback
          });
        }
        const updatedRecord = refreshedRows[0] || baseRecord;
        if (!baseRecord) {
          throw ApiError.internal("Global record not found after revert");
        }
        await this.createVersion(tx, baseRecord, "update", normalized);
        await this.executeHooks(
          this.state.hooks?.afterUpdate,
          this.createHookContext({
            data: updatedRecord,
            input: restoreWithFieldHooks,
            context: normalized,
            db: tx
          })
        );
        await this.executeHooks(
          this.state.hooks?.afterChange,
          this.createHookContext({
            data: updatedRecord,
            input: restoreWithFieldHooks,
            context: normalized,
            db: tx
          })
        );
        if (updatedRecord) {
          await this.runFieldOutputHooks(
            updatedRecord,
            "update",
            normalized,
            tx,
            existing
          );
        }
        return updatedRecord;
      });
    };
  }
  /**
   * Create a new version of the record
   * Delegates to extracted createVersionRecord utility
   */
  async createVersion(tx, row, operation, context) {
    if (!this.versionsTable) return;
    await createVersionRecord({
      tx,
      row,
      operation,
      versionsTable: this.versionsTable,
      i18nVersionsTable: this.i18nVersionsTable,
      i18nTable: this.i18nTable,
      options: this.state.options,
      context
    });
  }
  buildSelectObject(context, columns, i18nCurrentTable, i18nFallbackTable) {
    const select = {
      id: this.table.id
    };
    const includeAllFields = !columns;
    const hasFallback = !!i18nFallbackTable;
    for (const [name2, _column] of Object.entries(this.state.fields)) {
      if (columns && !columns[name2]) continue;
      const isLocalizedField = this.state.localized.includes(name2);
      if (isLocalizedField && i18nCurrentTable && context.locale) {
        const i18nCurrentTbl = i18nCurrentTable;
        const columnExistsInI18n = i18nCurrentTable && i18nCurrentTable[name2];
        if (columnExistsInI18n) {
          select[`_i18n_${name2}`] = i18nCurrentTbl[name2];
          if (hasFallback && i18nFallbackTable) {
            const i18nFallbackTbl = i18nFallbackTable;
            select[`_i18n_fallback_${name2}`] = i18nFallbackTbl[name2];
          }
        } else {
          select[name2] = this.table[name2];
        }
      } else {
        select[name2] = this.table[name2];
      }
    }
    const virtuals = this.getVirtuals ? this.getVirtuals(context) : this.state.virtuals;
    for (const [name2, sqlExpr] of Object.entries(virtuals)) {
      if (columns && !columns[name2]) continue;
      select[name2] = sqlExpr;
    }
    if (this.state.options.timestamps !== false) {
      if (includeAllFields || columns?.createdAt) {
        select.createdAt = this.table.createdAt;
      }
      if (includeAllFields || columns?.updatedAt) {
        select.updatedAt = this.table.updatedAt;
      }
    }
    return select;
  }
  buildVersionsSelectObject(context) {
    if (!this.versionsTable) return {};
    const versionsTable = this.versionsTable;
    const select = {
      versionId: versionsTable.versionId,
      id: versionsTable.id,
      versionNumber: versionsTable.versionNumber,
      versionOperation: versionsTable.versionOperation,
      versionUserId: versionsTable.versionUserId,
      versionCreatedAt: versionsTable.versionCreatedAt
    };
    const defaultLocale2 = context?.defaultLocale || DEFAULT_LOCALE;
    for (const [name2, _column] of Object.entries(this.state.fields)) {
      const isLocalizedField = this.state.localized.includes(name2);
      if (isLocalizedField && this.i18nVersionsTable && context.locale) {
        const i18nVersionsTable = this.i18nVersionsTable;
        const columnExistsInI18n = this.i18nVersionsTable[name2];
        if (columnExistsInI18n) {
          if (context.localeFallback === false) {
            select[name2] = i18nVersionsTable[name2];
          } else {
            select[name2] = sql$1`COALESCE(
							${i18nVersionsTable[name2]},
							(SELECT ${i18nVersionsTable[name2]} FROM ${this.i18nVersionsTable}
							 WHERE ${i18nVersionsTable.parentId} = ${versionsTable.id}
							 AND ${i18nVersionsTable.versionNumber} = ${versionsTable.versionNumber}
							 AND ${i18nVersionsTable.locale} = ${defaultLocale2} LIMIT 1)
						)`;
          }
        } else {
          select[name2] = versionsTable[name2];
        }
      } else {
        select[name2] = versionsTable[name2];
      }
    }
    const versionVirtuals = this.getVirtualsForVersions ? this.getVirtualsForVersions(context) : {};
    for (const [name2, sqlExpr] of Object.entries(versionVirtuals)) {
      select[name2] = sqlExpr;
    }
    if (this.state.options.timestamps !== false) {
      select.createdAt = versionsTable.createdAt;
      select.updatedAt = versionsTable.updatedAt;
    }
    return select;
  }
  /**
   * Split input data into localized and non-localized fields.
   * Uses field definition schemas to determine which nested fields are localized.
   */
  splitLocalizedFields(input) {
    const nestedSchemas = this.state.fieldDefinitions ? extractNestedLocalizationSchemas(this.state.fieldDefinitions) : {};
    return splitLocalizedFields(input, this.state.localized, nestedSchemas);
  }
  /**
   * Create hook context with full CMS access
   */
  createHookContext(params) {
    const normalized = this.normalizeContext(params.context);
    return {
      data: params.data,
      input: params.input,
      app: this.cms,
      session: normalized.session,
      locale: normalized.locale,
      accessMode: normalized.accessMode,
      db: params.db
    };
  }
  async executeHooks(hooks, ctx) {
    if (!hooks) return;
    const hookArray = Array.isArray(hooks) ? hooks : [hooks];
    for (const hook of hookArray) {
      await hook(ctx);
    }
  }
  /**
   * Enforce access control
   * Delegates to extracted executeAccessRule utility
   * Falls back to CMS defaultAccess if global doesn't define its own rules
   * Note: Globals only return boolean (no AccessWhere support)
   */
  async enforceAccessControl(operation, context, row, input) {
    const normalized = this.normalizeContext(context);
    const db = this.getDb(normalized);
    if (normalized.accessMode === "system") return true;
    const accessOperation = operation === "update" ? "update" : "read";
    const accessRule = this.state.access?.[operation] ?? this.cms?.defaultAccess?.[accessOperation];
    const result2 = await executeAccessRule(accessRule, {
      cms: this.cms,
      db,
      session: normalized.session,
      locale: normalized.locale,
      row,
      input
    });
    return result2 === true;
  }
  /**
   * Get fields the user can read based on field-level access control
   */
  getReadableFields(context) {
    const normalized = this.normalizeContext(context);
    const readableFields = /* @__PURE__ */ new Set();
    if (normalized.accessMode === "system") {
      return /* @__PURE__ */ new Set([
        ...Object.keys(this.state.fields),
        ...Object.keys(this.state.virtuals),
        "id",
        "createdAt",
        "updatedAt"
      ]);
    }
    const fieldAccess = this.getFieldAccessRules();
    if (!fieldAccess) {
      return /* @__PURE__ */ new Set([
        ...Object.keys(this.state.fields),
        ...Object.keys(this.state.virtuals),
        "id",
        "createdAt",
        "updatedAt"
      ]);
    }
    const allFields = [
      ...Object.keys(this.state.fields),
      ...Object.keys(this.state.virtuals)
    ];
    for (const fieldName of allFields) {
      const access = fieldAccess[fieldName];
      if (!access || access.read === void 0) {
        readableFields.add(fieldName);
        continue;
      }
      const readRule = access.read;
      if (typeof readRule === "boolean") {
        if (readRule) {
          readableFields.add(fieldName);
        }
        continue;
      }
      if (typeof readRule === "function") {
        readableFields.add(fieldName);
      }
    }
    readableFields.add("id");
    if (this.state.options.timestamps !== false) {
      readableFields.add("createdAt");
      readableFields.add("updatedAt");
    }
    return readableFields;
  }
  /**
   * Filter fields from result based on field-level read access
   * Delegates to extracted getRestrictedReadFields utility
   */
  async filterFieldsForRead(result2, context) {
    if (!result2) return;
    this.getDb(context);
    const fieldAccess = this.getFieldAccessRules();
    const fieldsToRemove = await getRestrictedReadFields(result2, context, {
      cms: this.cms,
      fieldAccess
    });
    for (const fieldName of fieldsToRemove) {
      delete result2[fieldName];
    }
  }
  /**
   * Check if user can write to a specific field
   */
  async canWriteField(fieldName, context, operation, row) {
    const fieldAccess = this.getFieldAccessRules();
    const access = fieldAccess?.[fieldName];
    if (!access) return true;
    const rule = operation === "create" ? access.create : access.update;
    if (rule === void 0 || rule === true) return true;
    if (rule === false) return false;
    if (typeof rule === "function") {
      const req2 = context.req ?? context.request ?? (typeof Request !== "undefined" ? new Request("http://questpie.local") : {});
      return await rule({
        req: req2,
        user: context.session?.user,
        doc: row,
        operation
      }) === true;
    }
    return true;
  }
  /**
   * Validate write access for all fields in input data
   */
  async validateFieldWriteAccess(data, context, operation, existing) {
    const normalized = this.normalizeContext(context);
    if (normalized.accessMode === "system") return;
    const fieldAccess = this.getFieldAccessRules();
    if (!fieldAccess) return;
    for (const fieldName of Object.keys(data)) {
      if (fieldName === "id" || fieldName === "createdAt" || fieldName === "updatedAt") {
        continue;
      }
      const canWrite = await this.canWriteField(
        fieldName,
        context,
        operation,
        existing
      );
      if (!canWrite) {
        throw ApiError.forbidden({
          operation: "update",
          resource: this.state.name,
          reason: `Cannot write field '${fieldName}': access denied`,
          fieldPath: fieldName
        });
      }
    }
  }
  /**
   * Resolve relations recursively (mirrors collection relation loading)
   */
  async resolveRelations(rows, withConfig, context) {
    if (!rows.length || !withConfig || !this.cms) return;
    const db = this.getDb(context);
    for (const [relationName, relationOptions] of Object.entries(withConfig)) {
      if (!relationOptions) continue;
      const relation = this.state.relations[relationName];
      if (!relation) continue;
      const relatedCrud = this.cms.api.collections[relation.collection];
      if (relation.fields && relation.fields.length > 0) {
        const sourceField = relation.fields[0];
        const targetFieldName = relation.references[0];
        const sourceColName = this.resolveFieldKey(this.state, sourceField, this.table) ?? sourceField.name;
        const sourceIds = new Set(
          rows.map((r2) => r2[sourceColName]).filter((id) => id !== null && id !== void 0)
        );
        if (sourceIds.size === 0) continue;
        const nestedOptions = typeof relationOptions === "object" ? relationOptions : {};
        const { docs: relatedRows } = await relatedCrud.find(
          {
            ...nestedOptions,
            where: {
              ...nestedOptions.where,
              [targetFieldName]: { in: Array.from(sourceIds) }
            }
          },
          context
        );
        const relatedMap = /* @__PURE__ */ new Map();
        for (const row of relatedRows) {
          relatedMap.set(row[targetFieldName], row);
        }
        for (const row of rows) {
          const sourceId = row[sourceColName];
          if (sourceId !== null && sourceId !== void 0) {
            row[relationName] = relatedMap.get(sourceId) || null;
          }
        }
      } else if (relation.type === "many" && !relation.fields) {
        const reverseRelationName = relation.relationName;
        if (!reverseRelationName) continue;
        const reverseRelation = relatedCrud["~internalState"].relations?.[reverseRelationName];
        if (!reverseRelation?.fields || reverseRelation.fields.length === 0)
          continue;
        const foreignKeyField = this.resolveFieldKey(
          relatedCrud["~internalState"],
          reverseRelation.fields[0],
          relatedCrud["~internalRelatedTable"]
        ) ?? reverseRelation.fields[0].name;
        const primaryKeyField = reverseRelation.references?.[0] || "id";
        const parentIds = new Set(
          rows.map((r2) => r2[primaryKeyField]).filter((id) => id !== null && id !== void 0)
        );
        if (parentIds.size === 0) continue;
        const nestedOptions = typeof relationOptions === "object" ? relationOptions : {};
        if (nestedOptions._count || nestedOptions._aggregate) {
          const relatedTable = relatedCrud["~internalRelatedTable"];
          const foreignKeyCol = relatedTable[foreignKeyField];
          const selectClause = {
            [foreignKeyField]: foreignKeyCol
          };
          if (nestedOptions._count) {
            selectClause._count = count().as("_count");
          }
          if (nestedOptions._aggregate) {
            const agg = nestedOptions._aggregate;
            if (agg._count) {
              selectClause._count = count().as("_count");
            }
            if (agg._sum) {
              for (const [field, enabled] of Object.entries(agg._sum)) {
                if (enabled && relatedTable[field]) {
                  selectClause[`_sum_${field}`] = sum(relatedTable[field]).as(
                    `_sum_${field}`
                  );
                }
              }
            }
            if (agg._avg) {
              for (const [field, enabled] of Object.entries(agg._avg)) {
                if (enabled && relatedTable[field]) {
                  selectClause[`_avg_${field}`] = avg(relatedTable[field]).as(
                    `_avg_${field}`
                  );
                }
              }
            }
            if (agg._min) {
              for (const [field, enabled] of Object.entries(agg._min)) {
                if (enabled && relatedTable[field]) {
                  selectClause[`_min_${field}`] = min$1(relatedTable[field]).as(
                    `_min_${field}`
                  );
                }
              }
            }
            if (agg._max) {
              for (const [field, enabled] of Object.entries(agg._max)) {
                if (enabled && relatedTable[field]) {
                  selectClause[`_max_${field}`] = max$1(relatedTable[field]).as(
                    `_max_${field}`
                  );
                }
              }
            }
          }
          const whereConditions = [
            inArray(foreignKeyCol, Array.from(parentIds))
          ];
          if (nestedOptions.where) {
            const additionalWhere = this.buildWhereClauseInternal(
              nestedOptions.where,
              false,
              relatedTable,
              context,
              relatedCrud["~internalState"],
              relatedCrud["~internalI18nTable"]
            );
            if (additionalWhere) {
              whereConditions.push(additionalWhere);
            }
          }
          const aggregateResults = await db.select(selectClause).from(relatedTable).where(and(...whereConditions)).groupBy(foreignKeyCol);
          const aggregateMap = /* @__PURE__ */ new Map();
          for (const result2 of aggregateResults) {
            const parentId = result2[foreignKeyField];
            const aggData = {};
            if (result2._count !== void 0) {
              aggData._count = Number(result2._count);
            }
            for (const key of Object.keys(result2)) {
              if (key.startsWith("_sum_")) {
                if (!aggData._sum) aggData._sum = {};
                aggData._sum[key.replace("_sum_", "")] = Number(result2[key]) || 0;
              } else if (key.startsWith("_avg_")) {
                if (!aggData._avg) aggData._avg = {};
                aggData._avg[key.replace("_avg_", "")] = Number(result2[key]) || 0;
              } else if (key.startsWith("_min_")) {
                if (!aggData._min) aggData._min = {};
                aggData._min[key.replace("_min_", "")] = result2[key];
              } else if (key.startsWith("_max_")) {
                if (!aggData._max) aggData._max = {};
                aggData._max[key.replace("_max_", "")] = result2[key];
              }
            }
            aggregateMap.set(parentId, aggData);
          }
          for (const row of rows) {
            const parentId = row[primaryKeyField];
            row[relationName] = aggregateMap.get(parentId) || { _count: 0 };
          }
        } else {
          const relatedWhere = {
            [foreignKeyField]: { in: Array.from(parentIds) }
          };
          if (nestedOptions.where) {
            relatedWhere.AND = [nestedOptions.where];
          }
          const queryOptions = { ...nestedOptions };
          if (queryOptions.columns) {
            queryOptions.columns = {
              ...queryOptions.columns,
              [foreignKeyField]: true
            };
          }
          const { docs: relatedRows } = await relatedCrud.find(
            {
              ...queryOptions,
              where: relatedWhere
            },
            context
          );
          const relatedMap = /* @__PURE__ */ new Map();
          for (const relatedRow of relatedRows) {
            const parentId = relatedRow[foreignKeyField];
            if (!relatedMap.has(parentId)) {
              relatedMap.set(parentId, []);
            }
            relatedMap.get(parentId)?.push(relatedRow);
          }
          for (const row of rows) {
            const parentId = row[primaryKeyField];
            row[relationName] = relatedMap.get(parentId) || [];
          }
        }
      } else if (relation.type === "manyToMany" && relation.through) {
        const sourceKey = relation.sourceKey || "id";
        const targetKey = relation.targetKey || "id";
        const sourceField = relation.sourceField;
        const targetField = relation.targetField;
        if (!sourceField || !targetField) continue;
        const junctionCrud = this.cms.api.collections[relation.through];
        const sourceIds = new Set(
          rows.map((r2) => r2[sourceKey]).filter((id) => id !== null && id !== void 0)
        );
        if (sourceIds.size === 0) continue;
        const { docs: junctionRows } = await junctionCrud.find(
          {
            where: { [sourceField]: { in: Array.from(sourceIds) } }
          },
          context
        );
        if (!junctionRows.length) {
          for (const row of rows) {
            row[relationName] = [];
          }
          continue;
        }
        const targetIds = [
          ...new Set(
            junctionRows.map((j) => j[targetField]).filter((id) => id !== null && id !== void 0)
          )
        ];
        if (!targetIds.length) {
          for (const row of rows) {
            row[relationName] = [];
          }
          continue;
        }
        const nestedOptions = typeof relationOptions === "object" ? relationOptions : {};
        const relatedWhere = {
          [targetKey]: { in: targetIds }
        };
        if (nestedOptions.where) {
          relatedWhere.AND = [nestedOptions.where];
        }
        const { docs: relatedRows } = await relatedCrud.find(
          {
            ...nestedOptions,
            where: relatedWhere
          },
          context
        );
        const junctionMap = /* @__PURE__ */ new Map();
        for (const j of junctionRows) {
          const sid = j[sourceField];
          if (!junctionMap.has(sid)) {
            junctionMap.set(sid, []);
          }
          junctionMap.get(sid)?.push(j[targetField]);
        }
        const relatedMap = /* @__PURE__ */ new Map();
        for (const r2 of relatedRows) {
          relatedMap.set(r2[targetKey], r2);
        }
        for (const row of rows) {
          const sourceId = row[sourceKey];
          const relatedIds = junctionMap.get(sourceId) || [];
          row[relationName] = relatedIds.map((tid) => relatedMap.get(tid)).filter((r2) => r2 !== void 0);
        }
      }
    }
  }
  resolveFieldKey(state, column, table) {
    if (typeof column === "string") return column;
    const columnName = column?.name ?? column?.config?.name;
    if (!columnName) return void 0;
    for (const [key, value] of Object.entries(state.fields)) {
      const valueName = value?.name ?? value?.config?.name;
      if (valueName === columnName) return key;
    }
    if (table) {
      for (const [key, value] of Object.entries(table)) {
        const valueName = value?.name ?? value?.config?.name;
        if (valueName === columnName) return key;
      }
    }
    return void 0;
  }
  buildRelationWhereClause(relation, relationWhere, parentTable, context) {
    switch (relation.type) {
      case "one":
        return this.buildBelongsToExistsClause(
          relation,
          relationWhere,
          context
        );
      case "many":
        return this.buildHasManyExistsClause(
          relation,
          relationWhere,
          parentTable,
          context
        );
      case "manyToMany":
        return this.buildManyToManyExistsClause(
          relation,
          relationWhere,
          parentTable,
          context
        );
      default:
        return void 0;
    }
  }
  buildBelongsToExistsClause(relation, relationWhere, context) {
    if (!this.cms || !relation.fields || !relation.references?.length) {
      return void 0;
    }
    const relatedCrud = this.cms.api.collections[relation.collection];
    const relatedTable = relatedCrud["~internalRelatedTable"];
    const relatedState = relatedCrud["~internalState"];
    const joinConditions = relation.fields.map((sourceField, index2) => {
      const targetFieldName = relation.references?.[index2];
      const targetColumn = targetFieldName ? relatedTable[targetFieldName] : void 0;
      return targetColumn ? eq(targetColumn, sourceField) : void 0;
    }).filter(Boolean);
    if (joinConditions.length === 0) return void 0;
    const whereConditions = [...joinConditions];
    if (relationWhere) {
      const nestedClause = this.buildWhereClauseInternal(
        relationWhere,
        false,
        relatedTable,
        context,
        relatedState,
        relatedCrud["~internalI18nTable"]
      );
      if (nestedClause) whereConditions.push(nestedClause);
    }
    if (relatedState.options?.softDelete) {
      whereConditions.push(sql$1`${relatedTable.deletedAt} IS NULL`);
    }
    const db = this.getDb(context);
    const subquery = db.select({ one: sql$1`1` }).from(relatedTable).where(and(...whereConditions));
    return sql$1`exists (${subquery})`;
  }
  buildHasManyExistsClause(relation, relationWhere, parentTable, context) {
    if (!this.cms || relation.fields) return void 0;
    const relatedCrud = this.cms.api.collections[relation.collection];
    const relatedTable = relatedCrud["~internalRelatedTable"];
    const relatedState = relatedCrud["~internalState"];
    const reverseRelationName = relation.relationName;
    const reverseRelation = reverseRelationName ? relatedState.relations?.[reverseRelationName] : void 0;
    if (!reverseRelation?.fields || !reverseRelation.references?.length) {
      return void 0;
    }
    const joinConditions = reverseRelation.fields.map((foreignField, index2) => {
      const parentFieldName = reverseRelation.references?.[index2];
      const parentColumn = parentFieldName ? parentTable[parentFieldName] : void 0;
      return parentColumn ? eq(foreignField, parentColumn) : void 0;
    }).filter(Boolean);
    if (joinConditions.length === 0) return void 0;
    const whereConditions = [...joinConditions];
    if (relationWhere) {
      const nestedClause = this.buildWhereClauseInternal(
        relationWhere,
        false,
        relatedTable,
        context,
        relatedState,
        relatedCrud["~internalI18nTable"]
      );
      if (nestedClause) whereConditions.push(nestedClause);
    }
    if (relatedState.options?.softDelete) {
      whereConditions.push(sql$1`${relatedTable.deletedAt} IS NULL`);
    }
    const db = this.getDb(context);
    const subquery = db.select({ one: sql$1`1` }).from(relatedTable).where(and(...whereConditions));
    return sql$1`exists (${subquery})`;
  }
  buildManyToManyExistsClause(relation, relationWhere, parentTable, context) {
    if (!this.cms || !relation.through) return void 0;
    const relatedCrud = this.cms.api.collections[relation.collection];
    const junctionCrud = this.cms.api.collections[relation.through];
    const relatedTable = relatedCrud["~internalRelatedTable"];
    const junctionTable = junctionCrud["~internalRelatedTable"];
    const relatedState = relatedCrud["~internalState"];
    const junctionState = junctionCrud["~internalState"];
    const sourceKey = relation.sourceKey || "id";
    const targetKey = relation.targetKey || "id";
    const sourceField = relation.sourceField;
    const targetField = relation.targetField;
    const parentColumn = parentTable[sourceKey];
    const relatedColumn = relatedTable[targetKey];
    const junctionSourceColumn = sourceField ? junctionTable[sourceField] : void 0;
    const junctionTargetColumn = targetField ? junctionTable[targetField] : void 0;
    if (!parentColumn || !relatedColumn || !junctionSourceColumn || !junctionTargetColumn) {
      return void 0;
    }
    const whereConditions = [eq(junctionSourceColumn, parentColumn)];
    if (relationWhere) {
      const nestedClause = this.buildWhereClauseInternal(
        relationWhere,
        false,
        relatedTable,
        context,
        relatedState,
        relatedCrud["~internalI18nTable"]
      );
      if (nestedClause) whereConditions.push(nestedClause);
    }
    if (junctionState.options?.softDelete) {
      whereConditions.push(sql$1`${junctionTable.deletedAt} IS NULL`);
    }
    if (relatedState.options?.softDelete) {
      whereConditions.push(sql$1`${relatedTable.deletedAt} IS NULL`);
    }
    const db = this.getDb(context);
    const subquery = db.select({ one: sql$1`1` }).from(junctionTable).innerJoin(relatedTable, eq(junctionTargetColumn, relatedColumn)).where(and(...whereConditions));
    return sql$1`exists (${subquery})`;
  }
  /**
   * Build WHERE clause from WHERE object
   * Delegates to extracted buildWhereClause function
   */
  buildWhereClauseInternal(where, useI18n = false, customTable, context, customState, i18nCurrentTable, i18nFallbackTable) {
    return buildWhereClause(where, {
      table: customTable || this.table,
      state: customState || this.state,
      i18nCurrentTable: i18nCurrentTable ?? null,
      i18nFallbackTable: i18nFallbackTable ?? null,
      context,
      cms: this.cms,
      useI18n,
      db: this.db
    });
  }
}
const defaultIdColumn = () => text("id").primaryKey().default(sql$1`gen_random_uuid()`);
function getColumnConfig(column) {
  return column.config || {};
}
function cloneColumnType(sourceColumn, newName) {
  const config2 = getColumnConfig(sourceColumn);
  const columnType = config2.columnType || sourceColumn.constructor.name;
  switch (columnType) {
    case "PgUUID":
      return uuid$1(newName);
    case "PgText":
      return text(newName);
    case "PgVarchar":
      return varchar(newName, { length: config2.length });
    case "PgChar":
      return char(newName, { length: config2.length });
    case "PgInteger":
      return integer(newName);
    case "PgSerial":
      return integer(newName);
    case "PgSmallInt":
      return smallint(newName);
    case "PgSmallSerial":
      return smallint(newName);
    case "PgBigInt53":
    case "PgBigInt64":
      return bigint(newName, { mode: config2.mode || "number" });
    case "PgBigSerial53":
    case "PgBigSerial64":
      return bigint(newName, { mode: config2.mode || "number" });
    default:
      return text(newName);
  }
}
class Global {
  name;
  table;
  i18nTable;
  // Simplified type for now
  versionsTable;
  i18nVersionsTable;
  state;
  /**
   * Type inference helper
   */
  $infer;
  constructor(state) {
    this.state = state;
    this.name = state.name;
    this.table = this.generateMainTable();
    this.i18nTable = this.generateI18nTable();
    this.versionsTable = this.generateVersionsTable();
    this.i18nVersionsTable = this.generateI18nVersionsTable();
    if (!state.validation) {
      const localizedFieldNames = new Set(state.localized);
      const mainFields = {};
      const localizedFields = {};
      const hasUserDefinedId = "id" in state.fields;
      if (!hasUserDefinedId) {
        mainFields.id = defaultIdColumn();
      }
      for (const [key, column] of Object.entries(state.fields)) {
        if (localizedFieldNames.has(key)) {
          localizedFields[key] = column;
        } else {
          mainFields[key] = column;
        }
      }
      if (state.options.timestamps !== false) {
        Object.assign(mainFields, Collection.timestampsCols());
      }
      state.validation = createGlobalValidationSchema(
        state.name,
        mainFields,
        localizedFields
      );
    }
    this.$infer = {};
  }
  getVirtuals(_context) {
    return this.state.virtuals;
  }
  getVirtualsForVersions(_context) {
    return this.state.virtuals;
  }
  /**
   * Generate CRUD operations
   */
  generateCRUD(db, cms2) {
    const crud = new GlobalCRUDGenerator(
      this.state,
      this.table,
      this.i18nTable,
      this.versionsTable,
      this.i18nVersionsTable,
      db,
      this.getVirtuals.bind(this),
      this.getVirtualsForVersions.bind(this),
      cms2
    );
    return crud.generate();
  }
  generateMainTable() {
    const tableName = this.state.name;
    const columns = {};
    const isScoped = !!this.state.options.scoped;
    const hasUserDefinedId = "id" in this.state.fields;
    if (!hasUserDefinedId) {
      columns.id = defaultIdColumn();
    }
    if (isScoped) {
      columns.scopeId = text("scope_id");
    }
    for (const [fieldName, column] of Object.entries(this.state.fields)) {
      if (this.state.localized.includes(fieldName)) continue;
      columns[fieldName] = column;
    }
    if (this.state.options.timestamps !== false) {
      Object.assign(columns, Collection.timestampsCols());
    }
    if (isScoped) {
      return pgTable(tableName, columns, (t2) => ({
        scopeIdx: uniqueIndex(`${tableName}_scope_idx`).on(t2.scopeId)
      }));
    }
    return pgTable(tableName, columns);
  }
  generateI18nTable() {
    if (this.state.localized.length === 0) return null;
    const tableName = `${this.state.name}_i18n`;
    const parentIdColumn = this.table.id;
    const columns = {
      id: text("id").primaryKey().default(sql$1`gen_random_uuid()`),
      parentId: cloneColumnType(parentIdColumn, "parent_id").notNull().references(() => this.table.id, { onDelete: "cascade" }),
      locale: text("locale").notNull()
    };
    for (const fieldName of this.state.localized) {
      const column = this.state.fields[fieldName];
      if (column) {
        columns[fieldName] = column;
      }
    }
    return pgTable(tableName, columns, (t2) => ({
      parentLocaleIdx: uniqueIndex().on(t2.parentId, t2.locale)
    }));
  }
  generateVersionsTable() {
    const versioning = this.state.options.versioning;
    if (!versioning) return null;
    if (typeof versioning === "object" && !versioning.enabled) return null;
    const tableName = `${this.state.name}_versions`;
    const isScoped = !!this.state.options.scoped;
    const parentIdColumn = this.table.id;
    const columns = {
      versionId: text("version_id").primaryKey().default(sql$1`gen_random_uuid()`),
      id: cloneColumnType(parentIdColumn, "id").notNull(),
      versionNumber: integer("version_number").notNull(),
      versionOperation: text("version_operation").notNull(),
      versionUserId: text("version_user_id"),
      versionCreatedAt: timestamp("version_created_at", { mode: "date" }).defaultNow().notNull()
    };
    if (isScoped) {
      columns.scopeId = text("scope_id");
    }
    for (const [fieldName, column] of Object.entries(this.state.fields)) {
      if (this.state.localized.includes(fieldName)) continue;
      if (fieldName === "id") continue;
      columns[fieldName] = column;
    }
    if (this.state.options.timestamps !== false) {
      Object.assign(columns, Collection.timestampsCols());
    }
    return pgTable(tableName, columns, (t2) => ({
      recordVersionIdx: index$2().on(t2.id, t2.versionNumber),
      versionCreatedAtIdx: index$2().on(t2.versionCreatedAt)
    }));
  }
  generateI18nVersionsTable() {
    const versioning = this.state.options.versioning;
    if (!versioning) return null;
    if (typeof versioning === "object" && !versioning.enabled) return null;
    if (this.state.localized.length === 0) return null;
    const tableName = `${this.state.name}_i18n_versions`;
    const parentIdColumn = this.table.id;
    const columns = {
      id: text("id").primaryKey().default(sql$1`gen_random_uuid()`),
      parentId: cloneColumnType(parentIdColumn, "parent_id").notNull(),
      versionNumber: integer("version_number").notNull(),
      locale: text("locale").notNull()
    };
    for (const fieldName of this.state.localized) {
      const column = this.state.fields[fieldName];
      if (column) {
        columns[fieldName] = column;
      }
    }
    return pgTable(tableName, columns, (t2) => ({
      parentVersionLocaleIdx: uniqueIndex().on(
        t2.parentId,
        t2.versionNumber,
        t2.locale
      ),
      parentVersionIdx: index$2().on(t2.parentId, t2.versionNumber)
    }));
  }
  createI18nAccessor(context) {
    const accessor = {};
    const defaultLocale2 = context?.defaultLocale || DEFAULT_LOCALE;
    if (!this.i18nTable) return accessor;
    for (const fieldName of this.state.localized) {
      const i18nTable = this.i18nTable;
      if (context?.localeFallback === false) {
        accessor[fieldName] = i18nTable[fieldName];
      } else {
        accessor[fieldName] = sql$1`COALESCE(
					${i18nTable[fieldName]},
					(SELECT ${i18nTable[fieldName]} FROM ${this.i18nTable}
					 WHERE ${i18nTable.parentId} = ${this.table.id}
					 AND ${i18nTable.locale} = ${defaultLocale2} LIMIT 1)
				)`;
      }
    }
    return accessor;
  }
  createI18nAccessorForVersions(table, i18nTable, context) {
    const accessor = {};
    const defaultLocale2 = context?.defaultLocale || DEFAULT_LOCALE;
    if (!i18nTable) return accessor;
    for (const fieldName of this.state.localized) {
      const i18nRef = i18nTable;
      if (context?.localeFallback === false) {
        accessor[fieldName] = i18nRef[fieldName];
      } else {
        accessor[fieldName] = sql$1`COALESCE(
					${i18nRef[fieldName]},
					(SELECT ${i18nRef[fieldName]} FROM ${i18nTable}
					 WHERE ${i18nRef.parentId} = ${table.id}
					 AND ${i18nRef.versionNumber} = ${table.versionNumber}
					 AND ${i18nRef.locale} = ${defaultLocale2} LIMIT 1)
				)`;
      }
    }
    return accessor;
  }
  getMeta() {
    return {
      name: this.state.name,
      fields: Object.entries(this.state.fields).map(([name2, column]) => ({
        name: name2,
        column,
        localized: this.state.localized.includes(name2),
        virtual: name2 in this.state.virtuals
      })),
      isGlobal: true,
      timestamps: this.state.options.timestamps !== false,
      virtualFields: Object.keys(this.state.virtuals),
      localizedFields: Array.from(this.state.localized),
      relations: Object.keys(this.state.relations)
    };
  }
}
class GlobalBuilder {
  state;
  _builtGlobal;
  constructor(state) {
    this.state = state;
  }
  // Implementation
  fields(fieldsOrFactory) {
    let columns;
    let virtuals = {};
    let fieldDefinitions;
    const pendingRelations = [];
    const localizedFields = [];
    if (typeof fieldsOrFactory === "function") {
      const questpieFields = this.state["~questpieApp"]?.state?.fields ?? builtinFields;
      const builderProxy = createFieldBuilder(questpieFields);
      const fieldDefs = fieldsOrFactory(builderProxy);
      fieldDefinitions = fieldDefs;
      columns = {};
      for (const [name2, fieldDef] of Object.entries(fieldDefs)) {
        if (fieldDef.state?.location === "i18n") {
          localizedFields.push(name2);
        }
        if (fieldDef.state?.location === "virtual") {
          const virtualValue = fieldDef.state.config?.virtual;
          if (virtualValue && virtualValue !== true) {
            virtuals[name2] = virtualValue;
          }
        }
        const metadata = fieldDef.getMetadata?.();
        if (metadata?.type === "relation") {
          pendingRelations.push({
            name: name2,
            metadata
          });
        }
        const column = fieldDef.toColumn(name2);
        if (column !== null) {
          if (Array.isArray(column)) {
            for (const col of column) {
              const colName = col.name ?? `${name2}_${Object.keys(columns).length}`;
              columns[colName] = col;
            }
          } else {
            columns[name2] = column;
          }
        }
      }
      virtuals = {
        ...this.state.virtuals || {},
        ...virtuals
      };
    } else {
      columns = fieldsOrFactory;
      virtuals = this.state.virtuals || {};
      fieldDefinitions = void 0;
    }
    const newState = {
      ...this.state,
      fields: columns,
      localized: localizedFields,
      virtuals,
      fieldDefinitions,
      _pendingRelations: pendingRelations
    };
    const newBuilder = new GlobalBuilder(newState);
    return newBuilder;
  }
  /**
   * Set global options
   */
  options(options) {
    const newState = {
      ...this.state,
      options
    };
    const newBuilder = new GlobalBuilder(newState);
    return newBuilder;
  }
  /**
   * Set lifecycle hooks
   */
  hooks(hooks) {
    const newState = {
      ...this.state,
      hooks
    };
    const newBuilder = new GlobalBuilder(newState);
    return newBuilder;
  }
  /**
   * Set access control rules
   */
  access(access) {
    const newState = {
      ...this.state,
      access
    };
    const newBuilder = new GlobalBuilder(newState);
    return newBuilder;
  }
  /**
   * Define RPC functions for this global
   */
  functions(functions) {
    const newState = {
      ...this.state,
      functions: {
        ...this.state.functions,
        ...functions
      }
    };
    const newBuilder = new GlobalBuilder(newState);
    return newBuilder;
  }
  /**
   * Convert RelationFieldMetadata to RelationConfig for CRUD operations.
   * Similar to collection builder's convertRelationMetadataToConfig.
   */
  convertRelationMetadataToConfig(fieldName, metadata, columns) {
    const { relationType, foreignKey, _toConfig, _throughConfig } = metadata;
    let { targetCollection, through } = metadata;
    if (targetCollection === "__unresolved__" && _toConfig) {
      if (typeof _toConfig === "function") {
        targetCollection = _toConfig().name;
      }
    }
    if (through === "__unresolved__" && _throughConfig) {
      through = _throughConfig().name;
    }
    const targetName = Array.isArray(targetCollection) ? targetCollection[0] : targetCollection;
    switch (relationType) {
      case "belongsTo": {
        const fkColumnName = fieldName;
        return {
          type: "one",
          collection: targetName,
          fields: columns[fkColumnName] ? [columns[fkColumnName]] : void 0,
          references: ["id"],
          relationName: metadata.relationName,
          onDelete: metadata.onDelete,
          onUpdate: metadata.onUpdate
        };
      }
      case "hasMany": {
        return {
          type: "many",
          collection: targetName,
          references: ["id"],
          relationName: metadata.relationName,
          onDelete: metadata.onDelete,
          onUpdate: metadata.onUpdate
        };
      }
      case "manyToMany": {
        return {
          type: "manyToMany",
          collection: targetName,
          references: ["id"],
          through,
          sourceField: metadata.sourceField,
          targetField: metadata.targetField,
          onDelete: metadata.onDelete,
          onUpdate: metadata.onUpdate
        };
      }
      default:
        return null;
    }
  }
  /**
   * Resolve pending relation metadata to RelationConfig.
   */
  resolvePendingRelations() {
    const pendingRelations = this.state._pendingRelations;
    if (!pendingRelations || pendingRelations.length === 0) {
      return this.state;
    }
    const columns = this.state.fields;
    const resolvedRelations = {
      ...this.state.relations
    };
    for (const { name: name2, metadata } of pendingRelations) {
      const relationConfig = this.convertRelationMetadataToConfig(
        name2,
        metadata,
        columns
      );
      if (relationConfig) {
        resolvedRelations[name2] = relationConfig;
      }
    }
    return {
      ...this.state,
      relations: resolvedRelations
    };
  }
  /**
   * Build the final global
   */
  build() {
    if (!this._builtGlobal) {
      const resolvedState = this.resolvePendingRelations();
      this._builtGlobal = new Global(resolvedState);
    }
    return this._builtGlobal;
  }
  /**
   * Lazy build getters
   */
  get table() {
    return this.build().table;
  }
  get i18nTable() {
    return this.build().i18nTable;
  }
  get versionsTable() {
    return this.build().versionsTable;
  }
  get i18nVersionsTable() {
    return this.build().i18nVersionsTable;
  }
  get name() {
    return this.state.name;
  }
  get $infer() {
    return this.build().$infer;
  }
}
const validationMessagesEN = {
  // General
  "validation.required": "This field is required",
  "validation.invalidType": "Expected {{expected}}, received {{received}}",
  "validation.custom": "{{message}}",
  // String
  "validation.string.min": "Must be at least {{min}} characters",
  "validation.string.max": "Must be at most {{max}} characters",
  "validation.string.length": "Must be exactly {{length}} characters",
  "validation.string.email": "Invalid email address",
  "validation.string.url": "Invalid URL",
  "validation.string.uuid": "Invalid UUID",
  "validation.string.regex": "Invalid format",
  "validation.string.startsWith": "Must start with {{prefix}}",
  "validation.string.endsWith": "Must end with {{suffix}}",
  "validation.string.includes": "Must include {{substring}}",
  "validation.string.datetime": "Invalid date/time format",
  "validation.string.ip": "Invalid IP address",
  "validation.string.base64": "Invalid base64 string",
  // Number
  "validation.number.min": "Must be at least {{min}}",
  "validation.number.max": "Must be at most {{max}}",
  "validation.number.int": "Must be an integer",
  "validation.number.positive": "Must be a positive number",
  "validation.number.negative": "Must be a negative number",
  "validation.number.nonpositive": "Must be zero or negative",
  "validation.number.nonnegative": "Must be zero or positive",
  "validation.number.multipleOf": "Must be a multiple of {{value}}",
  "validation.number.finite": "Must be a finite number",
  // Array
  "validation.array.min": {
    one: "Must have at least {{min}} item",
    other: "Must have at least {{min}} items"
  },
  "validation.array.max": {
    one: "Must have at most {{max}} item",
    other: "Must have at most {{max}} items"
  },
  "validation.array.length": {
    one: "Must have exactly {{length}} item",
    other: "Must have exactly {{length}} items"
  },
  "validation.array.nonempty": "Must have at least one item",
  // Date
  "validation.date.invalid": "Invalid date",
  "validation.date.min": "Date must be after {{min}}",
  "validation.date.max": "Date must be before {{max}}",
  "validation.time.invalid": "Invalid time format",
  // Other
  "validation.boolean.invalid": "Must be true or false",
  "validation.object.invalid": "Invalid object",
  "validation.object.unrecognizedKeys": "Unrecognized keys: {{keys}}",
  "validation.enum.invalid": "Invalid option. Expected one of: {{options}}",
  "validation.union.invalid": "Invalid input",
  "validation.file.tooLarge": "File must be smaller than {{max}}",
  "validation.file.invalidType": "Invalid file type. Allowed: {{types}}"
};
const en$1 = {
  // General errors
  "error.notFound": "Resource not found",
  "error.notFound.withId": "{{resource}} not found: {{id}}",
  "error.forbidden": "Access denied",
  "error.unauthorized": "Authentication required",
  "error.validation": "Validation failed",
  "error.internal": "Internal server error",
  "error.badRequest": "Bad request",
  "error.conflict": "Resource conflict",
  "error.notImplemented": "{{feature}} is not implemented",
  "error.timeout": "Request timeout",
  // CRUD errors
  "crud.create.forbidden": "You don't have permission to create {{resource}}",
  "crud.read.forbidden": "You don't have permission to read {{resource}}",
  "crud.update.forbidden": "You don't have permission to update {{resource}}",
  "crud.delete.forbidden": "You don't have permission to delete {{resource}}",
  "crud.notFound": "{{resource}} not found",
  // Auth errors
  "auth.invalidCredentials": "Invalid email or password",
  "auth.sessionExpired": "Your session has expired",
  "auth.tokenInvalid": "Invalid token",
  "auth.tokenExpired": "Token has expired",
  "auth.accountLocked": "Account is locked",
  "auth.emailNotVerified": "Email not verified",
  "auth.userNotFound": "User not found",
  "auth.userAlreadyExists": "User already exists",
  // Upload errors
  "upload.tooLarge": "File exceeds maximum size of {{maxSize}}",
  "upload.invalidType": "File type {{type}} is not allowed",
  "upload.failed": "File upload failed",
  // Hook errors
  "hook.beforeCreate.failed": "Pre-create validation failed",
  "hook.afterCreate.failed": "Post-create processing failed",
  "hook.beforeUpdate.failed": "Pre-update validation failed",
  "hook.afterUpdate.failed": "Post-update processing failed",
  "hook.beforeDelete.failed": "Pre-delete validation failed",
  "hook.afterDelete.failed": "Post-delete processing failed",
  "hook.validate.failed": "Custom validation failed",
  // Access errors
  "access.denied": "Access denied",
  "access.fieldDenied": "Access denied to field {{field}}",
  "access.operationDenied": "Operation {{operation}} is not allowed",
  // Database errors
  "error.database.uniqueViolation": "Duplicate {{field}}: {{value}}",
  "error.database.foreignKeyViolation": "Invalid {{field}}: referenced record does not exist",
  "error.database.notNullViolation": "{{field}} is required",
  "error.database.checkViolation": "Invalid value for {{field}}"
};
const messages$2 = {
  en: en$1
};
function convertValidationMessages(msgs) {
  const result2 = {};
  for (const [key, value] of Object.entries(msgs)) {
    if (typeof value === "string") {
      result2[key] = value;
    } else {
      result2[key] = {
        one: value.one,
        other: value.other,
        zero: value.zero,
        few: value.few,
        many: value.many
      };
    }
  }
  return result2;
}
const allBackendMessagesEN = {
  // Shared validation messages (from questpie/shared)
  ...convertValidationMessages(validationMessagesEN),
  // Backend-specific messages
  ...messages$2.en
};
const pluralRulesCache = /* @__PURE__ */ new Map();
function getPluralRules(locale) {
  let rules = pluralRulesCache.get(locale);
  if (!rules) {
    rules = new Intl.PluralRules(locale);
    pluralRulesCache.set(locale, rules);
  }
  return rules;
}
function isPluralMessages(value) {
  return typeof value === "object" && value !== null && "one" in value && "other" in value;
}
function getPluralForm(forms, count2, locale) {
  const rules = getPluralRules(locale);
  const category = rules.select(count2);
  switch (category) {
    case "zero":
      return forms.zero ?? forms.other;
    case "one":
      return forms.one;
    case "two":
      return forms.two ?? forms.other;
    case "few":
      return forms.few ?? forms.other;
    case "many":
      return forms.many ?? forms.other;
    default:
      return forms.other;
  }
}
function interpolate(str, params) {
  if (!params) return str;
  return str.replace(/\{\{(\w+)\}\}/g, (_, key) => {
    const value = params[key];
    return value !== void 0 ? String(value) : `{{${key}}}`;
  });
}
function createTranslator(config2) {
  const customMessages = config2?.messages ?? {};
  const fallbackLocale = config2?.fallbackLocale ?? DEFAULT_LOCALE;
  return (key, params, locale) => {
    const currentLocale = locale ?? fallbackLocale;
    let message2 = customMessages[currentLocale]?.[key];
    if (message2 === void 0) {
      message2 = allBackendMessagesEN[key];
    }
    if (message2 === void 0 && currentLocale !== fallbackLocale) {
      message2 = customMessages[fallbackLocale]?.[key];
    }
    if (message2 === void 0) {
      return key;
    }
    if (isPluralMessages(message2)) {
      const count2 = typeof params?.count === "number" ? params.count : 1;
      const form = getPluralForm(message2, count2, currentLocale);
      return interpolate(form, params);
    }
    return interpolate(message2, params);
  };
}
function mergeTranslationsConfig(base, override) {
  if (!base && !override) return void 0;
  if (!base) return override;
  if (!override) return base;
  const mergedMessages = {
    ...base.messages
  };
  for (const [locale, messages2] of Object.entries(override.messages)) {
    mergedMessages[locale] = {
      ...mergedMessages[locale] ?? {},
      ...messages2
    };
  }
  return {
    messages: mergedMessages,
    fallbackLocale: override.fallbackLocale ?? base.fallbackLocale
  };
}
function mergeMessagesIntoConfig(base, messages2, fallbackLocale) {
  const override = {
    messages: messages2,
    fallbackLocale
  };
  const merged = mergeTranslationsConfig(base, override);
  return merged ?? { messages: {}, fallbackLocale: DEFAULT_LOCALE };
}
class MemoryKVAdapter {
  store = /* @__PURE__ */ new Map();
  tagIndex = /* @__PURE__ */ new Map();
  async get(key) {
    const entry = this.store.get(key);
    if (!entry) return null;
    if (entry.expiresAt && Date.now() > entry.expiresAt) {
      this.store.delete(key);
      return null;
    }
    return entry.value;
  }
  async set(key, value, ttl) {
    const expiresAt = ttl ? Date.now() + ttl * 1e3 : void 0;
    this.store.set(key, { value, expiresAt });
  }
  async setWithTags(key, value, tags, ttl) {
    await this.set(key, value, ttl);
    for (const tag2 of tags) {
      if (!this.tagIndex.has(tag2)) {
        this.tagIndex.set(tag2, /* @__PURE__ */ new Set());
      }
      this.tagIndex.get(tag2).add(key);
    }
  }
  async invalidateByTag(tag2) {
    const keys = this.tagIndex.get(tag2);
    if (!keys) return;
    for (const key of keys) {
      this.store.delete(key);
    }
    this.tagIndex.delete(tag2);
  }
  async invalidateByTags(tags) {
    await Promise.all(tags.map((tag2) => this.invalidateByTag(tag2)));
  }
  async delete(key) {
    this.store.delete(key);
    for (const [tag2, keys] of this.tagIndex.entries()) {
      keys.delete(key);
      if (keys.size === 0) {
        this.tagIndex.delete(tag2);
      }
    }
  }
  async has(key) {
    const entry = this.store.get(key);
    if (!entry) return false;
    if (entry.expiresAt && Date.now() > entry.expiresAt) {
      this.store.delete(key);
      return false;
    }
    return true;
  }
  async clear() {
    this.store.clear();
    this.tagIndex.clear();
  }
}
class KVService {
  adapter;
  config;
  constructor(config2 = {}) {
    this.config = config2;
    this.adapter = config2.adapter || new MemoryKVAdapter();
  }
  async get(key) {
    return this.adapter.get(key);
  }
  async set(key, value, ttl) {
    return this.adapter.set(key, value, ttl ?? this.config.defaultTtl);
  }
  async delete(key) {
    return this.adapter.delete(key);
  }
  async has(key) {
    return this.adapter.has(key);
  }
  async clear() {
    return this.adapter.clear();
  }
}
var pino$1 = { exports: {} };
var errHelpers;
var hasRequiredErrHelpers;
function requireErrHelpers() {
  if (hasRequiredErrHelpers) return errHelpers;
  hasRequiredErrHelpers = 1;
  const isErrorLike = (err2) => {
    return err2 && typeof err2.message === "string";
  };
  const getErrorCause = (err2) => {
    if (!err2) return;
    const cause = err2.cause;
    if (typeof cause === "function") {
      const causeResult = err2.cause();
      return isErrorLike(causeResult) ? causeResult : void 0;
    } else {
      return isErrorLike(cause) ? cause : void 0;
    }
  };
  const _stackWithCauses = (err2, seen) => {
    if (!isErrorLike(err2)) return "";
    const stack = err2.stack || "";
    if (seen.has(err2)) {
      return stack + "\ncauses have become circular...";
    }
    const cause = getErrorCause(err2);
    if (cause) {
      seen.add(err2);
      return stack + "\ncaused by: " + _stackWithCauses(cause, seen);
    } else {
      return stack;
    }
  };
  const stackWithCauses = (err2) => _stackWithCauses(err2, /* @__PURE__ */ new Set());
  const _messageWithCauses = (err2, seen, skip) => {
    if (!isErrorLike(err2)) return "";
    const message2 = skip ? "" : err2.message || "";
    if (seen.has(err2)) {
      return message2 + ": ...";
    }
    const cause = getErrorCause(err2);
    if (cause) {
      seen.add(err2);
      const skipIfVErrorStyleCause = typeof err2.cause === "function";
      return message2 + (skipIfVErrorStyleCause ? "" : ": ") + _messageWithCauses(cause, seen, skipIfVErrorStyleCause);
    } else {
      return message2;
    }
  };
  const messageWithCauses = (err2) => _messageWithCauses(err2, /* @__PURE__ */ new Set());
  errHelpers = {
    isErrorLike,
    getErrorCause,
    stackWithCauses,
    messageWithCauses
  };
  return errHelpers;
}
var errProto;
var hasRequiredErrProto;
function requireErrProto() {
  if (hasRequiredErrProto) return errProto;
  hasRequiredErrProto = 1;
  const seen = /* @__PURE__ */ Symbol("circular-ref-tag");
  const rawSymbol = /* @__PURE__ */ Symbol("pino-raw-err-ref");
  const pinoErrProto = Object.create({}, {
    type: {
      enumerable: true,
      writable: true,
      value: void 0
    },
    message: {
      enumerable: true,
      writable: true,
      value: void 0
    },
    stack: {
      enumerable: true,
      writable: true,
      value: void 0
    },
    aggregateErrors: {
      enumerable: true,
      writable: true,
      value: void 0
    },
    raw: {
      enumerable: false,
      get: function() {
        return this[rawSymbol];
      },
      set: function(val) {
        this[rawSymbol] = val;
      }
    }
  });
  Object.defineProperty(pinoErrProto, rawSymbol, {
    writable: true,
    value: {}
  });
  errProto = {
    pinoErrProto,
    pinoErrorSymbols: {
      seen,
      rawSymbol
    }
  };
  return errProto;
}
var err;
var hasRequiredErr;
function requireErr() {
  if (hasRequiredErr) return err;
  hasRequiredErr = 1;
  err = errSerializer;
  const { messageWithCauses, stackWithCauses, isErrorLike } = requireErrHelpers();
  const { pinoErrProto, pinoErrorSymbols } = requireErrProto();
  const { seen } = pinoErrorSymbols;
  const { toString } = Object.prototype;
  function errSerializer(err2) {
    if (!isErrorLike(err2)) {
      return err2;
    }
    err2[seen] = void 0;
    const _err = Object.create(pinoErrProto);
    _err.type = toString.call(err2.constructor) === "[object Function]" ? err2.constructor.name : err2.name;
    _err.message = messageWithCauses(err2);
    _err.stack = stackWithCauses(err2);
    if (Array.isArray(err2.errors)) {
      _err.aggregateErrors = err2.errors.map((err3) => errSerializer(err3));
    }
    for (const key in err2) {
      if (_err[key] === void 0) {
        const val = err2[key];
        if (isErrorLike(val)) {
          if (key !== "cause" && !Object.prototype.hasOwnProperty.call(val, seen)) {
            _err[key] = errSerializer(val);
          }
        } else {
          _err[key] = val;
        }
      }
    }
    delete err2[seen];
    _err.raw = err2;
    return _err;
  }
  return err;
}
var errWithCause;
var hasRequiredErrWithCause;
function requireErrWithCause() {
  if (hasRequiredErrWithCause) return errWithCause;
  hasRequiredErrWithCause = 1;
  errWithCause = errWithCauseSerializer;
  const { isErrorLike } = requireErrHelpers();
  const { pinoErrProto, pinoErrorSymbols } = requireErrProto();
  const { seen } = pinoErrorSymbols;
  const { toString } = Object.prototype;
  function errWithCauseSerializer(err2) {
    if (!isErrorLike(err2)) {
      return err2;
    }
    err2[seen] = void 0;
    const _err = Object.create(pinoErrProto);
    _err.type = toString.call(err2.constructor) === "[object Function]" ? err2.constructor.name : err2.name;
    _err.message = err2.message;
    _err.stack = err2.stack;
    if (Array.isArray(err2.errors)) {
      _err.aggregateErrors = err2.errors.map((err3) => errWithCauseSerializer(err3));
    }
    if (isErrorLike(err2.cause) && !Object.prototype.hasOwnProperty.call(err2.cause, seen)) {
      _err.cause = errWithCauseSerializer(err2.cause);
    }
    for (const key in err2) {
      if (_err[key] === void 0) {
        const val = err2[key];
        if (isErrorLike(val)) {
          if (!Object.prototype.hasOwnProperty.call(val, seen)) {
            _err[key] = errWithCauseSerializer(val);
          }
        } else {
          _err[key] = val;
        }
      }
    }
    delete err2[seen];
    _err.raw = err2;
    return _err;
  }
  return errWithCause;
}
var req;
var hasRequiredReq;
function requireReq() {
  if (hasRequiredReq) return req;
  hasRequiredReq = 1;
  req = {
    mapHttpRequest,
    reqSerializer
  };
  const rawSymbol = /* @__PURE__ */ Symbol("pino-raw-req-ref");
  const pinoReqProto = Object.create({}, {
    id: {
      enumerable: true,
      writable: true,
      value: ""
    },
    method: {
      enumerable: true,
      writable: true,
      value: ""
    },
    url: {
      enumerable: true,
      writable: true,
      value: ""
    },
    query: {
      enumerable: true,
      writable: true,
      value: ""
    },
    params: {
      enumerable: true,
      writable: true,
      value: ""
    },
    headers: {
      enumerable: true,
      writable: true,
      value: {}
    },
    remoteAddress: {
      enumerable: true,
      writable: true,
      value: ""
    },
    remotePort: {
      enumerable: true,
      writable: true,
      value: ""
    },
    raw: {
      enumerable: false,
      get: function() {
        return this[rawSymbol];
      },
      set: function(val) {
        this[rawSymbol] = val;
      }
    }
  });
  Object.defineProperty(pinoReqProto, rawSymbol, {
    writable: true,
    value: {}
  });
  function reqSerializer(req2) {
    const connection2 = req2.info || req2.socket;
    const _req = Object.create(pinoReqProto);
    _req.id = typeof req2.id === "function" ? req2.id() : req2.id || (req2.info ? req2.info.id : void 0);
    _req.method = req2.method;
    if (req2.originalUrl) {
      _req.url = req2.originalUrl;
    } else {
      const path = req2.path;
      _req.url = typeof path === "string" ? path : req2.url ? req2.url.path || req2.url : void 0;
    }
    if (req2.query) {
      _req.query = req2.query;
    }
    if (req2.params) {
      _req.params = req2.params;
    }
    _req.headers = req2.headers;
    _req.remoteAddress = connection2 && connection2.remoteAddress;
    _req.remotePort = connection2 && connection2.remotePort;
    _req.raw = req2.raw || req2;
    return _req;
  }
  function mapHttpRequest(req2) {
    return {
      req: reqSerializer(req2)
    };
  }
  return req;
}
var res;
var hasRequiredRes;
function requireRes() {
  if (hasRequiredRes) return res;
  hasRequiredRes = 1;
  res = {
    mapHttpResponse,
    resSerializer
  };
  const rawSymbol = /* @__PURE__ */ Symbol("pino-raw-res-ref");
  const pinoResProto = Object.create({}, {
    statusCode: {
      enumerable: true,
      writable: true,
      value: 0
    },
    headers: {
      enumerable: true,
      writable: true,
      value: ""
    },
    raw: {
      enumerable: false,
      get: function() {
        return this[rawSymbol];
      },
      set: function(val) {
        this[rawSymbol] = val;
      }
    }
  });
  Object.defineProperty(pinoResProto, rawSymbol, {
    writable: true,
    value: {}
  });
  function resSerializer(res2) {
    const _res = Object.create(pinoResProto);
    _res.statusCode = res2.headersSent ? res2.statusCode : null;
    _res.headers = res2.getHeaders ? res2.getHeaders() : res2._headers;
    _res.raw = res2;
    return _res;
  }
  function mapHttpResponse(res2) {
    return {
      res: resSerializer(res2)
    };
  }
  return res;
}
var pinoStdSerializers;
var hasRequiredPinoStdSerializers;
function requirePinoStdSerializers() {
  if (hasRequiredPinoStdSerializers) return pinoStdSerializers;
  hasRequiredPinoStdSerializers = 1;
  const errSerializer = requireErr();
  const errWithCauseSerializer = requireErrWithCause();
  const reqSerializers = requireReq();
  const resSerializers = requireRes();
  pinoStdSerializers = {
    err: errSerializer,
    errWithCause: errWithCauseSerializer,
    mapHttpRequest: reqSerializers.mapHttpRequest,
    mapHttpResponse: resSerializers.mapHttpResponse,
    req: reqSerializers.reqSerializer,
    res: resSerializers.resSerializer,
    wrapErrorSerializer: function wrapErrorSerializer(customSerializer) {
      if (customSerializer === errSerializer) return customSerializer;
      return function wrapErrSerializer(err2) {
        return customSerializer(errSerializer(err2));
      };
    },
    wrapRequestSerializer: function wrapRequestSerializer(customSerializer) {
      if (customSerializer === reqSerializers.reqSerializer) return customSerializer;
      return function wrappedReqSerializer(req2) {
        return customSerializer(reqSerializers.reqSerializer(req2));
      };
    },
    wrapResponseSerializer: function wrapResponseSerializer(customSerializer) {
      if (customSerializer === resSerializers.resSerializer) return customSerializer;
      return function wrappedResSerializer(res2) {
        return customSerializer(resSerializers.resSerializer(res2));
      };
    }
  };
  return pinoStdSerializers;
}
var caller;
var hasRequiredCaller;
function requireCaller() {
  if (hasRequiredCaller) return caller;
  hasRequiredCaller = 1;
  function noOpPrepareStackTrace(_, stack) {
    return stack;
  }
  caller = function getCallers() {
    const originalPrepare = Error.prepareStackTrace;
    Error.prepareStackTrace = noOpPrepareStackTrace;
    const stack = new Error().stack;
    Error.prepareStackTrace = originalPrepare;
    if (!Array.isArray(stack)) {
      return void 0;
    }
    const entries = stack.slice(2);
    const fileNames = [];
    for (const entry of entries) {
      if (!entry) {
        continue;
      }
      fileNames.push(entry.getFileName());
    }
    return fileNames;
  };
  return caller;
}
var redact;
var hasRequiredRedact;
function requireRedact() {
  if (hasRequiredRedact) return redact;
  hasRequiredRedact = 1;
  function deepClone(obj) {
    if (obj === null || typeof obj !== "object") {
      return obj;
    }
    if (obj instanceof Date) {
      return new Date(obj.getTime());
    }
    if (obj instanceof Array) {
      const cloned = [];
      for (let i = 0; i < obj.length; i++) {
        cloned[i] = deepClone(obj[i]);
      }
      return cloned;
    }
    if (typeof obj === "object") {
      const cloned = Object.create(Object.getPrototypeOf(obj));
      for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          cloned[key] = deepClone(obj[key]);
        }
      }
      return cloned;
    }
    return obj;
  }
  function parsePath2(path) {
    const parts = [];
    let current = "";
    let inBrackets = false;
    let inQuotes = false;
    let quoteChar = "";
    for (let i = 0; i < path.length; i++) {
      const char2 = path[i];
      if (!inBrackets && char2 === ".") {
        if (current) {
          parts.push(current);
          current = "";
        }
      } else if (char2 === "[") {
        if (current) {
          parts.push(current);
          current = "";
        }
        inBrackets = true;
      } else if (char2 === "]" && inBrackets) {
        parts.push(current);
        current = "";
        inBrackets = false;
        inQuotes = false;
      } else if ((char2 === '"' || char2 === "'") && inBrackets) {
        if (!inQuotes) {
          inQuotes = true;
          quoteChar = char2;
        } else if (char2 === quoteChar) {
          inQuotes = false;
          quoteChar = "";
        } else {
          current += char2;
        }
      } else {
        current += char2;
      }
    }
    if (current) {
      parts.push(current);
    }
    return parts;
  }
  function setValue(obj, parts, value) {
    let current = obj;
    for (let i = 0; i < parts.length - 1; i++) {
      const key = parts[i];
      if (typeof current !== "object" || current === null || !(key in current)) {
        return false;
      }
      if (typeof current[key] !== "object" || current[key] === null) {
        return false;
      }
      current = current[key];
    }
    const lastKey = parts[parts.length - 1];
    if (lastKey === "*") {
      if (Array.isArray(current)) {
        for (let i = 0; i < current.length; i++) {
          current[i] = value;
        }
      } else if (typeof current === "object" && current !== null) {
        for (const key in current) {
          if (Object.prototype.hasOwnProperty.call(current, key)) {
            current[key] = value;
          }
        }
      }
    } else {
      if (typeof current === "object" && current !== null && lastKey in current && Object.prototype.hasOwnProperty.call(current, lastKey)) {
        current[lastKey] = value;
      }
    }
    return true;
  }
  function removeKey(obj, parts) {
    let current = obj;
    for (let i = 0; i < parts.length - 1; i++) {
      const key = parts[i];
      if (typeof current !== "object" || current === null || !(key in current)) {
        return false;
      }
      if (typeof current[key] !== "object" || current[key] === null) {
        return false;
      }
      current = current[key];
    }
    const lastKey = parts[parts.length - 1];
    if (lastKey === "*") {
      if (Array.isArray(current)) {
        for (let i = 0; i < current.length; i++) {
          current[i] = void 0;
        }
      } else if (typeof current === "object" && current !== null) {
        for (const key in current) {
          if (Object.prototype.hasOwnProperty.call(current, key)) {
            delete current[key];
          }
        }
      }
    } else {
      if (typeof current === "object" && current !== null && lastKey in current && Object.prototype.hasOwnProperty.call(current, lastKey)) {
        delete current[lastKey];
      }
    }
    return true;
  }
  const PATH_NOT_FOUND = /* @__PURE__ */ Symbol("PATH_NOT_FOUND");
  function getValueIfExists(obj, parts) {
    let current = obj;
    for (const part of parts) {
      if (current === null || current === void 0) {
        return PATH_NOT_FOUND;
      }
      if (typeof current !== "object" || current === null) {
        return PATH_NOT_FOUND;
      }
      if (!(part in current)) {
        return PATH_NOT_FOUND;
      }
      current = current[part];
    }
    return current;
  }
  function getValue(obj, parts) {
    let current = obj;
    for (const part of parts) {
      if (current === null || current === void 0) {
        return void 0;
      }
      if (typeof current !== "object" || current === null) {
        return void 0;
      }
      current = current[part];
    }
    return current;
  }
  function redactPaths(obj, paths2, censor, remove = false) {
    for (const path of paths2) {
      const parts = parsePath2(path);
      if (parts.includes("*")) {
        redactWildcardPath(obj, parts, censor, path, remove);
      } else {
        if (remove) {
          removeKey(obj, parts);
        } else {
          const value = getValueIfExists(obj, parts);
          if (value === PATH_NOT_FOUND) {
            continue;
          }
          const actualCensor = typeof censor === "function" ? censor(value, parts) : censor;
          setValue(obj, parts, actualCensor);
        }
      }
    }
  }
  function redactWildcardPath(obj, parts, censor, originalPath, remove = false) {
    const wildcardIndex = parts.indexOf("*");
    if (wildcardIndex === parts.length - 1) {
      const parentParts = parts.slice(0, -1);
      let current = obj;
      for (const part of parentParts) {
        if (current === null || current === void 0) return;
        if (typeof current !== "object" || current === null) return;
        current = current[part];
      }
      if (Array.isArray(current)) {
        if (remove) {
          for (let i = 0; i < current.length; i++) {
            current[i] = void 0;
          }
        } else {
          for (let i = 0; i < current.length; i++) {
            const indexPath = [...parentParts, i.toString()];
            const actualCensor = typeof censor === "function" ? censor(current[i], indexPath) : censor;
            current[i] = actualCensor;
          }
        }
      } else if (typeof current === "object" && current !== null) {
        if (remove) {
          const keysToDelete = [];
          for (const key in current) {
            if (Object.prototype.hasOwnProperty.call(current, key)) {
              keysToDelete.push(key);
            }
          }
          for (const key of keysToDelete) {
            delete current[key];
          }
        } else {
          for (const key in current) {
            const keyPath = [...parentParts, key];
            const actualCensor = typeof censor === "function" ? censor(current[key], keyPath) : censor;
            current[key] = actualCensor;
          }
        }
      }
    } else {
      redactIntermediateWildcard(obj, parts, censor, wildcardIndex, originalPath, remove);
    }
  }
  function redactIntermediateWildcard(obj, parts, censor, wildcardIndex, originalPath, remove = false) {
    const beforeWildcard = parts.slice(0, wildcardIndex);
    const afterWildcard = parts.slice(wildcardIndex + 1);
    const pathArray = [];
    function traverse2(current, pathLength) {
      if (pathLength === beforeWildcard.length) {
        if (Array.isArray(current)) {
          for (let i = 0; i < current.length; i++) {
            pathArray[pathLength] = i.toString();
            traverse2(current[i], pathLength + 1);
          }
        } else if (typeof current === "object" && current !== null) {
          for (const key in current) {
            pathArray[pathLength] = key;
            traverse2(current[key], pathLength + 1);
          }
        }
      } else if (pathLength < beforeWildcard.length) {
        const nextKey = beforeWildcard[pathLength];
        if (current && typeof current === "object" && current !== null && nextKey in current) {
          pathArray[pathLength] = nextKey;
          traverse2(current[nextKey], pathLength + 1);
        }
      } else {
        if (afterWildcard.includes("*")) {
          const wrappedCensor = typeof censor === "function" ? (value, path) => {
            const fullPath = [...pathArray.slice(0, pathLength), ...path];
            return censor(value, fullPath);
          } : censor;
          redactWildcardPath(current, afterWildcard, wrappedCensor, originalPath, remove);
        } else {
          if (remove) {
            removeKey(current, afterWildcard);
          } else {
            const actualCensor = typeof censor === "function" ? censor(getValue(current, afterWildcard), [...pathArray.slice(0, pathLength), ...afterWildcard]) : censor;
            setValue(current, afterWildcard, actualCensor);
          }
        }
      }
    }
    if (beforeWildcard.length === 0) {
      traverse2(obj, 0);
    } else {
      let current = obj;
      for (let i = 0; i < beforeWildcard.length; i++) {
        const part = beforeWildcard[i];
        if (current === null || current === void 0) return;
        if (typeof current !== "object" || current === null) return;
        current = current[part];
        pathArray[i] = part;
      }
      if (current !== null && current !== void 0) {
        traverse2(current, beforeWildcard.length);
      }
    }
  }
  function buildPathStructure(pathsToClone) {
    if (pathsToClone.length === 0) {
      return null;
    }
    const pathStructure = /* @__PURE__ */ new Map();
    for (const path of pathsToClone) {
      const parts = parsePath2(path);
      let current = pathStructure;
      for (let i = 0; i < parts.length; i++) {
        const part = parts[i];
        if (!current.has(part)) {
          current.set(part, /* @__PURE__ */ new Map());
        }
        current = current.get(part);
      }
    }
    return pathStructure;
  }
  function selectiveClone(obj, pathStructure) {
    if (!pathStructure) {
      return obj;
    }
    function cloneSelectively(source, pathMap, depth = 0) {
      if (!pathMap || pathMap.size === 0) {
        return source;
      }
      if (source === null || typeof source !== "object") {
        return source;
      }
      if (source instanceof Date) {
        return new Date(source.getTime());
      }
      if (Array.isArray(source)) {
        const cloned2 = [];
        for (let i = 0; i < source.length; i++) {
          const indexStr = i.toString();
          if (pathMap.has(indexStr) || pathMap.has("*")) {
            cloned2[i] = cloneSelectively(source[i], pathMap.get(indexStr) || pathMap.get("*"));
          } else {
            cloned2[i] = source[i];
          }
        }
        return cloned2;
      }
      const cloned = Object.create(Object.getPrototypeOf(source));
      for (const key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          if (pathMap.has(key) || pathMap.has("*")) {
            cloned[key] = cloneSelectively(source[key], pathMap.get(key) || pathMap.get("*"));
          } else {
            cloned[key] = source[key];
          }
        }
      }
      return cloned;
    }
    return cloneSelectively(obj, pathStructure);
  }
  function validatePath2(path) {
    if (typeof path !== "string") {
      throw new Error("Paths must be (non-empty) strings");
    }
    if (path === "") {
      throw new Error("Invalid redaction path ()");
    }
    if (path.includes("..")) {
      throw new Error(`Invalid redaction path (${path})`);
    }
    if (path.includes(",")) {
      throw new Error(`Invalid redaction path (${path})`);
    }
    let bracketCount = 0;
    let inQuotes = false;
    let quoteChar = "";
    for (let i = 0; i < path.length; i++) {
      const char2 = path[i];
      if ((char2 === '"' || char2 === "'") && bracketCount > 0) {
        if (!inQuotes) {
          inQuotes = true;
          quoteChar = char2;
        } else if (char2 === quoteChar) {
          inQuotes = false;
          quoteChar = "";
        }
      } else if (char2 === "[" && !inQuotes) {
        bracketCount++;
      } else if (char2 === "]" && !inQuotes) {
        bracketCount--;
        if (bracketCount < 0) {
          throw new Error(`Invalid redaction path (${path})`);
        }
      }
    }
    if (bracketCount !== 0) {
      throw new Error(`Invalid redaction path (${path})`);
    }
  }
  function validatePaths(paths2) {
    if (!Array.isArray(paths2)) {
      throw new TypeError("paths must be an array");
    }
    for (const path of paths2) {
      validatePath2(path);
    }
  }
  function slowRedact(options = {}) {
    const {
      paths: paths2 = [],
      censor = "[REDACTED]",
      serialize: serialize2 = JSON.stringify,
      strict = true,
      remove = false
    } = options;
    validatePaths(paths2);
    const pathStructure = buildPathStructure(paths2);
    return function redact2(obj) {
      if (strict && (obj === null || typeof obj !== "object")) {
        if (obj === null || obj === void 0) {
          return serialize2 ? serialize2(obj) : obj;
        }
        if (typeof obj !== "object") {
          return serialize2 ? serialize2(obj) : obj;
        }
      }
      const cloned = selectiveClone(obj, pathStructure);
      const original = obj;
      let actualCensor = censor;
      if (typeof censor === "function") {
        actualCensor = censor;
      }
      redactPaths(cloned, paths2, actualCensor, remove);
      if (serialize2 === false) {
        cloned.restore = function() {
          return deepClone(original);
        };
        return cloned;
      }
      if (typeof serialize2 === "function") {
        return serialize2(cloned);
      }
      return JSON.stringify(cloned);
    };
  }
  redact = slowRedact;
  return redact;
}
var symbols;
var hasRequiredSymbols;
function requireSymbols() {
  if (hasRequiredSymbols) return symbols;
  hasRequiredSymbols = 1;
  const setLevelSym = /* @__PURE__ */ Symbol("pino.setLevel");
  const getLevelSym = /* @__PURE__ */ Symbol("pino.getLevel");
  const levelValSym = /* @__PURE__ */ Symbol("pino.levelVal");
  const levelCompSym = /* @__PURE__ */ Symbol("pino.levelComp");
  const useLevelLabelsSym = /* @__PURE__ */ Symbol("pino.useLevelLabels");
  const useOnlyCustomLevelsSym = /* @__PURE__ */ Symbol("pino.useOnlyCustomLevels");
  const mixinSym = /* @__PURE__ */ Symbol("pino.mixin");
  const lsCacheSym = /* @__PURE__ */ Symbol("pino.lsCache");
  const chindingsSym = /* @__PURE__ */ Symbol("pino.chindings");
  const asJsonSym = /* @__PURE__ */ Symbol("pino.asJson");
  const writeSym = /* @__PURE__ */ Symbol("pino.write");
  const redactFmtSym = /* @__PURE__ */ Symbol("pino.redactFmt");
  const timeSym = /* @__PURE__ */ Symbol("pino.time");
  const timeSliceIndexSym = /* @__PURE__ */ Symbol("pino.timeSliceIndex");
  const streamSym = /* @__PURE__ */ Symbol("pino.stream");
  const stringifySym = /* @__PURE__ */ Symbol("pino.stringify");
  const stringifySafeSym = /* @__PURE__ */ Symbol("pino.stringifySafe");
  const stringifiersSym = /* @__PURE__ */ Symbol("pino.stringifiers");
  const endSym = /* @__PURE__ */ Symbol("pino.end");
  const formatOptsSym = /* @__PURE__ */ Symbol("pino.formatOpts");
  const messageKeySym = /* @__PURE__ */ Symbol("pino.messageKey");
  const errorKeySym = /* @__PURE__ */ Symbol("pino.errorKey");
  const nestedKeySym = /* @__PURE__ */ Symbol("pino.nestedKey");
  const nestedKeyStrSym = /* @__PURE__ */ Symbol("pino.nestedKeyStr");
  const mixinMergeStrategySym = /* @__PURE__ */ Symbol("pino.mixinMergeStrategy");
  const msgPrefixSym = /* @__PURE__ */ Symbol("pino.msgPrefix");
  const wildcardFirstSym = /* @__PURE__ */ Symbol("pino.wildcardFirst");
  const serializersSym = /* @__PURE__ */ Symbol.for("pino.serializers");
  const formattersSym = /* @__PURE__ */ Symbol.for("pino.formatters");
  const hooksSym = /* @__PURE__ */ Symbol.for("pino.hooks");
  const needsMetadataGsym = /* @__PURE__ */ Symbol.for("pino.metadata");
  symbols = {
    setLevelSym,
    getLevelSym,
    levelValSym,
    levelCompSym,
    useLevelLabelsSym,
    mixinSym,
    lsCacheSym,
    chindingsSym,
    asJsonSym,
    writeSym,
    serializersSym,
    redactFmtSym,
    timeSym,
    timeSliceIndexSym,
    streamSym,
    stringifySym,
    stringifySafeSym,
    stringifiersSym,
    endSym,
    formatOptsSym,
    messageKeySym,
    errorKeySym,
    nestedKeySym,
    wildcardFirstSym,
    needsMetadataGsym,
    useOnlyCustomLevelsSym,
    formattersSym,
    hooksSym,
    nestedKeyStrSym,
    mixinMergeStrategySym,
    msgPrefixSym
  };
  return symbols;
}
var redaction_1;
var hasRequiredRedaction;
function requireRedaction() {
  if (hasRequiredRedaction) return redaction_1;
  hasRequiredRedaction = 1;
  const Redact = requireRedact();
  const { redactFmtSym, wildcardFirstSym } = requireSymbols();
  const rx = /[^.[\]]+|\[([^[\]]*?)\]/g;
  const CENSOR = "[Redacted]";
  const strict = false;
  function redaction(opts, serialize2) {
    const { paths: paths2, censor, remove } = handle(opts);
    const shape = paths2.reduce((o2, str) => {
      rx.lastIndex = 0;
      const first = rx.exec(str);
      const next2 = rx.exec(str);
      let ns = first[1] !== void 0 ? first[1].replace(/^(?:"|'|`)(.*)(?:"|'|`)$/, "$1") : first[0];
      if (ns === "*") {
        ns = wildcardFirstSym;
      }
      if (next2 === null) {
        o2[ns] = null;
        return o2;
      }
      if (o2[ns] === null) {
        return o2;
      }
      const { index: index2 } = next2;
      const nextPath = `${str.substr(index2, str.length - 1)}`;
      o2[ns] = o2[ns] || [];
      if (ns !== wildcardFirstSym && o2[ns].length === 0) {
        o2[ns].push(...o2[wildcardFirstSym] || []);
      }
      if (ns === wildcardFirstSym) {
        Object.keys(o2).forEach(function(k) {
          if (o2[k]) {
            o2[k].push(nextPath);
          }
        });
      }
      o2[ns].push(nextPath);
      return o2;
    }, {});
    const result2 = {
      [redactFmtSym]: Redact({ paths: paths2, censor, serialize: serialize2, strict, remove })
    };
    const topCensor = (...args) => {
      return typeof censor === "function" ? serialize2(censor(...args)) : serialize2(censor);
    };
    return [...Object.keys(shape), ...Object.getOwnPropertySymbols(shape)].reduce((o2, k) => {
      if (shape[k] === null) {
        o2[k] = (value) => topCensor(value, [k]);
      } else {
        const wrappedCensor = typeof censor === "function" ? (value, path) => {
          return censor(value, [k, ...path]);
        } : censor;
        o2[k] = Redact({
          paths: shape[k],
          censor: wrappedCensor,
          serialize: serialize2,
          strict,
          remove
        });
      }
      return o2;
    }, result2);
  }
  function handle(opts) {
    if (Array.isArray(opts)) {
      opts = { paths: opts, censor: CENSOR };
      return opts;
    }
    let { paths: paths2, censor = CENSOR, remove } = opts;
    if (Array.isArray(paths2) === false) {
      throw Error("pino  redact must contain an array of strings");
    }
    if (remove === true) censor = void 0;
    return { paths: paths2, censor, remove };
  }
  redaction_1 = redaction;
  return redaction_1;
}
var time;
var hasRequiredTime;
function requireTime() {
  if (hasRequiredTime) return time;
  hasRequiredTime = 1;
  const nullTime = () => "";
  const epochTime = () => `,"time":${Date.now()}`;
  const unixTime = () => `,"time":${Math.round(Date.now() / 1e3)}`;
  const isoTime = () => `,"time":"${new Date(Date.now()).toISOString()}"`;
  const NS_PER_MS = 1000000n;
  const NS_PER_SEC = 1000000000n;
  const startWallTimeNs = BigInt(Date.now()) * NS_PER_MS;
  const startHrTime = process.hrtime.bigint();
  const isoTimeNano = () => {
    const elapsedNs = process.hrtime.bigint() - startHrTime;
    const currentTimeNs = startWallTimeNs + elapsedNs;
    const secondsSinceEpoch = currentTimeNs / NS_PER_SEC;
    const nanosWithinSecond = currentTimeNs % NS_PER_SEC;
    const msSinceEpoch = Number(secondsSinceEpoch * 1000n + nanosWithinSecond / 1000000n);
    const date2 = new Date(msSinceEpoch);
    const year2 = date2.getUTCFullYear();
    const month = (date2.getUTCMonth() + 1).toString().padStart(2, "0");
    const day2 = date2.getUTCDate().toString().padStart(2, "0");
    const hours = date2.getUTCHours().toString().padStart(2, "0");
    const minutes = date2.getUTCMinutes().toString().padStart(2, "0");
    const seconds = date2.getUTCSeconds().toString().padStart(2, "0");
    return `,"time":"${year2}-${month}-${day2}T${hours}:${minutes}:${seconds}.${nanosWithinSecond.toString().padStart(9, "0")}Z"`;
  };
  time = { nullTime, epochTime, unixTime, isoTime, isoTimeNano };
  return time;
}
var quickFormatUnescaped;
var hasRequiredQuickFormatUnescaped;
function requireQuickFormatUnescaped() {
  if (hasRequiredQuickFormatUnescaped) return quickFormatUnescaped;
  hasRequiredQuickFormatUnescaped = 1;
  function tryStringify(o2) {
    try {
      return JSON.stringify(o2);
    } catch (e2) {
      return '"[Circular]"';
    }
  }
  quickFormatUnescaped = format2;
  function format2(f, args, opts) {
    var ss = opts && opts.stringify || tryStringify;
    var offset2 = 1;
    if (typeof f === "object" && f !== null) {
      var len = args.length + offset2;
      if (len === 1) return f;
      var objects = new Array(len);
      objects[0] = ss(f);
      for (var index2 = 1; index2 < len; index2++) {
        objects[index2] = ss(args[index2]);
      }
      return objects.join(" ");
    }
    if (typeof f !== "string") {
      return f;
    }
    var argLen = args.length;
    if (argLen === 0) return f;
    var str = "";
    var a = 1 - offset2;
    var lastPos = -1;
    var flen = f && f.length || 0;
    for (var i = 0; i < flen; ) {
      if (f.charCodeAt(i) === 37 && i + 1 < flen) {
        lastPos = lastPos > -1 ? lastPos : 0;
        switch (f.charCodeAt(i + 1)) {
          case 100:
          // 'd'
          case 102:
            if (a >= argLen)
              break;
            if (args[a] == null) break;
            if (lastPos < i)
              str += f.slice(lastPos, i);
            str += Number(args[a]);
            lastPos = i + 2;
            i++;
            break;
          case 105:
            if (a >= argLen)
              break;
            if (args[a] == null) break;
            if (lastPos < i)
              str += f.slice(lastPos, i);
            str += Math.floor(Number(args[a]));
            lastPos = i + 2;
            i++;
            break;
          case 79:
          // 'O'
          case 111:
          // 'o'
          case 106:
            if (a >= argLen)
              break;
            if (args[a] === void 0) break;
            if (lastPos < i)
              str += f.slice(lastPos, i);
            var type2 = typeof args[a];
            if (type2 === "string") {
              str += "'" + args[a] + "'";
              lastPos = i + 2;
              i++;
              break;
            }
            if (type2 === "function") {
              str += args[a].name || "<anonymous>";
              lastPos = i + 2;
              i++;
              break;
            }
            str += ss(args[a]);
            lastPos = i + 2;
            i++;
            break;
          case 115:
            if (a >= argLen)
              break;
            if (lastPos < i)
              str += f.slice(lastPos, i);
            str += String(args[a]);
            lastPos = i + 2;
            i++;
            break;
          case 37:
            if (lastPos < i)
              str += f.slice(lastPos, i);
            str += "%";
            lastPos = i + 2;
            i++;
            a--;
            break;
        }
        ++a;
      }
      ++i;
    }
    if (lastPos === -1)
      return f;
    else if (lastPos < flen) {
      str += f.slice(lastPos);
    }
    return str;
  }
  return quickFormatUnescaped;
}
var atomicSleep = { exports: {} };
var hasRequiredAtomicSleep;
function requireAtomicSleep() {
  if (hasRequiredAtomicSleep) return atomicSleep.exports;
  hasRequiredAtomicSleep = 1;
  if (typeof SharedArrayBuffer !== "undefined" && typeof Atomics !== "undefined") {
    let sleep = function(ms2) {
      const valid = ms2 > 0 && ms2 < Infinity;
      if (valid === false) {
        if (typeof ms2 !== "number" && typeof ms2 !== "bigint") {
          throw TypeError("sleep: ms must be a number");
        }
        throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
      }
      Atomics.wait(nil, 0, 0, Number(ms2));
    };
    const nil = new Int32Array(new SharedArrayBuffer(4));
    atomicSleep.exports = sleep;
  } else {
    let sleep = function(ms2) {
      const valid = ms2 > 0 && ms2 < Infinity;
      if (valid === false) {
        if (typeof ms2 !== "number" && typeof ms2 !== "bigint") {
          throw TypeError("sleep: ms must be a number");
        }
        throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
      }
    };
    atomicSleep.exports = sleep;
  }
  return atomicSleep.exports;
}
var sonicBoom;
var hasRequiredSonicBoom;
function requireSonicBoom() {
  if (hasRequiredSonicBoom) return sonicBoom;
  hasRequiredSonicBoom = 1;
  const fs = require$$1$2;
  const EventEmitter2 = require$$0$7;
  const inherits = require$$1$1.inherits;
  const path = require$$0$6;
  const sleep = requireAtomicSleep();
  const assert2 = require$$5$1;
  const BUSY_WRITE_TIMEOUT = 100;
  const kEmptyBuffer = Buffer.allocUnsafe(0);
  const MAX_WRITE = 16 * 1024;
  const kContentModeBuffer = "buffer";
  const kContentModeUtf8 = "utf8";
  const [major, minor] = (process.versions.node || "0.0").split(".").map(Number);
  const kCopyBuffer = major >= 22 && minor >= 7;
  function openFile(file, sonic) {
    sonic._opening = true;
    sonic._writing = true;
    sonic._asyncDrainScheduled = false;
    function fileOpened(err2, fd) {
      if (err2) {
        sonic._reopening = false;
        sonic._writing = false;
        sonic._opening = false;
        if (sonic.sync) {
          process.nextTick(() => {
            if (sonic.listenerCount("error") > 0) {
              sonic.emit("error", err2);
            }
          });
        } else {
          sonic.emit("error", err2);
        }
        return;
      }
      const reopening = sonic._reopening;
      sonic.fd = fd;
      sonic.file = file;
      sonic._reopening = false;
      sonic._opening = false;
      sonic._writing = false;
      if (sonic.sync) {
        process.nextTick(() => sonic.emit("ready"));
      } else {
        sonic.emit("ready");
      }
      if (sonic.destroyed) {
        return;
      }
      if (!sonic._writing && sonic._len > sonic.minLength || sonic._flushPending) {
        sonic._actualWrite();
      } else if (reopening) {
        process.nextTick(() => sonic.emit("drain"));
      }
    }
    const flags = sonic.append ? "a" : "w";
    const mode = sonic.mode;
    if (sonic.sync) {
      try {
        if (sonic.mkdir) fs.mkdirSync(path.dirname(file), { recursive: true });
        const fd = fs.openSync(file, flags, mode);
        fileOpened(null, fd);
      } catch (err2) {
        fileOpened(err2);
        throw err2;
      }
    } else if (sonic.mkdir) {
      fs.mkdir(path.dirname(file), { recursive: true }, (err2) => {
        if (err2) return fileOpened(err2);
        fs.open(file, flags, mode, fileOpened);
      });
    } else {
      fs.open(file, flags, mode, fileOpened);
    }
  }
  function SonicBoom(opts) {
    if (!(this instanceof SonicBoom)) {
      return new SonicBoom(opts);
    }
    let { fd, dest, minLength, maxLength, maxWrite, periodicFlush, sync, append = true, mkdir, retryEAGAIN, fsync, contentMode, mode } = opts || {};
    fd = fd || dest;
    this._len = 0;
    this.fd = -1;
    this._bufs = [];
    this._lens = [];
    this._writing = false;
    this._ending = false;
    this._reopening = false;
    this._asyncDrainScheduled = false;
    this._flushPending = false;
    this._hwm = Math.max(minLength || 0, 16387);
    this.file = null;
    this.destroyed = false;
    this.minLength = minLength || 0;
    this.maxLength = maxLength || 0;
    this.maxWrite = maxWrite || MAX_WRITE;
    this._periodicFlush = periodicFlush || 0;
    this._periodicFlushTimer = void 0;
    this.sync = sync || false;
    this.writable = true;
    this._fsync = fsync || false;
    this.append = append || false;
    this.mode = mode;
    this.retryEAGAIN = retryEAGAIN || (() => true);
    this.mkdir = mkdir || false;
    let fsWriteSync;
    let fsWrite;
    if (contentMode === kContentModeBuffer) {
      this._writingBuf = kEmptyBuffer;
      this.write = writeBuffer;
      this.flush = flushBuffer;
      this.flushSync = flushBufferSync;
      this._actualWrite = actualWriteBuffer;
      fsWriteSync = () => fs.writeSync(this.fd, this._writingBuf);
      fsWrite = () => fs.write(this.fd, this._writingBuf, this.release);
    } else if (contentMode === void 0 || contentMode === kContentModeUtf8) {
      this._writingBuf = "";
      this.write = write;
      this.flush = flush;
      this.flushSync = flushSync;
      this._actualWrite = actualWrite;
      fsWriteSync = () => fs.writeSync(this.fd, this._writingBuf, "utf8");
      fsWrite = () => fs.write(this.fd, this._writingBuf, "utf8", this.release);
    } else {
      throw new Error(`SonicBoom supports "${kContentModeUtf8}" and "${kContentModeBuffer}", but passed ${contentMode}`);
    }
    if (typeof fd === "number") {
      this.fd = fd;
      process.nextTick(() => this.emit("ready"));
    } else if (typeof fd === "string") {
      openFile(fd, this);
    } else {
      throw new Error("SonicBoom supports only file descriptors and files");
    }
    if (this.minLength >= this.maxWrite) {
      throw new Error(`minLength should be smaller than maxWrite (${this.maxWrite})`);
    }
    this.release = (err2, n2) => {
      if (err2) {
        if ((err2.code === "EAGAIN" || err2.code === "EBUSY") && this.retryEAGAIN(err2, this._writingBuf.length, this._len - this._writingBuf.length)) {
          if (this.sync) {
            try {
              sleep(BUSY_WRITE_TIMEOUT);
              this.release(void 0, 0);
            } catch (err3) {
              this.release(err3);
            }
          } else {
            setTimeout(fsWrite, BUSY_WRITE_TIMEOUT);
          }
        } else {
          this._writing = false;
          this.emit("error", err2);
        }
        return;
      }
      this.emit("write", n2);
      const releasedBufObj = releaseWritingBuf(this._writingBuf, this._len, n2);
      this._len = releasedBufObj.len;
      this._writingBuf = releasedBufObj.writingBuf;
      if (this._writingBuf.length) {
        if (!this.sync) {
          fsWrite();
          return;
        }
        try {
          do {
            const n3 = fsWriteSync();
            const releasedBufObj2 = releaseWritingBuf(this._writingBuf, this._len, n3);
            this._len = releasedBufObj2.len;
            this._writingBuf = releasedBufObj2.writingBuf;
          } while (this._writingBuf.length);
        } catch (err3) {
          this.release(err3);
          return;
        }
      }
      if (this._fsync) {
        fs.fsyncSync(this.fd);
      }
      const len = this._len;
      if (this._reopening) {
        this._writing = false;
        this._reopening = false;
        this.reopen();
      } else if (len > this.minLength) {
        this._actualWrite();
      } else if (this._ending) {
        if (len > 0) {
          this._actualWrite();
        } else {
          this._writing = false;
          actualClose(this);
        }
      } else {
        this._writing = false;
        if (this.sync) {
          if (!this._asyncDrainScheduled) {
            this._asyncDrainScheduled = true;
            process.nextTick(emitDrain, this);
          }
        } else {
          this.emit("drain");
        }
      }
    };
    this.on("newListener", function(name2) {
      if (name2 === "drain") {
        this._asyncDrainScheduled = false;
      }
    });
    if (this._periodicFlush !== 0) {
      this._periodicFlushTimer = setInterval(() => this.flush(null), this._periodicFlush);
      this._periodicFlushTimer.unref();
    }
  }
  function releaseWritingBuf(writingBuf, len, n2) {
    if (typeof writingBuf === "string" && Buffer.byteLength(writingBuf) !== n2) {
      n2 = Buffer.from(writingBuf).subarray(0, n2).toString().length;
    }
    len = Math.max(len - n2, 0);
    writingBuf = writingBuf.slice(n2);
    return { writingBuf, len };
  }
  function emitDrain(sonic) {
    const hasListeners = sonic.listenerCount("drain") > 0;
    if (!hasListeners) return;
    sonic._asyncDrainScheduled = false;
    sonic.emit("drain");
  }
  inherits(SonicBoom, EventEmitter2);
  function mergeBuf(bufs, len) {
    if (bufs.length === 0) {
      return kEmptyBuffer;
    }
    if (bufs.length === 1) {
      return bufs[0];
    }
    return Buffer.concat(bufs, len);
  }
  function write(data) {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    const len = this._len + data.length;
    const bufs = this._bufs;
    if (this.maxLength && len > this.maxLength) {
      this.emit("drop", data);
      return this._len < this._hwm;
    }
    if (bufs.length === 0 || bufs[bufs.length - 1].length + data.length > this.maxWrite) {
      bufs.push("" + data);
    } else {
      bufs[bufs.length - 1] += data;
    }
    this._len = len;
    if (!this._writing && this._len >= this.minLength) {
      this._actualWrite();
    }
    return this._len < this._hwm;
  }
  function writeBuffer(data) {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    const len = this._len + data.length;
    const bufs = this._bufs;
    const lens = this._lens;
    if (this.maxLength && len > this.maxLength) {
      this.emit("drop", data);
      return this._len < this._hwm;
    }
    if (bufs.length === 0 || lens[lens.length - 1] + data.length > this.maxWrite) {
      bufs.push([data]);
      lens.push(data.length);
    } else {
      bufs[bufs.length - 1].push(data);
      lens[lens.length - 1] += data.length;
    }
    this._len = len;
    if (!this._writing && this._len >= this.minLength) {
      this._actualWrite();
    }
    return this._len < this._hwm;
  }
  function callFlushCallbackOnDrain(cb) {
    this._flushPending = true;
    const onDrain = () => {
      if (!this._fsync) {
        try {
          fs.fsync(this.fd, (err2) => {
            this._flushPending = false;
            cb(err2);
          });
        } catch (err2) {
          cb(err2);
        }
      } else {
        this._flushPending = false;
        cb();
      }
      this.off("error", onError);
    };
    const onError = (err2) => {
      this._flushPending = false;
      cb(err2);
      this.off("drain", onDrain);
    };
    this.once("drain", onDrain);
    this.once("error", onError);
  }
  function flush(cb) {
    if (cb != null && typeof cb !== "function") {
      throw new Error("flush cb must be a function");
    }
    if (this.destroyed) {
      const error2 = new Error("SonicBoom destroyed");
      if (cb) {
        cb(error2);
        return;
      }
      throw error2;
    }
    if (this.minLength <= 0) {
      cb?.();
      return;
    }
    if (cb) {
      callFlushCallbackOnDrain.call(this, cb);
    }
    if (this._writing) {
      return;
    }
    if (this._bufs.length === 0) {
      this._bufs.push("");
    }
    this._actualWrite();
  }
  function flushBuffer(cb) {
    if (cb != null && typeof cb !== "function") {
      throw new Error("flush cb must be a function");
    }
    if (this.destroyed) {
      const error2 = new Error("SonicBoom destroyed");
      if (cb) {
        cb(error2);
        return;
      }
      throw error2;
    }
    if (this.minLength <= 0) {
      cb?.();
      return;
    }
    if (cb) {
      callFlushCallbackOnDrain.call(this, cb);
    }
    if (this._writing) {
      return;
    }
    if (this._bufs.length === 0) {
      this._bufs.push([]);
      this._lens.push(0);
    }
    this._actualWrite();
  }
  SonicBoom.prototype.reopen = function(file) {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    if (this._opening) {
      this.once("ready", () => {
        this.reopen(file);
      });
      return;
    }
    if (this._ending) {
      return;
    }
    if (!this.file) {
      throw new Error("Unable to reopen a file descriptor, you must pass a file to SonicBoom");
    }
    if (file) {
      this.file = file;
    }
    this._reopening = true;
    if (this._writing) {
      return;
    }
    const fd = this.fd;
    this.once("ready", () => {
      if (fd !== this.fd) {
        fs.close(fd, (err2) => {
          if (err2) {
            return this.emit("error", err2);
          }
        });
      }
    });
    openFile(this.file, this);
  };
  SonicBoom.prototype.end = function() {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    if (this._opening) {
      this.once("ready", () => {
        this.end();
      });
      return;
    }
    if (this._ending) {
      return;
    }
    this._ending = true;
    if (this._writing) {
      return;
    }
    if (this._len > 0 && this.fd >= 0) {
      this._actualWrite();
    } else {
      actualClose(this);
    }
  };
  function flushSync() {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    if (this.fd < 0) {
      throw new Error("sonic boom is not ready yet");
    }
    if (!this._writing && this._writingBuf.length > 0) {
      this._bufs.unshift(this._writingBuf);
      this._writingBuf = "";
    }
    let buf = "";
    while (this._bufs.length || buf) {
      if (buf.length <= 0) {
        buf = this._bufs[0];
      }
      try {
        const n2 = fs.writeSync(this.fd, buf, "utf8");
        const releasedBufObj = releaseWritingBuf(buf, this._len, n2);
        buf = releasedBufObj.writingBuf;
        this._len = releasedBufObj.len;
        if (buf.length <= 0) {
          this._bufs.shift();
        }
      } catch (err2) {
        const shouldRetry = err2.code === "EAGAIN" || err2.code === "EBUSY";
        if (shouldRetry && !this.retryEAGAIN(err2, buf.length, this._len - buf.length)) {
          throw err2;
        }
        sleep(BUSY_WRITE_TIMEOUT);
      }
    }
    try {
      fs.fsyncSync(this.fd);
    } catch {
    }
  }
  function flushBufferSync() {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    if (this.fd < 0) {
      throw new Error("sonic boom is not ready yet");
    }
    if (!this._writing && this._writingBuf.length > 0) {
      this._bufs.unshift([this._writingBuf]);
      this._writingBuf = kEmptyBuffer;
    }
    let buf = kEmptyBuffer;
    while (this._bufs.length || buf.length) {
      if (buf.length <= 0) {
        buf = mergeBuf(this._bufs[0], this._lens[0]);
      }
      try {
        const n2 = fs.writeSync(this.fd, buf);
        buf = buf.subarray(n2);
        this._len = Math.max(this._len - n2, 0);
        if (buf.length <= 0) {
          this._bufs.shift();
          this._lens.shift();
        }
      } catch (err2) {
        const shouldRetry = err2.code === "EAGAIN" || err2.code === "EBUSY";
        if (shouldRetry && !this.retryEAGAIN(err2, buf.length, this._len - buf.length)) {
          throw err2;
        }
        sleep(BUSY_WRITE_TIMEOUT);
      }
    }
  }
  SonicBoom.prototype.destroy = function() {
    if (this.destroyed) {
      return;
    }
    actualClose(this);
  };
  function actualWrite() {
    const release = this.release;
    this._writing = true;
    this._writingBuf = this._writingBuf || this._bufs.shift() || "";
    if (this.sync) {
      try {
        const written = fs.writeSync(this.fd, this._writingBuf, "utf8");
        release(null, written);
      } catch (err2) {
        release(err2);
      }
    } else {
      fs.write(this.fd, this._writingBuf, "utf8", release);
    }
  }
  function actualWriteBuffer() {
    const release = this.release;
    this._writing = true;
    this._writingBuf = this._writingBuf.length ? this._writingBuf : mergeBuf(this._bufs.shift(), this._lens.shift());
    if (this.sync) {
      try {
        const written = fs.writeSync(this.fd, this._writingBuf);
        release(null, written);
      } catch (err2) {
        release(err2);
      }
    } else {
      if (kCopyBuffer) {
        this._writingBuf = Buffer.from(this._writingBuf);
      }
      fs.write(this.fd, this._writingBuf, release);
    }
  }
  function actualClose(sonic) {
    if (sonic.fd === -1) {
      sonic.once("ready", actualClose.bind(null, sonic));
      return;
    }
    if (sonic._periodicFlushTimer !== void 0) {
      clearInterval(sonic._periodicFlushTimer);
    }
    sonic.destroyed = true;
    sonic._bufs = [];
    sonic._lens = [];
    assert2(typeof sonic.fd === "number", `sonic.fd must be a number, got ${typeof sonic.fd}`);
    try {
      fs.fsync(sonic.fd, closeWrapped);
    } catch {
    }
    function closeWrapped() {
      if (sonic.fd !== 1 && sonic.fd !== 2) {
        fs.close(sonic.fd, done);
      } else {
        done();
      }
    }
    function done(err2) {
      if (err2) {
        sonic.emit("error", err2);
        return;
      }
      if (sonic._ending && !sonic._writing) {
        sonic.emit("finish");
      }
      sonic.emit("close");
    }
  }
  SonicBoom.SonicBoom = SonicBoom;
  SonicBoom.default = SonicBoom;
  sonicBoom = SonicBoom;
  return sonicBoom;
}
var onExitLeakFree;
var hasRequiredOnExitLeakFree;
function requireOnExitLeakFree() {
  if (hasRequiredOnExitLeakFree) return onExitLeakFree;
  hasRequiredOnExitLeakFree = 1;
  const refs = {
    exit: [],
    beforeExit: []
  };
  const functions = {
    exit: onExit,
    beforeExit: onBeforeExit
  };
  let registry;
  function ensureRegistry() {
    if (registry === void 0) {
      registry = new FinalizationRegistry(clear);
    }
  }
  function install(event) {
    if (refs[event].length > 0) {
      return;
    }
    process.on(event, functions[event]);
  }
  function uninstall(event) {
    if (refs[event].length > 0) {
      return;
    }
    process.removeListener(event, functions[event]);
    if (refs.exit.length === 0 && refs.beforeExit.length === 0) {
      registry = void 0;
    }
  }
  function onExit() {
    callRefs("exit");
  }
  function onBeforeExit() {
    callRefs("beforeExit");
  }
  function callRefs(event) {
    for (const ref2 of refs[event]) {
      const obj = ref2.deref();
      const fn2 = ref2.fn;
      if (obj !== void 0) {
        fn2(obj, event);
      }
    }
    refs[event] = [];
  }
  function clear(ref2) {
    for (const event of ["exit", "beforeExit"]) {
      const index2 = refs[event].indexOf(ref2);
      refs[event].splice(index2, index2 + 1);
      uninstall(event);
    }
  }
  function _register(event, obj, fn2) {
    if (obj === void 0) {
      throw new Error("the object can't be undefined");
    }
    install(event);
    const ref2 = new WeakRef(obj);
    ref2.fn = fn2;
    ensureRegistry();
    registry.register(obj, ref2);
    refs[event].push(ref2);
  }
  function register(obj, fn2) {
    _register("exit", obj, fn2);
  }
  function registerBeforeExit(obj, fn2) {
    _register("beforeExit", obj, fn2);
  }
  function unregister(obj) {
    if (registry === void 0) {
      return;
    }
    registry.unregister(obj);
    for (const event of ["exit", "beforeExit"]) {
      refs[event] = refs[event].filter((ref2) => {
        const _obj = ref2.deref();
        return _obj && _obj !== obj;
      });
      uninstall(event);
    }
  }
  onExitLeakFree = {
    register,
    registerBeforeExit,
    unregister
  };
  return onExitLeakFree;
}
const version$1 = "4.0.0";
const require$$0$3 = {
  version: version$1
};
var wait_1;
var hasRequiredWait;
function requireWait() {
  if (hasRequiredWait) return wait_1;
  hasRequiredWait = 1;
  const WAIT_MS = 1e4;
  function wait(state, index2, expected, timeout, done) {
    const max2 = timeout === Infinity ? Infinity : Date.now() + timeout;
    const check2 = () => {
      const current = Atomics.load(state, index2);
      if (current === expected) {
        done(null, "ok");
        return;
      }
      if (max2 !== Infinity && Date.now() > max2) {
        done(null, "timed-out");
        return;
      }
      const remaining = max2 === Infinity ? WAIT_MS : Math.min(WAIT_MS, Math.max(1, max2 - Date.now()));
      const result2 = Atomics.waitAsync(state, index2, current, remaining);
      if (result2.async) {
        result2.value.then(check2);
      } else {
        setImmediate(check2);
      }
    };
    check2();
  }
  function waitDiff(state, index2, expected, timeout, done) {
    const max2 = timeout === Infinity ? Infinity : Date.now() + timeout;
    const check2 = () => {
      const current = Atomics.load(state, index2);
      if (current !== expected) {
        done(null, "ok");
        return;
      }
      if (max2 !== Infinity && Date.now() > max2) {
        done(null, "timed-out");
        return;
      }
      const remaining = max2 === Infinity ? WAIT_MS : Math.min(WAIT_MS, Math.max(1, max2 - Date.now()));
      const result2 = Atomics.waitAsync(state, index2, expected, remaining);
      if (result2.async) {
        result2.value.then(check2);
      } else {
        setImmediate(check2);
      }
    };
    check2();
  }
  wait_1 = { wait, waitDiff };
  return wait_1;
}
var indexes;
var hasRequiredIndexes;
function requireIndexes() {
  if (hasRequiredIndexes) return indexes;
  hasRequiredIndexes = 1;
  const WRITE_INDEX = 4;
  const READ_INDEX = 8;
  indexes = {
    WRITE_INDEX,
    READ_INDEX
  };
  return indexes;
}
var threadStream;
var hasRequiredThreadStream;
function requireThreadStream() {
  if (hasRequiredThreadStream) return threadStream;
  hasRequiredThreadStream = 1;
  const { version: version2 } = require$$0$3;
  const { EventEmitter: EventEmitter2 } = require$$0$7;
  const { Worker: Worker2 } = require$$2$1;
  const { join: join2 } = require$$0$6;
  const { pathToFileURL } = require$$0$8;
  const { wait } = requireWait();
  const {
    WRITE_INDEX,
    READ_INDEX
  } = requireIndexes();
  const buffer = require$$7$1;
  const assert2 = require$$5$1;
  const kImpl = /* @__PURE__ */ Symbol("kImpl");
  const MAX_STRING = buffer.constants.MAX_STRING_LENGTH;
  class FakeWeakRef {
    constructor(value) {
      this._value = value;
    }
    deref() {
      return this._value;
    }
  }
  class FakeFinalizationRegistry {
    register() {
    }
    unregister() {
    }
  }
  const FinalizationRegistry2 = process.env.NODE_V8_COVERAGE ? FakeFinalizationRegistry : commonjsGlobal.FinalizationRegistry || FakeFinalizationRegistry;
  const WeakRef2 = process.env.NODE_V8_COVERAGE ? FakeWeakRef : commonjsGlobal.WeakRef || FakeWeakRef;
  const registry = new FinalizationRegistry2((worker) => {
    if (worker.exited) {
      return;
    }
    worker.terminate();
  });
  function createWorker(stream2, opts) {
    const { filename, workerData } = opts;
    const bundlerOverrides = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
    const toExecute = bundlerOverrides["thread-stream-worker"] || join2(__dirname, "lib", "worker.js");
    const worker = new Worker2(toExecute, {
      ...opts.workerOpts,
      trackUnmanagedFds: false,
      workerData: {
        filename: filename.indexOf("file://") === 0 ? filename : pathToFileURL(filename).href,
        dataBuf: stream2[kImpl].dataBuf,
        stateBuf: stream2[kImpl].stateBuf,
        workerData: {
          $context: {
            threadStreamVersion: version2
          },
          ...workerData
        }
      }
    });
    worker.stream = new FakeWeakRef(stream2);
    worker.on("message", onWorkerMessage);
    worker.on("exit", onWorkerExit);
    registry.register(stream2, worker);
    return worker;
  }
  function drain(stream2) {
    assert2(!stream2[kImpl].sync);
    if (stream2[kImpl].needDrain) {
      stream2[kImpl].needDrain = false;
      stream2.emit("drain");
    }
  }
  function nextFlush(stream2) {
    const writeIndex = Atomics.load(stream2[kImpl].state, WRITE_INDEX);
    let leftover = stream2[kImpl].data.length - writeIndex;
    if (leftover > 0) {
      if (stream2[kImpl].buf.length === 0) {
        stream2[kImpl].flushing = false;
        if (stream2[kImpl].ending) {
          end(stream2);
        } else if (stream2[kImpl].needDrain) {
          process.nextTick(drain, stream2);
        }
        return;
      }
      let toWrite = stream2[kImpl].buf.slice(0, leftover);
      let toWriteBytes = Buffer.byteLength(toWrite);
      if (toWriteBytes <= leftover) {
        stream2[kImpl].buf = stream2[kImpl].buf.slice(leftover);
        write(stream2, toWrite, nextFlush.bind(null, stream2));
      } else {
        stream2.flush(() => {
          if (stream2.destroyed) {
            return;
          }
          Atomics.store(stream2[kImpl].state, READ_INDEX, 0);
          Atomics.store(stream2[kImpl].state, WRITE_INDEX, 0);
          Atomics.notify(stream2[kImpl].state, READ_INDEX);
          while (toWriteBytes > stream2[kImpl].data.length) {
            leftover = leftover / 2;
            toWrite = stream2[kImpl].buf.slice(0, leftover);
            toWriteBytes = Buffer.byteLength(toWrite);
          }
          stream2[kImpl].buf = stream2[kImpl].buf.slice(leftover);
          write(stream2, toWrite, nextFlush.bind(null, stream2));
        });
      }
    } else if (leftover === 0) {
      if (writeIndex === 0 && stream2[kImpl].buf.length === 0) {
        return;
      }
      stream2.flush(() => {
        Atomics.store(stream2[kImpl].state, READ_INDEX, 0);
        Atomics.store(stream2[kImpl].state, WRITE_INDEX, 0);
        Atomics.notify(stream2[kImpl].state, READ_INDEX);
        nextFlush(stream2);
      });
    } else {
      destroy(stream2, new Error("overwritten"));
    }
  }
  function onWorkerMessage(msg) {
    const stream2 = this.stream.deref();
    if (stream2 === void 0) {
      this.exited = true;
      this.terminate();
      return;
    }
    switch (msg.code) {
      case "READY":
        this.stream = new WeakRef2(stream2);
        stream2.flush(() => {
          stream2[kImpl].ready = true;
          stream2.emit("ready");
        });
        break;
      case "ERROR":
        destroy(stream2, msg.err);
        break;
      case "EVENT":
        if (Array.isArray(msg.args)) {
          stream2.emit(msg.name, ...msg.args);
        } else {
          stream2.emit(msg.name, msg.args);
        }
        break;
      case "WARNING":
        process.emitWarning(msg.err);
        break;
      default:
        destroy(stream2, new Error("this should not happen: " + msg.code));
    }
  }
  function onWorkerExit(code) {
    const stream2 = this.stream.deref();
    if (stream2 === void 0) {
      return;
    }
    registry.unregister(stream2);
    stream2.worker.exited = true;
    stream2.worker.off("exit", onWorkerExit);
    destroy(stream2, code !== 0 ? new Error("the worker thread exited") : null);
  }
  class ThreadStream extends EventEmitter2 {
    constructor(opts = {}) {
      super();
      if (opts.bufferSize < 4) {
        throw new Error("bufferSize must at least fit a 4-byte utf-8 char");
      }
      this[kImpl] = {};
      this[kImpl].stateBuf = new SharedArrayBuffer(128);
      this[kImpl].state = new Int32Array(this[kImpl].stateBuf);
      this[kImpl].dataBuf = new SharedArrayBuffer(opts.bufferSize || 4 * 1024 * 1024);
      this[kImpl].data = Buffer.from(this[kImpl].dataBuf);
      this[kImpl].sync = opts.sync || false;
      this[kImpl].ending = false;
      this[kImpl].ended = false;
      this[kImpl].needDrain = false;
      this[kImpl].destroyed = false;
      this[kImpl].flushing = false;
      this[kImpl].ready = false;
      this[kImpl].finished = false;
      this[kImpl].errored = null;
      this[kImpl].closed = false;
      this[kImpl].buf = "";
      this.worker = createWorker(this, opts);
      this.on("message", (message2, transferList) => {
        this.worker.postMessage(message2, transferList);
      });
    }
    write(data) {
      if (this[kImpl].destroyed) {
        error2(this, new Error("the worker has exited"));
        return false;
      }
      if (this[kImpl].ending) {
        error2(this, new Error("the worker is ending"));
        return false;
      }
      if (this[kImpl].flushing && this[kImpl].buf.length + data.length >= MAX_STRING) {
        try {
          writeSync(this);
          this[kImpl].flushing = true;
        } catch (err2) {
          destroy(this, err2);
          return false;
        }
      }
      this[kImpl].buf += data;
      if (this[kImpl].sync) {
        try {
          writeSync(this);
          return true;
        } catch (err2) {
          destroy(this, err2);
          return false;
        }
      }
      if (!this[kImpl].flushing) {
        this[kImpl].flushing = true;
        setImmediate(nextFlush, this);
      }
      this[kImpl].needDrain = this[kImpl].data.length - this[kImpl].buf.length - Atomics.load(this[kImpl].state, WRITE_INDEX) <= 0;
      return !this[kImpl].needDrain;
    }
    end() {
      if (this[kImpl].destroyed) {
        return;
      }
      this[kImpl].ending = true;
      end(this);
    }
    flush(cb) {
      if (this[kImpl].destroyed) {
        if (typeof cb === "function") {
          process.nextTick(cb, new Error("the worker has exited"));
        }
        return;
      }
      const writeIndex = Atomics.load(this[kImpl].state, WRITE_INDEX);
      wait(this[kImpl].state, READ_INDEX, writeIndex, Infinity, (err2, res2) => {
        if (err2) {
          destroy(this, err2);
          process.nextTick(cb, err2);
          return;
        }
        if (res2 === "not-equal") {
          this.flush(cb);
          return;
        }
        process.nextTick(cb);
      });
    }
    flushSync() {
      if (this[kImpl].destroyed) {
        return;
      }
      writeSync(this);
      flushSync(this);
    }
    unref() {
      this.worker.unref();
    }
    ref() {
      this.worker.ref();
    }
    get ready() {
      return this[kImpl].ready;
    }
    get destroyed() {
      return this[kImpl].destroyed;
    }
    get closed() {
      return this[kImpl].closed;
    }
    get writable() {
      return !this[kImpl].destroyed && !this[kImpl].ending;
    }
    get writableEnded() {
      return this[kImpl].ending;
    }
    get writableFinished() {
      return this[kImpl].finished;
    }
    get writableNeedDrain() {
      return this[kImpl].needDrain;
    }
    get writableObjectMode() {
      return false;
    }
    get writableErrored() {
      return this[kImpl].errored;
    }
  }
  function error2(stream2, err2) {
    setImmediate(() => {
      stream2.emit("error", err2);
    });
  }
  function destroy(stream2, err2) {
    if (stream2[kImpl].destroyed) {
      return;
    }
    stream2[kImpl].destroyed = true;
    if (err2) {
      stream2[kImpl].errored = err2;
      error2(stream2, err2);
    }
    if (!stream2.worker.exited) {
      stream2.worker.terminate().catch(() => {
      }).then(() => {
        stream2[kImpl].closed = true;
        stream2.emit("close");
      });
    } else {
      setImmediate(() => {
        stream2[kImpl].closed = true;
        stream2.emit("close");
      });
    }
  }
  function write(stream2, data, cb) {
    const current = Atomics.load(stream2[kImpl].state, WRITE_INDEX);
    const length = Buffer.byteLength(data);
    stream2[kImpl].data.write(data, current);
    Atomics.store(stream2[kImpl].state, WRITE_INDEX, current + length);
    Atomics.notify(stream2[kImpl].state, WRITE_INDEX);
    cb();
    return true;
  }
  function end(stream2) {
    if (stream2[kImpl].ended || !stream2[kImpl].ending || stream2[kImpl].flushing) {
      return;
    }
    stream2[kImpl].ended = true;
    try {
      stream2.flushSync();
      let readIndex = Atomics.load(stream2[kImpl].state, READ_INDEX);
      Atomics.store(stream2[kImpl].state, WRITE_INDEX, -1);
      Atomics.notify(stream2[kImpl].state, WRITE_INDEX);
      let spins = 0;
      while (readIndex !== -1) {
        Atomics.wait(stream2[kImpl].state, READ_INDEX, readIndex, 1e3);
        readIndex = Atomics.load(stream2[kImpl].state, READ_INDEX);
        if (readIndex === -2) {
          destroy(stream2, new Error("end() failed"));
          return;
        }
        if (++spins === 10) {
          destroy(stream2, new Error("end() took too long (10s)"));
          return;
        }
      }
      process.nextTick(() => {
        stream2[kImpl].finished = true;
        stream2.emit("finish");
      });
    } catch (err2) {
      destroy(stream2, err2);
    }
  }
  function writeSync(stream2) {
    const cb = () => {
      if (stream2[kImpl].ending) {
        end(stream2);
      } else if (stream2[kImpl].needDrain) {
        process.nextTick(drain, stream2);
      }
    };
    stream2[kImpl].flushing = false;
    while (stream2[kImpl].buf.length !== 0) {
      const writeIndex = Atomics.load(stream2[kImpl].state, WRITE_INDEX);
      let leftover = stream2[kImpl].data.length - writeIndex;
      if (leftover === 0) {
        flushSync(stream2);
        Atomics.store(stream2[kImpl].state, READ_INDEX, 0);
        Atomics.store(stream2[kImpl].state, WRITE_INDEX, 0);
        Atomics.notify(stream2[kImpl].state, READ_INDEX);
        continue;
      } else if (leftover < 0) {
        throw new Error("overwritten");
      }
      let toWrite = stream2[kImpl].buf.slice(0, leftover);
      let toWriteBytes = Buffer.byteLength(toWrite);
      if (toWriteBytes <= leftover) {
        stream2[kImpl].buf = stream2[kImpl].buf.slice(leftover);
        write(stream2, toWrite, cb);
      } else {
        flushSync(stream2);
        Atomics.store(stream2[kImpl].state, READ_INDEX, 0);
        Atomics.store(stream2[kImpl].state, WRITE_INDEX, 0);
        Atomics.notify(stream2[kImpl].state, READ_INDEX);
        while (toWriteBytes > stream2[kImpl].buf.length) {
          leftover = leftover / 2;
          toWrite = stream2[kImpl].buf.slice(0, leftover);
          toWriteBytes = Buffer.byteLength(toWrite);
        }
        stream2[kImpl].buf = stream2[kImpl].buf.slice(leftover);
        write(stream2, toWrite, cb);
      }
    }
  }
  function flushSync(stream2) {
    if (stream2[kImpl].flushing) {
      throw new Error("unable to flush while flushing");
    }
    const writeIndex = Atomics.load(stream2[kImpl].state, WRITE_INDEX);
    let spins = 0;
    while (true) {
      const readIndex = Atomics.load(stream2[kImpl].state, READ_INDEX);
      if (readIndex === -2) {
        throw Error("_flushSync failed");
      }
      if (readIndex !== writeIndex) {
        Atomics.wait(stream2[kImpl].state, READ_INDEX, readIndex, 1e3);
      } else {
        break;
      }
      if (++spins === 10) {
        throw new Error("_flushSync took too long (10s)");
      }
    }
  }
  threadStream = ThreadStream;
  return threadStream;
}
var transport_1;
var hasRequiredTransport;
function requireTransport() {
  if (hasRequiredTransport) return transport_1;
  hasRequiredTransport = 1;
  const { createRequire } = require$$0$9;
  const getCallers = requireCaller();
  const { join: join2, isAbsolute, sep } = require$$2$2;
  const sleep = requireAtomicSleep();
  const onExit = requireOnExitLeakFree();
  const ThreadStream = requireThreadStream();
  function setupOnExit(stream2) {
    onExit.register(stream2, autoEnd);
    onExit.registerBeforeExit(stream2, flush);
    stream2.on("close", function() {
      onExit.unregister(stream2);
    });
  }
  function hasPreloadFlags() {
    const execArgv = process.execArgv;
    for (let i = 0; i < execArgv.length; i++) {
      const arg = execArgv[i];
      if (arg === "--import" || arg === "--require" || arg === "-r") {
        return true;
      }
      if (arg.startsWith("--import=") || arg.startsWith("--require=") || arg.startsWith("-r=")) {
        return true;
      }
    }
    return false;
  }
  function buildStream(filename, workerData, workerOpts, sync, name2) {
    if (!workerOpts.execArgv && hasPreloadFlags() && require.main === void 0) {
      workerOpts = {
        ...workerOpts,
        execArgv: []
      };
    }
    workerOpts = { ...workerOpts, name: name2 };
    const stream2 = new ThreadStream({
      filename,
      workerData,
      workerOpts,
      sync
    });
    stream2.on("ready", onReady);
    stream2.on("close", function() {
      process.removeListener("exit", onExit2);
    });
    process.on("exit", onExit2);
    function onReady() {
      process.removeListener("exit", onExit2);
      stream2.unref();
      if (workerOpts.autoEnd !== false) {
        setupOnExit(stream2);
      }
    }
    function onExit2() {
      if (stream2.closed) {
        return;
      }
      stream2.flushSync();
      sleep(100);
      stream2.end();
    }
    return stream2;
  }
  function autoEnd(stream2) {
    stream2.ref();
    stream2.flushSync();
    stream2.end();
    stream2.once("close", function() {
      stream2.unref();
    });
  }
  function flush(stream2) {
    stream2.flushSync();
  }
  function transport(fullOptions) {
    const { pipeline, targets, levels: levels2, dedupe, worker = {}, caller: caller2 = getCallers(), sync = false } = fullOptions;
    const options = {
      ...fullOptions.options
    };
    const callers = typeof caller2 === "string" ? [caller2] : caller2;
    const bundlerOverrides = typeof globalThis === "object" && Object.prototype.hasOwnProperty.call(globalThis, "__bundlerPathsOverrides") && globalThis.__bundlerPathsOverrides && typeof globalThis.__bundlerPathsOverrides === "object" ? globalThis.__bundlerPathsOverrides : /* @__PURE__ */ Object.create(null);
    let target = fullOptions.target;
    if (target && targets) {
      throw new Error("only one of target or targets can be specified");
    }
    if (targets) {
      target = bundlerOverrides["pino-worker"] || join2(__dirname, "worker.js");
      options.targets = targets.filter((dest) => dest.target).map((dest) => {
        return {
          ...dest,
          target: fixTarget(dest.target)
        };
      });
      options.pipelines = targets.filter((dest) => dest.pipeline).map((dest) => {
        return dest.pipeline.map((t2) => {
          return {
            ...t2,
            level: dest.level,
            // duplicate the pipeline `level` property defined in the upper level
            target: fixTarget(t2.target)
          };
        });
      });
    } else if (pipeline) {
      target = bundlerOverrides["pino-worker"] || join2(__dirname, "worker.js");
      options.pipelines = [pipeline.map((dest) => {
        return {
          ...dest,
          target: fixTarget(dest.target)
        };
      })];
    }
    if (levels2) {
      options.levels = levels2;
    }
    if (dedupe) {
      options.dedupe = dedupe;
    }
    options.pinoWillSendConfig = true;
    const name2 = targets || pipeline ? "pino.transport" : target;
    return buildStream(fixTarget(target), options, worker, sync, name2);
    function fixTarget(origin) {
      origin = bundlerOverrides[origin] || origin;
      if (isAbsolute(origin) || origin.indexOf("file://") === 0) {
        return origin;
      }
      if (origin === "pino/file") {
        return join2(__dirname, "..", "file.js");
      }
      let fixTarget2;
      for (const filePath of callers) {
        try {
          const context = filePath === "node:repl" ? process.cwd() + sep : filePath;
          fixTarget2 = createRequire(context).resolve(origin);
          break;
        } catch (err2) {
          continue;
        }
      }
      if (!fixTarget2) {
        throw new Error(`unable to determine transport target for "${origin}"`);
      }
      return fixTarget2;
    }
  }
  transport_1 = transport;
  return transport_1;
}
var tools;
var hasRequiredTools;
function requireTools() {
  if (hasRequiredTools) return tools;
  hasRequiredTools = 1;
  const diagChan = require$$0$a;
  const format2 = requireQuickFormatUnescaped();
  const { mapHttpRequest, mapHttpResponse } = requirePinoStdSerializers();
  const SonicBoom = requireSonicBoom();
  const onExit = requireOnExitLeakFree();
  const {
    lsCacheSym,
    chindingsSym,
    writeSym,
    serializersSym,
    formatOptsSym,
    endSym,
    stringifiersSym,
    stringifySym,
    stringifySafeSym,
    wildcardFirstSym,
    nestedKeySym,
    formattersSym,
    messageKeySym,
    errorKeySym,
    nestedKeyStrSym,
    msgPrefixSym
  } = requireSymbols();
  const { isMainThread } = require$$2$1;
  const transport = requireTransport();
  const [nodeMajor] = process.versions.node.split(".").map((v) => Number(v));
  const asJsonChan = diagChan.tracingChannel("pino_asJson");
  const asString = nodeMajor >= 25 ? (str) => JSON.stringify(str) : _asString;
  function noop2() {
  }
  function genLog(level, hook) {
    if (!hook) return LOG;
    return function hookWrappedLog(...args) {
      hook.call(this, args, LOG, level);
    };
    function LOG(o2, ...n2) {
      if (typeof o2 === "object") {
        let msg = o2;
        if (o2 !== null) {
          if (o2.method && o2.headers && o2.socket) {
            o2 = mapHttpRequest(o2);
          } else if (typeof o2.setHeader === "function") {
            o2 = mapHttpResponse(o2);
          }
        }
        let formatParams;
        if (msg === null && n2.length === 0) {
          formatParams = [null];
        } else {
          msg = n2.shift();
          formatParams = n2;
        }
        if (typeof this[msgPrefixSym] === "string" && msg !== void 0 && msg !== null) {
          msg = this[msgPrefixSym] + msg;
        }
        this[writeSym](o2, format2(msg, formatParams, this[formatOptsSym]), level);
      } else {
        let msg = o2 === void 0 ? n2.shift() : o2;
        if (typeof this[msgPrefixSym] === "string" && msg !== void 0 && msg !== null) {
          msg = this[msgPrefixSym] + msg;
        }
        this[writeSym](null, format2(msg, n2, this[formatOptsSym]), level);
      }
    }
  }
  function _asString(str) {
    let result2 = "";
    let last = 0;
    let found = false;
    let point = 255;
    const l2 = str.length;
    if (l2 > 100) {
      return JSON.stringify(str);
    }
    for (var i = 0; i < l2 && point >= 32; i++) {
      point = str.charCodeAt(i);
      if (point === 34 || point === 92) {
        result2 += str.slice(last, i) + "\\";
        last = i;
        found = true;
      }
    }
    if (!found) {
      result2 = str;
    } else {
      result2 += str.slice(last);
    }
    return point < 32 ? JSON.stringify(str) : '"' + result2 + '"';
  }
  function asJson(obj, msg, num, time2) {
    if (asJsonChan.hasSubscribers === false) {
      return _asJson.call(this, obj, msg, num, time2);
    }
    const store = { instance: this, arguments };
    return asJsonChan.traceSync(_asJson, store, this, obj, msg, num, time2);
  }
  function _asJson(obj, msg, num, time2) {
    const stringify3 = this[stringifySym];
    const stringifySafe = this[stringifySafeSym];
    const stringifiers = this[stringifiersSym];
    const end = this[endSym];
    const chindings = this[chindingsSym];
    const serializers = this[serializersSym];
    const formatters = this[formattersSym];
    const messageKey = this[messageKeySym];
    const errorKey = this[errorKeySym];
    let data = this[lsCacheSym][num] + time2;
    data = data + chindings;
    let value;
    if (formatters.log) {
      obj = formatters.log(obj);
    }
    const wildcardStringifier = stringifiers[wildcardFirstSym];
    let propStr = "";
    for (const key in obj) {
      value = obj[key];
      if (Object.prototype.hasOwnProperty.call(obj, key) && value !== void 0) {
        if (serializers[key]) {
          value = serializers[key](value);
        } else if (key === errorKey && serializers.err) {
          value = serializers.err(value);
        }
        const stringifier = stringifiers[key] || wildcardStringifier;
        switch (typeof value) {
          case "undefined":
          case "function":
            continue;
          case "number":
            if (Number.isFinite(value) === false) {
              value = null;
            }
          // this case explicitly falls through to the next one
          case "boolean":
            if (stringifier) value = stringifier(value);
            break;
          case "string":
            value = (stringifier || asString)(value);
            break;
          default:
            value = (stringifier || stringify3)(value, stringifySafe);
        }
        if (value === void 0) continue;
        const strKey = asString(key);
        propStr += "," + strKey + ":" + value;
      }
    }
    let msgStr = "";
    if (msg !== void 0) {
      value = serializers[messageKey] ? serializers[messageKey](msg) : msg;
      const stringifier = stringifiers[messageKey] || wildcardStringifier;
      switch (typeof value) {
        case "function":
          break;
        case "number":
          if (Number.isFinite(value) === false) {
            value = null;
          }
        // this case explicitly falls through to the next one
        case "boolean":
          if (stringifier) value = stringifier(value);
          msgStr = ',"' + messageKey + '":' + value;
          break;
        case "string":
          value = (stringifier || asString)(value);
          msgStr = ',"' + messageKey + '":' + value;
          break;
        default:
          value = (stringifier || stringify3)(value, stringifySafe);
          msgStr = ',"' + messageKey + '":' + value;
      }
    }
    if (this[nestedKeySym] && propStr) {
      return data + this[nestedKeyStrSym] + propStr.slice(1) + "}" + msgStr + end;
    } else {
      return data + propStr + msgStr + end;
    }
  }
  function asChindings(instance, bindings) {
    let value;
    let data = instance[chindingsSym];
    const stringify3 = instance[stringifySym];
    const stringifySafe = instance[stringifySafeSym];
    const stringifiers = instance[stringifiersSym];
    const wildcardStringifier = stringifiers[wildcardFirstSym];
    const serializers = instance[serializersSym];
    const formatter = instance[formattersSym].bindings;
    bindings = formatter(bindings);
    for (const key in bindings) {
      value = bindings[key];
      const valid = (key.length < 5 || key !== "level" && key !== "serializers" && key !== "formatters" && key !== "customLevels") && bindings.hasOwnProperty(key) && value !== void 0;
      if (valid === true) {
        value = serializers[key] ? serializers[key](value) : value;
        value = (stringifiers[key] || wildcardStringifier || stringify3)(value, stringifySafe);
        if (value === void 0) continue;
        data += ',"' + key + '":' + value;
      }
    }
    return data;
  }
  function hasBeenTampered(stream2) {
    return stream2.write !== stream2.constructor.prototype.write;
  }
  function buildSafeSonicBoom(opts) {
    const stream2 = new SonicBoom(opts);
    stream2.on("error", filterBrokenPipe);
    if (!opts.sync && isMainThread) {
      onExit.register(stream2, autoEnd);
      stream2.on("close", function() {
        onExit.unregister(stream2);
      });
    }
    return stream2;
    function filterBrokenPipe(err2) {
      if (err2.code === "EPIPE") {
        stream2.write = noop2;
        stream2.end = noop2;
        stream2.flushSync = noop2;
        stream2.destroy = noop2;
        return;
      }
      stream2.removeListener("error", filterBrokenPipe);
      stream2.emit("error", err2);
    }
  }
  function autoEnd(stream2, eventName) {
    if (stream2.destroyed) {
      return;
    }
    if (eventName === "beforeExit") {
      stream2.flush();
      stream2.on("drain", function() {
        stream2.end();
      });
    } else {
      stream2.flushSync();
    }
  }
  function createArgsNormalizer(defaultOptions) {
    return function normalizeArgs(instance, caller2, opts = {}, stream2) {
      if (typeof opts === "string") {
        stream2 = buildSafeSonicBoom({ dest: opts });
        opts = {};
      } else if (typeof stream2 === "string") {
        if (opts && opts.transport) {
          throw Error("only one of option.transport or stream can be specified");
        }
        stream2 = buildSafeSonicBoom({ dest: stream2 });
      } else if (opts instanceof SonicBoom || opts.writable || opts._writableState) {
        stream2 = opts;
        opts = {};
      } else if (opts.transport) {
        if (opts.transport instanceof SonicBoom || opts.transport.writable || opts.transport._writableState) {
          throw Error("option.transport do not allow stream, please pass to option directly. e.g. pino(transport)");
        }
        if (opts.transport.targets && opts.transport.targets.length && opts.formatters && typeof opts.formatters.level === "function") {
          throw Error("option.transport.targets do not allow custom level formatters");
        }
        let customLevels;
        if (opts.customLevels) {
          customLevels = opts.useOnlyCustomLevels ? opts.customLevels : Object.assign({}, opts.levels, opts.customLevels);
        }
        stream2 = transport({ caller: caller2, ...opts.transport, levels: customLevels });
      }
      opts = Object.assign({}, defaultOptions, opts);
      opts.serializers = Object.assign({}, defaultOptions.serializers, opts.serializers);
      opts.formatters = Object.assign({}, defaultOptions.formatters, opts.formatters);
      if (opts.prettyPrint) {
        throw new Error("prettyPrint option is no longer supported, see the pino-pretty package (https://github.com/pinojs/pino-pretty)");
      }
      const { enabled, onChild } = opts;
      if (enabled === false) opts.level = "silent";
      if (!onChild) opts.onChild = noop2;
      if (!stream2) {
        if (!hasBeenTampered(process.stdout)) {
          stream2 = buildSafeSonicBoom({ fd: process.stdout.fd || 1 });
        } else {
          stream2 = process.stdout;
        }
      }
      return { opts, stream: stream2 };
    };
  }
  function stringify2(obj, stringifySafeFn) {
    try {
      return JSON.stringify(obj);
    } catch (_) {
      try {
        const stringify3 = stringifySafeFn || this[stringifySafeSym];
        return stringify3(obj);
      } catch (_2) {
        return '"[unable to serialize, circular reference is too complex to analyze]"';
      }
    }
  }
  function buildFormatters(level, bindings, log) {
    return {
      level,
      bindings,
      log
    };
  }
  function normalizeDestFileDescriptor(destination) {
    const fd = Number(destination);
    if (typeof destination === "string" && Number.isFinite(fd)) {
      return fd;
    }
    if (destination === void 0) {
      return 1;
    }
    return destination;
  }
  tools = {
    noop: noop2,
    buildSafeSonicBoom,
    asChindings,
    asJson,
    genLog,
    createArgsNormalizer,
    stringify: stringify2,
    buildFormatters,
    normalizeDestFileDescriptor
  };
  return tools;
}
var constants;
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants) return constants;
  hasRequiredConstants = 1;
  const DEFAULT_LEVELS = {
    trace: 10,
    debug: 20,
    info: 30,
    warn: 40,
    error: 50,
    fatal: 60
  };
  const SORTING_ORDER = {
    ASC: "ASC",
    DESC: "DESC"
  };
  constants = {
    DEFAULT_LEVELS,
    SORTING_ORDER
  };
  return constants;
}
var levels;
var hasRequiredLevels;
function requireLevels() {
  if (hasRequiredLevels) return levels;
  hasRequiredLevels = 1;
  const {
    lsCacheSym,
    levelValSym,
    useOnlyCustomLevelsSym,
    streamSym,
    formattersSym,
    hooksSym,
    levelCompSym
  } = requireSymbols();
  const { noop: noop2, genLog } = requireTools();
  const { DEFAULT_LEVELS, SORTING_ORDER } = requireConstants();
  const levelMethods = {
    fatal: (hook) => {
      const logFatal = genLog(DEFAULT_LEVELS.fatal, hook);
      return function(...args) {
        const stream2 = this[streamSym];
        logFatal.call(this, ...args);
        if (typeof stream2.flushSync === "function") {
          try {
            stream2.flushSync();
          } catch (e2) {
          }
        }
      };
    },
    error: (hook) => genLog(DEFAULT_LEVELS.error, hook),
    warn: (hook) => genLog(DEFAULT_LEVELS.warn, hook),
    info: (hook) => genLog(DEFAULT_LEVELS.info, hook),
    debug: (hook) => genLog(DEFAULT_LEVELS.debug, hook),
    trace: (hook) => genLog(DEFAULT_LEVELS.trace, hook)
  };
  const nums = Object.keys(DEFAULT_LEVELS).reduce((o2, k) => {
    o2[DEFAULT_LEVELS[k]] = k;
    return o2;
  }, {});
  const initialLsCache = Object.keys(nums).reduce((o2, k) => {
    o2[k] = '{"level":' + Number(k);
    return o2;
  }, {});
  function genLsCache(instance) {
    const formatter = instance[formattersSym].level;
    const { labels } = instance.levels;
    const cache2 = {};
    for (const label in labels) {
      const level = formatter(labels[label], Number(label));
      cache2[label] = JSON.stringify(level).slice(0, -1);
    }
    instance[lsCacheSym] = cache2;
    return instance;
  }
  function isStandardLevel(level, useOnlyCustomLevels) {
    if (useOnlyCustomLevels) {
      return false;
    }
    switch (level) {
      case "fatal":
      case "error":
      case "warn":
      case "info":
      case "debug":
      case "trace":
        return true;
      default:
        return false;
    }
  }
  function setLevel(level) {
    const { labels, values } = this.levels;
    if (typeof level === "number") {
      if (labels[level] === void 0) throw Error("unknown level value" + level);
      level = labels[level];
    }
    if (values[level] === void 0) throw Error("unknown level " + level);
    const preLevelVal = this[levelValSym];
    const levelVal = this[levelValSym] = values[level];
    const useOnlyCustomLevelsVal = this[useOnlyCustomLevelsSym];
    const levelComparison = this[levelCompSym];
    const hook = this[hooksSym].logMethod;
    for (const key in values) {
      if (levelComparison(values[key], levelVal) === false) {
        this[key] = noop2;
        continue;
      }
      this[key] = isStandardLevel(key, useOnlyCustomLevelsVal) ? levelMethods[key](hook) : genLog(values[key], hook);
    }
    this.emit(
      "level-change",
      level,
      levelVal,
      labels[preLevelVal],
      preLevelVal,
      this
    );
  }
  function getLevel(level) {
    const { levels: levels2, levelVal } = this;
    return levels2 && levels2.labels ? levels2.labels[levelVal] : "";
  }
  function isLevelEnabled(logLevel) {
    const { values } = this.levels;
    const logLevelVal = values[logLevel];
    return logLevelVal !== void 0 && this[levelCompSym](logLevelVal, this[levelValSym]);
  }
  function compareLevel(direction, current, expected) {
    if (direction === SORTING_ORDER.DESC) {
      return current <= expected;
    }
    return current >= expected;
  }
  function genLevelComparison(levelComparison) {
    if (typeof levelComparison === "string") {
      return compareLevel.bind(null, levelComparison);
    }
    return levelComparison;
  }
  function mappings(customLevels = null, useOnlyCustomLevels = false) {
    const customNums = customLevels ? Object.keys(customLevels).reduce((o2, k) => {
      o2[customLevels[k]] = k;
      return o2;
    }, {}) : null;
    const labels = Object.assign(
      Object.create(Object.prototype, { Infinity: { value: "silent" } }),
      useOnlyCustomLevels ? null : nums,
      customNums
    );
    const values = Object.assign(
      Object.create(Object.prototype, { silent: { value: Infinity } }),
      useOnlyCustomLevels ? null : DEFAULT_LEVELS,
      customLevels
    );
    return { labels, values };
  }
  function assertDefaultLevelFound(defaultLevel, customLevels, useOnlyCustomLevels) {
    if (typeof defaultLevel === "number") {
      const values = [].concat(
        Object.keys(customLevels || {}).map((key) => customLevels[key]),
        useOnlyCustomLevels ? [] : Object.keys(nums).map((level) => +level),
        Infinity
      );
      if (!values.includes(defaultLevel)) {
        throw Error(`default level:${defaultLevel} must be included in custom levels`);
      }
      return;
    }
    const labels = Object.assign(
      Object.create(Object.prototype, { silent: { value: Infinity } }),
      useOnlyCustomLevels ? null : DEFAULT_LEVELS,
      customLevels
    );
    if (!(defaultLevel in labels)) {
      throw Error(`default level:${defaultLevel} must be included in custom levels`);
    }
  }
  function assertNoLevelCollisions(levels2, customLevels) {
    const { labels, values } = levels2;
    for (const k in customLevels) {
      if (k in values) {
        throw Error("levels cannot be overridden");
      }
      if (customLevels[k] in labels) {
        throw Error("pre-existing level values cannot be used for new levels");
      }
    }
  }
  function assertLevelComparison(levelComparison) {
    if (typeof levelComparison === "function") {
      return;
    }
    if (typeof levelComparison === "string" && Object.values(SORTING_ORDER).includes(levelComparison)) {
      return;
    }
    throw new Error('Levels comparison should be one of "ASC", "DESC" or "function" type');
  }
  levels = {
    initialLsCache,
    genLsCache,
    levelMethods,
    getLevel,
    setLevel,
    isLevelEnabled,
    mappings,
    assertNoLevelCollisions,
    assertDefaultLevelFound,
    genLevelComparison,
    assertLevelComparison
  };
  return levels;
}
var meta;
var hasRequiredMeta;
function requireMeta() {
  if (hasRequiredMeta) return meta;
  hasRequiredMeta = 1;
  meta = { version: "10.3.0" };
  return meta;
}
var proto;
var hasRequiredProto;
function requireProto() {
  if (hasRequiredProto) return proto;
  hasRequiredProto = 1;
  const { EventEmitter: EventEmitter$1 } = EventEmitter;
  const {
    lsCacheSym,
    levelValSym,
    setLevelSym,
    getLevelSym,
    chindingsSym,
    mixinSym,
    asJsonSym,
    writeSym,
    mixinMergeStrategySym,
    timeSym,
    timeSliceIndexSym,
    streamSym,
    serializersSym,
    formattersSym,
    errorKeySym,
    messageKeySym,
    useOnlyCustomLevelsSym,
    needsMetadataGsym,
    redactFmtSym,
    stringifySym,
    formatOptsSym,
    stringifiersSym,
    msgPrefixSym,
    hooksSym
  } = requireSymbols();
  const {
    getLevel,
    setLevel,
    isLevelEnabled,
    mappings,
    initialLsCache,
    genLsCache,
    assertNoLevelCollisions
  } = requireLevels();
  const {
    asChindings,
    asJson,
    buildFormatters,
    stringify: stringify2,
    noop: noop2
  } = requireTools();
  const {
    version: version2
  } = requireMeta();
  const redaction = requireRedaction();
  const constructor = class Pino {
  };
  const prototype = {
    constructor,
    child,
    bindings,
    setBindings,
    flush,
    isLevelEnabled,
    version: version2,
    get level() {
      return this[getLevelSym]();
    },
    set level(lvl) {
      this[setLevelSym](lvl);
    },
    get levelVal() {
      return this[levelValSym];
    },
    set levelVal(n2) {
      throw Error("levelVal is read-only");
    },
    get msgPrefix() {
      return this[msgPrefixSym];
    },
    get [Symbol.toStringTag]() {
      return "Pino";
    },
    [lsCacheSym]: initialLsCache,
    [writeSym]: write,
    [asJsonSym]: asJson,
    [getLevelSym]: getLevel,
    [setLevelSym]: setLevel
  };
  Object.setPrototypeOf(prototype, EventEmitter$1.prototype);
  proto = function() {
    return Object.create(prototype);
  };
  const resetChildingsFormatter = (bindings2) => bindings2;
  function child(bindings2, options) {
    if (!bindings2) {
      throw Error("missing bindings for child Pino");
    }
    const serializers = this[serializersSym];
    const formatters = this[formattersSym];
    const instance = Object.create(this);
    if (options == null) {
      if (instance[formattersSym].bindings !== resetChildingsFormatter) {
        instance[formattersSym] = buildFormatters(
          formatters.level,
          resetChildingsFormatter,
          formatters.log
        );
      }
      instance[chindingsSym] = asChindings(instance, bindings2);
      if (this.onChild !== noop2) {
        this.onChild(instance);
      }
      return instance;
    }
    if (options.hasOwnProperty("serializers") === true) {
      instance[serializersSym] = /* @__PURE__ */ Object.create(null);
      for (const k in serializers) {
        instance[serializersSym][k] = serializers[k];
      }
      const parentSymbols = Object.getOwnPropertySymbols(serializers);
      for (var i = 0; i < parentSymbols.length; i++) {
        const ks = parentSymbols[i];
        instance[serializersSym][ks] = serializers[ks];
      }
      for (const bk in options.serializers) {
        instance[serializersSym][bk] = options.serializers[bk];
      }
      const bindingsSymbols = Object.getOwnPropertySymbols(options.serializers);
      for (var bi = 0; bi < bindingsSymbols.length; bi++) {
        const bks = bindingsSymbols[bi];
        instance[serializersSym][bks] = options.serializers[bks];
      }
    } else instance[serializersSym] = serializers;
    if (options.hasOwnProperty("formatters")) {
      const { level, bindings: chindings, log } = options.formatters;
      instance[formattersSym] = buildFormatters(
        level || formatters.level,
        chindings || resetChildingsFormatter,
        log || formatters.log
      );
    } else {
      instance[formattersSym] = buildFormatters(
        formatters.level,
        resetChildingsFormatter,
        formatters.log
      );
    }
    if (options.hasOwnProperty("customLevels") === true) {
      assertNoLevelCollisions(this.levels, options.customLevels);
      instance.levels = mappings(options.customLevels, instance[useOnlyCustomLevelsSym]);
      genLsCache(instance);
    }
    if (typeof options.redact === "object" && options.redact !== null || Array.isArray(options.redact)) {
      instance.redact = options.redact;
      const stringifiers = redaction(instance.redact, stringify2);
      const formatOpts = { stringify: stringifiers[redactFmtSym] };
      instance[stringifySym] = stringify2;
      instance[stringifiersSym] = stringifiers;
      instance[formatOptsSym] = formatOpts;
    }
    if (typeof options.msgPrefix === "string") {
      instance[msgPrefixSym] = (this[msgPrefixSym] || "") + options.msgPrefix;
    }
    instance[chindingsSym] = asChindings(instance, bindings2);
    if (options.level !== void 0 && options.level !== this.level || options.hasOwnProperty("customLevels")) {
      const childLevel = options.level || this.level;
      instance[setLevelSym](childLevel);
    }
    this.onChild(instance);
    return instance;
  }
  function bindings() {
    const chindings = this[chindingsSym];
    const chindingsJson = `{${chindings.substr(1)}}`;
    const bindingsFromJson = JSON.parse(chindingsJson);
    delete bindingsFromJson.pid;
    delete bindingsFromJson.hostname;
    return bindingsFromJson;
  }
  function setBindings(newBindings) {
    const chindings = asChindings(this, newBindings);
    this[chindingsSym] = chindings;
  }
  function defaultMixinMergeStrategy(mergeObject, mixinObject) {
    return Object.assign(mixinObject, mergeObject);
  }
  function write(_obj, msg, num) {
    const t2 = this[timeSym]();
    const mixin = this[mixinSym];
    const errorKey = this[errorKeySym];
    const messageKey = this[messageKeySym];
    const mixinMergeStrategy = this[mixinMergeStrategySym] || defaultMixinMergeStrategy;
    let obj;
    const streamWriteHook = this[hooksSym].streamWrite;
    if (_obj === void 0 || _obj === null) {
      obj = {};
    } else if (_obj instanceof Error) {
      obj = { [errorKey]: _obj };
      if (msg === void 0) {
        msg = _obj.message;
      }
    } else {
      obj = _obj;
      if (msg === void 0 && _obj[messageKey] === void 0 && _obj[errorKey]) {
        msg = _obj[errorKey].message;
      }
    }
    if (mixin) {
      obj = mixinMergeStrategy(obj, mixin(obj, num, this));
    }
    const s2 = this[asJsonSym](obj, msg, num, t2);
    const stream2 = this[streamSym];
    if (stream2[needsMetadataGsym] === true) {
      stream2.lastLevel = num;
      stream2.lastObj = obj;
      stream2.lastMsg = msg;
      stream2.lastTime = t2.slice(this[timeSliceIndexSym]);
      stream2.lastLogger = this;
    }
    stream2.write(streamWriteHook ? streamWriteHook(s2) : s2);
  }
  function flush(cb) {
    if (cb != null && typeof cb !== "function") {
      throw Error("callback must be a function");
    }
    const stream2 = this[streamSym];
    if (typeof stream2.flush === "function") {
      stream2.flush(cb || noop2);
    } else if (cb) cb();
  }
  return proto;
}
var multistream_1;
var hasRequiredMultistream;
function requireMultistream() {
  if (hasRequiredMultistream) return multistream_1;
  hasRequiredMultistream = 1;
  const metadata = /* @__PURE__ */ Symbol.for("pino.metadata");
  const { DEFAULT_LEVELS } = requireConstants();
  const DEFAULT_INFO_LEVEL = DEFAULT_LEVELS.info;
  function multistream(streamsArray, opts) {
    streamsArray = streamsArray || [];
    opts = opts || { dedupe: false };
    const streamLevels = Object.create(DEFAULT_LEVELS);
    streamLevels.silent = Infinity;
    if (opts.levels && typeof opts.levels === "object") {
      Object.keys(opts.levels).forEach((i) => {
        streamLevels[i] = opts.levels[i];
      });
    }
    const res2 = {
      write,
      add,
      remove,
      emit,
      flushSync,
      end,
      minLevel: 0,
      lastId: 0,
      streams: [],
      clone: clone2,
      [metadata]: true,
      streamLevels
    };
    if (Array.isArray(streamsArray)) {
      streamsArray.forEach(add, res2);
    } else {
      add.call(res2, streamsArray);
    }
    streamsArray = null;
    return res2;
    function write(data) {
      let dest;
      const level = this.lastLevel;
      const { streams } = this;
      let recordedLevel = 0;
      let stream2;
      for (let i = initLoopVar(streams.length, opts.dedupe); checkLoopVar(i, streams.length, opts.dedupe); i = adjustLoopVar(i, opts.dedupe)) {
        dest = streams[i];
        if (dest.level <= level) {
          if (recordedLevel !== 0 && recordedLevel !== dest.level) {
            break;
          }
          stream2 = dest.stream;
          if (stream2[metadata]) {
            const { lastTime, lastMsg, lastObj, lastLogger } = this;
            stream2.lastLevel = level;
            stream2.lastTime = lastTime;
            stream2.lastMsg = lastMsg;
            stream2.lastObj = lastObj;
            stream2.lastLogger = lastLogger;
          }
          stream2.write(data);
          if (opts.dedupe) {
            recordedLevel = dest.level;
          }
        } else if (!opts.dedupe) {
          break;
        }
      }
    }
    function emit(...args) {
      for (const { stream: stream2 } of this.streams) {
        if (typeof stream2.emit === "function") {
          stream2.emit(...args);
        }
      }
    }
    function flushSync() {
      for (const { stream: stream2 } of this.streams) {
        if (typeof stream2.flushSync === "function") {
          stream2.flushSync();
        }
      }
    }
    function add(dest) {
      if (!dest) {
        return res2;
      }
      const isStream = typeof dest.write === "function" || dest.stream;
      const stream_ = dest.write ? dest : dest.stream;
      if (!isStream) {
        throw Error("stream object needs to implement either StreamEntry or DestinationStream interface");
      }
      const { streams, streamLevels: streamLevels2 } = this;
      let level;
      if (typeof dest.levelVal === "number") {
        level = dest.levelVal;
      } else if (typeof dest.level === "string") {
        level = streamLevels2[dest.level];
      } else if (typeof dest.level === "number") {
        level = dest.level;
      } else {
        level = DEFAULT_INFO_LEVEL;
      }
      const dest_ = {
        stream: stream_,
        level,
        levelVal: void 0,
        id: ++res2.lastId
      };
      streams.unshift(dest_);
      streams.sort(compareByLevel);
      this.minLevel = streams[0].level;
      return res2;
    }
    function remove(id) {
      const { streams } = this;
      const index2 = streams.findIndex((s2) => s2.id === id);
      if (index2 >= 0) {
        streams.splice(index2, 1);
        streams.sort(compareByLevel);
        this.minLevel = streams.length > 0 ? streams[0].level : -1;
      }
      return res2;
    }
    function end() {
      for (const { stream: stream2 } of this.streams) {
        if (typeof stream2.flushSync === "function") {
          stream2.flushSync();
        }
        stream2.end();
      }
    }
    function clone2(level) {
      const streams = new Array(this.streams.length);
      for (let i = 0; i < streams.length; i++) {
        streams[i] = {
          level,
          stream: this.streams[i].stream
        };
      }
      return {
        write,
        add,
        remove,
        minLevel: level,
        streams,
        clone: clone2,
        emit,
        flushSync,
        [metadata]: true
      };
    }
  }
  function compareByLevel(a, b) {
    return a.level - b.level;
  }
  function initLoopVar(length, dedupe) {
    return dedupe ? length - 1 : 0;
  }
  function adjustLoopVar(i, dedupe) {
    return dedupe ? i - 1 : i + 1;
  }
  function checkLoopVar(i, length, dedupe) {
    return dedupe ? i >= 0 : i < length;
  }
  multistream_1 = multistream;
  return multistream_1;
}
var hasRequiredPino;
function requirePino() {
  if (hasRequiredPino) return pino$1.exports;
  hasRequiredPino = 1;
  const os = require$$0$b;
  const stdSerializers = requirePinoStdSerializers();
  const caller2 = requireCaller();
  const redaction = requireRedaction();
  const time2 = requireTime();
  const proto2 = requireProto();
  const symbols2 = requireSymbols();
  const { configure: configure2 } = requireSafeStableStringify();
  const { assertDefaultLevelFound, mappings, genLsCache, genLevelComparison, assertLevelComparison } = requireLevels();
  const { DEFAULT_LEVELS, SORTING_ORDER } = requireConstants();
  const {
    createArgsNormalizer,
    asChindings,
    buildSafeSonicBoom,
    buildFormatters,
    stringify: stringify2,
    normalizeDestFileDescriptor,
    noop: noop2
  } = requireTools();
  const { version: version2 } = requireMeta();
  const {
    chindingsSym,
    redactFmtSym,
    serializersSym,
    timeSym,
    timeSliceIndexSym,
    streamSym,
    stringifySym,
    stringifySafeSym,
    stringifiersSym,
    setLevelSym,
    endSym,
    formatOptsSym,
    messageKeySym,
    errorKeySym,
    nestedKeySym,
    mixinSym,
    levelCompSym,
    useOnlyCustomLevelsSym,
    formattersSym,
    hooksSym,
    nestedKeyStrSym,
    mixinMergeStrategySym,
    msgPrefixSym
  } = symbols2;
  const { epochTime, nullTime } = time2;
  const { pid } = process;
  const hostname = os.hostname();
  const defaultErrorSerializer = stdSerializers.err;
  const defaultOptions = {
    level: "info",
    levelComparison: SORTING_ORDER.ASC,
    levels: DEFAULT_LEVELS,
    messageKey: "msg",
    errorKey: "err",
    nestedKey: null,
    enabled: true,
    base: { pid, hostname },
    serializers: Object.assign(/* @__PURE__ */ Object.create(null), {
      err: defaultErrorSerializer
    }),
    formatters: Object.assign(/* @__PURE__ */ Object.create(null), {
      bindings(bindings) {
        return bindings;
      },
      level(label, number) {
        return { level: number };
      }
    }),
    hooks: {
      logMethod: void 0,
      streamWrite: void 0
    },
    timestamp: epochTime,
    name: void 0,
    redact: null,
    customLevels: null,
    useOnlyCustomLevels: false,
    depthLimit: 5,
    edgeLimit: 100
  };
  const normalize2 = createArgsNormalizer(defaultOptions);
  const serializers = Object.assign(/* @__PURE__ */ Object.create(null), stdSerializers);
  function pino2(...args) {
    const instance = {};
    const { opts, stream: stream2 } = normalize2(instance, caller2(), ...args);
    if (opts.level && typeof opts.level === "string" && DEFAULT_LEVELS[opts.level.toLowerCase()] !== void 0) opts.level = opts.level.toLowerCase();
    const {
      redact: redact2,
      crlf,
      serializers: serializers2,
      timestamp: timestamp2,
      messageKey,
      errorKey,
      nestedKey,
      base,
      name: name2,
      level,
      customLevels,
      levelComparison,
      mixin,
      mixinMergeStrategy,
      useOnlyCustomLevels,
      formatters,
      hooks,
      depthLimit,
      edgeLimit,
      onChild,
      msgPrefix
    } = opts;
    const stringifySafe = configure2({
      maximumDepth: depthLimit,
      maximumBreadth: edgeLimit
    });
    const allFormatters = buildFormatters(
      formatters.level,
      formatters.bindings,
      formatters.log
    );
    const stringifyFn = stringify2.bind({
      [stringifySafeSym]: stringifySafe
    });
    const stringifiers = redact2 ? redaction(redact2, stringifyFn) : {};
    const formatOpts = redact2 ? { stringify: stringifiers[redactFmtSym] } : { stringify: stringifyFn };
    const end = "}" + (crlf ? "\r\n" : "\n");
    const coreChindings = asChindings.bind(null, {
      [chindingsSym]: "",
      [serializersSym]: serializers2,
      [stringifiersSym]: stringifiers,
      [stringifySym]: stringify2,
      [stringifySafeSym]: stringifySafe,
      [formattersSym]: allFormatters
    });
    let chindings = "";
    if (base !== null) {
      if (name2 === void 0) {
        chindings = coreChindings(base);
      } else {
        chindings = coreChindings(Object.assign({}, base, { name: name2 }));
      }
    }
    const time3 = timestamp2 instanceof Function ? timestamp2 : timestamp2 ? epochTime : nullTime;
    const timeSliceIndex = time3().indexOf(":") + 1;
    if (useOnlyCustomLevels && !customLevels) throw Error("customLevels is required if useOnlyCustomLevels is set true");
    if (mixin && typeof mixin !== "function") throw Error(`Unknown mixin type "${typeof mixin}" - expected "function"`);
    if (msgPrefix && typeof msgPrefix !== "string") throw Error(`Unknown msgPrefix type "${typeof msgPrefix}" - expected "string"`);
    assertDefaultLevelFound(level, customLevels, useOnlyCustomLevels);
    const levels2 = mappings(customLevels, useOnlyCustomLevels);
    if (typeof stream2.emit === "function") {
      stream2.emit("message", { code: "PINO_CONFIG", config: { levels: levels2, messageKey, errorKey } });
    }
    assertLevelComparison(levelComparison);
    const levelCompFunc = genLevelComparison(levelComparison);
    Object.assign(instance, {
      levels: levels2,
      [levelCompSym]: levelCompFunc,
      [useOnlyCustomLevelsSym]: useOnlyCustomLevels,
      [streamSym]: stream2,
      [timeSym]: time3,
      [timeSliceIndexSym]: timeSliceIndex,
      [stringifySym]: stringify2,
      [stringifySafeSym]: stringifySafe,
      [stringifiersSym]: stringifiers,
      [endSym]: end,
      [formatOptsSym]: formatOpts,
      [messageKeySym]: messageKey,
      [errorKeySym]: errorKey,
      [nestedKeySym]: nestedKey,
      // protect against injection
      [nestedKeyStrSym]: nestedKey ? `,${JSON.stringify(nestedKey)}:{` : "",
      [serializersSym]: serializers2,
      [mixinSym]: mixin,
      [mixinMergeStrategySym]: mixinMergeStrategy,
      [chindingsSym]: chindings,
      [formattersSym]: allFormatters,
      [hooksSym]: hooks,
      silent: noop2,
      onChild,
      [msgPrefixSym]: msgPrefix
    });
    Object.setPrototypeOf(instance, proto2());
    genLsCache(instance);
    instance[setLevelSym](level);
    return instance;
  }
  pino$1.exports = pino2;
  pino$1.exports.destination = (dest = process.stdout.fd) => {
    if (typeof dest === "object") {
      dest.dest = normalizeDestFileDescriptor(dest.dest || process.stdout.fd);
      return buildSafeSonicBoom(dest);
    } else {
      return buildSafeSonicBoom({ dest: normalizeDestFileDescriptor(dest), minLength: 0 });
    }
  };
  pino$1.exports.transport = requireTransport();
  pino$1.exports.multistream = requireMultistream();
  pino$1.exports.levels = mappings();
  pino$1.exports.stdSerializers = serializers;
  pino$1.exports.stdTimeFunctions = Object.assign({}, time2);
  pino$1.exports.symbols = symbols2;
  pino$1.exports.version = version2;
  pino$1.exports.default = pino2;
  pino$1.exports.pino = pino2;
  return pino$1.exports;
}
var pinoExports = requirePino();
const pino = /* @__PURE__ */ getDefaultExportFromCjs(pinoExports);
class PinoLoggerAdapter {
  logger;
  constructor(config2 = {}) {
    const isDev2 = process.env.NODE_ENV === "development";
    this.logger = pino({
      level: config2.level || "info",
      redact: config2.redact,
      transport: config2.pretty ?? isDev2 ? {
        target: "pino-pretty",
        options: {
          colorize: true,
          ignore: "pid,hostname",
          translateTime: "HH:MM:ss Z"
        }
      } : void 0
    });
  }
  debug(msg, ...args) {
    this.logger.debug(msg, ...args);
  }
  info(msg, ...args) {
    this.logger.info(msg, ...args);
  }
  warn(msg, ...args) {
    this.logger.warn(msg, ...args);
  }
  error(msg, ...args) {
    this.logger.error(msg, ...args);
  }
  child(bindings) {
    const childAdapter = new PinoLoggerAdapter();
    childAdapter.logger = this.logger.child(bindings);
    return childAdapter;
  }
}
class LoggerService {
  adapter;
  constructor(config2 = {}) {
    if ("adapter" in config2 && config2.adapter) {
      this.adapter = config2.adapter;
    } else {
      this.adapter = new PinoLoggerAdapter(config2);
    }
  }
  debug(msg, ...args) {
    this.adapter.debug(msg, ...args);
  }
  info(msg, ...args) {
    this.adapter.info(msg, ...args);
  }
  warn(msg, ...args) {
    this.adapter.warn(msg, ...args);
  }
  error(msg, ...args) {
    this.adapter.error(msg, ...args);
  }
  child(bindings) {
    const childAdapter = this.adapter.child(bindings);
    return new LoggerService({ adapter: childAdapter });
  }
}
class MailAdapter {
}
var ElementType;
(function(ElementType2) {
  ElementType2["Root"] = "root";
  ElementType2["Text"] = "text";
  ElementType2["Directive"] = "directive";
  ElementType2["Comment"] = "comment";
  ElementType2["Script"] = "script";
  ElementType2["Style"] = "style";
  ElementType2["Tag"] = "tag";
  ElementType2["CDATA"] = "cdata";
  ElementType2["Doctype"] = "doctype";
})(ElementType || (ElementType = {}));
function isTag$1(elem) {
  return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
}
const Root = ElementType.Root;
const Text$1 = ElementType.Text;
const Directive = ElementType.Directive;
const Comment$1 = ElementType.Comment;
const Script = ElementType.Script;
const Style = ElementType.Style;
const Tag = ElementType.Tag;
const CDATA$1 = ElementType.CDATA;
const Doctype = ElementType.Doctype;
class Node {
  constructor() {
    this.parent = null;
    this.prev = null;
    this.next = null;
    this.startIndex = null;
    this.endIndex = null;
  }
  // Read-write aliases for properties
  /**
   * Same as {@link parent}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get parentNode() {
    return this.parent;
  }
  set parentNode(parent) {
    this.parent = parent;
  }
  /**
   * Same as {@link prev}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get previousSibling() {
    return this.prev;
  }
  set previousSibling(prev) {
    this.prev = prev;
  }
  /**
   * Same as {@link next}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get nextSibling() {
    return this.next;
  }
  set nextSibling(next2) {
    this.next = next2;
  }
  /**
   * Clone this node, and optionally its children.
   *
   * @param recursive Clone child nodes as well.
   * @returns A clone of the node.
   */
  cloneNode(recursive = false) {
    return cloneNode(this, recursive);
  }
}
class DataNode extends Node {
  /**
   * @param data The content of the data node
   */
  constructor(data) {
    super();
    this.data = data;
  }
  /**
   * Same as {@link data}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get nodeValue() {
    return this.data;
  }
  set nodeValue(data) {
    this.data = data;
  }
}
class Text extends DataNode {
  constructor() {
    super(...arguments);
    this.type = ElementType.Text;
  }
  get nodeType() {
    return 3;
  }
}
class Comment extends DataNode {
  constructor() {
    super(...arguments);
    this.type = ElementType.Comment;
  }
  get nodeType() {
    return 8;
  }
}
class ProcessingInstruction extends DataNode {
  constructor(name2, data) {
    super(data);
    this.name = name2;
    this.type = ElementType.Directive;
  }
  get nodeType() {
    return 1;
  }
}
class NodeWithChildren extends Node {
  /**
   * @param children Children of the node. Only certain node types can have children.
   */
  constructor(children) {
    super();
    this.children = children;
  }
  // Aliases
  /** First child of the node. */
  get firstChild() {
    var _a2;
    return (_a2 = this.children[0]) !== null && _a2 !== void 0 ? _a2 : null;
  }
  /** Last child of the node. */
  get lastChild() {
    return this.children.length > 0 ? this.children[this.children.length - 1] : null;
  }
  /**
   * Same as {@link children}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get childNodes() {
    return this.children;
  }
  set childNodes(children) {
    this.children = children;
  }
}
class CDATA extends NodeWithChildren {
  constructor() {
    super(...arguments);
    this.type = ElementType.CDATA;
  }
  get nodeType() {
    return 4;
  }
}
class Document extends NodeWithChildren {
  constructor() {
    super(...arguments);
    this.type = ElementType.Root;
  }
  get nodeType() {
    return 9;
  }
}
class Element extends NodeWithChildren {
  /**
   * @param name Name of the tag, eg. `div`, `span`.
   * @param attribs Object mapping attribute names to attribute values.
   * @param children Children of the node.
   */
  constructor(name2, attribs, children = [], type2 = name2 === "script" ? ElementType.Script : name2 === "style" ? ElementType.Style : ElementType.Tag) {
    super(children);
    this.name = name2;
    this.attribs = attribs;
    this.type = type2;
  }
  get nodeType() {
    return 1;
  }
  // DOM Level 1 aliases
  /**
   * Same as {@link name}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get tagName() {
    return this.name;
  }
  set tagName(name2) {
    this.name = name2;
  }
  get attributes() {
    return Object.keys(this.attribs).map((name2) => {
      var _a2, _b;
      return {
        name: name2,
        value: this.attribs[name2],
        namespace: (_a2 = this["x-attribsNamespace"]) === null || _a2 === void 0 ? void 0 : _a2[name2],
        prefix: (_b = this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name2]
      };
    });
  }
}
function isTag(node) {
  return isTag$1(node);
}
function isCDATA(node) {
  return node.type === ElementType.CDATA;
}
function isText(node) {
  return node.type === ElementType.Text;
}
function isComment(node) {
  return node.type === ElementType.Comment;
}
function isDirective(node) {
  return node.type === ElementType.Directive;
}
function isDocument(node) {
  return node.type === ElementType.Root;
}
function cloneNode(node, recursive = false) {
  let result2;
  if (isText(node)) {
    result2 = new Text(node.data);
  } else if (isComment(node)) {
    result2 = new Comment(node.data);
  } else if (isTag(node)) {
    const children = recursive ? cloneChildren(node.children) : [];
    const clone2 = new Element(node.name, { ...node.attribs }, children);
    children.forEach((child) => child.parent = clone2);
    if (node.namespace != null) {
      clone2.namespace = node.namespace;
    }
    if (node["x-attribsNamespace"]) {
      clone2["x-attribsNamespace"] = { ...node["x-attribsNamespace"] };
    }
    if (node["x-attribsPrefix"]) {
      clone2["x-attribsPrefix"] = { ...node["x-attribsPrefix"] };
    }
    result2 = clone2;
  } else if (isCDATA(node)) {
    const children = recursive ? cloneChildren(node.children) : [];
    const clone2 = new CDATA(children);
    children.forEach((child) => child.parent = clone2);
    result2 = clone2;
  } else if (isDocument(node)) {
    const children = recursive ? cloneChildren(node.children) : [];
    const clone2 = new Document(children);
    children.forEach((child) => child.parent = clone2);
    if (node["x-mode"]) {
      clone2["x-mode"] = node["x-mode"];
    }
    result2 = clone2;
  } else if (isDirective(node)) {
    const instruction = new ProcessingInstruction(node.name, node.data);
    if (node["x-name"] != null) {
      instruction["x-name"] = node["x-name"];
      instruction["x-publicId"] = node["x-publicId"];
      instruction["x-systemId"] = node["x-systemId"];
    }
    result2 = instruction;
  } else {
    throw new Error(`Not implemented yet: ${node.type}`);
  }
  result2.startIndex = node.startIndex;
  result2.endIndex = node.endIndex;
  if (node.sourceCodeLocation != null) {
    result2.sourceCodeLocation = node.sourceCodeLocation;
  }
  return result2;
}
function cloneChildren(childs) {
  const children = childs.map((child) => cloneNode(child, true));
  for (let i = 1; i < children.length; i++) {
    children[i].prev = children[i - 1];
    children[i - 1].next = children[i];
  }
  return children;
}
const defaultOpts = {
  withStartIndices: false,
  withEndIndices: false,
  xmlMode: false
};
class DomHandler {
  /**
   * @param callback Called once parsing has completed.
   * @param options Settings for the handler.
   * @param elementCB Callback whenever a tag is closed.
   */
  constructor(callback, options, elementCB) {
    this.dom = [];
    this.root = new Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
    if (typeof options === "function") {
      elementCB = options;
      options = defaultOpts;
    }
    if (typeof callback === "object") {
      options = callback;
      callback = void 0;
    }
    this.callback = callback !== null && callback !== void 0 ? callback : null;
    this.options = options !== null && options !== void 0 ? options : defaultOpts;
    this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
  }
  onparserinit(parser2) {
    this.parser = parser2;
  }
  // Resets the handler back to starting state
  onreset() {
    this.dom = [];
    this.root = new Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
  }
  // Signals the handler that parsing is done
  onend() {
    if (this.done)
      return;
    this.done = true;
    this.parser = null;
    this.handleCallback(null);
  }
  onerror(error2) {
    this.handleCallback(error2);
  }
  onclosetag() {
    this.lastNode = null;
    const elem = this.tagStack.pop();
    if (this.options.withEndIndices) {
      elem.endIndex = this.parser.endIndex;
    }
    if (this.elementCB)
      this.elementCB(elem);
  }
  onopentag(name2, attribs) {
    const type2 = this.options.xmlMode ? ElementType.Tag : void 0;
    const element = new Element(name2, attribs, void 0, type2);
    this.addNode(element);
    this.tagStack.push(element);
  }
  ontext(data) {
    const { lastNode } = this;
    if (lastNode && lastNode.type === ElementType.Text) {
      lastNode.data += data;
      if (this.options.withEndIndices) {
        lastNode.endIndex = this.parser.endIndex;
      }
    } else {
      const node = new Text(data);
      this.addNode(node);
      this.lastNode = node;
    }
  }
  oncomment(data) {
    if (this.lastNode && this.lastNode.type === ElementType.Comment) {
      this.lastNode.data += data;
      return;
    }
    const node = new Comment(data);
    this.addNode(node);
    this.lastNode = node;
  }
  oncommentend() {
    this.lastNode = null;
  }
  oncdatastart() {
    const text2 = new Text("");
    const node = new CDATA([text2]);
    this.addNode(node);
    text2.parent = node;
    this.lastNode = text2;
  }
  oncdataend() {
    this.lastNode = null;
  }
  onprocessinginstruction(name2, data) {
    const node = new ProcessingInstruction(name2, data);
    this.addNode(node);
  }
  handleCallback(error2) {
    if (typeof this.callback === "function") {
      this.callback(error2, this.dom);
    } else if (error2) {
      throw error2;
    }
  }
  addNode(node) {
    const parent = this.tagStack[this.tagStack.length - 1];
    const previousSibling = parent.children[parent.children.length - 1];
    if (this.options.withStartIndices) {
      node.startIndex = this.parser.startIndex;
    }
    if (this.options.withEndIndices) {
      node.endIndex = this.parser.endIndex;
    }
    parent.children.push(node);
    if (previousSibling) {
      node.prev = previousSibling;
      previousSibling.next = node;
    }
    node.parent = parent;
    this.lastNode = null;
  }
}
const e = /\n/g;
function n$1(n2) {
  const o2 = [...n2.matchAll(e)].map(((e2) => e2.index || 0));
  o2.unshift(-1);
  const s2 = t(o2, 0, o2.length);
  return (e2) => r$1(s2, e2);
}
function t(e2, n2, r2) {
  if (r2 - n2 == 1) return { offset: e2[n2], index: n2 + 1 };
  const o2 = Math.ceil((n2 + r2) / 2), s2 = t(e2, n2, o2), l2 = t(e2, o2, r2);
  return { offset: s2.offset, low: s2, high: l2 };
}
function r$1(e2, n2) {
  return (function(e3) {
    return Object.prototype.hasOwnProperty.call(e3, "index");
  })(e2) ? { line: e2.index, column: n2 - e2.offset } : r$1(e2.high.offset < n2 ? e2.high : e2.low, n2);
}
function o(e2, t2 = "", r2 = {}) {
  const o2 = "string" != typeof t2 ? t2 : r2, l2 = "string" == typeof t2 ? t2 : "", c2 = e2.map(s$1), f = !!o2.lineNumbers;
  return function(e3, t3 = 0) {
    const r3 = f ? n$1(e3) : () => ({ line: 0, column: 0 });
    let o3 = t3;
    const s2 = [];
    e: for (; o3 < e3.length; ) {
      let n2 = false;
      for (const t4 of c2) {
        t4.regex.lastIndex = o3;
        const c3 = t4.regex.exec(e3);
        if (c3 && c3[0].length > 0) {
          if (!t4.discard) {
            const e4 = r3(o3), n3 = "string" == typeof t4.replace ? c3[0].replace(new RegExp(t4.regex.source, t4.regex.flags), t4.replace) : c3[0];
            s2.push({ state: l2, name: t4.name, text: n3, offset: o3, len: c3[0].length, line: e4.line, column: e4.column });
          }
          if (o3 = t4.regex.lastIndex, n2 = true, t4.push) {
            const n3 = t4.push(e3, o3);
            s2.push(...n3.tokens), o3 = n3.offset;
          }
          if (t4.pop) break e;
          break;
        }
      }
      if (!n2) break;
    }
    return { tokens: s2, offset: o3, complete: e3.length <= o3 };
  };
}
function s$1(e2, n2) {
  return { ...e2, regex: l$1(e2, n2) };
}
function l$1(e2, n2) {
  if (0 === e2.name.length) throw new Error(`Rule #${n2} has empty name, which is not allowed.`);
  if ((function(e3) {
    return Object.prototype.hasOwnProperty.call(e3, "regex");
  })(e2)) return (function(e3) {
    if (e3.global) throw new Error(`Regular expression /${e3.source}/${e3.flags} contains the global flag, which is not allowed.`);
    return e3.sticky ? e3 : new RegExp(e3.source, e3.flags + "y");
  })(e2.regex);
  if ((function(e3) {
    return Object.prototype.hasOwnProperty.call(e3, "str");
  })(e2)) {
    if (0 === e2.str.length) throw new Error(`Rule #${n2} ("${e2.name}") has empty "str" property, which is not allowed.`);
    return new RegExp(c(e2.str), "y");
  }
  return new RegExp(c(e2.name), "y");
}
function c(e2) {
  return e2.replace(/[-[\]{}()*+!<=:?./\\^$|#\s,]/g, "\\$&");
}
function token(onToken, onEnd) {
  return (data, i) => {
    let position = i;
    let value = void 0;
    if (i < data.tokens.length) {
      value = onToken(data.tokens[i], data, i);
      if (value !== void 0) {
        position++;
      }
    }
    return value === void 0 ? { matched: false } : {
      matched: true,
      position,
      value
    };
  };
}
function mapInner(r2, f) {
  return r2.matched ? {
    matched: true,
    position: r2.position,
    value: f(r2.value, r2.position)
  } : r2;
}
function mapOuter(r2, f) {
  return r2.matched ? f(r2) : r2;
}
function map(p, mapper) {
  return (data, i) => mapInner(p(data, i), (v, j) => mapper(v, data, i, j));
}
function option(p, def) {
  return (data, i) => {
    const r2 = p(data, i);
    return r2.matched ? r2 : {
      matched: true,
      position: i,
      value: def
    };
  };
}
function choice(...ps) {
  return (data, i) => {
    for (const p of ps) {
      const result2 = p(data, i);
      if (result2.matched) {
        return result2;
      }
    }
    return { matched: false };
  };
}
function otherwise(pa, pb) {
  return (data, i) => {
    const r1 = pa(data, i);
    return r1.matched ? r1 : pb(data, i);
  };
}
function takeWhile(p, test) {
  return (data, i) => {
    const values = [];
    let success = true;
    do {
      const r2 = p(data, i);
      if (r2.matched && test(r2.value, values.length + 1, data, i, r2.position)) {
        values.push(r2.value);
        i = r2.position;
      } else {
        success = false;
      }
    } while (success);
    return {
      matched: true,
      position: i,
      value: values
    };
  };
}
function many(p) {
  return takeWhile(p, () => true);
}
function many1(p) {
  return ab(p, many(p), (head, tail) => [head, ...tail]);
}
function ab(pa, pb, join2) {
  return (data, i) => mapOuter(pa(data, i), (ma) => mapInner(pb(data, ma.position), (vb, j) => join2(ma.value, vb, data, i, j)));
}
function left(pa, pb) {
  return ab(pa, pb, (va) => va);
}
function right(pa, pb) {
  return ab(pa, pb, (va, vb) => vb);
}
function abc(pa, pb, pc, join2) {
  return (data, i) => mapOuter(pa(data, i), (ma) => mapOuter(pb(data, ma.position), (mb) => mapInner(pc(data, mb.position), (vc, j) => join2(ma.value, mb.value, vc, data, i, j))));
}
function middle(pa, pb, pc) {
  return abc(pa, pb, pc, (ra, rb) => rb);
}
function all(...ps) {
  return (data, i) => {
    const result2 = [];
    let position = i;
    for (const p of ps) {
      const r1 = p(data, position);
      if (r1.matched) {
        result2.push(r1.value);
        position = r1.position;
      } else {
        return { matched: false };
      }
    }
    return {
      matched: true,
      position,
      value: result2
    };
  };
}
function flatten$1(...ps) {
  return flatten1(all(...ps));
}
function flatten1(p) {
  return map(p, (vs) => vs.flatMap((v) => v));
}
function chainReduce(acc, f) {
  return (data, i) => {
    let loop = true;
    let acc1 = acc;
    let pos = i;
    do {
      const r2 = f(acc1, data, pos)(data, pos);
      if (r2.matched) {
        acc1 = r2.value;
        pos = r2.position;
      } else {
        loop = false;
      }
    } while (loop);
    return {
      matched: true,
      position: pos,
      value: acc1
    };
  };
}
function reduceLeft(acc, p, reducer) {
  return chainReduce(acc, (acc2) => map(p, (v, data, i, j) => reducer(acc2, v, data, i, j)));
}
function leftAssoc2(pLeft, pOper, pRight) {
  return chain(pLeft, (v0) => reduceLeft(v0, ab(pOper, pRight, (f, y) => [f, y]), (acc, [f, y]) => f(acc, y)));
}
function chain(p, f) {
  return (data, i) => mapOuter(p(data, i), (m1) => f(m1.value, data, i, m1.position)(data, m1.position));
}
const ws = `(?:[ \\t\\r\\n\\f]*)`;
const nl = `(?:\\n|\\r\\n|\\r|\\f)`;
const nonascii = `[^\\x00-\\x7F]`;
const unicode = `(?:\\\\[0-9a-f]{1,6}(?:\\r\\n|[ \\n\\r\\t\\f])?)`;
const escape$1 = `(?:\\\\[^\\n\\r\\f0-9a-f])`;
const nmstart = `(?:[_a-z]|${nonascii}|${unicode}|${escape$1})`;
const nmchar = `(?:[_a-z0-9-]|${nonascii}|${unicode}|${escape$1})`;
const name$1 = `(?:${nmchar}+)`;
const ident = `(?:[-]?${nmstart}${nmchar}*)`;
const string1 = `'([^\\n\\r\\f\\\\']|\\\\${nl}|${nonascii}|${unicode}|${escape$1})*'`;
const string2 = `"([^\\n\\r\\f\\\\"]|\\\\${nl}|${nonascii}|${unicode}|${escape$1})*"`;
const lexSelector = o([
  { name: "ws", regex: new RegExp(ws) },
  { name: "hash", regex: new RegExp(`#${name$1}`, "i") },
  { name: "ident", regex: new RegExp(ident, "i") },
  { name: "str1", regex: new RegExp(string1, "i") },
  { name: "str2", regex: new RegExp(string2, "i") },
  { name: "*" },
  { name: "." },
  { name: "," },
  { name: "[" },
  { name: "]" },
  { name: "=" },
  { name: ">" },
  { name: "|" },
  { name: "+" },
  { name: "~" },
  { name: "^" },
  { name: "$" }
]);
const lexEscapedString = o([
  { name: "unicode", regex: new RegExp(unicode, "i") },
  { name: "escape", regex: new RegExp(escape$1, "i") },
  { name: "any", regex: new RegExp("[\\s\\S]", "i") }
]);
function sumSpec([a0, a1, a2], [b0, b1, b2]) {
  return [a0 + b0, a1 + b1, a2 + b2];
}
function sumAllSpec(ss) {
  return ss.reduce(sumSpec, [0, 0, 0]);
}
const unicodeEscapedSequence_ = token((t2) => t2.name === "unicode" ? String.fromCodePoint(parseInt(t2.text.slice(1), 16)) : void 0);
const escapedSequence_ = token((t2) => t2.name === "escape" ? t2.text.slice(1) : void 0);
const anyChar_ = token((t2) => t2.name === "any" ? t2.text : void 0);
const escapedString_ = map(many(choice(unicodeEscapedSequence_, escapedSequence_, anyChar_)), (cs2) => cs2.join(""));
function unescape$1(escapedString) {
  const lexerResult = lexEscapedString(escapedString);
  const result2 = escapedString_({ tokens: lexerResult.tokens, options: void 0 }, 0);
  return result2.value;
}
function literal(name2) {
  return token((t2) => t2.name === name2 ? true : void 0);
}
const whitespace_ = token((t2) => t2.name === "ws" ? null : void 0);
const optionalWhitespace_ = option(whitespace_, null);
function optionallySpaced(parser2) {
  return middle(optionalWhitespace_, parser2, optionalWhitespace_);
}
const identifier_ = token((t2) => t2.name === "ident" ? unescape$1(t2.text) : void 0);
const hashId_ = token((t2) => t2.name === "hash" ? unescape$1(t2.text.slice(1)) : void 0);
const string_ = token((t2) => t2.name.startsWith("str") ? unescape$1(t2.text.slice(1, -1)) : void 0);
const namespace_ = left(option(identifier_, ""), literal("|"));
const qualifiedName_ = otherwise(ab(namespace_, identifier_, (ns, name2) => ({ name: name2, namespace: ns })), map(identifier_, (name2) => ({ name: name2, namespace: null })));
const uniSelector_ = otherwise(ab(namespace_, literal("*"), (ns) => ({ type: "universal", namespace: ns, specificity: [0, 0, 0] })), map(literal("*"), () => ({ type: "universal", namespace: null, specificity: [0, 0, 0] })));
const tagSelector_ = map(qualifiedName_, ({ name: name2, namespace }) => ({
  type: "tag",
  name: name2,
  namespace,
  specificity: [0, 0, 1]
}));
const classSelector_ = ab(literal("."), identifier_, (fullstop, name2) => ({
  type: "class",
  name: name2,
  specificity: [0, 1, 0]
}));
const idSelector_ = map(hashId_, (name2) => ({
  type: "id",
  name: name2,
  specificity: [1, 0, 0]
}));
const attrModifier_ = token((t2) => {
  if (t2.name === "ident") {
    if (t2.text === "i" || t2.text === "I") {
      return "i";
    }
    if (t2.text === "s" || t2.text === "S") {
      return "s";
    }
  }
  return void 0;
});
const attrValue_ = otherwise(ab(string_, option(right(optionalWhitespace_, attrModifier_), null), (v, mod) => ({ value: v, modifier: mod })), ab(identifier_, option(right(whitespace_, attrModifier_), null), (v, mod) => ({ value: v, modifier: mod })));
const attrMatcher_ = choice(map(literal("="), () => "="), ab(literal("~"), literal("="), () => "~="), ab(literal("|"), literal("="), () => "|="), ab(literal("^"), literal("="), () => "^="), ab(literal("$"), literal("="), () => "$="), ab(literal("*"), literal("="), () => "*="));
const attrPresenceSelector_ = abc(literal("["), optionallySpaced(qualifiedName_), literal("]"), (lbr, { name: name2, namespace }) => ({
  type: "attrPresence",
  name: name2,
  namespace,
  specificity: [0, 1, 0]
}));
const attrValueSelector_ = middle(literal("["), abc(optionallySpaced(qualifiedName_), attrMatcher_, optionallySpaced(attrValue_), ({ name: name2, namespace }, matcher, { value, modifier }) => ({
  type: "attrValue",
  name: name2,
  namespace,
  matcher,
  value,
  modifier,
  specificity: [0, 1, 0]
})), literal("]"));
const attrSelector_ = otherwise(attrPresenceSelector_, attrValueSelector_);
const typeSelector_ = otherwise(uniSelector_, tagSelector_);
const subclassSelector_ = choice(idSelector_, classSelector_, attrSelector_);
const compoundSelector_ = map(otherwise(flatten$1(typeSelector_, many(subclassSelector_)), many1(subclassSelector_)), (ss) => {
  return {
    type: "compound",
    list: ss,
    specificity: sumAllSpec(ss.map((s2) => s2.specificity))
  };
});
const combinator_ = choice(map(literal(">"), () => ">"), map(literal("+"), () => "+"), map(literal("~"), () => "~"), ab(literal("|"), literal("|"), () => "||"));
const combinatorSeparator_ = otherwise(optionallySpaced(combinator_), map(whitespace_, () => " "));
const complexSelector_ = leftAssoc2(compoundSelector_, map(combinatorSeparator_, (c2) => (left2, right2) => ({
  type: "compound",
  list: [...right2.list, { type: "combinator", combinator: c2, left: left2, specificity: left2.specificity }],
  specificity: sumSpec(left2.specificity, right2.specificity)
})), compoundSelector_);
function parse_(parser2, str) {
  if (!(typeof str === "string" || str instanceof String)) {
    throw new Error("Expected a selector string. Actual input is not a string!");
  }
  const lexerResult = lexSelector(str);
  if (!lexerResult.complete) {
    throw new Error(`The input "${str}" was only partially tokenized, stopped at offset ${lexerResult.offset}!
` + prettyPrintPosition(str, lexerResult.offset));
  }
  const result2 = optionallySpaced(parser2)({ tokens: lexerResult.tokens, options: void 0 }, 0);
  if (!result2.matched) {
    throw new Error(`No match for "${str}" input!`);
  }
  if (result2.position < lexerResult.tokens.length) {
    const token2 = lexerResult.tokens[result2.position];
    throw new Error(`The input "${str}" was only partially parsed, stopped at offset ${token2.offset}!
` + prettyPrintPosition(str, token2.offset, token2.len));
  }
  return result2.value;
}
function prettyPrintPosition(str, offset2, len = 1) {
  return `${str.replace(/(\t)|(\r)|(\n)/g, (m, t2, r2) => t2 ? "" : r2 ? "" : "")}
${"".padEnd(offset2)}${"^".repeat(len)}`;
}
function parse1(str) {
  return parse_(complexSelector_, str);
}
function serialize$1(selector) {
  if (!selector.type) {
    throw new Error("This is not an AST node.");
  }
  switch (selector.type) {
    case "universal":
      return _serNs(selector.namespace) + "*";
    case "tag":
      return _serNs(selector.namespace) + _serIdent(selector.name);
    case "class":
      return "." + _serIdent(selector.name);
    case "id":
      return "#" + _serIdent(selector.name);
    case "attrPresence":
      return `[${_serNs(selector.namespace)}${_serIdent(selector.name)}]`;
    case "attrValue":
      return `[${_serNs(selector.namespace)}${_serIdent(selector.name)}${selector.matcher}"${_serStr(selector.value)}"${selector.modifier ? selector.modifier : ""}]`;
    case "combinator":
      return serialize$1(selector.left) + selector.combinator;
    case "compound":
      return selector.list.reduce((acc, node) => {
        if (node.type === "combinator") {
          return serialize$1(node) + acc;
        } else {
          return acc + serialize$1(node);
        }
      }, "");
    case "list":
      return selector.list.map(serialize$1).join(",");
  }
}
function _serNs(ns) {
  return ns || ns === "" ? _serIdent(ns) + "|" : "";
}
function _codePoint(char2) {
  return `\\${char2.codePointAt(0).toString(16)} `;
}
function _serIdent(str) {
  return str.replace(
    /(^[0-9])|(^-[0-9])|(^-$)|([-0-9a-zA-Z_]|[^\x00-\x7F])|(\x00)|([\x01-\x1f]|\x7f)|([\s\S])/g,
    (m, d1, d2, hy, safe, nl2, ctrl, other) => d1 ? _codePoint(d1) : d2 ? "-" + _codePoint(d2.slice(1)) : hy ? "\\-" : safe ? safe : nl2 ? "" : ctrl ? _codePoint(ctrl) : "\\" + other
  );
}
function _serStr(str) {
  return str.replace(
    /(")|(\\)|(\x00)|([\x01-\x1f]|\x7f)/g,
    (m, dq, bs, nl2, ctrl) => dq ? '\\"' : bs ? "\\\\" : nl2 ? "" : _codePoint(ctrl)
  );
}
function normalize(selector) {
  if (!selector.type) {
    throw new Error("This is not an AST node.");
  }
  switch (selector.type) {
    case "compound": {
      selector.list.forEach(normalize);
      selector.list.sort((a, b) => _compareArrays(_getSelectorPriority(a), _getSelectorPriority(b)));
      break;
    }
    case "combinator": {
      normalize(selector.left);
      break;
    }
    case "list": {
      selector.list.forEach(normalize);
      selector.list.sort((a, b) => serialize$1(a) < serialize$1(b) ? -1 : 1);
      break;
    }
  }
  return selector;
}
function _getSelectorPriority(selector) {
  switch (selector.type) {
    case "universal":
      return [1];
    case "tag":
      return [1];
    case "id":
      return [2];
    case "class":
      return [3, selector.name];
    case "attrPresence":
      return [4, serialize$1(selector)];
    case "attrValue":
      return [5, serialize$1(selector)];
    case "combinator":
      return [15, serialize$1(selector)];
  }
}
function compareSpecificity(a, b) {
  return _compareArrays(a, b);
}
function _compareArrays(a, b) {
  if (!Array.isArray(a) || !Array.isArray(b)) {
    throw new Error("Arguments must be arrays.");
  }
  const shorter = a.length < b.length ? a.length : b.length;
  for (let i = 0; i < shorter; i++) {
    if (a[i] === b[i]) {
      continue;
    }
    return a[i] < b[i] ? -1 : 1;
  }
  return a.length - b.length;
}
class DecisionTree {
  constructor(input) {
    this.branches = weave(toAstTerminalPairs(input));
  }
  build(builder) {
    return builder(this.branches);
  }
}
function toAstTerminalPairs(array) {
  const len = array.length;
  const results = new Array(len);
  for (let i = 0; i < len; i++) {
    const [selectorString, val] = array[i];
    const ast = preprocess(parse1(selectorString));
    results[i] = {
      ast,
      terminal: {
        type: "terminal",
        valueContainer: { index: i, value: val, specificity: ast.specificity }
      }
    };
  }
  return results;
}
function preprocess(ast) {
  reduceSelectorVariants(ast);
  normalize(ast);
  return ast;
}
function reduceSelectorVariants(ast) {
  const newList = [];
  ast.list.forEach((sel) => {
    switch (sel.type) {
      case "class":
        newList.push({
          matcher: "~=",
          modifier: null,
          name: "class",
          namespace: null,
          specificity: sel.specificity,
          type: "attrValue",
          value: sel.name
        });
        break;
      case "id":
        newList.push({
          matcher: "=",
          modifier: null,
          name: "id",
          namespace: null,
          specificity: sel.specificity,
          type: "attrValue",
          value: sel.name
        });
        break;
      case "combinator":
        reduceSelectorVariants(sel.left);
        newList.push(sel);
        break;
      case "universal":
        break;
      default:
        newList.push(sel);
        break;
    }
  });
  ast.list = newList;
}
function weave(items) {
  const branches = [];
  while (items.length) {
    const topKind = findTopKey(items, (sel) => true, getSelectorKind);
    const { matches, nonmatches, empty: empty2 } = breakByKind(items, topKind);
    items = nonmatches;
    if (matches.length) {
      branches.push(branchOfKind(topKind, matches));
    }
    if (empty2.length) {
      branches.push(...terminate(empty2));
    }
  }
  return branches;
}
function terminate(items) {
  const results = [];
  for (const item of items) {
    const terminal = item.terminal;
    if (terminal.type === "terminal") {
      results.push(terminal);
    } else {
      const { matches, rest } = partition(terminal.cont, (node) => node.type === "terminal");
      matches.forEach((node) => results.push(node));
      if (rest.length) {
        terminal.cont = rest;
        results.push(terminal);
      }
    }
  }
  return results;
}
function breakByKind(items, selectedKind) {
  const matches = [];
  const nonmatches = [];
  const empty2 = [];
  for (const item of items) {
    const simpsels = item.ast.list;
    if (simpsels.length) {
      const isMatch2 = simpsels.some((node) => getSelectorKind(node) === selectedKind);
      (isMatch2 ? matches : nonmatches).push(item);
    } else {
      empty2.push(item);
    }
  }
  return { matches, nonmatches, empty: empty2 };
}
function getSelectorKind(sel) {
  switch (sel.type) {
    case "attrPresence":
      return `attrPresence ${sel.name}`;
    case "attrValue":
      return `attrValue ${sel.name}`;
    case "combinator":
      return `combinator ${sel.combinator}`;
    default:
      return sel.type;
  }
}
function branchOfKind(kind, items) {
  if (kind === "tag") {
    return tagNameBranch(items);
  }
  if (kind.startsWith("attrValue ")) {
    return attrValueBranch(kind.substring(10), items);
  }
  if (kind.startsWith("attrPresence ")) {
    return attrPresenceBranch(kind.substring(13), items);
  }
  if (kind === "combinator >") {
    return combinatorBranch(">", items);
  }
  if (kind === "combinator +") {
    return combinatorBranch("+", items);
  }
  throw new Error(`Unsupported selector kind: ${kind}`);
}
function tagNameBranch(items) {
  const groups = spliceAndGroup(items, (x) => x.type === "tag", (x) => x.name);
  const variants = Object.entries(groups).map(([name2, group]) => ({
    type: "variant",
    value: name2,
    cont: weave(group.items)
  }));
  return {
    type: "tagName",
    variants
  };
}
function attrPresenceBranch(name2, items) {
  for (const item of items) {
    spliceSimpleSelector(item, (x) => x.type === "attrPresence" && x.name === name2);
  }
  return {
    type: "attrPresence",
    name: name2,
    cont: weave(items)
  };
}
function attrValueBranch(name2, items) {
  const groups = spliceAndGroup(items, (x) => x.type === "attrValue" && x.name === name2, (x) => `${x.matcher} ${x.modifier || ""} ${x.value}`);
  const matchers = [];
  for (const group of Object.values(groups)) {
    const sel = group.oneSimpleSelector;
    const predicate = getAttrPredicate(sel);
    const continuation = weave(group.items);
    matchers.push({
      type: "matcher",
      matcher: sel.matcher,
      modifier: sel.modifier,
      value: sel.value,
      predicate,
      cont: continuation
    });
  }
  return {
    type: "attrValue",
    name: name2,
    matchers
  };
}
function getAttrPredicate(sel) {
  if (sel.modifier === "i") {
    const expected = sel.value.toLowerCase();
    switch (sel.matcher) {
      case "=":
        return (actual) => expected === actual.toLowerCase();
      case "~=":
        return (actual) => actual.toLowerCase().split(/[ \t]+/).includes(expected);
      case "^=":
        return (actual) => actual.toLowerCase().startsWith(expected);
      case "$=":
        return (actual) => actual.toLowerCase().endsWith(expected);
      case "*=":
        return (actual) => actual.toLowerCase().includes(expected);
      case "|=":
        return (actual) => {
          const lower = actual.toLowerCase();
          return expected === lower || lower.startsWith(expected) && lower[expected.length] === "-";
        };
    }
  } else {
    const expected = sel.value;
    switch (sel.matcher) {
      case "=":
        return (actual) => expected === actual;
      case "~=":
        return (actual) => actual.split(/[ \t]+/).includes(expected);
      case "^=":
        return (actual) => actual.startsWith(expected);
      case "$=":
        return (actual) => actual.endsWith(expected);
      case "*=":
        return (actual) => actual.includes(expected);
      case "|=":
        return (actual) => expected === actual || actual.startsWith(expected) && actual[expected.length] === "-";
    }
  }
}
function combinatorBranch(combinator, items) {
  const groups = spliceAndGroup(items, (x) => x.type === "combinator" && x.combinator === combinator, (x) => serialize$1(x.left));
  const leftItems = [];
  for (const group of Object.values(groups)) {
    const rightCont = weave(group.items);
    const leftAst = group.oneSimpleSelector.left;
    leftItems.push({
      ast: leftAst,
      terminal: { type: "popElement", cont: rightCont }
    });
  }
  return {
    type: "pushElement",
    combinator,
    cont: weave(leftItems)
  };
}
function spliceAndGroup(items, predicate, keyCallback) {
  const groups = {};
  while (items.length) {
    const bestKey = findTopKey(items, predicate, keyCallback);
    const bestKeyPredicate = (sel) => predicate(sel) && keyCallback(sel) === bestKey;
    const hasBestKeyPredicate = (item) => item.ast.list.some(bestKeyPredicate);
    const { matches, rest } = partition1(items, hasBestKeyPredicate);
    let oneSimpleSelector = null;
    for (const item of matches) {
      const splicedNode = spliceSimpleSelector(item, bestKeyPredicate);
      if (!oneSimpleSelector) {
        oneSimpleSelector = splicedNode;
      }
    }
    if (oneSimpleSelector == null) {
      throw new Error("No simple selector is found.");
    }
    groups[bestKey] = { oneSimpleSelector, items: matches };
    items = rest;
  }
  return groups;
}
function spliceSimpleSelector(item, predicate) {
  const simpsels = item.ast.list;
  const matches = new Array(simpsels.length);
  let firstIndex = -1;
  for (let i = simpsels.length; i-- > 0; ) {
    if (predicate(simpsels[i])) {
      matches[i] = true;
      firstIndex = i;
    }
  }
  if (firstIndex == -1) {
    throw new Error(`Couldn't find the required simple selector.`);
  }
  const result2 = simpsels[firstIndex];
  item.ast.list = simpsels.filter((sel, i) => !matches[i]);
  return result2;
}
function findTopKey(items, predicate, keyCallback) {
  const candidates = {};
  for (const item of items) {
    const candidates1 = {};
    for (const node of item.ast.list.filter(predicate)) {
      candidates1[keyCallback(node)] = true;
    }
    for (const key of Object.keys(candidates1)) {
      if (candidates[key]) {
        candidates[key]++;
      } else {
        candidates[key] = 1;
      }
    }
  }
  let topKind = "";
  let topCounter = 0;
  for (const entry of Object.entries(candidates)) {
    if (entry[1] > topCounter) {
      topKind = entry[0];
      topCounter = entry[1];
    }
  }
  return topKind;
}
function partition(src, predicate) {
  const matches = [];
  const rest = [];
  for (const x of src) {
    if (predicate(x)) {
      matches.push(x);
    } else {
      rest.push(x);
    }
  }
  return { matches, rest };
}
function partition1(src, predicate) {
  const matches = [];
  const rest = [];
  for (const x of src) {
    if (predicate(x)) {
      matches.push(x);
    } else {
      rest.push(x);
    }
  }
  return { matches, rest };
}
class Picker {
  constructor(f) {
    this.f = f;
  }
  pickAll(el) {
    return this.f(el);
  }
  pick1(el, preferFirst = false) {
    const results = this.f(el);
    const len = results.length;
    if (len === 0) {
      return null;
    }
    if (len === 1) {
      return results[0].value;
    }
    const comparator = preferFirst ? comparatorPreferFirst : comparatorPreferLast;
    let result2 = results[0];
    for (let i = 1; i < len; i++) {
      const next2 = results[i];
      if (comparator(result2, next2)) {
        result2 = next2;
      }
    }
    return result2.value;
  }
}
function comparatorPreferFirst(acc, next2) {
  const diff2 = compareSpecificity(next2.specificity, acc.specificity);
  return diff2 > 0 || diff2 === 0 && next2.index < acc.index;
}
function comparatorPreferLast(acc, next2) {
  const diff2 = compareSpecificity(next2.specificity, acc.specificity);
  return diff2 > 0 || diff2 === 0 && next2.index > acc.index;
}
function hp2Builder(nodes) {
  return new Picker(handleArray(nodes));
}
function handleArray(nodes) {
  const matchers = nodes.map(handleNode);
  return (el, ...tail) => matchers.flatMap((m) => m(el, ...tail));
}
function handleNode(node) {
  switch (node.type) {
    case "terminal": {
      const result2 = [node.valueContainer];
      return (el, ...tail) => result2;
    }
    case "tagName":
      return handleTagName(node);
    case "attrValue":
      return handleAttrValueName(node);
    case "attrPresence":
      return handleAttrPresenceName(node);
    case "pushElement":
      return handlePushElementNode(node);
    case "popElement":
      return handlePopElementNode(node);
  }
}
function handleTagName(node) {
  const variants = {};
  for (const variant of node.variants) {
    variants[variant.value] = handleArray(variant.cont);
  }
  return (el, ...tail) => {
    const continuation = variants[el.name];
    return continuation ? continuation(el, ...tail) : [];
  };
}
function handleAttrPresenceName(node) {
  const attrName = node.name;
  const continuation = handleArray(node.cont);
  return (el, ...tail) => Object.prototype.hasOwnProperty.call(el.attribs, attrName) ? continuation(el, ...tail) : [];
}
function handleAttrValueName(node) {
  const callbacks = [];
  for (const matcher of node.matchers) {
    const predicate = matcher.predicate;
    const continuation = handleArray(matcher.cont);
    callbacks.push((attr, el, ...tail) => predicate(attr) ? continuation(el, ...tail) : []);
  }
  const attrName = node.name;
  return (el, ...tail) => {
    const attr = el.attribs[attrName];
    return attr || attr === "" ? callbacks.flatMap((cb) => cb(attr, el, ...tail)) : [];
  };
}
function handlePushElementNode(node) {
  const continuation = handleArray(node.cont);
  const leftElementGetter = node.combinator === "+" ? getPrecedingElement : getParentElement;
  return (el, ...tail) => {
    const next2 = leftElementGetter(el);
    if (next2 === null) {
      return [];
    }
    return continuation(next2, el, ...tail);
  };
}
const getPrecedingElement = (el) => {
  const prev = el.prev;
  if (prev === null) {
    return null;
  }
  return isTag(prev) ? prev : getPrecedingElement(prev);
};
const getParentElement = (el) => {
  const parent = el.parent;
  return parent && isTag(parent) ? parent : null;
};
function handlePopElementNode(node) {
  const continuation = handleArray(node.cont);
  return (el, next2, ...tail) => continuation(next2, ...tail);
}
const htmlDecodeTree = new Uint16Array(
  // prettier-ignore
  '<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map((c2) => c2.charCodeAt(0))
);
const xmlDecodeTree = new Uint16Array(
  // prettier-ignore
  "aglq	\x1B\0\0p;os;t;t;uot;".split("").map((c2) => c2.charCodeAt(0))
);
var _a;
const decodeMap = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
const fromCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
    let output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  }
);
function replaceCodePoint(codePoint) {
  var _a2;
  if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
    return 65533;
  }
  return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
}
var CharCodes$1;
(function(CharCodes2) {
  CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
  CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
  CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
  CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
  CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
  CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
  CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
  CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
  CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
  CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
  CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
  CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes$1 || (CharCodes$1 = {}));
const TO_LOWER_BIT = 32;
var BinTrieFlags;
(function(BinTrieFlags2) {
  BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
  BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
  BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags || (BinTrieFlags = {}));
function isNumber$2(code) {
  return code >= CharCodes$1.ZERO && code <= CharCodes$1.NINE;
}
function isHexadecimalCharacter(code) {
  return code >= CharCodes$1.UPPER_A && code <= CharCodes$1.UPPER_F || code >= CharCodes$1.LOWER_A && code <= CharCodes$1.LOWER_F;
}
function isAsciiAlphaNumeric(code) {
  return code >= CharCodes$1.UPPER_A && code <= CharCodes$1.UPPER_Z || code >= CharCodes$1.LOWER_A && code <= CharCodes$1.LOWER_Z || isNumber$2(code);
}
function isEntityInAttributeInvalidEnd(code) {
  return code === CharCodes$1.EQUALS || isAsciiAlphaNumeric(code);
}
var EntityDecoderState;
(function(EntityDecoderState2) {
  EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
  EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
  EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
  EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
  EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
var DecodingMode;
(function(DecodingMode2) {
  DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
  DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
  DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
})(DecodingMode || (DecodingMode = {}));
class EntityDecoder {
  constructor(decodeTree, emitCodePoint, errors) {
    this.decodeTree = decodeTree;
    this.emitCodePoint = emitCodePoint;
    this.errors = errors;
    this.state = EntityDecoderState.EntityStart;
    this.consumed = 1;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.decodeMode = DecodingMode.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(decodeMode) {
    this.decodeMode = decodeMode;
    this.state = EntityDecoderState.EntityStart;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(str, offset2) {
    switch (this.state) {
      case EntityDecoderState.EntityStart: {
        if (str.charCodeAt(offset2) === CharCodes$1.NUM) {
          this.state = EntityDecoderState.NumericStart;
          this.consumed += 1;
          return this.stateNumericStart(str, offset2 + 1);
        }
        this.state = EntityDecoderState.NamedEntity;
        return this.stateNamedEntity(str, offset2);
      }
      case EntityDecoderState.NumericStart: {
        return this.stateNumericStart(str, offset2);
      }
      case EntityDecoderState.NumericDecimal: {
        return this.stateNumericDecimal(str, offset2);
      }
      case EntityDecoderState.NumericHex: {
        return this.stateNumericHex(str, offset2);
      }
      case EntityDecoderState.NamedEntity: {
        return this.stateNamedEntity(str, offset2);
      }
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(str, offset2) {
    if (offset2 >= str.length) {
      return -1;
    }
    if ((str.charCodeAt(offset2) | TO_LOWER_BIT) === CharCodes$1.LOWER_X) {
      this.state = EntityDecoderState.NumericHex;
      this.consumed += 1;
      return this.stateNumericHex(str, offset2 + 1);
    }
    this.state = EntityDecoderState.NumericDecimal;
    return this.stateNumericDecimal(str, offset2);
  }
  addToNumericResult(str, start, end, base) {
    if (start !== end) {
      const digitCount = end - start;
      this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);
      this.consumed += digitCount;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(str, offset2) {
    const startIdx = offset2;
    while (offset2 < str.length) {
      const char2 = str.charCodeAt(offset2);
      if (isNumber$2(char2) || isHexadecimalCharacter(char2)) {
        offset2 += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset2, 16);
        return this.emitNumericEntity(char2, 3);
      }
    }
    this.addToNumericResult(str, startIdx, offset2, 16);
    return -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(str, offset2) {
    const startIdx = offset2;
    while (offset2 < str.length) {
      const char2 = str.charCodeAt(offset2);
      if (isNumber$2(char2)) {
        offset2 += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset2, 10);
        return this.emitNumericEntity(char2, 2);
      }
    }
    this.addToNumericResult(str, startIdx, offset2, 10);
    return -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(lastCp, expectedLength) {
    var _a2;
    if (this.consumed <= expectedLength) {
      (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
      return 0;
    }
    if (lastCp === CharCodes$1.SEMI) {
      this.consumed += 1;
    } else if (this.decodeMode === DecodingMode.Strict) {
      return 0;
    }
    this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
    if (this.errors) {
      if (lastCp !== CharCodes$1.SEMI) {
        this.errors.missingSemicolonAfterCharacterReference();
      }
      this.errors.validateNumericCharacterReference(this.result);
    }
    return this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(str, offset2) {
    const { decodeTree } = this;
    let current = decodeTree[this.treeIndex];
    let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
    for (; offset2 < str.length; offset2++, this.excess++) {
      const char2 = str.charCodeAt(offset2);
      this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char2);
      if (this.treeIndex < 0) {
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
        (valueLength === 0 || // And there should be no invalid characters.
        isEntityInAttributeInvalidEnd(char2)) ? 0 : this.emitNotTerminatedNamedEntity();
      }
      current = decodeTree[this.treeIndex];
      valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
      if (valueLength !== 0) {
        if (char2 === CharCodes$1.SEMI) {
          return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
        }
        if (this.decodeMode !== DecodingMode.Strict) {
          this.result = this.treeIndex;
          this.consumed += this.excess;
          this.excess = 0;
        }
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var _a2;
    const { result: result2, decodeTree } = this;
    const valueLength = (decodeTree[result2] & BinTrieFlags.VALUE_LENGTH) >> 14;
    this.emitNamedEntityData(result2, valueLength, this.consumed);
    (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.missingSemicolonAfterCharacterReference();
    return this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(result2, valueLength, consumed) {
    const { decodeTree } = this;
    this.emitCodePoint(valueLength === 1 ? decodeTree[result2] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result2 + 1], consumed);
    if (valueLength === 3) {
      this.emitCodePoint(decodeTree[result2 + 2], consumed);
    }
    return consumed;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var _a2;
    switch (this.state) {
      case EntityDecoderState.NamedEntity: {
        return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      }
      // Otherwise, emit a numeric entity if we have one.
      case EntityDecoderState.NumericDecimal: {
        return this.emitNumericEntity(0, 2);
      }
      case EntityDecoderState.NumericHex: {
        return this.emitNumericEntity(0, 3);
      }
      case EntityDecoderState.NumericStart: {
        (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      case EntityDecoderState.EntityStart: {
        return 0;
      }
    }
  }
}
function getDecoder(decodeTree) {
  let ret = "";
  const decoder2 = new EntityDecoder(decodeTree, (str) => ret += fromCodePoint(str));
  return function decodeWithTrie(str, decodeMode) {
    let lastIndex = 0;
    let offset2 = 0;
    while ((offset2 = str.indexOf("&", offset2)) >= 0) {
      ret += str.slice(lastIndex, offset2);
      decoder2.startEntity(decodeMode);
      const len = decoder2.write(
        str,
        // Skip the "&"
        offset2 + 1
      );
      if (len < 0) {
        lastIndex = offset2 + decoder2.end();
        break;
      }
      lastIndex = offset2 + len;
      offset2 = len === 0 ? lastIndex + 1 : lastIndex;
    }
    const result2 = ret + str.slice(lastIndex);
    ret = "";
    return result2;
  };
}
function determineBranch(decodeTree, current, nodeIdx, char2) {
  const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
  const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
  if (branchCount === 0) {
    return jumpOffset !== 0 && char2 === jumpOffset ? nodeIdx : -1;
  }
  if (jumpOffset) {
    const value = char2 - jumpOffset;
    return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
  }
  let lo = nodeIdx;
  let hi = lo + branchCount - 1;
  while (lo <= hi) {
    const mid = lo + hi >>> 1;
    const midVal = decodeTree[mid];
    if (midVal < char2) {
      lo = mid + 1;
    } else if (midVal > char2) {
      hi = mid - 1;
    } else {
      return decodeTree[mid + branchCount];
    }
  }
  return -1;
}
getDecoder(htmlDecodeTree);
getDecoder(xmlDecodeTree);
var CharCodes;
(function(CharCodes2) {
  CharCodes2[CharCodes2["Tab"] = 9] = "Tab";
  CharCodes2[CharCodes2["NewLine"] = 10] = "NewLine";
  CharCodes2[CharCodes2["FormFeed"] = 12] = "FormFeed";
  CharCodes2[CharCodes2["CarriageReturn"] = 13] = "CarriageReturn";
  CharCodes2[CharCodes2["Space"] = 32] = "Space";
  CharCodes2[CharCodes2["ExclamationMark"] = 33] = "ExclamationMark";
  CharCodes2[CharCodes2["Number"] = 35] = "Number";
  CharCodes2[CharCodes2["Amp"] = 38] = "Amp";
  CharCodes2[CharCodes2["SingleQuote"] = 39] = "SingleQuote";
  CharCodes2[CharCodes2["DoubleQuote"] = 34] = "DoubleQuote";
  CharCodes2[CharCodes2["Dash"] = 45] = "Dash";
  CharCodes2[CharCodes2["Slash"] = 47] = "Slash";
  CharCodes2[CharCodes2["Zero"] = 48] = "Zero";
  CharCodes2[CharCodes2["Nine"] = 57] = "Nine";
  CharCodes2[CharCodes2["Semi"] = 59] = "Semi";
  CharCodes2[CharCodes2["Lt"] = 60] = "Lt";
  CharCodes2[CharCodes2["Eq"] = 61] = "Eq";
  CharCodes2[CharCodes2["Gt"] = 62] = "Gt";
  CharCodes2[CharCodes2["Questionmark"] = 63] = "Questionmark";
  CharCodes2[CharCodes2["UpperA"] = 65] = "UpperA";
  CharCodes2[CharCodes2["LowerA"] = 97] = "LowerA";
  CharCodes2[CharCodes2["UpperF"] = 70] = "UpperF";
  CharCodes2[CharCodes2["LowerF"] = 102] = "LowerF";
  CharCodes2[CharCodes2["UpperZ"] = 90] = "UpperZ";
  CharCodes2[CharCodes2["LowerZ"] = 122] = "LowerZ";
  CharCodes2[CharCodes2["LowerX"] = 120] = "LowerX";
  CharCodes2[CharCodes2["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
})(CharCodes || (CharCodes = {}));
var State;
(function(State2) {
  State2[State2["Text"] = 1] = "Text";
  State2[State2["BeforeTagName"] = 2] = "BeforeTagName";
  State2[State2["InTagName"] = 3] = "InTagName";
  State2[State2["InSelfClosingTag"] = 4] = "InSelfClosingTag";
  State2[State2["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
  State2[State2["InClosingTagName"] = 6] = "InClosingTagName";
  State2[State2["AfterClosingTagName"] = 7] = "AfterClosingTagName";
  State2[State2["BeforeAttributeName"] = 8] = "BeforeAttributeName";
  State2[State2["InAttributeName"] = 9] = "InAttributeName";
  State2[State2["AfterAttributeName"] = 10] = "AfterAttributeName";
  State2[State2["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
  State2[State2["InAttributeValueDq"] = 12] = "InAttributeValueDq";
  State2[State2["InAttributeValueSq"] = 13] = "InAttributeValueSq";
  State2[State2["InAttributeValueNq"] = 14] = "InAttributeValueNq";
  State2[State2["BeforeDeclaration"] = 15] = "BeforeDeclaration";
  State2[State2["InDeclaration"] = 16] = "InDeclaration";
  State2[State2["InProcessingInstruction"] = 17] = "InProcessingInstruction";
  State2[State2["BeforeComment"] = 18] = "BeforeComment";
  State2[State2["CDATASequence"] = 19] = "CDATASequence";
  State2[State2["InSpecialComment"] = 20] = "InSpecialComment";
  State2[State2["InCommentLike"] = 21] = "InCommentLike";
  State2[State2["BeforeSpecialS"] = 22] = "BeforeSpecialS";
  State2[State2["SpecialStartSequence"] = 23] = "SpecialStartSequence";
  State2[State2["InSpecialTag"] = 24] = "InSpecialTag";
  State2[State2["BeforeEntity"] = 25] = "BeforeEntity";
  State2[State2["BeforeNumericEntity"] = 26] = "BeforeNumericEntity";
  State2[State2["InNamedEntity"] = 27] = "InNamedEntity";
  State2[State2["InNumericEntity"] = 28] = "InNumericEntity";
  State2[State2["InHexEntity"] = 29] = "InHexEntity";
})(State || (State = {}));
function isWhitespace(c2) {
  return c2 === CharCodes.Space || c2 === CharCodes.NewLine || c2 === CharCodes.Tab || c2 === CharCodes.FormFeed || c2 === CharCodes.CarriageReturn;
}
function isEndOfTagSection(c2) {
  return c2 === CharCodes.Slash || c2 === CharCodes.Gt || isWhitespace(c2);
}
function isNumber$1(c2) {
  return c2 >= CharCodes.Zero && c2 <= CharCodes.Nine;
}
function isASCIIAlpha(c2) {
  return c2 >= CharCodes.LowerA && c2 <= CharCodes.LowerZ || c2 >= CharCodes.UpperA && c2 <= CharCodes.UpperZ;
}
function isHexDigit(c2) {
  return c2 >= CharCodes.UpperA && c2 <= CharCodes.UpperF || c2 >= CharCodes.LowerA && c2 <= CharCodes.LowerF;
}
var QuoteType;
(function(QuoteType2) {
  QuoteType2[QuoteType2["NoValue"] = 0] = "NoValue";
  QuoteType2[QuoteType2["Unquoted"] = 1] = "Unquoted";
  QuoteType2[QuoteType2["Single"] = 2] = "Single";
  QuoteType2[QuoteType2["Double"] = 3] = "Double";
})(QuoteType || (QuoteType = {}));
const Sequences = {
  Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
  CdataEnd: new Uint8Array([93, 93, 62]),
  CommentEnd: new Uint8Array([45, 45, 62]),
  ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
  StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
  TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101])
  // `</title`
};
class Tokenizer {
  constructor({ xmlMode = false, decodeEntities = true }, cbs) {
    this.cbs = cbs;
    this.state = State.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = State.Text;
    this.isSpecial = false;
    this.running = true;
    this.offset = 0;
    this.currentSequence = void 0;
    this.sequenceIndex = 0;
    this.trieIndex = 0;
    this.trieCurrent = 0;
    this.entityResult = 0;
    this.entityExcess = 0;
    this.xmlMode = xmlMode;
    this.decodeEntities = decodeEntities;
    this.entityTrie = xmlMode ? xmlDecodeTree : htmlDecodeTree;
  }
  reset() {
    this.state = State.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = State.Text;
    this.currentSequence = void 0;
    this.running = true;
    this.offset = 0;
  }
  write(chunk) {
    this.offset += this.buffer.length;
    this.buffer = chunk;
    this.parse();
  }
  end() {
    if (this.running)
      this.finish();
  }
  pause() {
    this.running = false;
  }
  resume() {
    this.running = true;
    if (this.index < this.buffer.length + this.offset) {
      this.parse();
    }
  }
  /**
   * The current index within all of the written data.
   */
  getIndex() {
    return this.index;
  }
  /**
   * The start of the current section.
   */
  getSectionStart() {
    return this.sectionStart;
  }
  stateText(c2) {
    if (c2 === CharCodes.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes.Lt)) {
      if (this.index > this.sectionStart) {
        this.cbs.ontext(this.sectionStart, this.index);
      }
      this.state = State.BeforeTagName;
      this.sectionStart = this.index;
    } else if (this.decodeEntities && c2 === CharCodes.Amp) {
      this.state = State.BeforeEntity;
    }
  }
  stateSpecialStartSequence(c2) {
    const isEnd = this.sequenceIndex === this.currentSequence.length;
    const isMatch2 = isEnd ? (
      // If we are at the end of the sequence, make sure the tag name has ended
      isEndOfTagSection(c2)
    ) : (
      // Otherwise, do a case-insensitive comparison
      (c2 | 32) === this.currentSequence[this.sequenceIndex]
    );
    if (!isMatch2) {
      this.isSpecial = false;
    } else if (!isEnd) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0;
    this.state = State.InTagName;
    this.stateInTagName(c2);
  }
  /** Look for an end tag. For <title> tags, also decode entities. */
  stateInSpecialTag(c2) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (c2 === CharCodes.Gt || isWhitespace(c2)) {
        const endOfText = this.index - this.currentSequence.length;
        if (this.sectionStart < endOfText) {
          const actualIndex = this.index;
          this.index = endOfText;
          this.cbs.ontext(this.sectionStart, endOfText);
          this.index = actualIndex;
        }
        this.isSpecial = false;
        this.sectionStart = endOfText + 2;
        this.stateInClosingTagName(c2);
        return;
      }
      this.sequenceIndex = 0;
    }
    if ((c2 | 32) === this.currentSequence[this.sequenceIndex]) {
      this.sequenceIndex += 1;
    } else if (this.sequenceIndex === 0) {
      if (this.currentSequence === Sequences.TitleEnd) {
        if (this.decodeEntities && c2 === CharCodes.Amp) {
          this.state = State.BeforeEntity;
        }
      } else if (this.fastForwardTo(CharCodes.Lt)) {
        this.sequenceIndex = 1;
      }
    } else {
      this.sequenceIndex = Number(c2 === CharCodes.Lt);
    }
  }
  stateCDATASequence(c2) {
    if (c2 === Sequences.Cdata[this.sequenceIndex]) {
      if (++this.sequenceIndex === Sequences.Cdata.length) {
        this.state = State.InCommentLike;
        this.currentSequence = Sequences.CdataEnd;
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
      }
    } else {
      this.sequenceIndex = 0;
      this.state = State.InDeclaration;
      this.stateInDeclaration(c2);
    }
  }
  /**
   * When we wait for one specific character, we can speed things up
   * by skipping through the buffer until we find it.
   *
   * @returns Whether the character was found.
   */
  fastForwardTo(c2) {
    while (++this.index < this.buffer.length + this.offset) {
      if (this.buffer.charCodeAt(this.index - this.offset) === c2) {
        return true;
      }
    }
    this.index = this.buffer.length + this.offset - 1;
    return false;
  }
  /**
   * Comments and CDATA end with `-->` and `]]>`.
   *
   * Their common qualities are:
   * - Their end sequences have a distinct character they start with.
   * - That character is then repeated, so we have to check multiple repeats.
   * - All characters but the start character of the sequence can be skipped.
   */
  stateInCommentLike(c2) {
    if (c2 === this.currentSequence[this.sequenceIndex]) {
      if (++this.sequenceIndex === this.currentSequence.length) {
        if (this.currentSequence === Sequences.CdataEnd) {
          this.cbs.oncdata(this.sectionStart, this.index, 2);
        } else {
          this.cbs.oncomment(this.sectionStart, this.index, 2);
        }
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
        this.state = State.Text;
      }
    } else if (this.sequenceIndex === 0) {
      if (this.fastForwardTo(this.currentSequence[0])) {
        this.sequenceIndex = 1;
      }
    } else if (c2 !== this.currentSequence[this.sequenceIndex - 1]) {
      this.sequenceIndex = 0;
    }
  }
  /**
   * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
   *
   * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
   * We allow anything that wouldn't end the tag.
   */
  isTagStartChar(c2) {
    return this.xmlMode ? !isEndOfTagSection(c2) : isASCIIAlpha(c2);
  }
  startSpecial(sequence, offset2) {
    this.isSpecial = true;
    this.currentSequence = sequence;
    this.sequenceIndex = offset2;
    this.state = State.SpecialStartSequence;
  }
  stateBeforeTagName(c2) {
    if (c2 === CharCodes.ExclamationMark) {
      this.state = State.BeforeDeclaration;
      this.sectionStart = this.index + 1;
    } else if (c2 === CharCodes.Questionmark) {
      this.state = State.InProcessingInstruction;
      this.sectionStart = this.index + 1;
    } else if (this.isTagStartChar(c2)) {
      const lower = c2 | 32;
      this.sectionStart = this.index;
      if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {
        this.startSpecial(Sequences.TitleEnd, 3);
      } else {
        this.state = !this.xmlMode && lower === Sequences.ScriptEnd[2] ? State.BeforeSpecialS : State.InTagName;
      }
    } else if (c2 === CharCodes.Slash) {
      this.state = State.BeforeClosingTagName;
    } else {
      this.state = State.Text;
      this.stateText(c2);
    }
  }
  stateInTagName(c2) {
    if (isEndOfTagSection(c2)) {
      this.cbs.onopentagname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c2);
    }
  }
  stateBeforeClosingTagName(c2) {
    if (isWhitespace(c2)) ;
    else if (c2 === CharCodes.Gt) {
      this.state = State.Text;
    } else {
      this.state = this.isTagStartChar(c2) ? State.InClosingTagName : State.InSpecialComment;
      this.sectionStart = this.index;
    }
  }
  stateInClosingTagName(c2) {
    if (c2 === CharCodes.Gt || isWhitespace(c2)) {
      this.cbs.onclosetag(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.AfterClosingTagName;
      this.stateAfterClosingTagName(c2);
    }
  }
  stateAfterClosingTagName(c2) {
    if (c2 === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
      this.state = State.Text;
      this.baseState = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeAttributeName(c2) {
    if (c2 === CharCodes.Gt) {
      this.cbs.onopentagend(this.index);
      if (this.isSpecial) {
        this.state = State.InSpecialTag;
        this.sequenceIndex = 0;
      } else {
        this.state = State.Text;
      }
      this.baseState = this.state;
      this.sectionStart = this.index + 1;
    } else if (c2 === CharCodes.Slash) {
      this.state = State.InSelfClosingTag;
    } else if (!isWhitespace(c2)) {
      this.state = State.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateInSelfClosingTag(c2) {
    if (c2 === CharCodes.Gt) {
      this.cbs.onselfclosingtag(this.index);
      this.state = State.Text;
      this.baseState = State.Text;
      this.sectionStart = this.index + 1;
      this.isSpecial = false;
    } else if (!isWhitespace(c2)) {
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c2);
    }
  }
  stateInAttributeName(c2) {
    if (c2 === CharCodes.Eq || isEndOfTagSection(c2)) {
      this.cbs.onattribname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.AfterAttributeName;
      this.stateAfterAttributeName(c2);
    }
  }
  stateAfterAttributeName(c2) {
    if (c2 === CharCodes.Eq) {
      this.state = State.BeforeAttributeValue;
    } else if (c2 === CharCodes.Slash || c2 === CharCodes.Gt) {
      this.cbs.onattribend(QuoteType.NoValue, this.index);
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c2);
    } else if (!isWhitespace(c2)) {
      this.cbs.onattribend(QuoteType.NoValue, this.index);
      this.state = State.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateBeforeAttributeValue(c2) {
    if (c2 === CharCodes.DoubleQuote) {
      this.state = State.InAttributeValueDq;
      this.sectionStart = this.index + 1;
    } else if (c2 === CharCodes.SingleQuote) {
      this.state = State.InAttributeValueSq;
      this.sectionStart = this.index + 1;
    } else if (!isWhitespace(c2)) {
      this.sectionStart = this.index;
      this.state = State.InAttributeValueNq;
      this.stateInAttributeValueNoQuotes(c2);
    }
  }
  handleInAttributeValue(c2, quote) {
    if (c2 === quote || !this.decodeEntities && this.fastForwardTo(quote)) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(quote === CharCodes.DoubleQuote ? QuoteType.Double : QuoteType.Single, this.index);
      this.state = State.BeforeAttributeName;
    } else if (this.decodeEntities && c2 === CharCodes.Amp) {
      this.baseState = this.state;
      this.state = State.BeforeEntity;
    }
  }
  stateInAttributeValueDoubleQuotes(c2) {
    this.handleInAttributeValue(c2, CharCodes.DoubleQuote);
  }
  stateInAttributeValueSingleQuotes(c2) {
    this.handleInAttributeValue(c2, CharCodes.SingleQuote);
  }
  stateInAttributeValueNoQuotes(c2) {
    if (isWhitespace(c2) || c2 === CharCodes.Gt) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(QuoteType.Unquoted, this.index);
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c2);
    } else if (this.decodeEntities && c2 === CharCodes.Amp) {
      this.baseState = this.state;
      this.state = State.BeforeEntity;
    }
  }
  stateBeforeDeclaration(c2) {
    if (c2 === CharCodes.OpeningSquareBracket) {
      this.state = State.CDATASequence;
      this.sequenceIndex = 0;
    } else {
      this.state = c2 === CharCodes.Dash ? State.BeforeComment : State.InDeclaration;
    }
  }
  stateInDeclaration(c2) {
    if (c2 === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
      this.cbs.ondeclaration(this.sectionStart, this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateInProcessingInstruction(c2) {
    if (c2 === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
      this.cbs.onprocessinginstruction(this.sectionStart, this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeComment(c2) {
    if (c2 === CharCodes.Dash) {
      this.state = State.InCommentLike;
      this.currentSequence = Sequences.CommentEnd;
      this.sequenceIndex = 2;
      this.sectionStart = this.index + 1;
    } else {
      this.state = State.InDeclaration;
    }
  }
  stateInSpecialComment(c2) {
    if (c2 === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
      this.cbs.oncomment(this.sectionStart, this.index, 0);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeSpecialS(c2) {
    const lower = c2 | 32;
    if (lower === Sequences.ScriptEnd[3]) {
      this.startSpecial(Sequences.ScriptEnd, 4);
    } else if (lower === Sequences.StyleEnd[3]) {
      this.startSpecial(Sequences.StyleEnd, 4);
    } else {
      this.state = State.InTagName;
      this.stateInTagName(c2);
    }
  }
  stateBeforeEntity(c2) {
    this.entityExcess = 1;
    this.entityResult = 0;
    if (c2 === CharCodes.Number) {
      this.state = State.BeforeNumericEntity;
    } else if (c2 === CharCodes.Amp) ;
    else {
      this.trieIndex = 0;
      this.trieCurrent = this.entityTrie[0];
      this.state = State.InNamedEntity;
      this.stateInNamedEntity(c2);
    }
  }
  stateInNamedEntity(c2) {
    this.entityExcess += 1;
    this.trieIndex = determineBranch(this.entityTrie, this.trieCurrent, this.trieIndex + 1, c2);
    if (this.trieIndex < 0) {
      this.emitNamedEntity();
      this.index--;
      return;
    }
    this.trieCurrent = this.entityTrie[this.trieIndex];
    const masked = this.trieCurrent & BinTrieFlags.VALUE_LENGTH;
    if (masked) {
      const valueLength = (masked >> 14) - 1;
      if (!this.allowLegacyEntity() && c2 !== CharCodes.Semi) {
        this.trieIndex += valueLength;
      } else {
        const entityStart = this.index - this.entityExcess + 1;
        if (entityStart > this.sectionStart) {
          this.emitPartial(this.sectionStart, entityStart);
        }
        this.entityResult = this.trieIndex;
        this.trieIndex += valueLength;
        this.entityExcess = 0;
        this.sectionStart = this.index + 1;
        if (valueLength === 0) {
          this.emitNamedEntity();
        }
      }
    }
  }
  emitNamedEntity() {
    this.state = this.baseState;
    if (this.entityResult === 0) {
      return;
    }
    const valueLength = (this.entityTrie[this.entityResult] & BinTrieFlags.VALUE_LENGTH) >> 14;
    switch (valueLength) {
      case 1: {
        this.emitCodePoint(this.entityTrie[this.entityResult] & ~BinTrieFlags.VALUE_LENGTH);
        break;
      }
      case 2: {
        this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
        break;
      }
      case 3: {
        this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
        this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
      }
    }
  }
  stateBeforeNumericEntity(c2) {
    if ((c2 | 32) === CharCodes.LowerX) {
      this.entityExcess++;
      this.state = State.InHexEntity;
    } else {
      this.state = State.InNumericEntity;
      this.stateInNumericEntity(c2);
    }
  }
  emitNumericEntity(strict) {
    const entityStart = this.index - this.entityExcess - 1;
    const numberStart = entityStart + 2 + Number(this.state === State.InHexEntity);
    if (numberStart !== this.index) {
      if (entityStart > this.sectionStart) {
        this.emitPartial(this.sectionStart, entityStart);
      }
      this.sectionStart = this.index + Number(strict);
      this.emitCodePoint(replaceCodePoint(this.entityResult));
    }
    this.state = this.baseState;
  }
  stateInNumericEntity(c2) {
    if (c2 === CharCodes.Semi) {
      this.emitNumericEntity(true);
    } else if (isNumber$1(c2)) {
      this.entityResult = this.entityResult * 10 + (c2 - CharCodes.Zero);
      this.entityExcess++;
    } else {
      if (this.allowLegacyEntity()) {
        this.emitNumericEntity(false);
      } else {
        this.state = this.baseState;
      }
      this.index--;
    }
  }
  stateInHexEntity(c2) {
    if (c2 === CharCodes.Semi) {
      this.emitNumericEntity(true);
    } else if (isNumber$1(c2)) {
      this.entityResult = this.entityResult * 16 + (c2 - CharCodes.Zero);
      this.entityExcess++;
    } else if (isHexDigit(c2)) {
      this.entityResult = this.entityResult * 16 + ((c2 | 32) - CharCodes.LowerA + 10);
      this.entityExcess++;
    } else {
      if (this.allowLegacyEntity()) {
        this.emitNumericEntity(false);
      } else {
        this.state = this.baseState;
      }
      this.index--;
    }
  }
  allowLegacyEntity() {
    return !this.xmlMode && (this.baseState === State.Text || this.baseState === State.InSpecialTag);
  }
  /**
   * Remove data that has already been consumed from the buffer.
   */
  cleanup() {
    if (this.running && this.sectionStart !== this.index) {
      if (this.state === State.Text || this.state === State.InSpecialTag && this.sequenceIndex === 0) {
        this.cbs.ontext(this.sectionStart, this.index);
        this.sectionStart = this.index;
      } else if (this.state === State.InAttributeValueDq || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueNq) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = this.index;
      }
    }
  }
  shouldContinue() {
    return this.index < this.buffer.length + this.offset && this.running;
  }
  /**
   * Iterates through the buffer, calling the function corresponding to the current state.
   *
   * States that are more likely to be hit are higher up, as a performance improvement.
   */
  parse() {
    while (this.shouldContinue()) {
      const c2 = this.buffer.charCodeAt(this.index - this.offset);
      switch (this.state) {
        case State.Text: {
          this.stateText(c2);
          break;
        }
        case State.SpecialStartSequence: {
          this.stateSpecialStartSequence(c2);
          break;
        }
        case State.InSpecialTag: {
          this.stateInSpecialTag(c2);
          break;
        }
        case State.CDATASequence: {
          this.stateCDATASequence(c2);
          break;
        }
        case State.InAttributeValueDq: {
          this.stateInAttributeValueDoubleQuotes(c2);
          break;
        }
        case State.InAttributeName: {
          this.stateInAttributeName(c2);
          break;
        }
        case State.InCommentLike: {
          this.stateInCommentLike(c2);
          break;
        }
        case State.InSpecialComment: {
          this.stateInSpecialComment(c2);
          break;
        }
        case State.BeforeAttributeName: {
          this.stateBeforeAttributeName(c2);
          break;
        }
        case State.InTagName: {
          this.stateInTagName(c2);
          break;
        }
        case State.InClosingTagName: {
          this.stateInClosingTagName(c2);
          break;
        }
        case State.BeforeTagName: {
          this.stateBeforeTagName(c2);
          break;
        }
        case State.AfterAttributeName: {
          this.stateAfterAttributeName(c2);
          break;
        }
        case State.InAttributeValueSq: {
          this.stateInAttributeValueSingleQuotes(c2);
          break;
        }
        case State.BeforeAttributeValue: {
          this.stateBeforeAttributeValue(c2);
          break;
        }
        case State.BeforeClosingTagName: {
          this.stateBeforeClosingTagName(c2);
          break;
        }
        case State.AfterClosingTagName: {
          this.stateAfterClosingTagName(c2);
          break;
        }
        case State.BeforeSpecialS: {
          this.stateBeforeSpecialS(c2);
          break;
        }
        case State.InAttributeValueNq: {
          this.stateInAttributeValueNoQuotes(c2);
          break;
        }
        case State.InSelfClosingTag: {
          this.stateInSelfClosingTag(c2);
          break;
        }
        case State.InDeclaration: {
          this.stateInDeclaration(c2);
          break;
        }
        case State.BeforeDeclaration: {
          this.stateBeforeDeclaration(c2);
          break;
        }
        case State.BeforeComment: {
          this.stateBeforeComment(c2);
          break;
        }
        case State.InProcessingInstruction: {
          this.stateInProcessingInstruction(c2);
          break;
        }
        case State.InNamedEntity: {
          this.stateInNamedEntity(c2);
          break;
        }
        case State.BeforeEntity: {
          this.stateBeforeEntity(c2);
          break;
        }
        case State.InHexEntity: {
          this.stateInHexEntity(c2);
          break;
        }
        case State.InNumericEntity: {
          this.stateInNumericEntity(c2);
          break;
        }
        default: {
          this.stateBeforeNumericEntity(c2);
        }
      }
      this.index++;
    }
    this.cleanup();
  }
  finish() {
    if (this.state === State.InNamedEntity) {
      this.emitNamedEntity();
    }
    if (this.sectionStart < this.index) {
      this.handleTrailingData();
    }
    this.cbs.onend();
  }
  /** Handle any trailing data. */
  handleTrailingData() {
    const endIndex = this.buffer.length + this.offset;
    if (this.state === State.InCommentLike) {
      if (this.currentSequence === Sequences.CdataEnd) {
        this.cbs.oncdata(this.sectionStart, endIndex, 0);
      } else {
        this.cbs.oncomment(this.sectionStart, endIndex, 0);
      }
    } else if (this.state === State.InNumericEntity && this.allowLegacyEntity()) {
      this.emitNumericEntity(false);
    } else if (this.state === State.InHexEntity && this.allowLegacyEntity()) {
      this.emitNumericEntity(false);
    } else if (this.state === State.InTagName || this.state === State.BeforeAttributeName || this.state === State.BeforeAttributeValue || this.state === State.AfterAttributeName || this.state === State.InAttributeName || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueDq || this.state === State.InAttributeValueNq || this.state === State.InClosingTagName) ;
    else {
      this.cbs.ontext(this.sectionStart, endIndex);
    }
  }
  emitPartial(start, endIndex) {
    if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
      this.cbs.onattribdata(start, endIndex);
    } else {
      this.cbs.ontext(start, endIndex);
    }
  }
  emitCodePoint(cp) {
    if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
      this.cbs.onattribentity(cp);
    } else {
      this.cbs.ontextentity(cp);
    }
  }
}
const formTags = /* @__PURE__ */ new Set([
  "input",
  "option",
  "optgroup",
  "select",
  "button",
  "datalist",
  "textarea"
]);
const pTag = /* @__PURE__ */ new Set(["p"]);
const tableSectionTags = /* @__PURE__ */ new Set(["thead", "tbody"]);
const ddtTags = /* @__PURE__ */ new Set(["dd", "dt"]);
const rtpTags = /* @__PURE__ */ new Set(["rt", "rp"]);
const openImpliesClose = /* @__PURE__ */ new Map([
  ["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
  ["th", /* @__PURE__ */ new Set(["th"])],
  ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
  ["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
  ["li", /* @__PURE__ */ new Set(["li"])],
  ["p", pTag],
  ["h1", pTag],
  ["h2", pTag],
  ["h3", pTag],
  ["h4", pTag],
  ["h5", pTag],
  ["h6", pTag],
  ["select", formTags],
  ["input", formTags],
  ["output", formTags],
  ["button", formTags],
  ["datalist", formTags],
  ["textarea", formTags],
  ["option", /* @__PURE__ */ new Set(["option"])],
  ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
  ["dd", ddtTags],
  ["dt", ddtTags],
  ["address", pTag],
  ["article", pTag],
  ["aside", pTag],
  ["blockquote", pTag],
  ["details", pTag],
  ["div", pTag],
  ["dl", pTag],
  ["fieldset", pTag],
  ["figcaption", pTag],
  ["figure", pTag],
  ["footer", pTag],
  ["form", pTag],
  ["header", pTag],
  ["hr", pTag],
  ["main", pTag],
  ["nav", pTag],
  ["ol", pTag],
  ["pre", pTag],
  ["section", pTag],
  ["table", pTag],
  ["ul", pTag],
  ["rt", rtpTags],
  ["rp", rtpTags],
  ["tbody", tableSectionTags],
  ["tfoot", tableSectionTags]
]);
const voidElements = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
const foreignContextElements = /* @__PURE__ */ new Set(["math", "svg"]);
const htmlIntegrationElements = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignobject",
  "desc",
  "title"
]);
const reNameEnd = /\s|\//;
class Parser {
  constructor(cbs, options = {}) {
    var _a2, _b, _c, _d, _e;
    this.options = options;
    this.startIndex = 0;
    this.endIndex = 0;
    this.openTagStart = 0;
    this.tagname = "";
    this.attribname = "";
    this.attribvalue = "";
    this.attribs = null;
    this.stack = [];
    this.foreignContext = [];
    this.buffers = [];
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
    this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
    this.lowerCaseTagNames = (_a2 = options.lowerCaseTags) !== null && _a2 !== void 0 ? _a2 : !options.xmlMode;
    this.lowerCaseAttributeNames = (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options.xmlMode;
    this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer)(this.options, this);
    (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);
  }
  // Tokenizer event handlers
  /** @internal */
  ontext(start, endIndex) {
    var _a2, _b;
    const data = this.getSlice(start, endIndex);
    this.endIndex = endIndex - 1;
    (_b = (_a2 = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a2, data);
    this.startIndex = endIndex;
  }
  /** @internal */
  ontextentity(cp) {
    var _a2, _b;
    const index2 = this.tokenizer.getSectionStart();
    this.endIndex = index2 - 1;
    (_b = (_a2 = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a2, fromCodePoint(cp));
    this.startIndex = index2;
  }
  isVoidElement(name2) {
    return !this.options.xmlMode && voidElements.has(name2);
  }
  /** @internal */
  onopentagname(start, endIndex) {
    this.endIndex = endIndex;
    let name2 = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name2 = name2.toLowerCase();
    }
    this.emitOpenTag(name2);
  }
  emitOpenTag(name2) {
    var _a2, _b, _c, _d;
    this.openTagStart = this.startIndex;
    this.tagname = name2;
    const impliesClose = !this.options.xmlMode && openImpliesClose.get(name2);
    if (impliesClose) {
      while (this.stack.length > 0 && impliesClose.has(this.stack[this.stack.length - 1])) {
        const element = this.stack.pop();
        (_b = (_a2 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a2, element, true);
      }
    }
    if (!this.isVoidElement(name2)) {
      this.stack.push(name2);
      if (foreignContextElements.has(name2)) {
        this.foreignContext.push(true);
      } else if (htmlIntegrationElements.has(name2)) {
        this.foreignContext.push(false);
      }
    }
    (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name2);
    if (this.cbs.onopentag)
      this.attribs = {};
  }
  endOpenTag(isImplied) {
    var _a2, _b;
    this.startIndex = this.openTagStart;
    if (this.attribs) {
      (_b = (_a2 = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a2, this.tagname, this.attribs, isImplied);
      this.attribs = null;
    }
    if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
      this.cbs.onclosetag(this.tagname, true);
    }
    this.tagname = "";
  }
  /** @internal */
  onopentagend(endIndex) {
    this.endIndex = endIndex;
    this.endOpenTag(false);
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onclosetag(start, endIndex) {
    var _a2, _b, _c, _d, _e, _f;
    this.endIndex = endIndex;
    let name2 = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name2 = name2.toLowerCase();
    }
    if (foreignContextElements.has(name2) || htmlIntegrationElements.has(name2)) {
      this.foreignContext.pop();
    }
    if (!this.isVoidElement(name2)) {
      const pos = this.stack.lastIndexOf(name2);
      if (pos !== -1) {
        if (this.cbs.onclosetag) {
          let count2 = this.stack.length - pos;
          while (count2--) {
            this.cbs.onclosetag(this.stack.pop(), count2 !== 0);
          }
        } else
          this.stack.length = pos;
      } else if (!this.options.xmlMode && name2 === "p") {
        this.emitOpenTag("p");
        this.closeCurrentTag(true);
      }
    } else if (!this.options.xmlMode && name2 === "br") {
      (_b = (_a2 = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a2, "br");
      (_d = (_c = this.cbs).onopentag) === null || _d === void 0 ? void 0 : _d.call(_c, "br", {}, true);
      (_f = (_e = this.cbs).onclosetag) === null || _f === void 0 ? void 0 : _f.call(_e, "br", false);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onselfclosingtag(endIndex) {
    this.endIndex = endIndex;
    if (this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1]) {
      this.closeCurrentTag(false);
      this.startIndex = endIndex + 1;
    } else {
      this.onopentagend(endIndex);
    }
  }
  closeCurrentTag(isOpenImplied) {
    var _a2, _b;
    const name2 = this.tagname;
    this.endOpenTag(isOpenImplied);
    if (this.stack[this.stack.length - 1] === name2) {
      (_b = (_a2 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a2, name2, !isOpenImplied);
      this.stack.pop();
    }
  }
  /** @internal */
  onattribname(start, endIndex) {
    this.startIndex = start;
    const name2 = this.getSlice(start, endIndex);
    this.attribname = this.lowerCaseAttributeNames ? name2.toLowerCase() : name2;
  }
  /** @internal */
  onattribdata(start, endIndex) {
    this.attribvalue += this.getSlice(start, endIndex);
  }
  /** @internal */
  onattribentity(cp) {
    this.attribvalue += fromCodePoint(cp);
  }
  /** @internal */
  onattribend(quote, endIndex) {
    var _a2, _b;
    this.endIndex = endIndex;
    (_b = (_a2 = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a2, this.attribname, this.attribvalue, quote === QuoteType.Double ? '"' : quote === QuoteType.Single ? "'" : quote === QuoteType.NoValue ? void 0 : null);
    if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
      this.attribs[this.attribname] = this.attribvalue;
    }
    this.attribvalue = "";
  }
  getInstructionName(value) {
    const index2 = value.search(reNameEnd);
    let name2 = index2 < 0 ? value : value.substr(0, index2);
    if (this.lowerCaseTagNames) {
      name2 = name2.toLowerCase();
    }
    return name2;
  }
  /** @internal */
  ondeclaration(start, endIndex) {
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name2 = this.getInstructionName(value);
      this.cbs.onprocessinginstruction(`!${name2}`, `!${value}`);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onprocessinginstruction(start, endIndex) {
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name2 = this.getInstructionName(value);
      this.cbs.onprocessinginstruction(`?${name2}`, `?${value}`);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  oncomment(start, endIndex, offset2) {
    var _a2, _b, _c, _d;
    this.endIndex = endIndex;
    (_b = (_a2 = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a2, this.getSlice(start, endIndex - offset2));
    (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  oncdata(start, endIndex, offset2) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex - offset2);
    if (this.options.xmlMode || this.options.recognizeCDATA) {
      (_b = (_a2 = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a2);
      (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
      (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
    } else {
      (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, `[CDATA[${value}]]`);
      (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onend() {
    var _a2, _b;
    if (this.cbs.onclosetag) {
      this.endIndex = this.startIndex;
      for (let index2 = this.stack.length; index2 > 0; this.cbs.onclosetag(this.stack[--index2], true))
        ;
    }
    (_b = (_a2 = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a2);
  }
  /**
   * Resets the parser to a blank state, ready to parse a new HTML document
   */
  reset() {
    var _a2, _b, _c, _d;
    (_b = (_a2 = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a2);
    this.tokenizer.reset();
    this.tagname = "";
    this.attribname = "";
    this.attribs = null;
    this.stack.length = 0;
    this.startIndex = 0;
    this.endIndex = 0;
    (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
    this.buffers.length = 0;
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
  }
  /**
   * Resets the parser, then parses a complete document and
   * pushes it to the handler.
   *
   * @param data Document to parse.
   */
  parseComplete(data) {
    this.reset();
    this.end(data);
  }
  getSlice(start, end) {
    while (start - this.bufferOffset >= this.buffers[0].length) {
      this.shiftBuffer();
    }
    let slice = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
    while (end - this.bufferOffset > this.buffers[0].length) {
      this.shiftBuffer();
      slice += this.buffers[0].slice(0, end - this.bufferOffset);
    }
    return slice;
  }
  shiftBuffer() {
    this.bufferOffset += this.buffers[0].length;
    this.writeIndex--;
    this.buffers.shift();
  }
  /**
   * Parses a chunk of data and calls the corresponding callbacks.
   *
   * @param chunk Chunk to parse.
   */
  write(chunk) {
    var _a2, _b;
    if (this.ended) {
      (_b = (_a2 = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a2, new Error(".write() after done!"));
      return;
    }
    this.buffers.push(chunk);
    if (this.tokenizer.running) {
      this.tokenizer.write(chunk);
      this.writeIndex++;
    }
  }
  /**
   * Parses the end of the buffer and clears the stack, calls onend.
   *
   * @param chunk Optional final chunk to parse.
   */
  end(chunk) {
    var _a2, _b;
    if (this.ended) {
      (_b = (_a2 = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a2, new Error(".end() after done!"));
      return;
    }
    if (chunk)
      this.write(chunk);
    this.ended = true;
    this.tokenizer.end();
  }
  /**
   * Pauses parsing. The parser won't emit events until `resume` is called.
   */
  pause() {
    this.tokenizer.pause();
  }
  /**
   * Resumes parsing after `pause` was called.
   */
  resume() {
    this.tokenizer.resume();
    while (this.tokenizer.running && this.writeIndex < this.buffers.length) {
      this.tokenizer.write(this.buffers[this.writeIndex++]);
    }
    if (this.ended)
      this.tokenizer.end();
  }
  /**
   * Alias of `write`, for backwards compatibility.
   *
   * @param chunk Chunk to parse.
   * @deprecated
   */
  parseChunk(chunk) {
    this.write(chunk);
  }
  /**
   * Alias of `end`, for backwards compatibility.
   *
   * @param chunk Optional final chunk to parse.
   * @deprecated
   */
  done(chunk) {
    this.end(chunk);
  }
}
const xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
const xmlCodeMap = /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [39, "&apos;"],
  [60, "&lt;"],
  [62, "&gt;"]
]);
const getCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? (str, index2) => str.codePointAt(index2) : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    (c2, index2) => (c2.charCodeAt(index2) & 64512) === 55296 ? (c2.charCodeAt(index2) - 55296) * 1024 + c2.charCodeAt(index2 + 1) - 56320 + 65536 : c2.charCodeAt(index2)
  )
);
function encodeXML(str) {
  let ret = "";
  let lastIdx = 0;
  let match2;
  while ((match2 = xmlReplacer.exec(str)) !== null) {
    const i = match2.index;
    const char2 = str.charCodeAt(i);
    const next2 = xmlCodeMap.get(char2);
    if (next2 !== void 0) {
      ret += str.substring(lastIdx, i) + next2;
      lastIdx = i + 1;
    } else {
      ret += `${str.substring(lastIdx, i)}&#x${getCodePoint(str, i).toString(16)};`;
      lastIdx = xmlReplacer.lastIndex += Number((char2 & 64512) === 55296);
    }
  }
  return ret + str.substr(lastIdx);
}
function getEscaper(regex, map2) {
  return function escape2(data) {
    let match2;
    let lastIdx = 0;
    let result2 = "";
    while (match2 = regex.exec(data)) {
      if (lastIdx !== match2.index) {
        result2 += data.substring(lastIdx, match2.index);
      }
      result2 += map2.get(match2[0].charCodeAt(0));
      lastIdx = match2.index + 1;
    }
    return result2 + data.substring(lastIdx);
  };
}
const escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [160, "&nbsp;"]
]));
const escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
  [38, "&amp;"],
  [60, "&lt;"],
  [62, "&gt;"],
  [160, "&nbsp;"]
]));
const elementNames = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((val) => [val.toLowerCase(), val]));
const attributeNames = new Map([
  "definitionURL",
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((val) => [val.toLowerCase(), val]));
const unencodedElements = /* @__PURE__ */ new Set([
  "style",
  "script",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "plaintext",
  "noscript"
]);
function replaceQuotes(value) {
  return value.replace(/"/g, "&quot;");
}
function formatAttributes(attributes, opts) {
  var _a2;
  if (!attributes)
    return;
  const encode2 = ((_a2 = opts.encodeEntities) !== null && _a2 !== void 0 ? _a2 : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML : escapeAttribute;
  return Object.keys(attributes).map((key) => {
    var _a3, _b;
    const value = (_a3 = attributes[key]) !== null && _a3 !== void 0 ? _a3 : "";
    if (opts.xmlMode === "foreign") {
      key = (_b = attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
    }
    if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
      return key;
    }
    return `${key}="${encode2(value)}"`;
  }).join(" ");
}
const singleTag = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
function render$1(node, options = {}) {
  const nodes = "length" in node ? node : [node];
  let output = "";
  for (let i = 0; i < nodes.length; i++) {
    output += renderNode(nodes[i], options);
  }
  return output;
}
function renderNode(node, options) {
  switch (node.type) {
    case Root:
      return render$1(node.children, options);
    // @ts-expect-error We don't use `Doctype` yet
    case Doctype:
    case Directive:
      return renderDirective(node);
    case Comment$1:
      return renderComment(node);
    case CDATA$1:
      return renderCdata(node);
    case Script:
    case Style:
    case Tag:
      return renderTag(node, options);
    case Text$1:
      return renderText(node, options);
  }
}
const foreignModeIntegrationPoints = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignObject",
  "desc",
  "title"
]);
const foreignElements = /* @__PURE__ */ new Set(["svg", "math"]);
function renderTag(elem, opts) {
  var _a2;
  if (opts.xmlMode === "foreign") {
    elem.name = (_a2 = elementNames.get(elem.name)) !== null && _a2 !== void 0 ? _a2 : elem.name;
    if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
      opts = { ...opts, xmlMode: false };
    }
  }
  if (!opts.xmlMode && foreignElements.has(elem.name)) {
    opts = { ...opts, xmlMode: "foreign" };
  }
  let tag2 = `<${elem.name}`;
  const attribs = formatAttributes(elem.attribs, opts);
  if (attribs) {
    tag2 += ` ${attribs}`;
  }
  if (elem.children.length === 0 && (opts.xmlMode ? (
    // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
    opts.selfClosingTags !== false
  ) : (
    // User explicitly asked for self-closing tags, even in HTML mode
    opts.selfClosingTags && singleTag.has(elem.name)
  ))) {
    if (!opts.xmlMode)
      tag2 += " ";
    tag2 += "/>";
  } else {
    tag2 += ">";
    if (elem.children.length > 0) {
      tag2 += render$1(elem.children, opts);
    }
    if (opts.xmlMode || !singleTag.has(elem.name)) {
      tag2 += `</${elem.name}>`;
    }
  }
  return tag2;
}
function renderDirective(elem) {
  return `<${elem.data}>`;
}
function renderText(elem, opts) {
  var _a2;
  let data = elem.data || "";
  if (((_a2 = opts.encodeEntities) !== null && _a2 !== void 0 ? _a2 : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
    data = opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML(data) : escapeText(data);
  }
  return data;
}
function renderCdata(elem) {
  return `<![CDATA[${elem.children[0].data}]]>`;
}
function renderComment(elem) {
  return `<!--${elem.data}-->`;
}
function parseDocument(data, options) {
  const handler2 = new DomHandler(void 0, options);
  new Parser(handler2, options).end(data);
  return handler2.root;
}
var cjs;
var hasRequiredCjs;
function requireCjs() {
  if (hasRequiredCjs) return cjs;
  hasRequiredCjs = 1;
  var isMergeableObject = function isMergeableObject2(value) {
    return isNonNullObject(value) && !isSpecial(value);
  };
  function isNonNullObject(value) {
    return !!value && typeof value === "object";
  }
  function isSpecial(value) {
    var stringValue = Object.prototype.toString.call(value);
    return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
  }
  var canUseSymbol = typeof Symbol === "function" && Symbol.for;
  var REACT_ELEMENT_TYPE = canUseSymbol ? /* @__PURE__ */ Symbol.for("react.element") : 60103;
  function isReactElement(value) {
    return value.$$typeof === REACT_ELEMENT_TYPE;
  }
  function emptyTarget(val) {
    return Array.isArray(val) ? [] : {};
  }
  function cloneUnlessOtherwiseSpecified(value, options) {
    return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
  }
  function defaultArrayMerge(target, source, options) {
    return target.concat(source).map(function(element) {
      return cloneUnlessOtherwiseSpecified(element, options);
    });
  }
  function getMergeFunction(key, options) {
    if (!options.customMerge) {
      return deepmerge;
    }
    var customMerge = options.customMerge(key);
    return typeof customMerge === "function" ? customMerge : deepmerge;
  }
  function getEnumerableOwnPropertySymbols(target) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol2) {
      return Object.propertyIsEnumerable.call(target, symbol2);
    }) : [];
  }
  function getKeys(target) {
    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
  }
  function propertyIsOnObject(object, property) {
    try {
      return property in object;
    } catch (_) {
      return false;
    }
  }
  function propertyIsUnsafe(target, key) {
    return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
  }
  function mergeObject(target, source, options) {
    var destination = {};
    if (options.isMergeableObject(target)) {
      getKeys(target).forEach(function(key) {
        destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
      });
    }
    getKeys(source).forEach(function(key) {
      if (propertyIsUnsafe(target, key)) {
        return;
      }
      if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
        destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
      } else {
        destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
      }
    });
    return destination;
  }
  function deepmerge(target, source, options) {
    options = options || {};
    options.arrayMerge = options.arrayMerge || defaultArrayMerge;
    options.isMergeableObject = options.isMergeableObject || isMergeableObject;
    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
    var sourceIsArray = Array.isArray(source);
    var targetIsArray = Array.isArray(target);
    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
    if (!sourceAndTargetTypesMatch) {
      return cloneUnlessOtherwiseSpecified(source, options);
    } else if (sourceIsArray) {
      return options.arrayMerge(target, source, options);
    } else {
      return mergeObject(target, source, options);
    }
  }
  deepmerge.all = function deepmergeAll(array, options) {
    if (!Array.isArray(array)) {
      throw new Error("first argument should be an array");
    }
    return array.reduce(function(prev, next2) {
      return deepmerge(prev, next2, options);
    }, {});
  };
  var deepmerge_1 = deepmerge;
  cjs = deepmerge_1;
  return cjs;
}
var cjsExports = requireCjs();
const merge = /* @__PURE__ */ getDefaultExportFromCjs(cjsExports);
function limitedDepthRecursive(n2, f, g = () => void 0) {
  if (n2 === void 0) {
    const f1 = function(...args) {
      return f(f1, ...args);
    };
    return f1;
  }
  if (n2 >= 0) {
    return function(...args) {
      return f(limitedDepthRecursive(n2 - 1, f, g), ...args);
    };
  }
  return g;
}
function trimCharacter(str, char2) {
  let start = 0;
  let end = str.length;
  while (start < end && str[start] === char2) {
    ++start;
  }
  while (end > start && str[end - 1] === char2) {
    --end;
  }
  return start > 0 || end < str.length ? str.substring(start, end) : str;
}
function trimCharacterEnd(str, char2) {
  let end = str.length;
  while (end > 0 && str[end - 1] === char2) {
    --end;
  }
  return end < str.length ? str.substring(0, end) : str;
}
function unicodeEscape(str) {
  return str.replace(/[\s\S]/g, (c2) => "\\u" + c2.charCodeAt().toString(16).padStart(4, "0"));
}
function mergeDuplicatesPreferLast(items, getKey) {
  const map2 = /* @__PURE__ */ new Map();
  for (let i = items.length; i-- > 0; ) {
    const item = items[i];
    const key = getKey(item);
    map2.set(
      key,
      map2.has(key) ? merge(item, map2.get(key), { arrayMerge: overwriteMerge$1 }) : item
    );
  }
  return [...map2.values()].reverse();
}
const overwriteMerge$1 = (acc, src, options) => [...src];
function get(obj, path) {
  for (const key of path) {
    if (!obj) {
      return void 0;
    }
    obj = obj[key];
  }
  return obj;
}
function numberToLetterSequence(num, baseChar = "a", base = 26) {
  const digits = [];
  do {
    num -= 1;
    digits.push(num % base);
    num = num / base >> 0;
  } while (num > 0);
  const baseCode = baseChar.charCodeAt(0);
  return digits.reverse().map((n2) => String.fromCharCode(baseCode + n2)).join("");
}
const I = ["I", "X", "C", "M"];
const V = ["V", "L", "D"];
function numberToRoman(num) {
  return [...num + ""].map((n2) => +n2).reverse().map((v, i) => v % 5 < 4 ? (v < 5 ? "" : V[i]) + I[i].repeat(v % 5) : I[i] + (v < 5 ? V[i] : I[i + 1])).reverse().join("");
}
class InlineTextBuilder {
  /**
   * Creates an instance of InlineTextBuilder.
   *
   * If `maxLineLength` is not provided then it is either `options.wordwrap` or unlimited.
   *
   * @param { Options } options           HtmlToText options.
   * @param { number }  [ maxLineLength ] This builder will try to wrap text to fit this line length.
   */
  constructor(options, maxLineLength = void 0) {
    this.lines = [];
    this.nextLineWords = [];
    this.maxLineLength = maxLineLength || options.wordwrap || Number.MAX_VALUE;
    this.nextLineAvailableChars = this.maxLineLength;
    this.wrapCharacters = get(options, ["longWordSplit", "wrapCharacters"]) || [];
    this.forceWrapOnLimit = get(options, ["longWordSplit", "forceWrapOnLimit"]) || false;
    this.stashedSpace = false;
    this.wordBreakOpportunity = false;
  }
  /**
   * Add a new word.
   *
   * @param { string } word A word to add.
   * @param { boolean } [noWrap] Don't wrap text even if the line is too long.
   */
  pushWord(word, noWrap = false) {
    if (this.nextLineAvailableChars <= 0 && !noWrap) {
      this.startNewLine();
    }
    const isLineStart = this.nextLineWords.length === 0;
    const cost = word.length + (isLineStart ? 0 : 1);
    if (cost <= this.nextLineAvailableChars || noWrap) {
      this.nextLineWords.push(word);
      this.nextLineAvailableChars -= cost;
    } else {
      const [first, ...rest] = this.splitLongWord(word);
      if (!isLineStart) {
        this.startNewLine();
      }
      this.nextLineWords.push(first);
      this.nextLineAvailableChars -= first.length;
      for (const part of rest) {
        this.startNewLine();
        this.nextLineWords.push(part);
        this.nextLineAvailableChars -= part.length;
      }
    }
  }
  /**
   * Pop a word from the currently built line.
   * This doesn't affect completed lines.
   *
   * @returns { string }
   */
  popWord() {
    const lastWord = this.nextLineWords.pop();
    if (lastWord !== void 0) {
      const isLineStart = this.nextLineWords.length === 0;
      const cost = lastWord.length + (isLineStart ? 0 : 1);
      this.nextLineAvailableChars += cost;
    }
    return lastWord;
  }
  /**
   * Concat a word to the last word already in the builder.
   * Adds a new word in case there are no words yet in the last line.
   *
   * @param { string } word A word to be concatenated.
   * @param { boolean } [noWrap] Don't wrap text even if the line is too long.
   */
  concatWord(word, noWrap = false) {
    if (this.wordBreakOpportunity && word.length > this.nextLineAvailableChars) {
      this.pushWord(word, noWrap);
      this.wordBreakOpportunity = false;
    } else {
      const lastWord = this.popWord();
      this.pushWord(lastWord ? lastWord.concat(word) : word, noWrap);
    }
  }
  /**
   * Add current line (and more empty lines if provided argument > 1) to the list of complete lines and start a new one.
   *
   * @param { number } n Number of line breaks that will be added to the resulting string.
   */
  startNewLine(n2 = 1) {
    this.lines.push(this.nextLineWords);
    if (n2 > 1) {
      this.lines.push(...Array.from({ length: n2 - 1 }, () => []));
    }
    this.nextLineWords = [];
    this.nextLineAvailableChars = this.maxLineLength;
  }
  /**
   * No words in this builder.
   *
   * @returns { boolean }
   */
  isEmpty() {
    return this.lines.length === 0 && this.nextLineWords.length === 0;
  }
  clear() {
    this.lines.length = 0;
    this.nextLineWords.length = 0;
    this.nextLineAvailableChars = this.maxLineLength;
  }
  /**
   * Join all lines of words inside the InlineTextBuilder into a complete string.
   *
   * @returns { string }
   */
  toString() {
    return [...this.lines, this.nextLineWords].map((words) => words.join(" ")).join("\n");
  }
  /**
   * Split a long word up to fit within the word wrap limit.
   * Use either a character to split looking back from the word wrap limit,
   * or truncate to the word wrap limit.
   *
   * @param   { string }   word Input word.
   * @returns { string[] }      Parts of the word.
   */
  splitLongWord(word) {
    const parts = [];
    let idx = 0;
    while (word.length > this.maxLineLength) {
      const firstLine = word.substring(0, this.maxLineLength);
      const remainingChars = word.substring(this.maxLineLength);
      const splitIndex = firstLine.lastIndexOf(this.wrapCharacters[idx]);
      if (splitIndex > -1) {
        word = firstLine.substring(splitIndex + 1) + remainingChars;
        parts.push(firstLine.substring(0, splitIndex + 1));
      } else {
        idx++;
        if (idx < this.wrapCharacters.length) {
          word = firstLine + remainingChars;
        } else {
          if (this.forceWrapOnLimit) {
            parts.push(firstLine);
            word = remainingChars;
            if (word.length > this.maxLineLength) {
              continue;
            }
          } else {
            word = firstLine + remainingChars;
          }
          break;
        }
      }
    }
    parts.push(word);
    return parts;
  }
}
class StackItem {
  constructor(next2 = null) {
    this.next = next2;
  }
  getRoot() {
    return this.next ? this.next : this;
  }
}
class BlockStackItem extends StackItem {
  constructor(options, next2 = null, leadingLineBreaks = 1, maxLineLength = void 0) {
    super(next2);
    this.leadingLineBreaks = leadingLineBreaks;
    this.inlineTextBuilder = new InlineTextBuilder(options, maxLineLength);
    this.rawText = "";
    this.stashedLineBreaks = 0;
    this.isPre = next2 && next2.isPre;
    this.isNoWrap = next2 && next2.isNoWrap;
  }
}
class ListStackItem extends BlockStackItem {
  constructor(options, next2 = null, {
    interRowLineBreaks = 1,
    leadingLineBreaks = 2,
    maxLineLength = void 0,
    maxPrefixLength = 0,
    prefixAlign = "left"
  } = {}) {
    super(options, next2, leadingLineBreaks, maxLineLength);
    this.maxPrefixLength = maxPrefixLength;
    this.prefixAlign = prefixAlign;
    this.interRowLineBreaks = interRowLineBreaks;
  }
}
class ListItemStackItem extends BlockStackItem {
  constructor(options, next2 = null, {
    leadingLineBreaks = 1,
    maxLineLength = void 0,
    prefix = ""
  } = {}) {
    super(options, next2, leadingLineBreaks, maxLineLength);
    this.prefix = prefix;
  }
}
class TableStackItem extends StackItem {
  constructor(next2 = null) {
    super(next2);
    this.rows = [];
    this.isPre = next2 && next2.isPre;
    this.isNoWrap = next2 && next2.isNoWrap;
  }
}
class TableRowStackItem extends StackItem {
  constructor(next2 = null) {
    super(next2);
    this.cells = [];
    this.isPre = next2 && next2.isPre;
    this.isNoWrap = next2 && next2.isNoWrap;
  }
}
class TableCellStackItem extends StackItem {
  constructor(options, next2 = null, maxColumnWidth = void 0) {
    super(next2);
    this.inlineTextBuilder = new InlineTextBuilder(options, maxColumnWidth);
    this.rawText = "";
    this.stashedLineBreaks = 0;
    this.isPre = next2 && next2.isPre;
    this.isNoWrap = next2 && next2.isNoWrap;
  }
}
class TransformerStackItem extends StackItem {
  constructor(next2 = null, transform2) {
    super(next2);
    this.transform = transform2;
  }
}
function charactersToCodes(str) {
  return [...str].map((c2) => "\\u" + c2.charCodeAt(0).toString(16).padStart(4, "0")).join("");
}
class WhitespaceProcessor {
  /**
   * Creates an instance of WhitespaceProcessor.
   *
   * @param { Options } options    HtmlToText options.
   * @memberof WhitespaceProcessor
   */
  constructor(options) {
    this.whitespaceChars = options.preserveNewlines ? options.whitespaceCharacters.replace(/\n/g, "") : options.whitespaceCharacters;
    const whitespaceCodes = charactersToCodes(this.whitespaceChars);
    this.leadingWhitespaceRe = new RegExp(`^[${whitespaceCodes}]`);
    this.trailingWhitespaceRe = new RegExp(`[${whitespaceCodes}]$`);
    this.allWhitespaceOrEmptyRe = new RegExp(`^[${whitespaceCodes}]*$`);
    this.newlineOrNonWhitespaceRe = new RegExp(`(\\n|[^\\n${whitespaceCodes}])`, "g");
    this.newlineOrNonNewlineStringRe = new RegExp(`(\\n|[^\\n]+)`, "g");
    if (options.preserveNewlines) {
      const wordOrNewlineRe = new RegExp(`\\n|[^\\n${whitespaceCodes}]+`, "gm");
      this.shrinkWrapAdd = function(text2, inlineTextBuilder, transform2 = ((str) => str), noWrap = false) {
        if (!text2) {
          return;
        }
        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
        let anyMatch = false;
        let m = wordOrNewlineRe.exec(text2);
        if (m) {
          anyMatch = true;
          if (m[0] === "\n") {
            inlineTextBuilder.startNewLine();
          } else if (previouslyStashedSpace || this.testLeadingWhitespace(text2)) {
            inlineTextBuilder.pushWord(transform2(m[0]), noWrap);
          } else {
            inlineTextBuilder.concatWord(transform2(m[0]), noWrap);
          }
          while ((m = wordOrNewlineRe.exec(text2)) !== null) {
            if (m[0] === "\n") {
              inlineTextBuilder.startNewLine();
            } else {
              inlineTextBuilder.pushWord(transform2(m[0]), noWrap);
            }
          }
        }
        inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text2);
      };
    } else {
      const wordRe = new RegExp(`[^${whitespaceCodes}]+`, "g");
      this.shrinkWrapAdd = function(text2, inlineTextBuilder, transform2 = ((str) => str), noWrap = false) {
        if (!text2) {
          return;
        }
        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
        let anyMatch = false;
        let m = wordRe.exec(text2);
        if (m) {
          anyMatch = true;
          if (previouslyStashedSpace || this.testLeadingWhitespace(text2)) {
            inlineTextBuilder.pushWord(transform2(m[0]), noWrap);
          } else {
            inlineTextBuilder.concatWord(transform2(m[0]), noWrap);
          }
          while ((m = wordRe.exec(text2)) !== null) {
            inlineTextBuilder.pushWord(transform2(m[0]), noWrap);
          }
        }
        inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text2);
      };
    }
  }
  /**
   * Add text with only minimal processing.
   * Everything between newlines considered a single word.
   * No whitespace is trimmed.
   * Not affected by preserveNewlines option - `\n` always starts a new line.
   *
   * `noWrap` argument is `true` by default - this won't start a new line
   * even if there is not enough space left in the current line.
   *
   * @param { string }            text              Input text.
   * @param { InlineTextBuilder } inlineTextBuilder A builder to receive processed text.
   * @param { boolean }           [noWrap] Don't wrap text even if the line is too long.
   */
  addLiteral(text2, inlineTextBuilder, noWrap = true) {
    if (!text2) {
      return;
    }
    const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
    let anyMatch = false;
    let m = this.newlineOrNonNewlineStringRe.exec(text2);
    if (m) {
      anyMatch = true;
      if (m[0] === "\n") {
        inlineTextBuilder.startNewLine();
      } else if (previouslyStashedSpace) {
        inlineTextBuilder.pushWord(m[0], noWrap);
      } else {
        inlineTextBuilder.concatWord(m[0], noWrap);
      }
      while ((m = this.newlineOrNonNewlineStringRe.exec(text2)) !== null) {
        if (m[0] === "\n") {
          inlineTextBuilder.startNewLine();
        } else {
          inlineTextBuilder.pushWord(m[0], noWrap);
        }
      }
    }
    inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch;
  }
  /**
   * Test whether the given text starts with HTML whitespace character.
   *
   * @param   { string }  text  The string to test.
   * @returns { boolean }
   */
  testLeadingWhitespace(text2) {
    return this.leadingWhitespaceRe.test(text2);
  }
  /**
   * Test whether the given text ends with HTML whitespace character.
   *
   * @param   { string }  text  The string to test.
   * @returns { boolean }
   */
  testTrailingWhitespace(text2) {
    return this.trailingWhitespaceRe.test(text2);
  }
  /**
   * Test whether the given text contains any non-whitespace characters.
   *
   * @param   { string }  text  The string to test.
   * @returns { boolean }
   */
  testContainsWords(text2) {
    return !this.allWhitespaceOrEmptyRe.test(text2);
  }
  /**
   * Return the number of newlines if there are no words.
   *
   * If any word is found then return zero regardless of the actual number of newlines.
   *
   * @param   { string }  text  Input string.
   * @returns { number }
   */
  countNewlinesNoWords(text2) {
    this.newlineOrNonWhitespaceRe.lastIndex = 0;
    let counter = 0;
    let match2;
    while ((match2 = this.newlineOrNonWhitespaceRe.exec(text2)) !== null) {
      if (match2[0] === "\n") {
        counter++;
      } else {
        return 0;
      }
    }
    return counter;
  }
}
class BlockTextBuilder {
  /**
   * Creates an instance of BlockTextBuilder.
   *
   * @param { Options } options HtmlToText options.
   * @param { import('selderee').Picker<DomNode, TagDefinition> } picker Selectors decision tree picker.
   * @param { any} [metadata] Optional metadata for HTML document, for use in formatters.
   */
  constructor(options, picker, metadata = void 0) {
    this.options = options;
    this.picker = picker;
    this.metadata = metadata;
    this.whitespaceProcessor = new WhitespaceProcessor(options);
    this._stackItem = new BlockStackItem(options);
    this._wordTransformer = void 0;
  }
  /**
   * Put a word-by-word transform function onto the transformations stack.
   *
   * Mainly used for uppercasing. Can be bypassed to add unformatted text such as URLs.
   *
   * Word transformations applied before wrapping.
   *
   * @param { (str: string) => string } wordTransform Word transformation function.
   */
  pushWordTransform(wordTransform) {
    this._wordTransformer = new TransformerStackItem(this._wordTransformer, wordTransform);
  }
  /**
   * Remove a function from the word transformations stack.
   *
   * @returns { (str: string) => string } A function that was removed.
   */
  popWordTransform() {
    if (!this._wordTransformer) {
      return void 0;
    }
    const transform2 = this._wordTransformer.transform;
    this._wordTransformer = this._wordTransformer.next;
    return transform2;
  }
  /**
   * Ignore wordwrap option in followup inline additions and disable automatic wrapping.
   */
  startNoWrap() {
    this._stackItem.isNoWrap = true;
  }
  /**
   * Return automatic wrapping to behavior defined by options.
   */
  stopNoWrap() {
    this._stackItem.isNoWrap = false;
  }
  /** @returns { (str: string) => string } */
  _getCombinedWordTransformer() {
    const wt = this._wordTransformer ? ((str) => applyTransformer(str, this._wordTransformer)) : void 0;
    const ce = this.options.encodeCharacters;
    return wt ? ce ? (str) => ce(wt(str)) : wt : ce;
  }
  _popStackItem() {
    const item = this._stackItem;
    this._stackItem = item.next;
    return item;
  }
  /**
   * Add a line break into currently built block.
   */
  addLineBreak() {
    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {
      return;
    }
    if (this._stackItem.isPre) {
      this._stackItem.rawText += "\n";
    } else {
      this._stackItem.inlineTextBuilder.startNewLine();
    }
  }
  /**
   * Allow to break line in case directly following text will not fit.
   */
  addWordBreakOpportunity() {
    if (this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem) {
      this._stackItem.inlineTextBuilder.wordBreakOpportunity = true;
    }
  }
  /**
   * Add a node inline into the currently built block.
   *
   * @param { string } str
   * Text content of a node to add.
   *
   * @param { object } [param1]
   * Object holding the parameters of the operation.
   *
   * @param { boolean } [param1.noWordTransform]
   * Ignore word transformers if there are any.
   * Don't encode characters as well.
   * (Use this for things like URL addresses).
   */
  addInline(str, { noWordTransform = false } = {}) {
    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {
      return;
    }
    if (this._stackItem.isPre) {
      this._stackItem.rawText += str;
      return;
    }
    if (str.length === 0 || // empty string
    this._stackItem.stashedLineBreaks && // stashed linebreaks make whitespace irrelevant
    !this.whitespaceProcessor.testContainsWords(str)) {
      return;
    }
    if (this.options.preserveNewlines) {
      const newlinesNumber = this.whitespaceProcessor.countNewlinesNoWords(str);
      if (newlinesNumber > 0) {
        this._stackItem.inlineTextBuilder.startNewLine(newlinesNumber);
        return;
      }
    }
    if (this._stackItem.stashedLineBreaks) {
      this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);
    }
    this.whitespaceProcessor.shrinkWrapAdd(
      str,
      this._stackItem.inlineTextBuilder,
      noWordTransform ? void 0 : this._getCombinedWordTransformer(),
      this._stackItem.isNoWrap
    );
    this._stackItem.stashedLineBreaks = 0;
  }
  /**
   * Add a string inline into the currently built block.
   *
   * Use this for markup elements that don't have to adhere
   * to text layout rules.
   *
   * @param { string } str Text to add.
   */
  addLiteral(str) {
    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {
      return;
    }
    if (str.length === 0) {
      return;
    }
    if (this._stackItem.isPre) {
      this._stackItem.rawText += str;
      return;
    }
    if (this._stackItem.stashedLineBreaks) {
      this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);
    }
    this.whitespaceProcessor.addLiteral(
      str,
      this._stackItem.inlineTextBuilder,
      this._stackItem.isNoWrap
    );
    this._stackItem.stashedLineBreaks = 0;
  }
  /**
   * Start building a new block.
   *
   * @param { object } [param0]
   * Object holding the parameters of the block.
   *
   * @param { number } [param0.leadingLineBreaks]
   * This block should have at least this number of line breaks to separate it from any preceding block.
   *
   * @param { number }  [param0.reservedLineLength]
   * Reserve this number of characters on each line for block markup.
   *
   * @param { boolean } [param0.isPre]
   * Should HTML whitespace be preserved inside this block.
   */
  openBlock({ leadingLineBreaks = 1, reservedLineLength = 0, isPre = false } = {}) {
    const maxLineLength = Math.max(20, this._stackItem.inlineTextBuilder.maxLineLength - reservedLineLength);
    this._stackItem = new BlockStackItem(
      this.options,
      this._stackItem,
      leadingLineBreaks,
      maxLineLength
    );
    if (isPre) {
      this._stackItem.isPre = true;
    }
  }
  /**
   * Finalize currently built block, add it's content to the parent block.
   *
   * @param { object } [param0]
   * Object holding the parameters of the block.
   *
   * @param { number } [param0.trailingLineBreaks]
   * This block should have at least this number of line breaks to separate it from any following block.
   *
   * @param { (str: string) => string } [param0.blockTransform]
   * A function to transform the block text before adding to the parent block.
   * This happens after word wrap and should be used in combination with reserved line length
   * in order to keep line lengths correct.
   * Used for whole block markup.
   */
  closeBlock({ trailingLineBreaks = 1, blockTransform = void 0 } = {}) {
    const block = this._popStackItem();
    const blockText = blockTransform ? blockTransform(getText(block)) : getText(block);
    addText(this._stackItem, blockText, block.leadingLineBreaks, Math.max(block.stashedLineBreaks, trailingLineBreaks));
  }
  /**
   * Start building a new list.
   *
   * @param { object } [param0]
   * Object holding the parameters of the list.
   *
   * @param { number } [param0.maxPrefixLength]
   * Length of the longest list item prefix.
   * If not supplied or too small then list items won't be aligned properly.
   *
   * @param { 'left' | 'right' } [param0.prefixAlign]
   * Specify how prefixes of different lengths have to be aligned
   * within a column.
   *
   * @param { number } [param0.interRowLineBreaks]
   * Minimum number of line breaks between list items.
   *
   * @param { number } [param0.leadingLineBreaks]
   * This list should have at least this number of line breaks to separate it from any preceding block.
   */
  openList({ maxPrefixLength = 0, prefixAlign = "left", interRowLineBreaks = 1, leadingLineBreaks = 2 } = {}) {
    this._stackItem = new ListStackItem(this.options, this._stackItem, {
      interRowLineBreaks,
      leadingLineBreaks,
      maxLineLength: this._stackItem.inlineTextBuilder.maxLineLength,
      maxPrefixLength,
      prefixAlign
    });
  }
  /**
   * Start building a new list item.
   *
   * @param {object} param0
   * Object holding the parameters of the list item.
   *
   * @param { string } [param0.prefix]
   * Prefix for this list item (item number, bullet point, etc).
   */
  openListItem({ prefix = "" } = {}) {
    if (!(this._stackItem instanceof ListStackItem)) {
      throw new Error("Can't add a list item to something that is not a list! Check the formatter.");
    }
    const list = this._stackItem;
    const prefixLength = Math.max(prefix.length, list.maxPrefixLength);
    const maxLineLength = Math.max(20, list.inlineTextBuilder.maxLineLength - prefixLength);
    this._stackItem = new ListItemStackItem(this.options, list, {
      prefix,
      maxLineLength,
      leadingLineBreaks: list.interRowLineBreaks
    });
  }
  /**
   * Finalize currently built list item, add it's content to the parent list.
   */
  closeListItem() {
    const listItem = this._popStackItem();
    const list = listItem.next;
    const prefixLength = Math.max(listItem.prefix.length, list.maxPrefixLength);
    const spacing = "\n" + " ".repeat(prefixLength);
    const prefix = list.prefixAlign === "right" ? listItem.prefix.padStart(prefixLength) : listItem.prefix.padEnd(prefixLength);
    const text2 = prefix + getText(listItem).replace(/\n/g, spacing);
    addText(
      list,
      text2,
      listItem.leadingLineBreaks,
      Math.max(listItem.stashedLineBreaks, list.interRowLineBreaks)
    );
  }
  /**
   * Finalize currently built list, add it's content to the parent block.
   *
   * @param { object } param0
   * Object holding the parameters of the list.
   *
   * @param { number } [param0.trailingLineBreaks]
   * This list should have at least this number of line breaks to separate it from any following block.
   */
  closeList({ trailingLineBreaks = 2 } = {}) {
    const list = this._popStackItem();
    const text2 = getText(list);
    if (text2) {
      addText(this._stackItem, text2, list.leadingLineBreaks, trailingLineBreaks);
    }
  }
  /**
   * Start building a table.
   */
  openTable() {
    this._stackItem = new TableStackItem(this._stackItem);
  }
  /**
   * Start building a table row.
   */
  openTableRow() {
    if (!(this._stackItem instanceof TableStackItem)) {
      throw new Error("Can't add a table row to something that is not a table! Check the formatter.");
    }
    this._stackItem = new TableRowStackItem(this._stackItem);
  }
  /**
   * Start building a table cell.
   *
   * @param { object } [param0]
   * Object holding the parameters of the cell.
   *
   * @param { number } [param0.maxColumnWidth]
   * Wrap cell content to this width. Fall back to global wordwrap value if undefined.
   */
  openTableCell({ maxColumnWidth = void 0 } = {}) {
    if (!(this._stackItem instanceof TableRowStackItem)) {
      throw new Error("Can't add a table cell to something that is not a table row! Check the formatter.");
    }
    this._stackItem = new TableCellStackItem(this.options, this._stackItem, maxColumnWidth);
  }
  /**
   * Finalize currently built table cell and add it to parent table row's cells.
   *
   * @param { object } [param0]
   * Object holding the parameters of the cell.
   *
   * @param { number } [param0.colspan] How many columns this cell should occupy.
   * @param { number } [param0.rowspan] How many rows this cell should occupy.
   */
  closeTableCell({ colspan = 1, rowspan = 1 } = {}) {
    const cell = this._popStackItem();
    const text2 = trimCharacter(getText(cell), "\n");
    cell.next.cells.push({ colspan, rowspan, text: text2 });
  }
  /**
   * Finalize currently built table row and add it to parent table's rows.
   */
  closeTableRow() {
    const row = this._popStackItem();
    row.next.rows.push(row.cells);
  }
  /**
   * Finalize currently built table and add the rendered text to the parent block.
   *
   * @param { object } param0
   * Object holding the parameters of the table.
   *
   * @param { TablePrinter } param0.tableToString
   * A function to convert a table of stringified cells into a complete table.
   *
   * @param { number } [param0.leadingLineBreaks]
   * This table should have at least this number of line breaks to separate if from any preceding block.
   *
   * @param { number } [param0.trailingLineBreaks]
   * This table should have at least this number of line breaks to separate it from any following block.
   */
  closeTable({ tableToString: tableToString2, leadingLineBreaks = 2, trailingLineBreaks = 2 }) {
    const table = this._popStackItem();
    const output = tableToString2(table.rows);
    if (output) {
      addText(this._stackItem, output, leadingLineBreaks, trailingLineBreaks);
    }
  }
  /**
   * Return the rendered text content of this builder.
   *
   * @returns { string }
   */
  toString() {
    return getText(this._stackItem.getRoot());
  }
}
function getText(stackItem) {
  if (!(stackItem instanceof BlockStackItem || stackItem instanceof ListItemStackItem || stackItem instanceof TableCellStackItem)) {
    throw new Error("Only blocks, list items and table cells can be requested for text contents.");
  }
  return stackItem.inlineTextBuilder.isEmpty() ? stackItem.rawText : stackItem.rawText + stackItem.inlineTextBuilder.toString();
}
function addText(stackItem, text2, leadingLineBreaks, trailingLineBreaks) {
  if (!(stackItem instanceof BlockStackItem || stackItem instanceof ListItemStackItem || stackItem instanceof TableCellStackItem)) {
    throw new Error("Only blocks, list items and table cells can contain text.");
  }
  const parentText = getText(stackItem);
  const lineBreaks = Math.max(stackItem.stashedLineBreaks, leadingLineBreaks);
  stackItem.inlineTextBuilder.clear();
  if (parentText) {
    stackItem.rawText = parentText + "\n".repeat(lineBreaks) + text2;
  } else {
    stackItem.rawText = text2;
    stackItem.leadingLineBreaks = lineBreaks;
  }
  stackItem.stashedLineBreaks = trailingLineBreaks;
}
function applyTransformer(str, transformer) {
  return transformer ? applyTransformer(transformer.transform(str), transformer.next) : str;
}
function compile$1(options = {}) {
  const selectorsWithoutFormat = options.selectors.filter((s2) => !s2.format);
  if (selectorsWithoutFormat.length) {
    throw new Error(
      "Following selectors have no specified format: " + selectorsWithoutFormat.map((s2) => `\`${s2.selector}\``).join(", ")
    );
  }
  const picker = new DecisionTree(
    options.selectors.map((s2) => [s2.selector, s2])
  ).build(hp2Builder);
  if (typeof options.encodeCharacters !== "function") {
    options.encodeCharacters = makeReplacerFromDict(options.encodeCharacters);
  }
  const baseSelectorsPicker = new DecisionTree(
    options.baseElements.selectors.map((s2, i) => [s2, i + 1])
  ).build(hp2Builder);
  function findBaseElements(dom) {
    return findBases(dom, options, baseSelectorsPicker);
  }
  const limitedWalk = limitedDepthRecursive(
    options.limits.maxDepth,
    recursiveWalk,
    function(dom, builder) {
      builder.addInline(options.limits.ellipsis || "");
    }
  );
  return function(html2, metadata = void 0) {
    return process$1(html2, metadata, options, picker, findBaseElements, limitedWalk);
  };
}
function process$1(html2, metadata, options, picker, findBaseElements, walk) {
  const maxInputLength = options.limits.maxInputLength;
  if (maxInputLength && html2 && html2.length > maxInputLength) {
    console.warn(
      `Input length ${html2.length} is above allowed limit of ${maxInputLength}. Truncating without ellipsis.`
    );
    html2 = html2.substring(0, maxInputLength);
  }
  const document = parseDocument(html2, { decodeEntities: options.decodeEntities });
  const bases = findBaseElements(document.children);
  const builder = new BlockTextBuilder(options, picker, metadata);
  walk(bases, builder);
  return builder.toString();
}
function findBases(dom, options, baseSelectorsPicker) {
  const results = [];
  function recursiveWalk2(walk, dom2) {
    dom2 = dom2.slice(0, options.limits.maxChildNodes);
    for (const elem of dom2) {
      if (elem.type !== "tag") {
        continue;
      }
      const pickedSelectorIndex = baseSelectorsPicker.pick1(elem);
      if (pickedSelectorIndex > 0) {
        results.push({ selectorIndex: pickedSelectorIndex, element: elem });
      } else if (elem.children) {
        walk(elem.children);
      }
      if (results.length >= options.limits.maxBaseElements) {
        return;
      }
    }
  }
  const limitedWalk = limitedDepthRecursive(
    options.limits.maxDepth,
    recursiveWalk2
  );
  limitedWalk(dom);
  if (options.baseElements.orderBy !== "occurrence") {
    results.sort((a, b) => a.selectorIndex - b.selectorIndex);
  }
  return options.baseElements.returnDomByDefault && results.length === 0 ? dom : results.map((x) => x.element);
}
function recursiveWalk(walk, dom, builder) {
  if (!dom) {
    return;
  }
  const options = builder.options;
  const tooManyChildNodes = dom.length > options.limits.maxChildNodes;
  if (tooManyChildNodes) {
    dom = dom.slice(0, options.limits.maxChildNodes);
    dom.push({
      data: options.limits.ellipsis,
      type: "text"
    });
  }
  for (const elem of dom) {
    switch (elem.type) {
      case "text": {
        builder.addInline(elem.data);
        break;
      }
      case "tag": {
        const tagDefinition = builder.picker.pick1(elem);
        const format2 = options.formatters[tagDefinition.format];
        format2(elem, walk, builder, tagDefinition.options || {});
        break;
      }
    }
  }
  return;
}
function makeReplacerFromDict(dict) {
  if (!dict || Object.keys(dict).length === 0) {
    return void 0;
  }
  const entries = Object.entries(dict).filter(([, v]) => v !== false);
  const regex = new RegExp(
    entries.map(([c2]) => `(${unicodeEscape([...c2][0])})`).join("|"),
    "g"
  );
  const values = entries.map(([, v]) => v);
  const replacer = (m, ...cgs) => values[cgs.findIndex((cg) => cg)];
  return (str) => str.replace(regex, replacer);
}
function formatSkip(elem, walk, builder, formatOptions) {
}
function formatInlineString(elem, walk, builder, formatOptions) {
  builder.addLiteral(formatOptions.string || "");
}
function formatBlockString(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.addLiteral(formatOptions.string || "");
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatInline(elem, walk, builder, formatOptions) {
  walk(elem.children, builder);
}
function formatBlock$1(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function renderOpenTag(elem) {
  const attrs = elem.attribs && elem.attribs.length ? " " + Object.entries(elem.attribs).map(([k, v]) => v === "" ? k : `${k}=${v.replace(/"/g, "&quot;")}`).join(" ") : "";
  return `<${elem.name}${attrs}>`;
}
function renderCloseTag(elem) {
  return `</${elem.name}>`;
}
function formatInlineTag(elem, walk, builder, formatOptions) {
  builder.startNoWrap();
  builder.addLiteral(renderOpenTag(elem));
  builder.stopNoWrap();
  walk(elem.children, builder);
  builder.startNoWrap();
  builder.addLiteral(renderCloseTag(elem));
  builder.stopNoWrap();
}
function formatBlockTag(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.startNoWrap();
  builder.addLiteral(renderOpenTag(elem));
  builder.stopNoWrap();
  walk(elem.children, builder);
  builder.startNoWrap();
  builder.addLiteral(renderCloseTag(elem));
  builder.stopNoWrap();
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatInlineHtml(elem, walk, builder, formatOptions) {
  builder.startNoWrap();
  builder.addLiteral(
    render$1(elem, { decodeEntities: builder.options.decodeEntities })
  );
  builder.stopNoWrap();
}
function formatBlockHtml(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.startNoWrap();
  builder.addLiteral(
    render$1(elem, { decodeEntities: builder.options.decodeEntities })
  );
  builder.stopNoWrap();
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatInlineSurround(elem, walk, builder, formatOptions) {
  builder.addLiteral(formatOptions.prefix || "");
  walk(elem.children, builder);
  builder.addLiteral(formatOptions.suffix || "");
}
var genericFormatters = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  block: formatBlock$1,
  blockHtml: formatBlockHtml,
  blockString: formatBlockString,
  blockTag: formatBlockTag,
  inline: formatInline,
  inlineHtml: formatInlineHtml,
  inlineString: formatInlineString,
  inlineSurround: formatInlineSurround,
  inlineTag: formatInlineTag,
  skip: formatSkip
});
function getRow(matrix, j) {
  if (!matrix[j]) {
    matrix[j] = [];
  }
  return matrix[j];
}
function findFirstVacantIndex(row, x = 0) {
  while (row[x]) {
    x++;
  }
  return x;
}
function transposeInPlace(matrix, maxSize) {
  for (let i = 0; i < maxSize; i++) {
    const rowI = getRow(matrix, i);
    for (let j = 0; j < i; j++) {
      const rowJ = getRow(matrix, j);
      if (rowI[j] || rowJ[i]) {
        const temp = rowI[j];
        rowI[j] = rowJ[i];
        rowJ[i] = temp;
      }
    }
  }
}
function putCellIntoLayout(cell, layout2, baseRow, baseCol) {
  for (let r2 = 0; r2 < cell.rowspan; r2++) {
    const layoutRow = getRow(layout2, baseRow + r2);
    for (let c2 = 0; c2 < cell.colspan; c2++) {
      layoutRow[baseCol + c2] = cell;
    }
  }
}
function getOrInitOffset(offsets, index2) {
  if (offsets[index2] === void 0) {
    offsets[index2] = index2 === 0 ? 0 : 1 + getOrInitOffset(offsets, index2 - 1);
  }
  return offsets[index2];
}
function updateOffset(offsets, base, span, value) {
  offsets[base + span] = Math.max(
    getOrInitOffset(offsets, base + span),
    getOrInitOffset(offsets, base) + value
  );
}
function tableToString(tableRows, rowSpacing, colSpacing) {
  const layout2 = [];
  let colNumber = 0;
  const rowNumber = tableRows.length;
  const rowOffsets = [0];
  for (let j = 0; j < rowNumber; j++) {
    const layoutRow = getRow(layout2, j);
    const cells = tableRows[j];
    let x = 0;
    for (let i = 0; i < cells.length; i++) {
      const cell = cells[i];
      x = findFirstVacantIndex(layoutRow, x);
      putCellIntoLayout(cell, layout2, j, x);
      x += cell.colspan;
      cell.lines = cell.text.split("\n");
      const cellHeight = cell.lines.length;
      updateOffset(rowOffsets, j, cell.rowspan, cellHeight + rowSpacing);
    }
    colNumber = layoutRow.length > colNumber ? layoutRow.length : colNumber;
  }
  transposeInPlace(layout2, rowNumber > colNumber ? rowNumber : colNumber);
  const outputLines = [];
  const colOffsets = [0];
  for (let x = 0; x < colNumber; x++) {
    let y = 0;
    let cell;
    const rowsInThisColumn = Math.min(rowNumber, layout2[x].length);
    while (y < rowsInThisColumn) {
      cell = layout2[x][y];
      if (cell) {
        if (!cell.rendered) {
          let cellWidth = 0;
          for (let j = 0; j < cell.lines.length; j++) {
            const line2 = cell.lines[j];
            const lineOffset = rowOffsets[y] + j;
            outputLines[lineOffset] = (outputLines[lineOffset] || "").padEnd(colOffsets[x]) + line2;
            cellWidth = line2.length > cellWidth ? line2.length : cellWidth;
          }
          updateOffset(colOffsets, x, cell.colspan, cellWidth + colSpacing);
          cell.rendered = true;
        }
        y += cell.rowspan;
      } else {
        const lineOffset = rowOffsets[y];
        outputLines[lineOffset] = outputLines[lineOffset] || "";
        y++;
      }
    }
  }
  return outputLines.join("\n");
}
function formatLineBreak(elem, walk, builder, formatOptions) {
  builder.addLineBreak();
}
function formatWbr(elem, walk, builder, formatOptions) {
  builder.addWordBreakOpportunity();
}
function formatHorizontalLine(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.addInline("-".repeat(formatOptions.length || builder.options.wordwrap || 40));
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatParagraph(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatPre(elem, walk, builder, formatOptions) {
  builder.openBlock({
    isPre: true,
    leadingLineBreaks: formatOptions.leadingLineBreaks || 2
  });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatHeading(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  if (formatOptions.uppercase !== false) {
    builder.pushWordTransform((str) => str.toUpperCase());
    walk(elem.children, builder);
    builder.popWordTransform();
  } else {
    walk(elem.children, builder);
  }
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatBlockquote(elem, walk, builder, formatOptions) {
  builder.openBlock({
    leadingLineBreaks: formatOptions.leadingLineBreaks || 2,
    reservedLineLength: 2
  });
  walk(elem.children, builder);
  builder.closeBlock({
    trailingLineBreaks: formatOptions.trailingLineBreaks || 2,
    blockTransform: (str) => (formatOptions.trimEmptyLines !== false ? trimCharacter(str, "\n") : str).split("\n").map((line2) => "> " + line2).join("\n")
  });
}
function withBrackets(str, brackets) {
  if (!brackets) {
    return str;
  }
  const lbr = typeof brackets[0] === "string" ? brackets[0] : "[";
  const rbr = typeof brackets[1] === "string" ? brackets[1] : "]";
  return lbr + str + rbr;
}
function pathRewrite(path, rewriter, baseUrl, metadata, elem) {
  const modifiedPath = typeof rewriter === "function" ? rewriter(path, metadata, elem) : path;
  return modifiedPath[0] === "/" && baseUrl ? trimCharacterEnd(baseUrl, "/") + modifiedPath : modifiedPath;
}
function formatImage(elem, walk, builder, formatOptions) {
  const attribs = elem.attribs || {};
  const alt = attribs.alt ? attribs.alt : "";
  const src = !attribs.src ? "" : pathRewrite(attribs.src, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);
  const text2 = !src ? alt : !alt ? withBrackets(src, formatOptions.linkBrackets) : alt + " " + withBrackets(src, formatOptions.linkBrackets);
  builder.addInline(text2, { noWordTransform: true });
}
function formatAnchor(elem, walk, builder, formatOptions) {
  function getHref() {
    if (formatOptions.ignoreHref) {
      return "";
    }
    if (!elem.attribs || !elem.attribs.href) {
      return "";
    }
    let href2 = elem.attribs.href.replace(/^mailto:/, "");
    if (formatOptions.noAnchorUrl && href2[0] === "#") {
      return "";
    }
    href2 = pathRewrite(href2, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);
    return href2;
  }
  const href = getHref();
  if (!href) {
    walk(elem.children, builder);
  } else {
    let text2 = "";
    builder.pushWordTransform(
      (str) => {
        if (str) {
          text2 += str;
        }
        return str;
      }
    );
    walk(elem.children, builder);
    builder.popWordTransform();
    const hideSameLink = formatOptions.hideLinkHrefIfSameAsText && href === text2;
    if (!hideSameLink) {
      builder.addInline(
        !text2 ? href : " " + withBrackets(href, formatOptions.linkBrackets),
        { noWordTransform: true }
      );
    }
  }
}
function formatList(elem, walk, builder, formatOptions, nextPrefixCallback) {
  const isNestedList = get(elem, ["parent", "name"]) === "li";
  let maxPrefixLength = 0;
  const listItems = (elem.children || []).filter((child) => child.type !== "text" || !/^\s*$/.test(child.data)).map(function(child) {
    if (child.name !== "li") {
      return { node: child, prefix: "" };
    }
    const prefix = isNestedList ? nextPrefixCallback().trimStart() : nextPrefixCallback();
    if (prefix.length > maxPrefixLength) {
      maxPrefixLength = prefix.length;
    }
    return { node: child, prefix };
  });
  if (!listItems.length) {
    return;
  }
  builder.openList({
    interRowLineBreaks: 1,
    leadingLineBreaks: isNestedList ? 1 : formatOptions.leadingLineBreaks || 2,
    maxPrefixLength,
    prefixAlign: "left"
  });
  for (const { node, prefix } of listItems) {
    builder.openListItem({ prefix });
    walk([node], builder);
    builder.closeListItem();
  }
  builder.closeList({ trailingLineBreaks: isNestedList ? 1 : formatOptions.trailingLineBreaks || 2 });
}
function formatUnorderedList(elem, walk, builder, formatOptions) {
  const prefix = formatOptions.itemPrefix || " * ";
  return formatList(elem, walk, builder, formatOptions, () => prefix);
}
function formatOrderedList(elem, walk, builder, formatOptions) {
  let nextIndex = Number(elem.attribs.start || "1");
  const indexFunction = getOrderedListIndexFunction(elem.attribs.type);
  const nextPrefixCallback = () => " " + indexFunction(nextIndex++) + ". ";
  return formatList(elem, walk, builder, formatOptions, nextPrefixCallback);
}
function getOrderedListIndexFunction(olType = "1") {
  switch (olType) {
    case "a":
      return (i) => numberToLetterSequence(i, "a");
    case "A":
      return (i) => numberToLetterSequence(i, "A");
    case "i":
      return (i) => numberToRoman(i).toLowerCase();
    case "I":
      return (i) => numberToRoman(i);
    case "1":
    default:
      return (i) => i.toString();
  }
}
function splitClassesAndIds(selectors) {
  const classes = [];
  const ids = [];
  for (const selector of selectors) {
    if (selector.startsWith(".")) {
      classes.push(selector.substring(1));
    } else if (selector.startsWith("#")) {
      ids.push(selector.substring(1));
    }
  }
  return { classes, ids };
}
function isDataTable(attr, tables) {
  if (tables === true) {
    return true;
  }
  if (!attr) {
    return false;
  }
  const { classes, ids } = splitClassesAndIds(tables);
  const attrClasses = (attr["class"] || "").split(" ");
  const attrIds = (attr["id"] || "").split(" ");
  return attrClasses.some((x) => classes.includes(x)) || attrIds.some((x) => ids.includes(x));
}
function formatTable(elem, walk, builder, formatOptions) {
  return isDataTable(elem.attribs, builder.options.tables) ? formatDataTable(elem, walk, builder, formatOptions) : formatBlock(elem, walk, builder, formatOptions);
}
function formatBlock(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks });
}
function formatDataTable(elem, walk, builder, formatOptions) {
  builder.openTable();
  elem.children.forEach(walkTable);
  builder.closeTable({
    tableToString: (rows) => tableToString(rows, formatOptions.rowSpacing ?? 0, formatOptions.colSpacing ?? 3),
    leadingLineBreaks: formatOptions.leadingLineBreaks,
    trailingLineBreaks: formatOptions.trailingLineBreaks
  });
  function formatCell(cellNode) {
    const colspan = +get(cellNode, ["attribs", "colspan"]) || 1;
    const rowspan = +get(cellNode, ["attribs", "rowspan"]) || 1;
    builder.openTableCell({ maxColumnWidth: formatOptions.maxColumnWidth });
    walk(cellNode.children, builder);
    builder.closeTableCell({ colspan, rowspan });
  }
  function walkTable(elem2) {
    if (elem2.type !== "tag") {
      return;
    }
    const formatHeaderCell = formatOptions.uppercaseHeaderCells !== false ? (cellNode) => {
      builder.pushWordTransform((str) => str.toUpperCase());
      formatCell(cellNode);
      builder.popWordTransform();
    } : formatCell;
    switch (elem2.name) {
      case "thead":
      case "tbody":
      case "tfoot":
      case "center":
        elem2.children.forEach(walkTable);
        return;
      case "tr": {
        builder.openTableRow();
        for (const childOfTr of elem2.children) {
          if (childOfTr.type !== "tag") {
            continue;
          }
          switch (childOfTr.name) {
            case "th": {
              formatHeaderCell(childOfTr);
              break;
            }
            case "td": {
              formatCell(childOfTr);
              break;
            }
          }
        }
        builder.closeTableRow();
        break;
      }
    }
  }
}
var textFormatters = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  anchor: formatAnchor,
  blockquote: formatBlockquote,
  dataTable: formatDataTable,
  heading: formatHeading,
  horizontalLine: formatHorizontalLine,
  image: formatImage,
  lineBreak: formatLineBreak,
  orderedList: formatOrderedList,
  paragraph: formatParagraph,
  pre: formatPre,
  table: formatTable,
  unorderedList: formatUnorderedList,
  wbr: formatWbr
});
const DEFAULT_OPTIONS = {
  baseElements: {
    selectors: ["body"],
    orderBy: "selectors",
    // 'selectors' | 'occurrence'
    returnDomByDefault: true
  },
  decodeEntities: true,
  encodeCharacters: {},
  formatters: {},
  limits: {
    ellipsis: "...",
    maxBaseElements: void 0,
    maxChildNodes: void 0,
    maxDepth: void 0,
    maxInputLength: 1 << 24
    // 16_777_216
  },
  longWordSplit: {
    forceWrapOnLimit: false,
    wrapCharacters: []
  },
  preserveNewlines: false,
  selectors: [
    { selector: "*", format: "inline" },
    {
      selector: "a",
      format: "anchor",
      options: {
        baseUrl: null,
        hideLinkHrefIfSameAsText: false,
        ignoreHref: false,
        linkBrackets: ["[", "]"],
        noAnchorUrl: true
      }
    },
    { selector: "article", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: "aside", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    {
      selector: "blockquote",
      format: "blockquote",
      options: { leadingLineBreaks: 2, trailingLineBreaks: 2, trimEmptyLines: true }
    },
    { selector: "br", format: "lineBreak" },
    { selector: "div", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: "footer", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: "form", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: "h1", format: "heading", options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
    { selector: "h2", format: "heading", options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
    { selector: "h3", format: "heading", options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
    { selector: "h4", format: "heading", options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
    { selector: "h5", format: "heading", options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
    { selector: "h6", format: "heading", options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
    { selector: "header", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    {
      selector: "hr",
      format: "horizontalLine",
      options: { leadingLineBreaks: 2, length: void 0, trailingLineBreaks: 2 }
    },
    {
      selector: "img",
      format: "image",
      options: { baseUrl: null, linkBrackets: ["[", "]"] }
    },
    { selector: "main", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: "nav", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    {
      selector: "ol",
      format: "orderedList",
      options: { leadingLineBreaks: 2, trailingLineBreaks: 2 }
    },
    { selector: "p", format: "paragraph", options: { leadingLineBreaks: 2, trailingLineBreaks: 2 } },
    { selector: "pre", format: "pre", options: { leadingLineBreaks: 2, trailingLineBreaks: 2 } },
    { selector: "section", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    {
      selector: "table",
      format: "table",
      options: {
        colSpacing: 3,
        leadingLineBreaks: 2,
        maxColumnWidth: 60,
        rowSpacing: 0,
        trailingLineBreaks: 2,
        uppercaseHeaderCells: true
      }
    },
    {
      selector: "ul",
      format: "unorderedList",
      options: { itemPrefix: " * ", leadingLineBreaks: 2, trailingLineBreaks: 2 }
    },
    { selector: "wbr", format: "wbr" }
  ],
  tables: [],
  // deprecated
  whitespaceCharacters: " 	\r\n\f",
  wordwrap: 80
};
const concatMerge = (acc, src, options) => [...acc, ...src];
const overwriteMerge = (acc, src, options) => [...src];
const selectorsMerge = (acc, src, options) => acc.some((s2) => typeof s2 === "object") ? concatMerge(acc, src) : overwriteMerge(acc, src);
function compile(options = {}) {
  options = merge(
    DEFAULT_OPTIONS,
    options,
    {
      arrayMerge: overwriteMerge,
      customMerge: (key) => key === "selectors" ? selectorsMerge : void 0
    }
  );
  options.formatters = Object.assign({}, genericFormatters, textFormatters, options.formatters);
  options.selectors = mergeDuplicatesPreferLast(options.selectors, ((s2) => s2.selector));
  handleDeprecatedOptions(options);
  return compile$1(options);
}
function convert(html2, options = {}, metadata = void 0) {
  return compile(options)(html2, metadata);
}
function handleDeprecatedOptions(options) {
  if (options.tags) {
    const tagDefinitions = Object.entries(options.tags).map(
      ([selector, definition]) => ({ ...definition, selector: selector || "*" })
    );
    options.selectors.push(...tagDefinitions);
    options.selectors = mergeDuplicatesPreferLast(options.selectors, ((s2) => s2.selector));
  }
  function set(obj, path, value) {
    const valueKey = path.pop();
    for (const key of path) {
      let nested = obj[key];
      if (!nested) {
        nested = {};
        obj[key] = nested;
      }
      obj = nested;
    }
    obj[valueKey] = value;
  }
  if (options["baseElement"]) {
    const baseElement = options["baseElement"];
    set(
      options,
      ["baseElements", "selectors"],
      Array.isArray(baseElement) ? baseElement : [baseElement]
    );
  }
  if (options["returnDomByDefault"] !== void 0) {
    set(options, ["baseElements", "returnDomByDefault"], options["returnDomByDefault"]);
  }
  for (const definition of options.selectors) {
    if (definition.format === "anchor" && get(definition, ["options", "noLinkBrackets"])) {
      set(definition, ["options", "linkBrackets"], false);
    }
  }
}
function recursivelyMapDoc(doc, callback) {
  if (Array.isArray(doc)) return doc.map((innerDoc) => recursivelyMapDoc(innerDoc, callback));
  if (typeof doc === "object") {
    if (doc.type === "group") return {
      ...doc,
      contents: recursivelyMapDoc(doc.contents, callback),
      expandedStates: recursivelyMapDoc(doc.expandedStates, callback)
    };
    if ("contents" in doc) return {
      ...doc,
      contents: recursivelyMapDoc(doc.contents, callback)
    };
    if ("parts" in doc) return {
      ...doc,
      parts: recursivelyMapDoc(doc.parts, callback)
    };
    if (doc.type === "if-break") return {
      ...doc,
      breakContents: recursivelyMapDoc(doc.breakContents, callback),
      flatContents: recursivelyMapDoc(doc.flatContents, callback)
    };
  }
  return callback(doc);
}
const modifiedHtml = { ...html$1 };
if (modifiedHtml.printers) {
  const previousPrint = modifiedHtml.printers.html.print;
  modifiedHtml.printers.html.print = (path, options, print, args) => {
    const node = path.getNode();
    const rawPrintingResult = previousPrint(path, options, print, args);
    if (node.type === "ieConditionalComment") return recursivelyMapDoc(rawPrintingResult, (doc) => {
      if (typeof doc === "object" && doc.type === "line") return doc.soft ? "" : " ";
      return doc;
    });
    return rawPrintingResult;
  };
}
const defaults$2 = {
  endOfLine: "lf",
  tabWidth: 2,
  plugins: [modifiedHtml],
  bracketSameLine: true,
  parser: "html"
};
const pretty = (str, options = {}) => {
  return format$2(str.replaceAll("\0", ""), {
    ...defaults$2,
    ...options
  });
};
const plainTextSelectors = [
  {
    selector: "img",
    format: "skip"
  },
  {
    selector: "[data-skip-in-text=true]",
    format: "skip"
  },
  {
    selector: "a",
    options: {
      linkBrackets: false,
      hideLinkHrefIfSameAsText: true
    }
  }
];
function toPlainText(html$12, options) {
  return convert(html$12, {
    wordwrap: false,
    ...options,
    selectors: [...plainTextSelectors, ...options?.selectors ?? []]
  });
}
function createErrorBoundary(reject) {
  if (!React__default.Component) return (props) => /* @__PURE__ */ jsx(Fragment, { children: props.children });
  return class ErrorBoundary extends React__default.Component {
    componentDidCatch(error2) {
      reject(error2);
    }
    render() {
      return this.props.children;
    }
  };
}
const readStream = async (stream2) => {
  let result2 = "";
  const decoder2 = new TextDecoder("utf-8");
  if ("pipeTo" in stream2) {
    const writableStream = new WritableStream({
      write(chunk) {
        result2 += decoder2.decode(chunk, { stream: true });
      },
      close() {
        result2 += decoder2.decode();
      }
    });
    await stream2.pipeTo(writableStream);
  } else {
    const writable = new Writable({
      write(chunk, _encoding, callback) {
        result2 += decoder2.decode(chunk, { stream: true });
        callback();
      },
      final(callback) {
        result2 += decoder2.decode();
        callback();
      }
    });
    await new Promise((resolve2, reject) => {
      writable.on("pipe", (source) => {
        source.on("error", (err2) => {
          writable.destroy(err2);
        });
      });
      writable.on("error", reject);
      writable.on("close", () => {
        resolve2();
      });
      stream2.pipe(writable);
    });
  }
  return result2;
};
const render = async (node, options) => {
  const reactDOMServer = await import("react-dom/server").then((m) => {
    if ("default" in m) return m.default;
    return m;
  });
  let html$12;
  await new Promise((resolve2, reject) => {
    if (Object.hasOwn(reactDOMServer, "renderToReadableStream") && typeof WritableStream !== "undefined") {
      const ErrorBoundary = createErrorBoundary(reject);
      reactDOMServer.renderToReadableStream(/* @__PURE__ */ jsx(ErrorBoundary, { children: /* @__PURE__ */ jsx(Suspense, { children: node }) }), {
        progressiveChunkSize: Number.POSITIVE_INFINITY,
        onError(error2) {
          throw error2;
        }
      }).then((stream2) => readStream(stream2)).then((result2) => {
        html$12 = result2;
        resolve2();
      }).catch(reject);
    } else {
      const ErrorBoundary = createErrorBoundary(reject);
      const stream2 = reactDOMServer.renderToPipeableStream(/* @__PURE__ */ jsx(ErrorBoundary, { children: /* @__PURE__ */ jsx(Suspense, { children: node }) }), {
        async onAllReady() {
          html$12 = await readStream(stream2);
          resolve2();
        },
        onError(error2) {
          reject(error2);
        },
        progressiveChunkSize: Number.POSITIVE_INFINITY
      });
    }
  });
  if (options?.plainText) return toPlainText(html$12, options.htmlToTextOptions);
  const document = `<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">${html$12.replace(/<!DOCTYPE.*?>/, "")}`;
  if (options?.pretty) return pretty(document);
  return document;
};
class ConsoleAdapter extends MailAdapter {
  logHtml;
  logger;
  constructor(opts = {}) {
    super();
    this.logHtml = opts.logHtml ?? false;
    this.logger = opts.logger ?? console.log;
  }
  async send(options) {
    const separator = "=".repeat(60);
    this.logger("\n" + separator);
    this.logger(" EMAIL (Console Adapter - Development Mode)");
    this.logger(separator);
    this.logger(`From: ${options.from}`);
    this.logger(
      `To: ${Array.isArray(options.to) ? options.to.join(", ") : options.to}`
    );
    if (options.cc) {
      this.logger(
        `CC: ${Array.isArray(options.cc) ? options.cc.join(", ") : options.cc}`
      );
    }
    if (options.bcc) {
      this.logger(
        `BCC: ${Array.isArray(options.bcc) ? options.bcc.join(", ") : options.bcc}`
      );
    }
    if (options.replyTo) {
      this.logger(`Reply-To: ${options.replyTo}`);
    }
    this.logger(`Subject: ${options.subject}`);
    this.logger(separator);
    this.logger("\nText Content:");
    this.logger(options.text);
    if (this.logHtml) {
      this.logger("\nHTML Content:");
      this.logger(options.html);
    } else {
      this.logger(
        "\n(HTML content available but not logged. Set logHtml: true to see it)"
      );
    }
    if (options.attachments && options.attachments.length > 0) {
      this.logger("\nAttachments:");
      for (const attachment of options.attachments) {
        this.logger(
          `  - ${attachment.filename} (${attachment.contentType || "unknown type"})`
        );
      }
    }
    this.logger(separator + "\n");
  }
}
const isDev = process.env.NODE_ENV !== "production";
class MailerService {
  constructor(config2) {
    this.config = config2;
    this.templates = /* @__PURE__ */ new Map();
    if (config2.templates) {
      for (const [_key, template] of Object.entries(config2.templates)) {
        this.templates.set(template.name, template);
      }
    }
    this.defaultFrom = config2.defaults?.from;
  }
  templates;
  defaultFrom;
  defaultAdapter = null;
  /**
   * Get the mail adapter, falling back to ConsoleAdapter in development
   */
  async getAdapter() {
    const adapter = await this.config.adapter;
    if (adapter) {
      return adapter;
    }
    if (isDev) {
      if (!this.defaultAdapter) {
        this.defaultAdapter = new ConsoleAdapter();
      }
      return this.defaultAdapter;
    }
    throw new Error(
      "QUESTPIE: Email adapter is not configured. Provide adapter in .build({ email: { adapter: ... } })"
    );
  }
  /**
   * Serialize mail options (render React, convert to plain text)
   */
  async serializeMailOptions({
    react,
    ...options
  }) {
    let html2 = options.html;
    let text2 = options.text;
    if (react) {
      html2 = await render(react);
      text2 ??= await render(react, { plainText: true });
    } else if (html2 && !text2) {
      text2 = convert(html2);
    }
    if (!html2 && !text2) {
      throw new Error("No text or html provided");
    }
    return {
      ...options,
      from: options.from || this.defaultFrom || "noreply@example.com",
      text: text2 || "",
      html: html2 || ""
    };
  }
  /**
   * Send an email
   */
  async send(options) {
    const serializedMail = await this.serializeMailOptions(options);
    const adapter = await this.getAdapter();
    return adapter.send(serializedMail);
  }
  /**
   * Send an email using a defined template
   */
  async sendTemplate(options) {
    const templateDef = this.templates.get(options.template);
    if (!templateDef) {
      throw new Error(`Template "${String(options.template)}" not found.`);
    }
    const validatedContext = templateDef.schema.parse(options.context);
    const RenderedComponent = templateDef.render;
    const element = RenderedComponent(validatedContext);
    const subject = options.subject || (templateDef.subject ? templateDef.subject(validatedContext) : void 0);
    if (!subject) {
      throw new Error(
        `Subject is required. Either provide 'subject' option or define 'subject' in template "${String(options.template)}"`
      );
    }
    return this.send({
      to: options.to,
      subject,
      from: options.from,
      cc: options.cc,
      bcc: options.bcc,
      react: element
    });
  }
}
var nodemailer = {};
var shared = { exports: {} };
var fetch$1 = { exports: {} };
var cookies;
var hasRequiredCookies;
function requireCookies() {
  if (hasRequiredCookies) return cookies;
  hasRequiredCookies = 1;
  const urllib = require$$0$8;
  const SESSION_TIMEOUT = 1800;
  class Cookies {
    constructor(options) {
      this.options = options || {};
      this.cookies = [];
    }
    /**
     * Stores a cookie string to the cookie storage
     *
     * @param {String} cookieStr Value from the 'Set-Cookie:' header
     * @param {String} url Current URL
     */
    set(cookieStr, url) {
      let urlparts = urllib.parse(url || "");
      let cookie = this.parse(cookieStr);
      let domain;
      if (cookie.domain) {
        domain = cookie.domain.replace(/^\./, "");
        if (
          // can't be valid if the requested domain is shorter than current hostname
          urlparts.hostname.length < domain.length || // prefix domains with dot to be sure that partial matches are not used
          ("." + urlparts.hostname).substr(-domain.length + 1) !== "." + domain
        ) {
          cookie.domain = urlparts.hostname;
        }
      } else {
        cookie.domain = urlparts.hostname;
      }
      if (!cookie.path) {
        cookie.path = this.getPath(urlparts.pathname);
      }
      if (!cookie.expires) {
        cookie.expires = new Date(Date.now() + (Number(this.options.sessionTimeout || SESSION_TIMEOUT) || SESSION_TIMEOUT) * 1e3);
      }
      return this.add(cookie);
    }
    /**
     * Returns cookie string for the 'Cookie:' header.
     *
     * @param {String} url URL to check for
     * @returns {String} Cookie header or empty string if no matches were found
     */
    get(url) {
      return this.list(url).map((cookie) => cookie.name + "=" + cookie.value).join("; ");
    }
    /**
     * Lists all valied cookie objects for the specified URL
     *
     * @param {String} url URL to check for
     * @returns {Array} An array of cookie objects
     */
    list(url) {
      let result2 = [];
      let i;
      let cookie;
      for (i = this.cookies.length - 1; i >= 0; i--) {
        cookie = this.cookies[i];
        if (this.isExpired(cookie)) {
          this.cookies.splice(i, i);
          continue;
        }
        if (this.match(cookie, url)) {
          result2.unshift(cookie);
        }
      }
      return result2;
    }
    /**
     * Parses cookie string from the 'Set-Cookie:' header
     *
     * @param {String} cookieStr String from the 'Set-Cookie:' header
     * @returns {Object} Cookie object
     */
    parse(cookieStr) {
      let cookie = {};
      (cookieStr || "").toString().split(";").forEach((cookiePart) => {
        let valueParts = cookiePart.split("=");
        let key = valueParts.shift().trim().toLowerCase();
        let value = valueParts.join("=").trim();
        let domain;
        if (!key) {
          return;
        }
        switch (key) {
          case "expires":
            value = new Date(value);
            if (value.toString() !== "Invalid Date") {
              cookie.expires = value;
            }
            break;
          case "path":
            cookie.path = value;
            break;
          case "domain":
            domain = value.toLowerCase();
            if (domain.length && domain.charAt(0) !== ".") {
              domain = "." + domain;
            }
            cookie.domain = domain;
            break;
          case "max-age":
            cookie.expires = new Date(Date.now() + (Number(value) || 0) * 1e3);
            break;
          case "secure":
            cookie.secure = true;
            break;
          case "httponly":
            cookie.httponly = true;
            break;
          default:
            if (!cookie.name) {
              cookie.name = key;
              cookie.value = value;
            }
        }
      });
      return cookie;
    }
    /**
     * Checks if a cookie object is valid for a specified URL
     *
     * @param {Object} cookie Cookie object
     * @param {String} url URL to check for
     * @returns {Boolean} true if cookie is valid for specifiec URL
     */
    match(cookie, url) {
      let urlparts = urllib.parse(url || "");
      if (urlparts.hostname !== cookie.domain && (cookie.domain.charAt(0) !== "." || ("." + urlparts.hostname).substr(-cookie.domain.length) !== cookie.domain)) {
        return false;
      }
      let path = this.getPath(urlparts.pathname);
      if (path.substr(0, cookie.path.length) !== cookie.path) {
        return false;
      }
      if (cookie.secure && urlparts.protocol !== "https:") {
        return false;
      }
      return true;
    }
    /**
     * Adds (or updates/removes if needed) a cookie object to the cookie storage
     *
     * @param {Object} cookie Cookie value to be stored
     */
    add(cookie) {
      let i;
      let len;
      if (!cookie || !cookie.name) {
        return false;
      }
      for (i = 0, len = this.cookies.length; i < len; i++) {
        if (this.compare(this.cookies[i], cookie)) {
          if (this.isExpired(cookie)) {
            this.cookies.splice(i, 1);
            return false;
          }
          this.cookies[i] = cookie;
          return true;
        }
      }
      if (!this.isExpired(cookie)) {
        this.cookies.push(cookie);
      }
      return true;
    }
    /**
     * Checks if two cookie objects are the same
     *
     * @param {Object} a Cookie to check against
     * @param {Object} b Cookie to check against
     * @returns {Boolean} True, if the cookies are the same
     */
    compare(a, b) {
      return a.name === b.name && a.path === b.path && a.domain === b.domain && a.secure === b.secure && a.httponly === a.httponly;
    }
    /**
     * Checks if a cookie is expired
     *
     * @param {Object} cookie Cookie object to check against
     * @returns {Boolean} True, if the cookie is expired
     */
    isExpired(cookie) {
      return cookie.expires && cookie.expires < /* @__PURE__ */ new Date() || !cookie.value;
    }
    /**
     * Returns normalized cookie path for an URL path argument
     *
     * @param {String} pathname
     * @returns {String} Normalized path
     */
    getPath(pathname) {
      let path = (pathname || "/").split("/");
      path.pop();
      path = path.join("/").trim();
      if (path.charAt(0) !== "/") {
        path = "/" + path;
      }
      if (path.substr(-1) !== "/") {
        path += "/";
      }
      return path;
    }
  }
  cookies = Cookies;
  return cookies;
}
const name = "nodemailer";
const version = "7.0.13";
const homepage = "https://nodemailer.com/";
const require$$9 = {
  name,
  version,
  homepage
};
var hasRequiredFetch;
function requireFetch() {
  if (hasRequiredFetch) return fetch$1.exports;
  hasRequiredFetch = 1;
  const http = require$$0$e;
  const https = require$$1$3;
  const urllib = require$$0$8;
  const zlib = require$$3;
  const PassThrough = require$$0$c.PassThrough;
  const Cookies = requireCookies();
  const packageData = require$$9;
  const net = require$$0$d;
  const MAX_REDIRECTS = 5;
  fetch$1.exports = function(url, options) {
    return nmfetch(url, options);
  };
  fetch$1.exports.Cookies = Cookies;
  function nmfetch(url, options) {
    options = options || {};
    options.fetchRes = options.fetchRes || new PassThrough();
    options.cookies = options.cookies || new Cookies();
    options.redirects = options.redirects || 0;
    options.maxRedirects = isNaN(options.maxRedirects) ? MAX_REDIRECTS : options.maxRedirects;
    if (options.cookie) {
      [].concat(options.cookie || []).forEach((cookie) => {
        options.cookies.set(cookie, url);
      });
      options.cookie = false;
    }
    let fetchRes = options.fetchRes;
    let parsed = urllib.parse(url);
    let method = (options.method || "").toString().trim().toUpperCase() || "GET";
    let finished = false;
    let cookies2;
    let body;
    let handler2 = parsed.protocol === "https:" ? https : http;
    let headers = {
      "accept-encoding": "gzip,deflate",
      "user-agent": "nodemailer/" + packageData.version
    };
    Object.keys(options.headers || {}).forEach((key) => {
      headers[key.toLowerCase().trim()] = options.headers[key];
    });
    if (options.userAgent) {
      headers["user-agent"] = options.userAgent;
    }
    if (parsed.auth) {
      headers.Authorization = "Basic " + Buffer.from(parsed.auth).toString("base64");
    }
    if (cookies2 = options.cookies.get(url)) {
      headers.cookie = cookies2;
    }
    if (options.body) {
      if (options.contentType !== false) {
        headers["Content-Type"] = options.contentType || "application/x-www-form-urlencoded";
      }
      if (typeof options.body.pipe === "function") {
        headers["Transfer-Encoding"] = "chunked";
        body = options.body;
        body.on("error", (err2) => {
          if (finished) {
            return;
          }
          finished = true;
          err2.type = "FETCH";
          err2.sourceUrl = url;
          fetchRes.emit("error", err2);
        });
      } else {
        if (options.body instanceof Buffer) {
          body = options.body;
        } else if (typeof options.body === "object") {
          try {
            body = Buffer.from(
              Object.keys(options.body).map((key) => {
                let value = options.body[key].toString().trim();
                return encodeURIComponent(key) + "=" + encodeURIComponent(value);
              }).join("&")
            );
          } catch (E) {
            if (finished) {
              return;
            }
            finished = true;
            E.type = "FETCH";
            E.sourceUrl = url;
            fetchRes.emit("error", E);
            return;
          }
        } else {
          body = Buffer.from(options.body.toString().trim());
        }
        headers["Content-Type"] = options.contentType || "application/x-www-form-urlencoded";
        headers["Content-Length"] = body.length;
      }
      method = (options.method || "").toString().trim().toUpperCase() || "POST";
    }
    let req2;
    let reqOptions = {
      method,
      host: parsed.hostname,
      path: parsed.path,
      port: parsed.port ? parsed.port : parsed.protocol === "https:" ? 443 : 80,
      headers,
      rejectUnauthorized: false,
      agent: false
    };
    if (options.tls) {
      Object.keys(options.tls).forEach((key) => {
        reqOptions[key] = options.tls[key];
      });
    }
    if (parsed.protocol === "https:" && parsed.hostname && parsed.hostname !== reqOptions.host && !net.isIP(parsed.hostname) && !reqOptions.servername) {
      reqOptions.servername = parsed.hostname;
    }
    try {
      req2 = handler2.request(reqOptions);
    } catch (E) {
      finished = true;
      setImmediate(() => {
        E.type = "FETCH";
        E.sourceUrl = url;
        fetchRes.emit("error", E);
      });
      return fetchRes;
    }
    if (options.timeout) {
      req2.setTimeout(options.timeout, () => {
        if (finished) {
          return;
        }
        finished = true;
        req2.abort();
        let err2 = new Error("Request Timeout");
        err2.type = "FETCH";
        err2.sourceUrl = url;
        fetchRes.emit("error", err2);
      });
    }
    req2.on("error", (err2) => {
      if (finished) {
        return;
      }
      finished = true;
      err2.type = "FETCH";
      err2.sourceUrl = url;
      fetchRes.emit("error", err2);
    });
    req2.on("response", (res2) => {
      let inflate;
      if (finished) {
        return;
      }
      switch (res2.headers["content-encoding"]) {
        case "gzip":
        case "deflate":
          inflate = zlib.createUnzip();
          break;
      }
      if (res2.headers["set-cookie"]) {
        [].concat(res2.headers["set-cookie"] || []).forEach((cookie) => {
          options.cookies.set(cookie, url);
        });
      }
      if ([301, 302, 303, 307, 308].includes(res2.statusCode) && res2.headers.location) {
        options.redirects++;
        if (options.redirects > options.maxRedirects) {
          finished = true;
          let err2 = new Error("Maximum redirect count exceeded");
          err2.type = "FETCH";
          err2.sourceUrl = url;
          fetchRes.emit("error", err2);
          req2.abort();
          return;
        }
        options.method = "GET";
        options.body = false;
        return nmfetch(urllib.resolve(url, res2.headers.location), options);
      }
      fetchRes.statusCode = res2.statusCode;
      fetchRes.headers = res2.headers;
      if (res2.statusCode >= 300 && !options.allowErrorResponse) {
        finished = true;
        let err2 = new Error("Invalid status code " + res2.statusCode);
        err2.type = "FETCH";
        err2.sourceUrl = url;
        fetchRes.emit("error", err2);
        req2.abort();
        return;
      }
      res2.on("error", (err2) => {
        if (finished) {
          return;
        }
        finished = true;
        err2.type = "FETCH";
        err2.sourceUrl = url;
        fetchRes.emit("error", err2);
        req2.abort();
      });
      if (inflate) {
        res2.pipe(inflate).pipe(fetchRes);
        inflate.on("error", (err2) => {
          if (finished) {
            return;
          }
          finished = true;
          err2.type = "FETCH";
          err2.sourceUrl = url;
          fetchRes.emit("error", err2);
          req2.abort();
        });
      } else {
        res2.pipe(fetchRes);
      }
    });
    setImmediate(() => {
      if (body) {
        try {
          if (typeof body.pipe === "function") {
            return body.pipe(req2);
          } else {
            req2.write(body);
          }
        } catch (err2) {
          finished = true;
          err2.type = "FETCH";
          err2.sourceUrl = url;
          fetchRes.emit("error", err2);
          return;
        }
      }
      req2.end();
    });
    return fetchRes;
  }
  return fetch$1.exports;
}
var hasRequiredShared;
function requireShared() {
  if (hasRequiredShared) return shared.exports;
  hasRequiredShared = 1;
  (function(module) {
    const urllib = require$$0$8;
    const util = require$$1$1;
    const fs = require$$1$2;
    const nmfetch = requireFetch();
    const dns = require$$4;
    const net = require$$0$d;
    const os = require$$6;
    const DNS_TTL = 5 * 60 * 1e3;
    const CACHE_CLEANUP_INTERVAL = 30 * 1e3;
    const MAX_CACHE_SIZE = 1e3;
    let lastCacheCleanup = 0;
    module.exports._lastCacheCleanup = () => lastCacheCleanup;
    module.exports._resetCacheCleanup = () => {
      lastCacheCleanup = 0;
    };
    let networkInterfaces;
    try {
      networkInterfaces = os.networkInterfaces();
    } catch (_err) {
    }
    module.exports.networkInterfaces = networkInterfaces;
    const isFamilySupported = (family, allowInternal) => {
      let networkInterfaces2 = module.exports.networkInterfaces;
      if (!networkInterfaces2) {
        return true;
      }
      const familySupported = (
        // crux that replaces Object.values(networkInterfaces) as Object.values is not supported in nodejs v6
        Object.keys(networkInterfaces2).map((key) => networkInterfaces2[key]).reduce((acc, val) => acc.concat(val), []).filter((i) => !i.internal || allowInternal).filter((i) => i.family === "IPv" + family || i.family === family).length > 0
      );
      return familySupported;
    };
    const resolver = (family, hostname, options, callback) => {
      options = options || {};
      const familySupported = isFamilySupported(family, options.allowInternalNetworkInterfaces);
      if (!familySupported) {
        return callback(null, []);
      }
      const resolver2 = dns.Resolver ? new dns.Resolver(options) : dns;
      resolver2["resolve" + family](hostname, (err2, addresses) => {
        if (err2) {
          switch (err2.code) {
            case dns.NODATA:
            case dns.NOTFOUND:
            case dns.NOTIMP:
            case dns.SERVFAIL:
            case dns.CONNREFUSED:
            case dns.REFUSED:
            case "EAI_AGAIN":
              return callback(null, []);
          }
          return callback(err2);
        }
        return callback(null, Array.isArray(addresses) ? addresses : [].concat(addresses || []));
      });
    };
    const dnsCache = module.exports.dnsCache = /* @__PURE__ */ new Map();
    const formatDNSValue = (value, extra) => {
      if (!value) {
        return Object.assign({}, extra || {});
      }
      return Object.assign(
        {
          servername: value.servername,
          host: !value.addresses || !value.addresses.length ? null : value.addresses.length === 1 ? value.addresses[0] : value.addresses[Math.floor(Math.random() * value.addresses.length)]
        },
        extra || {}
      );
    };
    module.exports.resolveHostname = (options, callback) => {
      options = options || {};
      if (!options.host && options.servername) {
        options.host = options.servername;
      }
      if (!options.host || net.isIP(options.host)) {
        let value = {
          addresses: [options.host],
          servername: options.servername || false
        };
        return callback(
          null,
          formatDNSValue(value, {
            cached: false
          })
        );
      }
      let cached;
      if (dnsCache.has(options.host)) {
        cached = dnsCache.get(options.host);
        const now2 = Date.now();
        if (now2 - lastCacheCleanup > CACHE_CLEANUP_INTERVAL) {
          lastCacheCleanup = now2;
          for (const [host, entry] of dnsCache.entries()) {
            if (entry.expires && entry.expires < now2) {
              dnsCache.delete(host);
            }
          }
          if (dnsCache.size > MAX_CACHE_SIZE) {
            const toDelete = Math.floor(MAX_CACHE_SIZE * 0.1);
            const keys = Array.from(dnsCache.keys()).slice(0, toDelete);
            keys.forEach((key) => dnsCache.delete(key));
          }
        }
        if (!cached.expires || cached.expires >= now2) {
          return callback(
            null,
            formatDNSValue(cached.value, {
              cached: true
            })
          );
        }
      }
      resolver(4, options.host, options, (err2, addresses) => {
        if (err2) {
          if (cached) {
            dnsCache.set(options.host, {
              value: cached.value,
              expires: Date.now() + (options.dnsTtl || DNS_TTL)
            });
            return callback(
              null,
              formatDNSValue(cached.value, {
                cached: true,
                error: err2
              })
            );
          }
          return callback(err2);
        }
        if (addresses && addresses.length) {
          let value = {
            addresses,
            servername: options.servername || options.host
          };
          dnsCache.set(options.host, {
            value,
            expires: Date.now() + (options.dnsTtl || DNS_TTL)
          });
          return callback(
            null,
            formatDNSValue(value, {
              cached: false
            })
          );
        }
        resolver(6, options.host, options, (err3, addresses2) => {
          if (err3) {
            if (cached) {
              dnsCache.set(options.host, {
                value: cached.value,
                expires: Date.now() + (options.dnsTtl || DNS_TTL)
              });
              return callback(
                null,
                formatDNSValue(cached.value, {
                  cached: true,
                  error: err3
                })
              );
            }
            return callback(err3);
          }
          if (addresses2 && addresses2.length) {
            let value = {
              addresses: addresses2,
              servername: options.servername || options.host
            };
            dnsCache.set(options.host, {
              value,
              expires: Date.now() + (options.dnsTtl || DNS_TTL)
            });
            return callback(
              null,
              formatDNSValue(value, {
                cached: false
              })
            );
          }
          try {
            dns.lookup(options.host, { all: true }, (err4, addresses3) => {
              if (err4) {
                if (cached) {
                  dnsCache.set(options.host, {
                    value: cached.value,
                    expires: Date.now() + (options.dnsTtl || DNS_TTL)
                  });
                  return callback(
                    null,
                    formatDNSValue(cached.value, {
                      cached: true,
                      error: err4
                    })
                  );
                }
                return callback(err4);
              }
              let address = addresses3 ? addresses3.filter((addr) => isFamilySupported(addr.family)).map((addr) => addr.address).shift() : false;
              if (addresses3 && addresses3.length && !address) {
                console.warn(`Failed to resolve IPv${addresses3[0].family} addresses with current network`);
              }
              if (!address && cached) {
                return callback(
                  null,
                  formatDNSValue(cached.value, {
                    cached: true
                  })
                );
              }
              let value = {
                addresses: address ? [address] : [options.host],
                servername: options.servername || options.host
              };
              dnsCache.set(options.host, {
                value,
                expires: Date.now() + (options.dnsTtl || DNS_TTL)
              });
              return callback(
                null,
                formatDNSValue(value, {
                  cached: false
                })
              );
            });
          } catch (_err) {
            if (cached) {
              dnsCache.set(options.host, {
                value: cached.value,
                expires: Date.now() + (options.dnsTtl || DNS_TTL)
              });
              return callback(
                null,
                formatDNSValue(cached.value, {
                  cached: true,
                  error: err3
                })
              );
            }
            return callback(err3);
          }
        });
      });
    };
    module.exports.parseConnectionUrl = (str) => {
      str = str || "";
      let options = {};
      [urllib.parse(str, true)].forEach((url) => {
        let auth2;
        switch (url.protocol) {
          case "smtp:":
            options.secure = false;
            break;
          case "smtps:":
            options.secure = true;
            break;
          case "direct:":
            options.direct = true;
            break;
        }
        if (!isNaN(url.port) && Number(url.port)) {
          options.port = Number(url.port);
        }
        if (url.hostname) {
          options.host = url.hostname;
        }
        if (url.auth) {
          auth2 = url.auth.split(":");
          if (!options.auth) {
            options.auth = {};
          }
          options.auth.user = auth2.shift();
          options.auth.pass = auth2.join(":");
        }
        Object.keys(url.query || {}).forEach((key) => {
          let obj = options;
          let lKey = key;
          let value = url.query[key];
          if (!isNaN(value)) {
            value = Number(value);
          }
          switch (value) {
            case "true":
              value = true;
              break;
            case "false":
              value = false;
              break;
          }
          if (key.indexOf("tls.") === 0) {
            lKey = key.substr(4);
            if (!options.tls) {
              options.tls = {};
            }
            obj = options.tls;
          } else if (key.indexOf(".") >= 0) {
            return;
          }
          if (!(lKey in obj)) {
            obj[lKey] = value;
          }
        });
      });
      return options;
    };
    module.exports._logFunc = (logger2, level, defaults2, data, message2, ...args) => {
      let entry = {};
      Object.keys(defaults2 || {}).forEach((key) => {
        if (key !== "level") {
          entry[key] = defaults2[key];
        }
      });
      Object.keys(data || {}).forEach((key) => {
        if (key !== "level") {
          entry[key] = data[key];
        }
      });
      logger2[level](entry, message2, ...args);
    };
    module.exports.getLogger = (options, defaults2) => {
      options = options || {};
      let response = {};
      let levels2 = ["trace", "debug", "info", "warn", "error", "fatal"];
      if (!options.logger) {
        levels2.forEach((level) => {
          response[level] = () => false;
        });
        return response;
      }
      let logger2 = options.logger;
      if (options.logger === true) {
        logger2 = createDefaultLogger(levels2);
      }
      levels2.forEach((level) => {
        response[level] = (data, message2, ...args) => {
          module.exports._logFunc(logger2, level, defaults2, data, message2, ...args);
        };
      });
      return response;
    };
    module.exports.callbackPromise = (resolve2, reject) => function() {
      let args = Array.from(arguments);
      let err2 = args.shift();
      if (err2) {
        reject(err2);
      } else {
        resolve2(...args);
      }
    };
    module.exports.parseDataURI = (uri2) => {
      if (typeof uri2 !== "string") {
        return null;
      }
      if (!uri2.startsWith("data:")) {
        return null;
      }
      const commaPos = uri2.indexOf(",");
      if (commaPos === -1) {
        return null;
      }
      const data = uri2.substring(commaPos + 1);
      const metaStr = uri2.substring("data:".length, commaPos);
      let encoding;
      const metaEntries = metaStr.split(";");
      if (metaEntries.length > 0) {
        const lastEntry = metaEntries[metaEntries.length - 1].toLowerCase().trim();
        if (["base64", "utf8", "utf-8"].includes(lastEntry) && lastEntry.indexOf("=") === -1) {
          encoding = lastEntry;
          metaEntries.pop();
        }
      }
      const contentType = metaEntries.length > 0 ? metaEntries.shift() : "application/octet-stream";
      const params = {};
      for (let i = 0; i < metaEntries.length; i++) {
        const entry = metaEntries[i];
        const sepPos = entry.indexOf("=");
        if (sepPos > 0) {
          const key = entry.substring(0, sepPos).trim();
          const value = entry.substring(sepPos + 1).trim();
          if (key) {
            params[key] = value;
          }
        }
      }
      let bufferData;
      try {
        if (encoding === "base64") {
          bufferData = Buffer.from(data, "base64");
        } else {
          try {
            bufferData = Buffer.from(decodeURIComponent(data));
          } catch (_decodeError) {
            bufferData = Buffer.from(data);
          }
        }
      } catch (_bufferError) {
        bufferData = Buffer.alloc(0);
      }
      return {
        data: bufferData,
        encoding: encoding || null,
        contentType: contentType || "application/octet-stream",
        params
      };
    };
    module.exports.resolveContent = (data, key, callback) => {
      let promise;
      if (!callback) {
        promise = new Promise((resolve2, reject) => {
          callback = module.exports.callbackPromise(resolve2, reject);
        });
      }
      let content2 = data && data[key] && data[key].content || data[key];
      let contentStream;
      let encoding = (typeof data[key] === "object" && data[key].encoding || "utf8").toString().toLowerCase().replace(/[-_\s]/g, "");
      if (!content2) {
        return callback(null, content2);
      }
      if (typeof content2 === "object") {
        if (typeof content2.pipe === "function") {
          return resolveStream(content2, (err2, value) => {
            if (err2) {
              return callback(err2);
            }
            if (data[key].content) {
              data[key].content = value;
            } else {
              data[key] = value;
            }
            callback(null, value);
          });
        } else if (/^https?:\/\//i.test(content2.path || content2.href)) {
          contentStream = nmfetch(content2.path || content2.href);
          return resolveStream(contentStream, callback);
        } else if (/^data:/i.test(content2.path || content2.href)) {
          let parsedDataUri = module.exports.parseDataURI(content2.path || content2.href);
          if (!parsedDataUri || !parsedDataUri.data) {
            return callback(null, Buffer.from(0));
          }
          return callback(null, parsedDataUri.data);
        } else if (content2.path) {
          return resolveStream(fs.createReadStream(content2.path), callback);
        }
      }
      if (typeof data[key].content === "string" && !["utf8", "usascii", "ascii"].includes(encoding)) {
        content2 = Buffer.from(data[key].content, encoding);
      }
      setImmediate(() => callback(null, content2));
      return promise;
    };
    module.exports.assign = function() {
      let args = Array.from(arguments);
      let target = args.shift() || {};
      args.forEach((source) => {
        Object.keys(source || {}).forEach((key) => {
          if (["tls", "auth"].includes(key) && source[key] && typeof source[key] === "object") {
            if (!target[key]) {
              target[key] = {};
            }
            Object.keys(source[key]).forEach((subKey) => {
              target[key][subKey] = source[key][subKey];
            });
          } else {
            target[key] = source[key];
          }
        });
      });
      return target;
    };
    module.exports.encodeXText = (str) => {
      if (!/[^\x21-\x2A\x2C-\x3C\x3E-\x7E]/.test(str)) {
        return str;
      }
      let buf = Buffer.from(str);
      let result2 = "";
      for (let i = 0, len = buf.length; i < len; i++) {
        let c2 = buf[i];
        if (c2 < 33 || c2 > 126 || c2 === 43 || c2 === 61) {
          result2 += "+" + (c2 < 16 ? "0" : "") + c2.toString(16).toUpperCase();
        } else {
          result2 += String.fromCharCode(c2);
        }
      }
      return result2;
    };
    function resolveStream(stream2, callback) {
      let responded = false;
      let chunks = [];
      let chunklen = 0;
      stream2.on("error", (err2) => {
        if (responded) {
          return;
        }
        responded = true;
        callback(err2);
      });
      stream2.on("readable", () => {
        let chunk;
        while ((chunk = stream2.read()) !== null) {
          chunks.push(chunk);
          chunklen += chunk.length;
        }
      });
      stream2.on("end", () => {
        if (responded) {
          return;
        }
        responded = true;
        let value;
        try {
          value = Buffer.concat(chunks, chunklen);
        } catch (E) {
          return callback(E);
        }
        callback(null, value);
      });
    }
    function createDefaultLogger(levels2) {
      let levelMaxLen = 0;
      let levelNames = /* @__PURE__ */ new Map();
      levels2.forEach((level) => {
        if (level.length > levelMaxLen) {
          levelMaxLen = level.length;
        }
      });
      levels2.forEach((level) => {
        let levelName = level.toUpperCase();
        if (levelName.length < levelMaxLen) {
          levelName += " ".repeat(levelMaxLen - levelName.length);
        }
        levelNames.set(level, levelName);
      });
      let print = (level, entry, message2, ...args) => {
        let prefix = "";
        if (entry) {
          if (entry.tnx === "server") {
            prefix = "S: ";
          } else if (entry.tnx === "client") {
            prefix = "C: ";
          }
          if (entry.sid) {
            prefix = "[" + entry.sid + "] " + prefix;
          }
          if (entry.cid) {
            prefix = "[#" + entry.cid + "] " + prefix;
          }
        }
        message2 = util.format(message2, ...args);
        message2.split(/\r?\n/).forEach((line2) => {
          console.log("[%s] %s %s", (/* @__PURE__ */ new Date()).toISOString().substr(0, 19).replace(/T/, " "), levelNames.get(level), prefix + line2);
        });
      };
      let logger2 = {};
      levels2.forEach((level) => {
        logger2[level] = print.bind(null, level);
      });
      return logger2;
    }
  })(shared);
  return shared.exports;
}
var mimeTypes_1;
var hasRequiredMimeTypes;
function requireMimeTypes() {
  if (hasRequiredMimeTypes) return mimeTypes_1;
  hasRequiredMimeTypes = 1;
  const path = require$$0$6;
  const defaultMimeType = "application/octet-stream";
  const defaultExtension = "bin";
  const mimeTypes2 = /* @__PURE__ */ new Map([
    ["application/acad", "dwg"],
    ["application/applixware", "aw"],
    ["application/arj", "arj"],
    ["application/atom+xml", "xml"],
    ["application/atomcat+xml", "atomcat"],
    ["application/atomsvc+xml", "atomsvc"],
    ["application/base64", ["mm", "mme"]],
    ["application/binhex", "hqx"],
    ["application/binhex4", "hqx"],
    ["application/book", ["book", "boo"]],
    ["application/ccxml+xml,", "ccxml"],
    ["application/cdf", "cdf"],
    ["application/cdmi-capability", "cdmia"],
    ["application/cdmi-container", "cdmic"],
    ["application/cdmi-domain", "cdmid"],
    ["application/cdmi-object", "cdmio"],
    ["application/cdmi-queue", "cdmiq"],
    ["application/clariscad", "ccad"],
    ["application/commonground", "dp"],
    ["application/cu-seeme", "cu"],
    ["application/davmount+xml", "davmount"],
    ["application/drafting", "drw"],
    ["application/dsptype", "tsp"],
    ["application/dssc+der", "dssc"],
    ["application/dssc+xml", "xdssc"],
    ["application/dxf", "dxf"],
    ["application/ecmascript", ["js", "es"]],
    ["application/emma+xml", "emma"],
    ["application/envoy", "evy"],
    ["application/epub+zip", "epub"],
    ["application/excel", ["xls", "xl", "xla", "xlb", "xlc", "xld", "xlk", "xll", "xlm", "xlt", "xlv", "xlw"]],
    ["application/exi", "exi"],
    ["application/font-tdpfr", "pfr"],
    ["application/fractals", "fif"],
    ["application/freeloader", "frl"],
    ["application/futuresplash", "spl"],
    ["application/geo+json", "geojson"],
    ["application/gnutar", "tgz"],
    ["application/groupwise", "vew"],
    ["application/hlp", "hlp"],
    ["application/hta", "hta"],
    ["application/hyperstudio", "stk"],
    ["application/i-deas", "unv"],
    ["application/iges", ["iges", "igs"]],
    ["application/inf", "inf"],
    ["application/internet-property-stream", "acx"],
    ["application/ipfix", "ipfix"],
    ["application/java", "class"],
    ["application/java-archive", "jar"],
    ["application/java-byte-code", "class"],
    ["application/java-serialized-object", "ser"],
    ["application/java-vm", "class"],
    ["application/javascript", "js"],
    ["application/json", "json"],
    ["application/lha", "lha"],
    ["application/lzx", "lzx"],
    ["application/mac-binary", "bin"],
    ["application/mac-binhex", "hqx"],
    ["application/mac-binhex40", "hqx"],
    ["application/mac-compactpro", "cpt"],
    ["application/macbinary", "bin"],
    ["application/mads+xml", "mads"],
    ["application/marc", "mrc"],
    ["application/marcxml+xml", "mrcx"],
    ["application/mathematica", "ma"],
    ["application/mathml+xml", "mathml"],
    ["application/mbedlet", "mbd"],
    ["application/mbox", "mbox"],
    ["application/mcad", "mcd"],
    ["application/mediaservercontrol+xml", "mscml"],
    ["application/metalink4+xml", "meta4"],
    ["application/mets+xml", "mets"],
    ["application/mime", "aps"],
    ["application/mods+xml", "mods"],
    ["application/mp21", "m21"],
    ["application/mp4", "mp4"],
    ["application/mspowerpoint", ["ppt", "pot", "pps", "ppz"]],
    ["application/msword", ["doc", "dot", "w6w", "wiz", "word"]],
    ["application/mswrite", "wri"],
    ["application/mxf", "mxf"],
    ["application/netmc", "mcp"],
    ["application/octet-stream", ["*"]],
    ["application/oda", "oda"],
    ["application/oebps-package+xml", "opf"],
    ["application/ogg", "ogx"],
    ["application/olescript", "axs"],
    ["application/onenote", "onetoc"],
    ["application/patch-ops-error+xml", "xer"],
    ["application/pdf", "pdf"],
    ["application/pgp-encrypted", "asc"],
    ["application/pgp-signature", "pgp"],
    ["application/pics-rules", "prf"],
    ["application/pkcs-12", "p12"],
    ["application/pkcs-crl", "crl"],
    ["application/pkcs10", "p10"],
    ["application/pkcs7-mime", ["p7c", "p7m"]],
    ["application/pkcs7-signature", "p7s"],
    ["application/pkcs8", "p8"],
    ["application/pkix-attr-cert", "ac"],
    ["application/pkix-cert", ["cer", "crt"]],
    ["application/pkix-crl", "crl"],
    ["application/pkix-pkipath", "pkipath"],
    ["application/pkixcmp", "pki"],
    ["application/plain", "text"],
    ["application/pls+xml", "pls"],
    ["application/postscript", ["ps", "ai", "eps"]],
    ["application/powerpoint", "ppt"],
    ["application/pro_eng", ["part", "prt"]],
    ["application/prs.cww", "cww"],
    ["application/pskc+xml", "pskcxml"],
    ["application/rdf+xml", "rdf"],
    ["application/reginfo+xml", "rif"],
    ["application/relax-ng-compact-syntax", "rnc"],
    ["application/resource-lists+xml", "rl"],
    ["application/resource-lists-diff+xml", "rld"],
    ["application/ringing-tones", "rng"],
    ["application/rls-services+xml", "rs"],
    ["application/rsd+xml", "rsd"],
    ["application/rss+xml", "xml"],
    ["application/rtf", ["rtf", "rtx"]],
    ["application/sbml+xml", "sbml"],
    ["application/scvp-cv-request", "scq"],
    ["application/scvp-cv-response", "scs"],
    ["application/scvp-vp-request", "spq"],
    ["application/scvp-vp-response", "spp"],
    ["application/sdp", "sdp"],
    ["application/sea", "sea"],
    ["application/set", "set"],
    ["application/set-payment-initiation", "setpay"],
    ["application/set-registration-initiation", "setreg"],
    ["application/shf+xml", "shf"],
    ["application/sla", "stl"],
    ["application/smil", ["smi", "smil"]],
    ["application/smil+xml", "smi"],
    ["application/solids", "sol"],
    ["application/sounder", "sdr"],
    ["application/sparql-query", "rq"],
    ["application/sparql-results+xml", "srx"],
    ["application/srgs", "gram"],
    ["application/srgs+xml", "grxml"],
    ["application/sru+xml", "sru"],
    ["application/ssml+xml", "ssml"],
    ["application/step", ["step", "stp"]],
    ["application/streamingmedia", "ssm"],
    ["application/tei+xml", "tei"],
    ["application/thraud+xml", "tfi"],
    ["application/timestamped-data", "tsd"],
    ["application/toolbook", "tbk"],
    ["application/vda", "vda"],
    ["application/vnd.3gpp.pic-bw-large", "plb"],
    ["application/vnd.3gpp.pic-bw-small", "psb"],
    ["application/vnd.3gpp.pic-bw-var", "pvb"],
    ["application/vnd.3gpp2.tcap", "tcap"],
    ["application/vnd.3m.post-it-notes", "pwn"],
    ["application/vnd.accpac.simply.aso", "aso"],
    ["application/vnd.accpac.simply.imp", "imp"],
    ["application/vnd.acucobol", "acu"],
    ["application/vnd.acucorp", "atc"],
    ["application/vnd.adobe.air-application-installer-package+zip", "air"],
    ["application/vnd.adobe.fxp", "fxp"],
    ["application/vnd.adobe.xdp+xml", "xdp"],
    ["application/vnd.adobe.xfdf", "xfdf"],
    ["application/vnd.ahead.space", "ahead"],
    ["application/vnd.airzip.filesecure.azf", "azf"],
    ["application/vnd.airzip.filesecure.azs", "azs"],
    ["application/vnd.amazon.ebook", "azw"],
    ["application/vnd.americandynamics.acc", "acc"],
    ["application/vnd.amiga.ami", "ami"],
    ["application/vnd.android.package-archive", "apk"],
    ["application/vnd.anser-web-certificate-issue-initiation", "cii"],
    ["application/vnd.anser-web-funds-transfer-initiation", "fti"],
    ["application/vnd.antix.game-component", "atx"],
    ["application/vnd.apple.installer+xml", "mpkg"],
    ["application/vnd.apple.mpegurl", "m3u8"],
    ["application/vnd.aristanetworks.swi", "swi"],
    ["application/vnd.audiograph", "aep"],
    ["application/vnd.blueice.multipass", "mpm"],
    ["application/vnd.bmi", "bmi"],
    ["application/vnd.businessobjects", "rep"],
    ["application/vnd.chemdraw+xml", "cdxml"],
    ["application/vnd.chipnuts.karaoke-mmd", "mmd"],
    ["application/vnd.cinderella", "cdy"],
    ["application/vnd.claymore", "cla"],
    ["application/vnd.cloanto.rp9", "rp9"],
    ["application/vnd.clonk.c4group", "c4g"],
    ["application/vnd.cluetrust.cartomobile-config", "c11amc"],
    ["application/vnd.cluetrust.cartomobile-config-pkg", "c11amz"],
    ["application/vnd.commonspace", "csp"],
    ["application/vnd.contact.cmsg", "cdbcmsg"],
    ["application/vnd.cosmocaller", "cmc"],
    ["application/vnd.crick.clicker", "clkx"],
    ["application/vnd.crick.clicker.keyboard", "clkk"],
    ["application/vnd.crick.clicker.palette", "clkp"],
    ["application/vnd.crick.clicker.template", "clkt"],
    ["application/vnd.crick.clicker.wordbank", "clkw"],
    ["application/vnd.criticaltools.wbs+xml", "wbs"],
    ["application/vnd.ctc-posml", "pml"],
    ["application/vnd.cups-ppd", "ppd"],
    ["application/vnd.curl.car", "car"],
    ["application/vnd.curl.pcurl", "pcurl"],
    ["application/vnd.data-vision.rdz", "rdz"],
    ["application/vnd.denovo.fcselayout-link", "fe_launch"],
    ["application/vnd.dna", "dna"],
    ["application/vnd.dolby.mlp", "mlp"],
    ["application/vnd.dpgraph", "dpg"],
    ["application/vnd.dreamfactory", "dfac"],
    ["application/vnd.dvb.ait", "ait"],
    ["application/vnd.dvb.service", "svc"],
    ["application/vnd.dynageo", "geo"],
    ["application/vnd.ecowin.chart", "mag"],
    ["application/vnd.enliven", "nml"],
    ["application/vnd.epson.esf", "esf"],
    ["application/vnd.epson.msf", "msf"],
    ["application/vnd.epson.quickanime", "qam"],
    ["application/vnd.epson.salt", "slt"],
    ["application/vnd.epson.ssf", "ssf"],
    ["application/vnd.eszigno3+xml", "es3"],
    ["application/vnd.ezpix-album", "ez2"],
    ["application/vnd.ezpix-package", "ez3"],
    ["application/vnd.fdf", "fdf"],
    ["application/vnd.fdsn.seed", "seed"],
    ["application/vnd.flographit", "gph"],
    ["application/vnd.fluxtime.clip", "ftc"],
    ["application/vnd.framemaker", "fm"],
    ["application/vnd.frogans.fnc", "fnc"],
    ["application/vnd.frogans.ltf", "ltf"],
    ["application/vnd.fsc.weblaunch", "fsc"],
    ["application/vnd.fujitsu.oasys", "oas"],
    ["application/vnd.fujitsu.oasys2", "oa2"],
    ["application/vnd.fujitsu.oasys3", "oa3"],
    ["application/vnd.fujitsu.oasysgp", "fg5"],
    ["application/vnd.fujitsu.oasysprs", "bh2"],
    ["application/vnd.fujixerox.ddd", "ddd"],
    ["application/vnd.fujixerox.docuworks", "xdw"],
    ["application/vnd.fujixerox.docuworks.binder", "xbd"],
    ["application/vnd.fuzzysheet", "fzs"],
    ["application/vnd.genomatix.tuxedo", "txd"],
    ["application/vnd.geogebra.file", "ggb"],
    ["application/vnd.geogebra.tool", "ggt"],
    ["application/vnd.geometry-explorer", "gex"],
    ["application/vnd.geonext", "gxt"],
    ["application/vnd.geoplan", "g2w"],
    ["application/vnd.geospace", "g3w"],
    ["application/vnd.gmx", "gmx"],
    ["application/vnd.google-earth.kml+xml", "kml"],
    ["application/vnd.google-earth.kmz", "kmz"],
    ["application/vnd.grafeq", "gqf"],
    ["application/vnd.groove-account", "gac"],
    ["application/vnd.groove-help", "ghf"],
    ["application/vnd.groove-identity-message", "gim"],
    ["application/vnd.groove-injector", "grv"],
    ["application/vnd.groove-tool-message", "gtm"],
    ["application/vnd.groove-tool-template", "tpl"],
    ["application/vnd.groove-vcard", "vcg"],
    ["application/vnd.hal+xml", "hal"],
    ["application/vnd.handheld-entertainment+xml", "zmm"],
    ["application/vnd.hbci", "hbci"],
    ["application/vnd.hhe.lesson-player", "les"],
    ["application/vnd.hp-hpgl", ["hgl", "hpg", "hpgl"]],
    ["application/vnd.hp-hpid", "hpid"],
    ["application/vnd.hp-hps", "hps"],
    ["application/vnd.hp-jlyt", "jlt"],
    ["application/vnd.hp-pcl", "pcl"],
    ["application/vnd.hp-pclxl", "pclxl"],
    ["application/vnd.hydrostatix.sof-data", "sfd-hdstx"],
    ["application/vnd.hzn-3d-crossword", "x3d"],
    ["application/vnd.ibm.minipay", "mpy"],
    ["application/vnd.ibm.modcap", "afp"],
    ["application/vnd.ibm.rights-management", "irm"],
    ["application/vnd.ibm.secure-container", "sc"],
    ["application/vnd.iccprofile", "icc"],
    ["application/vnd.igloader", "igl"],
    ["application/vnd.immervision-ivp", "ivp"],
    ["application/vnd.immervision-ivu", "ivu"],
    ["application/vnd.insors.igm", "igm"],
    ["application/vnd.intercon.formnet", "xpw"],
    ["application/vnd.intergeo", "i2g"],
    ["application/vnd.intu.qbo", "qbo"],
    ["application/vnd.intu.qfx", "qfx"],
    ["application/vnd.ipunplugged.rcprofile", "rcprofile"],
    ["application/vnd.irepository.package+xml", "irp"],
    ["application/vnd.is-xpr", "xpr"],
    ["application/vnd.isac.fcs", "fcs"],
    ["application/vnd.jam", "jam"],
    ["application/vnd.jcp.javame.midlet-rms", "rms"],
    ["application/vnd.jisp", "jisp"],
    ["application/vnd.joost.joda-archive", "joda"],
    ["application/vnd.kahootz", "ktz"],
    ["application/vnd.kde.karbon", "karbon"],
    ["application/vnd.kde.kchart", "chrt"],
    ["application/vnd.kde.kformula", "kfo"],
    ["application/vnd.kde.kivio", "flw"],
    ["application/vnd.kde.kontour", "kon"],
    ["application/vnd.kde.kpresenter", "kpr"],
    ["application/vnd.kde.kspread", "ksp"],
    ["application/vnd.kde.kword", "kwd"],
    ["application/vnd.kenameaapp", "htke"],
    ["application/vnd.kidspiration", "kia"],
    ["application/vnd.kinar", "kne"],
    ["application/vnd.koan", "skp"],
    ["application/vnd.kodak-descriptor", "sse"],
    ["application/vnd.las.las+xml", "lasxml"],
    ["application/vnd.llamagraphics.life-balance.desktop", "lbd"],
    ["application/vnd.llamagraphics.life-balance.exchange+xml", "lbe"],
    ["application/vnd.lotus-1-2-3", "123"],
    ["application/vnd.lotus-approach", "apr"],
    ["application/vnd.lotus-freelance", "pre"],
    ["application/vnd.lotus-notes", "nsf"],
    ["application/vnd.lotus-organizer", "org"],
    ["application/vnd.lotus-screencam", "scm"],
    ["application/vnd.lotus-wordpro", "lwp"],
    ["application/vnd.macports.portpkg", "portpkg"],
    ["application/vnd.mcd", "mcd"],
    ["application/vnd.medcalcdata", "mc1"],
    ["application/vnd.mediastation.cdkey", "cdkey"],
    ["application/vnd.mfer", "mwf"],
    ["application/vnd.mfmp", "mfm"],
    ["application/vnd.micrografx.flo", "flo"],
    ["application/vnd.micrografx.igx", "igx"],
    ["application/vnd.mif", "mif"],
    ["application/vnd.mobius.daf", "daf"],
    ["application/vnd.mobius.dis", "dis"],
    ["application/vnd.mobius.mbk", "mbk"],
    ["application/vnd.mobius.mqy", "mqy"],
    ["application/vnd.mobius.msl", "msl"],
    ["application/vnd.mobius.plc", "plc"],
    ["application/vnd.mobius.txf", "txf"],
    ["application/vnd.mophun.application", "mpn"],
    ["application/vnd.mophun.certificate", "mpc"],
    ["application/vnd.mozilla.xul+xml", "xul"],
    ["application/vnd.ms-artgalry", "cil"],
    ["application/vnd.ms-cab-compressed", "cab"],
    ["application/vnd.ms-excel", ["xls", "xla", "xlc", "xlm", "xlt", "xlw", "xlb", "xll"]],
    ["application/vnd.ms-excel.addin.macroenabled.12", "xlam"],
    ["application/vnd.ms-excel.sheet.binary.macroenabled.12", "xlsb"],
    ["application/vnd.ms-excel.sheet.macroenabled.12", "xlsm"],
    ["application/vnd.ms-excel.template.macroenabled.12", "xltm"],
    ["application/vnd.ms-fontobject", "eot"],
    ["application/vnd.ms-htmlhelp", "chm"],
    ["application/vnd.ms-ims", "ims"],
    ["application/vnd.ms-lrm", "lrm"],
    ["application/vnd.ms-officetheme", "thmx"],
    ["application/vnd.ms-outlook", "msg"],
    ["application/vnd.ms-pki.certstore", "sst"],
    ["application/vnd.ms-pki.pko", "pko"],
    ["application/vnd.ms-pki.seccat", "cat"],
    ["application/vnd.ms-pki.stl", "stl"],
    ["application/vnd.ms-pkicertstore", "sst"],
    ["application/vnd.ms-pkiseccat", "cat"],
    ["application/vnd.ms-pkistl", "stl"],
    ["application/vnd.ms-powerpoint", ["ppt", "pot", "pps", "ppa", "pwz"]],
    ["application/vnd.ms-powerpoint.addin.macroenabled.12", "ppam"],
    ["application/vnd.ms-powerpoint.presentation.macroenabled.12", "pptm"],
    ["application/vnd.ms-powerpoint.slide.macroenabled.12", "sldm"],
    ["application/vnd.ms-powerpoint.slideshow.macroenabled.12", "ppsm"],
    ["application/vnd.ms-powerpoint.template.macroenabled.12", "potm"],
    ["application/vnd.ms-project", "mpp"],
    ["application/vnd.ms-word.document.macroenabled.12", "docm"],
    ["application/vnd.ms-word.template.macroenabled.12", "dotm"],
    ["application/vnd.ms-works", ["wks", "wcm", "wdb", "wps"]],
    ["application/vnd.ms-wpl", "wpl"],
    ["application/vnd.ms-xpsdocument", "xps"],
    ["application/vnd.mseq", "mseq"],
    ["application/vnd.musician", "mus"],
    ["application/vnd.muvee.style", "msty"],
    ["application/vnd.neurolanguage.nlu", "nlu"],
    ["application/vnd.noblenet-directory", "nnd"],
    ["application/vnd.noblenet-sealer", "nns"],
    ["application/vnd.noblenet-web", "nnw"],
    ["application/vnd.nokia.configuration-message", "ncm"],
    ["application/vnd.nokia.n-gage.data", "ngdat"],
    ["application/vnd.nokia.n-gage.symbian.install", "n-gage"],
    ["application/vnd.nokia.radio-preset", "rpst"],
    ["application/vnd.nokia.radio-presets", "rpss"],
    ["application/vnd.nokia.ringing-tone", "rng"],
    ["application/vnd.novadigm.edm", "edm"],
    ["application/vnd.novadigm.edx", "edx"],
    ["application/vnd.novadigm.ext", "ext"],
    ["application/vnd.oasis.opendocument.chart", "odc"],
    ["application/vnd.oasis.opendocument.chart-template", "otc"],
    ["application/vnd.oasis.opendocument.database", "odb"],
    ["application/vnd.oasis.opendocument.formula", "odf"],
    ["application/vnd.oasis.opendocument.formula-template", "odft"],
    ["application/vnd.oasis.opendocument.graphics", "odg"],
    ["application/vnd.oasis.opendocument.graphics-template", "otg"],
    ["application/vnd.oasis.opendocument.image", "odi"],
    ["application/vnd.oasis.opendocument.image-template", "oti"],
    ["application/vnd.oasis.opendocument.presentation", "odp"],
    ["application/vnd.oasis.opendocument.presentation-template", "otp"],
    ["application/vnd.oasis.opendocument.spreadsheet", "ods"],
    ["application/vnd.oasis.opendocument.spreadsheet-template", "ots"],
    ["application/vnd.oasis.opendocument.text", "odt"],
    ["application/vnd.oasis.opendocument.text-master", "odm"],
    ["application/vnd.oasis.opendocument.text-template", "ott"],
    ["application/vnd.oasis.opendocument.text-web", "oth"],
    ["application/vnd.olpc-sugar", "xo"],
    ["application/vnd.oma.dd2+xml", "dd2"],
    ["application/vnd.openofficeorg.extension", "oxt"],
    ["application/vnd.openxmlformats-officedocument.presentationml.presentation", "pptx"],
    ["application/vnd.openxmlformats-officedocument.presentationml.slide", "sldx"],
    ["application/vnd.openxmlformats-officedocument.presentationml.slideshow", "ppsx"],
    ["application/vnd.openxmlformats-officedocument.presentationml.template", "potx"],
    ["application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "xlsx"],
    ["application/vnd.openxmlformats-officedocument.spreadsheetml.template", "xltx"],
    ["application/vnd.openxmlformats-officedocument.wordprocessingml.document", "docx"],
    ["application/vnd.openxmlformats-officedocument.wordprocessingml.template", "dotx"],
    ["application/vnd.osgeo.mapguide.package", "mgp"],
    ["application/vnd.osgi.dp", "dp"],
    ["application/vnd.palm", "pdb"],
    ["application/vnd.pawaafile", "paw"],
    ["application/vnd.pg.format", "str"],
    ["application/vnd.pg.osasli", "ei6"],
    ["application/vnd.picsel", "efif"],
    ["application/vnd.pmi.widget", "wg"],
    ["application/vnd.pocketlearn", "plf"],
    ["application/vnd.powerbuilder6", "pbd"],
    ["application/vnd.previewsystems.box", "box"],
    ["application/vnd.proteus.magazine", "mgz"],
    ["application/vnd.publishare-delta-tree", "qps"],
    ["application/vnd.pvi.ptid1", "ptid"],
    ["application/vnd.quark.quarkxpress", "qxd"],
    ["application/vnd.realvnc.bed", "bed"],
    ["application/vnd.recordare.musicxml", "mxl"],
    ["application/vnd.recordare.musicxml+xml", "musicxml"],
    ["application/vnd.rig.cryptonote", "cryptonote"],
    ["application/vnd.rim.cod", "cod"],
    ["application/vnd.rn-realmedia", "rm"],
    ["application/vnd.rn-realplayer", "rnx"],
    ["application/vnd.route66.link66+xml", "link66"],
    ["application/vnd.sailingtracker.track", "st"],
    ["application/vnd.seemail", "see"],
    ["application/vnd.sema", "sema"],
    ["application/vnd.semd", "semd"],
    ["application/vnd.semf", "semf"],
    ["application/vnd.shana.informed.formdata", "ifm"],
    ["application/vnd.shana.informed.formtemplate", "itp"],
    ["application/vnd.shana.informed.interchange", "iif"],
    ["application/vnd.shana.informed.package", "ipk"],
    ["application/vnd.simtech-mindmapper", "twd"],
    ["application/vnd.smaf", "mmf"],
    ["application/vnd.smart.teacher", "teacher"],
    ["application/vnd.solent.sdkm+xml", "sdkm"],
    ["application/vnd.spotfire.dxp", "dxp"],
    ["application/vnd.spotfire.sfs", "sfs"],
    ["application/vnd.stardivision.calc", "sdc"],
    ["application/vnd.stardivision.draw", "sda"],
    ["application/vnd.stardivision.impress", "sdd"],
    ["application/vnd.stardivision.math", "smf"],
    ["application/vnd.stardivision.writer", "sdw"],
    ["application/vnd.stardivision.writer-global", "sgl"],
    ["application/vnd.stepmania.stepchart", "sm"],
    ["application/vnd.sun.xml.calc", "sxc"],
    ["application/vnd.sun.xml.calc.template", "stc"],
    ["application/vnd.sun.xml.draw", "sxd"],
    ["application/vnd.sun.xml.draw.template", "std"],
    ["application/vnd.sun.xml.impress", "sxi"],
    ["application/vnd.sun.xml.impress.template", "sti"],
    ["application/vnd.sun.xml.math", "sxm"],
    ["application/vnd.sun.xml.writer", "sxw"],
    ["application/vnd.sun.xml.writer.global", "sxg"],
    ["application/vnd.sun.xml.writer.template", "stw"],
    ["application/vnd.sus-calendar", "sus"],
    ["application/vnd.svd", "svd"],
    ["application/vnd.symbian.install", "sis"],
    ["application/vnd.syncml+xml", "xsm"],
    ["application/vnd.syncml.dm+wbxml", "bdm"],
    ["application/vnd.syncml.dm+xml", "xdm"],
    ["application/vnd.tao.intent-module-archive", "tao"],
    ["application/vnd.tmobile-livetv", "tmo"],
    ["application/vnd.trid.tpt", "tpt"],
    ["application/vnd.triscape.mxs", "mxs"],
    ["application/vnd.trueapp", "tra"],
    ["application/vnd.ufdl", "ufd"],
    ["application/vnd.uiq.theme", "utz"],
    ["application/vnd.umajin", "umj"],
    ["application/vnd.unity", "unityweb"],
    ["application/vnd.uoml+xml", "uoml"],
    ["application/vnd.vcx", "vcx"],
    ["application/vnd.visio", "vsd"],
    ["application/vnd.visionary", "vis"],
    ["application/vnd.vsf", "vsf"],
    ["application/vnd.wap.wbxml", "wbxml"],
    ["application/vnd.wap.wmlc", "wmlc"],
    ["application/vnd.wap.wmlscriptc", "wmlsc"],
    ["application/vnd.webturbo", "wtb"],
    ["application/vnd.wolfram.player", "nbp"],
    ["application/vnd.wordperfect", "wpd"],
    ["application/vnd.wqd", "wqd"],
    ["application/vnd.wt.stf", "stf"],
    ["application/vnd.xara", ["web", "xar"]],
    ["application/vnd.xfdl", "xfdl"],
    ["application/vnd.yamaha.hv-dic", "hvd"],
    ["application/vnd.yamaha.hv-script", "hvs"],
    ["application/vnd.yamaha.hv-voice", "hvp"],
    ["application/vnd.yamaha.openscoreformat", "osf"],
    ["application/vnd.yamaha.openscoreformat.osfpvg+xml", "osfpvg"],
    ["application/vnd.yamaha.smaf-audio", "saf"],
    ["application/vnd.yamaha.smaf-phrase", "spf"],
    ["application/vnd.yellowriver-custom-menu", "cmp"],
    ["application/vnd.zul", "zir"],
    ["application/vnd.zzazz.deck+xml", "zaz"],
    ["application/vocaltec-media-desc", "vmd"],
    ["application/vocaltec-media-file", "vmf"],
    ["application/voicexml+xml", "vxml"],
    ["application/widget", "wgt"],
    ["application/winhlp", "hlp"],
    ["application/wordperfect", ["wp", "wp5", "wp6", "wpd"]],
    ["application/wordperfect6.0", ["w60", "wp5"]],
    ["application/wordperfect6.1", "w61"],
    ["application/wsdl+xml", "wsdl"],
    ["application/wspolicy+xml", "wspolicy"],
    ["application/x-123", "wk1"],
    ["application/x-7z-compressed", "7z"],
    ["application/x-abiword", "abw"],
    ["application/x-ace-compressed", "ace"],
    ["application/x-aim", "aim"],
    ["application/x-authorware-bin", "aab"],
    ["application/x-authorware-map", "aam"],
    ["application/x-authorware-seg", "aas"],
    ["application/x-bcpio", "bcpio"],
    ["application/x-binary", "bin"],
    ["application/x-binhex40", "hqx"],
    ["application/x-bittorrent", "torrent"],
    ["application/x-bsh", ["bsh", "sh", "shar"]],
    ["application/x-bytecode.elisp", "elc"],
    ["application/x-bytecode.python", "pyc"],
    ["application/x-bzip", "bz"],
    ["application/x-bzip2", ["boz", "bz2"]],
    ["application/x-cdf", "cdf"],
    ["application/x-cdlink", "vcd"],
    ["application/x-chat", ["cha", "chat"]],
    ["application/x-chess-pgn", "pgn"],
    ["application/x-cmu-raster", "ras"],
    ["application/x-cocoa", "cco"],
    ["application/x-compactpro", "cpt"],
    ["application/x-compress", "z"],
    ["application/x-compressed", ["tgz", "gz", "z", "zip"]],
    ["application/x-conference", "nsc"],
    ["application/x-cpio", "cpio"],
    ["application/x-cpt", "cpt"],
    ["application/x-csh", "csh"],
    ["application/x-debian-package", "deb"],
    ["application/x-deepv", "deepv"],
    ["application/x-director", ["dir", "dcr", "dxr"]],
    ["application/x-doom", "wad"],
    ["application/x-dtbncx+xml", "ncx"],
    ["application/x-dtbook+xml", "dtb"],
    ["application/x-dtbresource+xml", "res"],
    ["application/x-dvi", "dvi"],
    ["application/x-elc", "elc"],
    ["application/x-envoy", ["env", "evy"]],
    ["application/x-esrehber", "es"],
    ["application/x-excel", ["xls", "xla", "xlb", "xlc", "xld", "xlk", "xll", "xlm", "xlt", "xlv", "xlw"]],
    ["application/x-font-bdf", "bdf"],
    ["application/x-font-ghostscript", "gsf"],
    ["application/x-font-linux-psf", "psf"],
    ["application/x-font-otf", "otf"],
    ["application/x-font-pcf", "pcf"],
    ["application/x-font-snf", "snf"],
    ["application/x-font-ttf", "ttf"],
    ["application/x-font-type1", "pfa"],
    ["application/x-font-woff", "woff"],
    ["application/x-frame", "mif"],
    ["application/x-freelance", "pre"],
    ["application/x-futuresplash", "spl"],
    ["application/x-gnumeric", "gnumeric"],
    ["application/x-gsp", "gsp"],
    ["application/x-gss", "gss"],
    ["application/x-gtar", "gtar"],
    ["application/x-gzip", ["gz", "gzip"]],
    ["application/x-hdf", "hdf"],
    ["application/x-helpfile", ["help", "hlp"]],
    ["application/x-httpd-imap", "imap"],
    ["application/x-ima", "ima"],
    ["application/x-internet-signup", ["ins", "isp"]],
    ["application/x-internett-signup", "ins"],
    ["application/x-inventor", "iv"],
    ["application/x-ip2", "ip"],
    ["application/x-iphone", "iii"],
    ["application/x-java-class", "class"],
    ["application/x-java-commerce", "jcm"],
    ["application/x-java-jnlp-file", "jnlp"],
    ["application/x-javascript", "js"],
    ["application/x-koan", ["skd", "skm", "skp", "skt"]],
    ["application/x-ksh", "ksh"],
    ["application/x-latex", ["latex", "ltx"]],
    ["application/x-lha", "lha"],
    ["application/x-lisp", "lsp"],
    ["application/x-livescreen", "ivy"],
    ["application/x-lotus", "wq1"],
    ["application/x-lotusscreencam", "scm"],
    ["application/x-lzh", "lzh"],
    ["application/x-lzx", "lzx"],
    ["application/x-mac-binhex40", "hqx"],
    ["application/x-macbinary", "bin"],
    ["application/x-magic-cap-package-1.0", "mc$"],
    ["application/x-mathcad", "mcd"],
    ["application/x-meme", "mm"],
    ["application/x-midi", ["mid", "midi"]],
    ["application/x-mif", "mif"],
    ["application/x-mix-transfer", "nix"],
    ["application/x-mobipocket-ebook", "prc"],
    ["application/x-mplayer2", "asx"],
    ["application/x-ms-application", "application"],
    ["application/x-ms-wmd", "wmd"],
    ["application/x-ms-wmz", "wmz"],
    ["application/x-ms-xbap", "xbap"],
    ["application/x-msaccess", "mdb"],
    ["application/x-msbinder", "obd"],
    ["application/x-mscardfile", "crd"],
    ["application/x-msclip", "clp"],
    ["application/x-msdownload", ["exe", "dll"]],
    ["application/x-msexcel", ["xls", "xla", "xlw"]],
    ["application/x-msmediaview", ["mvb", "m13", "m14"]],
    ["application/x-msmetafile", "wmf"],
    ["application/x-msmoney", "mny"],
    ["application/x-mspowerpoint", "ppt"],
    ["application/x-mspublisher", "pub"],
    ["application/x-msschedule", "scd"],
    ["application/x-msterminal", "trm"],
    ["application/x-mswrite", "wri"],
    ["application/x-navi-animation", "ani"],
    ["application/x-navidoc", "nvd"],
    ["application/x-navimap", "map"],
    ["application/x-navistyle", "stl"],
    ["application/x-netcdf", ["cdf", "nc"]],
    ["application/x-newton-compatible-pkg", "pkg"],
    ["application/x-nokia-9000-communicator-add-on-software", "aos"],
    ["application/x-omc", "omc"],
    ["application/x-omcdatamaker", "omcd"],
    ["application/x-omcregerator", "omcr"],
    ["application/x-pagemaker", ["pm4", "pm5"]],
    ["application/x-pcl", "pcl"],
    ["application/x-perfmon", ["pma", "pmc", "pml", "pmr", "pmw"]],
    ["application/x-pixclscript", "plx"],
    ["application/x-pkcs10", "p10"],
    ["application/x-pkcs12", ["p12", "pfx"]],
    ["application/x-pkcs7-certificates", ["p7b", "spc"]],
    ["application/x-pkcs7-certreqresp", "p7r"],
    ["application/x-pkcs7-mime", ["p7m", "p7c"]],
    ["application/x-pkcs7-signature", ["p7s", "p7a"]],
    ["application/x-pointplus", "css"],
    ["application/x-portable-anymap", "pnm"],
    ["application/x-project", ["mpc", "mpt", "mpv", "mpx"]],
    ["application/x-qpro", "wb1"],
    ["application/x-rar-compressed", "rar"],
    ["application/x-rtf", "rtf"],
    ["application/x-sdp", "sdp"],
    ["application/x-sea", "sea"],
    ["application/x-seelogo", "sl"],
    ["application/x-sh", "sh"],
    ["application/x-shar", ["shar", "sh"]],
    ["application/x-shockwave-flash", "swf"],
    ["application/x-silverlight-app", "xap"],
    ["application/x-sit", "sit"],
    ["application/x-sprite", ["spr", "sprite"]],
    ["application/x-stuffit", "sit"],
    ["application/x-stuffitx", "sitx"],
    ["application/x-sv4cpio", "sv4cpio"],
    ["application/x-sv4crc", "sv4crc"],
    ["application/x-tar", "tar"],
    ["application/x-tbook", ["sbk", "tbk"]],
    ["application/x-tcl", "tcl"],
    ["application/x-tex", "tex"],
    ["application/x-tex-tfm", "tfm"],
    ["application/x-texinfo", ["texi", "texinfo"]],
    ["application/x-troff", ["roff", "t", "tr"]],
    ["application/x-troff-man", "man"],
    ["application/x-troff-me", "me"],
    ["application/x-troff-ms", "ms"],
    ["application/x-troff-msvideo", "avi"],
    ["application/x-ustar", "ustar"],
    ["application/x-visio", ["vsd", "vst", "vsw"]],
    ["application/x-vnd.audioexplosion.mzz", "mzz"],
    ["application/x-vnd.ls-xpix", "xpix"],
    ["application/x-vrml", "vrml"],
    ["application/x-wais-source", ["src", "wsrc"]],
    ["application/x-winhelp", "hlp"],
    ["application/x-wintalk", "wtk"],
    ["application/x-world", ["wrl", "svr"]],
    ["application/x-wpwin", "wpd"],
    ["application/x-wri", "wri"],
    ["application/x-x509-ca-cert", ["cer", "crt", "der"]],
    ["application/x-x509-user-cert", "crt"],
    ["application/x-xfig", "fig"],
    ["application/x-xpinstall", "xpi"],
    ["application/x-zip-compressed", "zip"],
    ["application/xcap-diff+xml", "xdf"],
    ["application/xenc+xml", "xenc"],
    ["application/xhtml+xml", "xhtml"],
    ["application/xml", "xml"],
    ["application/xml-dtd", "dtd"],
    ["application/xop+xml", "xop"],
    ["application/xslt+xml", "xslt"],
    ["application/xspf+xml", "xspf"],
    ["application/xv+xml", "mxml"],
    ["application/yang", "yang"],
    ["application/yin+xml", "yin"],
    ["application/ynd.ms-pkipko", "pko"],
    ["application/zip", "zip"],
    ["audio/adpcm", "adp"],
    ["audio/aiff", ["aiff", "aif", "aifc"]],
    ["audio/basic", ["snd", "au"]],
    ["audio/it", "it"],
    ["audio/make", ["funk", "my", "pfunk"]],
    ["audio/make.my.funk", "pfunk"],
    ["audio/mid", ["mid", "rmi"]],
    ["audio/midi", ["midi", "kar", "mid"]],
    ["audio/mod", "mod"],
    ["audio/mp4", "mp4a"],
    ["audio/mpeg", ["mpga", "mp3", "m2a", "mp2", "mpa", "mpg"]],
    ["audio/mpeg3", "mp3"],
    ["audio/nspaudio", ["la", "lma"]],
    ["audio/ogg", "oga"],
    ["audio/s3m", "s3m"],
    ["audio/tsp-audio", "tsi"],
    ["audio/tsplayer", "tsp"],
    ["audio/vnd.dece.audio", "uva"],
    ["audio/vnd.digital-winds", "eol"],
    ["audio/vnd.dra", "dra"],
    ["audio/vnd.dts", "dts"],
    ["audio/vnd.dts.hd", "dtshd"],
    ["audio/vnd.lucent.voice", "lvp"],
    ["audio/vnd.ms-playready.media.pya", "pya"],
    ["audio/vnd.nuera.ecelp4800", "ecelp4800"],
    ["audio/vnd.nuera.ecelp7470", "ecelp7470"],
    ["audio/vnd.nuera.ecelp9600", "ecelp9600"],
    ["audio/vnd.qcelp", "qcp"],
    ["audio/vnd.rip", "rip"],
    ["audio/voc", "voc"],
    ["audio/voxware", "vox"],
    ["audio/wav", "wav"],
    ["audio/webm", "weba"],
    ["audio/x-aac", "aac"],
    ["audio/x-adpcm", "snd"],
    ["audio/x-aiff", ["aiff", "aif", "aifc"]],
    ["audio/x-au", "au"],
    ["audio/x-gsm", ["gsd", "gsm"]],
    ["audio/x-jam", "jam"],
    ["audio/x-liveaudio", "lam"],
    ["audio/x-mid", ["mid", "midi"]],
    ["audio/x-midi", ["midi", "mid"]],
    ["audio/x-mod", "mod"],
    ["audio/x-mpeg", "mp2"],
    ["audio/x-mpeg-3", "mp3"],
    ["audio/x-mpegurl", "m3u"],
    ["audio/x-mpequrl", "m3u"],
    ["audio/x-ms-wax", "wax"],
    ["audio/x-ms-wma", "wma"],
    ["audio/x-nspaudio", ["la", "lma"]],
    ["audio/x-pn-realaudio", ["ra", "ram", "rm", "rmm", "rmp"]],
    ["audio/x-pn-realaudio-plugin", ["ra", "rmp", "rpm"]],
    ["audio/x-psid", "sid"],
    ["audio/x-realaudio", "ra"],
    ["audio/x-twinvq", "vqf"],
    ["audio/x-twinvq-plugin", ["vqe", "vql"]],
    ["audio/x-vnd.audioexplosion.mjuicemediafile", "mjf"],
    ["audio/x-voc", "voc"],
    ["audio/x-wav", "wav"],
    ["audio/xm", "xm"],
    ["chemical/x-cdx", "cdx"],
    ["chemical/x-cif", "cif"],
    ["chemical/x-cmdf", "cmdf"],
    ["chemical/x-cml", "cml"],
    ["chemical/x-csml", "csml"],
    ["chemical/x-pdb", ["pdb", "xyz"]],
    ["chemical/x-xyz", "xyz"],
    ["drawing/x-dwf", "dwf"],
    ["i-world/i-vrml", "ivr"],
    ["image/bmp", ["bmp", "bm"]],
    ["image/cgm", "cgm"],
    ["image/cis-cod", "cod"],
    ["image/cmu-raster", ["ras", "rast"]],
    ["image/fif", "fif"],
    ["image/florian", ["flo", "turbot"]],
    ["image/g3fax", "g3"],
    ["image/gif", "gif"],
    ["image/ief", ["ief", "iefs"]],
    ["image/jpeg", ["jpeg", "jpe", "jpg", "jfif", "jfif-tbnl"]],
    ["image/jutvision", "jut"],
    ["image/ktx", "ktx"],
    ["image/naplps", ["nap", "naplps"]],
    ["image/pict", ["pic", "pict"]],
    ["image/pipeg", "jfif"],
    ["image/pjpeg", ["jfif", "jpe", "jpeg", "jpg"]],
    ["image/png", ["png", "x-png"]],
    ["image/prs.btif", "btif"],
    ["image/svg+xml", "svg"],
    ["image/tiff", ["tif", "tiff"]],
    ["image/vasa", "mcf"],
    ["image/vnd.adobe.photoshop", "psd"],
    ["image/vnd.dece.graphic", "uvi"],
    ["image/vnd.djvu", "djvu"],
    ["image/vnd.dvb.subtitle", "sub"],
    ["image/vnd.dwg", ["dwg", "dxf", "svf"]],
    ["image/vnd.dxf", "dxf"],
    ["image/vnd.fastbidsheet", "fbs"],
    ["image/vnd.fpx", "fpx"],
    ["image/vnd.fst", "fst"],
    ["image/vnd.fujixerox.edmics-mmr", "mmr"],
    ["image/vnd.fujixerox.edmics-rlc", "rlc"],
    ["image/vnd.ms-modi", "mdi"],
    ["image/vnd.net-fpx", ["fpx", "npx"]],
    ["image/vnd.rn-realflash", "rf"],
    ["image/vnd.rn-realpix", "rp"],
    ["image/vnd.wap.wbmp", "wbmp"],
    ["image/vnd.xiff", "xif"],
    ["image/webp", "webp"],
    ["image/x-cmu-raster", "ras"],
    ["image/x-cmx", "cmx"],
    ["image/x-dwg", ["dwg", "dxf", "svf"]],
    ["image/x-freehand", "fh"],
    ["image/x-icon", "ico"],
    ["image/x-jg", "art"],
    ["image/x-jps", "jps"],
    ["image/x-niff", ["niff", "nif"]],
    ["image/x-pcx", "pcx"],
    ["image/x-pict", ["pct", "pic"]],
    ["image/x-portable-anymap", "pnm"],
    ["image/x-portable-bitmap", "pbm"],
    ["image/x-portable-graymap", "pgm"],
    ["image/x-portable-greymap", "pgm"],
    ["image/x-portable-pixmap", "ppm"],
    ["image/x-quicktime", ["qif", "qti", "qtif"]],
    ["image/x-rgb", "rgb"],
    ["image/x-tiff", ["tif", "tiff"]],
    ["image/x-windows-bmp", "bmp"],
    ["image/x-xbitmap", "xbm"],
    ["image/x-xbm", "xbm"],
    ["image/x-xpixmap", ["xpm", "pm"]],
    ["image/x-xwd", "xwd"],
    ["image/x-xwindowdump", "xwd"],
    ["image/xbm", "xbm"],
    ["image/xpm", "xpm"],
    ["message/rfc822", ["eml", "mht", "mhtml", "nws", "mime"]],
    ["model/iges", ["iges", "igs"]],
    ["model/mesh", "msh"],
    ["model/vnd.collada+xml", "dae"],
    ["model/vnd.dwf", "dwf"],
    ["model/vnd.gdl", "gdl"],
    ["model/vnd.gtw", "gtw"],
    ["model/vnd.mts", "mts"],
    ["model/vnd.vtu", "vtu"],
    ["model/vrml", ["vrml", "wrl", "wrz"]],
    ["model/x-pov", "pov"],
    ["multipart/x-gzip", "gzip"],
    ["multipart/x-ustar", "ustar"],
    ["multipart/x-zip", "zip"],
    ["music/crescendo", ["mid", "midi"]],
    ["music/x-karaoke", "kar"],
    ["paleovu/x-pv", "pvu"],
    ["text/asp", "asp"],
    ["text/calendar", "ics"],
    ["text/css", "css"],
    ["text/csv", "csv"],
    ["text/ecmascript", "js"],
    ["text/h323", "323"],
    ["text/html", ["html", "htm", "stm", "acgi", "htmls", "htx", "shtml"]],
    ["text/iuls", "uls"],
    ["text/javascript", "js"],
    ["text/mcf", "mcf"],
    ["text/n3", "n3"],
    ["text/pascal", "pas"],
    [
      "text/plain",
      [
        "txt",
        "bas",
        "c",
        "h",
        "c++",
        "cc",
        "com",
        "conf",
        "cxx",
        "def",
        "f",
        "f90",
        "for",
        "g",
        "hh",
        "idc",
        "jav",
        "java",
        "list",
        "log",
        "lst",
        "m",
        "mar",
        "pl",
        "sdml",
        "text"
      ]
    ],
    ["text/plain-bas", "par"],
    ["text/prs.lines.tag", "dsc"],
    ["text/richtext", ["rtx", "rt", "rtf"]],
    ["text/scriplet", "wsc"],
    ["text/scriptlet", "sct"],
    ["text/sgml", ["sgm", "sgml"]],
    ["text/tab-separated-values", "tsv"],
    ["text/troff", "t"],
    ["text/turtle", "ttl"],
    ["text/uri-list", ["uni", "unis", "uri", "uris"]],
    ["text/vnd.abc", "abc"],
    ["text/vnd.curl", "curl"],
    ["text/vnd.curl.dcurl", "dcurl"],
    ["text/vnd.curl.mcurl", "mcurl"],
    ["text/vnd.curl.scurl", "scurl"],
    ["text/vnd.fly", "fly"],
    ["text/vnd.fmi.flexstor", "flx"],
    ["text/vnd.graphviz", "gv"],
    ["text/vnd.in3d.3dml", "3dml"],
    ["text/vnd.in3d.spot", "spot"],
    ["text/vnd.rn-realtext", "rt"],
    ["text/vnd.sun.j2me.app-descriptor", "jad"],
    ["text/vnd.wap.wml", "wml"],
    ["text/vnd.wap.wmlscript", "wmls"],
    ["text/webviewhtml", "htt"],
    ["text/x-asm", ["asm", "s"]],
    ["text/x-audiosoft-intra", "aip"],
    ["text/x-c", ["c", "cc", "cpp"]],
    ["text/x-component", "htc"],
    ["text/x-fortran", ["for", "f", "f77", "f90"]],
    ["text/x-h", ["h", "hh"]],
    ["text/x-java-source", ["java", "jav"]],
    ["text/x-java-source,java", "java"],
    ["text/x-la-asf", "lsx"],
    ["text/x-m", "m"],
    ["text/x-pascal", "p"],
    ["text/x-script", "hlb"],
    ["text/x-script.csh", "csh"],
    ["text/x-script.elisp", "el"],
    ["text/x-script.guile", "scm"],
    ["text/x-script.ksh", "ksh"],
    ["text/x-script.lisp", "lsp"],
    ["text/x-script.perl", "pl"],
    ["text/x-script.perl-module", "pm"],
    ["text/x-script.phyton", "py"],
    ["text/x-script.rexx", "rexx"],
    ["text/x-script.scheme", "scm"],
    ["text/x-script.sh", "sh"],
    ["text/x-script.tcl", "tcl"],
    ["text/x-script.tcsh", "tcsh"],
    ["text/x-script.zsh", "zsh"],
    ["text/x-server-parsed-html", ["shtml", "ssi"]],
    ["text/x-setext", "etx"],
    ["text/x-sgml", ["sgm", "sgml"]],
    ["text/x-speech", ["spc", "talk"]],
    ["text/x-uil", "uil"],
    ["text/x-uuencode", ["uu", "uue"]],
    ["text/x-vcalendar", "vcs"],
    ["text/x-vcard", "vcf"],
    ["text/xml", "xml"],
    ["video/3gpp", "3gp"],
    ["video/3gpp2", "3g2"],
    ["video/animaflex", "afl"],
    ["video/avi", "avi"],
    ["video/avs-video", "avs"],
    ["video/dl", "dl"],
    ["video/fli", "fli"],
    ["video/gl", "gl"],
    ["video/h261", "h261"],
    ["video/h263", "h263"],
    ["video/h264", "h264"],
    ["video/jpeg", "jpgv"],
    ["video/jpm", "jpm"],
    ["video/mj2", "mj2"],
    ["video/mp4", "mp4"],
    ["video/mpeg", ["mpeg", "mp2", "mpa", "mpe", "mpg", "mpv2", "m1v", "m2v", "mp3"]],
    ["video/msvideo", "avi"],
    ["video/ogg", "ogv"],
    ["video/quicktime", ["mov", "qt", "moov"]],
    ["video/vdo", "vdo"],
    ["video/vivo", ["viv", "vivo"]],
    ["video/vnd.dece.hd", "uvh"],
    ["video/vnd.dece.mobile", "uvm"],
    ["video/vnd.dece.pd", "uvp"],
    ["video/vnd.dece.sd", "uvs"],
    ["video/vnd.dece.video", "uvv"],
    ["video/vnd.fvt", "fvt"],
    ["video/vnd.mpegurl", "mxu"],
    ["video/vnd.ms-playready.media.pyv", "pyv"],
    ["video/vnd.rn-realvideo", "rv"],
    ["video/vnd.uvvu.mp4", "uvu"],
    ["video/vnd.vivo", ["viv", "vivo"]],
    ["video/vosaic", "vos"],
    ["video/webm", "webm"],
    ["video/x-amt-demorun", "xdr"],
    ["video/x-amt-showrun", "xsr"],
    ["video/x-atomic3d-feature", "fmf"],
    ["video/x-dl", "dl"],
    ["video/x-dv", ["dif", "dv"]],
    ["video/x-f4v", "f4v"],
    ["video/x-fli", "fli"],
    ["video/x-flv", "flv"],
    ["video/x-gl", "gl"],
    ["video/x-isvideo", "isu"],
    ["video/x-la-asf", ["lsf", "lsx"]],
    ["video/x-m4v", "m4v"],
    ["video/x-motion-jpeg", "mjpg"],
    ["video/x-mpeg", ["mp3", "mp2"]],
    ["video/x-mpeq2a", "mp2"],
    ["video/x-ms-asf", ["asf", "asr", "asx"]],
    ["video/x-ms-asf-plugin", "asx"],
    ["video/x-ms-wm", "wm"],
    ["video/x-ms-wmv", "wmv"],
    ["video/x-ms-wmx", "wmx"],
    ["video/x-ms-wvx", "wvx"],
    ["video/x-msvideo", "avi"],
    ["video/x-qtc", "qtc"],
    ["video/x-scm", "scm"],
    ["video/x-sgi-movie", ["movie", "mv"]],
    ["windows/metafile", "wmf"],
    ["www/mime", "mime"],
    ["x-conference/x-cooltalk", "ice"],
    ["x-music/x-midi", ["mid", "midi"]],
    ["x-world/x-3dmf", ["3dm", "3dmf", "qd3", "qd3d"]],
    ["x-world/x-svr", "svr"],
    ["x-world/x-vrml", ["flr", "vrml", "wrl", "wrz", "xaf", "xof"]],
    ["x-world/x-vrt", "vrt"],
    ["xgl/drawing", "xgz"],
    ["xgl/movie", "xmz"]
  ]);
  const extensions = /* @__PURE__ */ new Map([
    ["123", "application/vnd.lotus-1-2-3"],
    ["323", "text/h323"],
    ["*", "application/octet-stream"],
    ["3dm", "x-world/x-3dmf"],
    ["3dmf", "x-world/x-3dmf"],
    ["3dml", "text/vnd.in3d.3dml"],
    ["3g2", "video/3gpp2"],
    ["3gp", "video/3gpp"],
    ["7z", "application/x-7z-compressed"],
    ["a", "application/octet-stream"],
    ["aab", "application/x-authorware-bin"],
    ["aac", "audio/x-aac"],
    ["aam", "application/x-authorware-map"],
    ["aas", "application/x-authorware-seg"],
    ["abc", "text/vnd.abc"],
    ["abw", "application/x-abiword"],
    ["ac", "application/pkix-attr-cert"],
    ["acc", "application/vnd.americandynamics.acc"],
    ["ace", "application/x-ace-compressed"],
    ["acgi", "text/html"],
    ["acu", "application/vnd.acucobol"],
    ["acx", "application/internet-property-stream"],
    ["adp", "audio/adpcm"],
    ["aep", "application/vnd.audiograph"],
    ["afl", "video/animaflex"],
    ["afp", "application/vnd.ibm.modcap"],
    ["ahead", "application/vnd.ahead.space"],
    ["ai", "application/postscript"],
    ["aif", ["audio/aiff", "audio/x-aiff"]],
    ["aifc", ["audio/aiff", "audio/x-aiff"]],
    ["aiff", ["audio/aiff", "audio/x-aiff"]],
    ["aim", "application/x-aim"],
    ["aip", "text/x-audiosoft-intra"],
    ["air", "application/vnd.adobe.air-application-installer-package+zip"],
    ["ait", "application/vnd.dvb.ait"],
    ["ami", "application/vnd.amiga.ami"],
    ["ani", "application/x-navi-animation"],
    ["aos", "application/x-nokia-9000-communicator-add-on-software"],
    ["apk", "application/vnd.android.package-archive"],
    ["application", "application/x-ms-application"],
    ["apr", "application/vnd.lotus-approach"],
    ["aps", "application/mime"],
    ["arc", "application/octet-stream"],
    ["arj", ["application/arj", "application/octet-stream"]],
    ["art", "image/x-jg"],
    ["asf", "video/x-ms-asf"],
    ["asm", "text/x-asm"],
    ["aso", "application/vnd.accpac.simply.aso"],
    ["asp", "text/asp"],
    ["asr", "video/x-ms-asf"],
    ["asx", ["video/x-ms-asf", "application/x-mplayer2", "video/x-ms-asf-plugin"]],
    ["atc", "application/vnd.acucorp"],
    ["atomcat", "application/atomcat+xml"],
    ["atomsvc", "application/atomsvc+xml"],
    ["atx", "application/vnd.antix.game-component"],
    ["au", ["audio/basic", "audio/x-au"]],
    ["avi", ["video/avi", "video/msvideo", "application/x-troff-msvideo", "video/x-msvideo"]],
    ["avs", "video/avs-video"],
    ["aw", "application/applixware"],
    ["axs", "application/olescript"],
    ["azf", "application/vnd.airzip.filesecure.azf"],
    ["azs", "application/vnd.airzip.filesecure.azs"],
    ["azw", "application/vnd.amazon.ebook"],
    ["bas", "text/plain"],
    ["bcpio", "application/x-bcpio"],
    ["bdf", "application/x-font-bdf"],
    ["bdm", "application/vnd.syncml.dm+wbxml"],
    ["bed", "application/vnd.realvnc.bed"],
    ["bh2", "application/vnd.fujitsu.oasysprs"],
    [
      "bin",
      ["application/octet-stream", "application/mac-binary", "application/macbinary", "application/x-macbinary", "application/x-binary"]
    ],
    ["bm", "image/bmp"],
    ["bmi", "application/vnd.bmi"],
    ["bmp", ["image/bmp", "image/x-windows-bmp"]],
    ["boo", "application/book"],
    ["book", "application/book"],
    ["box", "application/vnd.previewsystems.box"],
    ["boz", "application/x-bzip2"],
    ["bsh", "application/x-bsh"],
    ["btif", "image/prs.btif"],
    ["bz", "application/x-bzip"],
    ["bz2", "application/x-bzip2"],
    ["c", ["text/plain", "text/x-c"]],
    ["c++", "text/plain"],
    ["c11amc", "application/vnd.cluetrust.cartomobile-config"],
    ["c11amz", "application/vnd.cluetrust.cartomobile-config-pkg"],
    ["c4g", "application/vnd.clonk.c4group"],
    ["cab", "application/vnd.ms-cab-compressed"],
    ["car", "application/vnd.curl.car"],
    ["cat", ["application/vnd.ms-pkiseccat", "application/vnd.ms-pki.seccat"]],
    ["cc", ["text/plain", "text/x-c"]],
    ["ccad", "application/clariscad"],
    ["cco", "application/x-cocoa"],
    ["ccxml", "application/ccxml+xml,"],
    ["cdbcmsg", "application/vnd.contact.cmsg"],
    ["cdf", ["application/cdf", "application/x-cdf", "application/x-netcdf"]],
    ["cdkey", "application/vnd.mediastation.cdkey"],
    ["cdmia", "application/cdmi-capability"],
    ["cdmic", "application/cdmi-container"],
    ["cdmid", "application/cdmi-domain"],
    ["cdmio", "application/cdmi-object"],
    ["cdmiq", "application/cdmi-queue"],
    ["cdx", "chemical/x-cdx"],
    ["cdxml", "application/vnd.chemdraw+xml"],
    ["cdy", "application/vnd.cinderella"],
    ["cer", ["application/pkix-cert", "application/x-x509-ca-cert"]],
    ["cgm", "image/cgm"],
    ["cha", "application/x-chat"],
    ["chat", "application/x-chat"],
    ["chm", "application/vnd.ms-htmlhelp"],
    ["chrt", "application/vnd.kde.kchart"],
    ["cif", "chemical/x-cif"],
    ["cii", "application/vnd.anser-web-certificate-issue-initiation"],
    ["cil", "application/vnd.ms-artgalry"],
    ["cla", "application/vnd.claymore"],
    [
      "class",
      ["application/octet-stream", "application/java", "application/java-byte-code", "application/java-vm", "application/x-java-class"]
    ],
    ["clkk", "application/vnd.crick.clicker.keyboard"],
    ["clkp", "application/vnd.crick.clicker.palette"],
    ["clkt", "application/vnd.crick.clicker.template"],
    ["clkw", "application/vnd.crick.clicker.wordbank"],
    ["clkx", "application/vnd.crick.clicker"],
    ["clp", "application/x-msclip"],
    ["cmc", "application/vnd.cosmocaller"],
    ["cmdf", "chemical/x-cmdf"],
    ["cml", "chemical/x-cml"],
    ["cmp", "application/vnd.yellowriver-custom-menu"],
    ["cmx", "image/x-cmx"],
    ["cod", ["image/cis-cod", "application/vnd.rim.cod"]],
    ["com", ["application/octet-stream", "text/plain"]],
    ["conf", "text/plain"],
    ["cpio", "application/x-cpio"],
    ["cpp", "text/x-c"],
    ["cpt", ["application/mac-compactpro", "application/x-compactpro", "application/x-cpt"]],
    ["crd", "application/x-mscardfile"],
    ["crl", ["application/pkix-crl", "application/pkcs-crl"]],
    ["crt", ["application/pkix-cert", "application/x-x509-user-cert", "application/x-x509-ca-cert"]],
    ["cryptonote", "application/vnd.rig.cryptonote"],
    ["csh", ["text/x-script.csh", "application/x-csh"]],
    ["csml", "chemical/x-csml"],
    ["csp", "application/vnd.commonspace"],
    ["css", ["text/css", "application/x-pointplus"]],
    ["csv", "text/csv"],
    ["cu", "application/cu-seeme"],
    ["curl", "text/vnd.curl"],
    ["cww", "application/prs.cww"],
    ["cxx", "text/plain"],
    ["dae", "model/vnd.collada+xml"],
    ["daf", "application/vnd.mobius.daf"],
    ["davmount", "application/davmount+xml"],
    ["dcr", "application/x-director"],
    ["dcurl", "text/vnd.curl.dcurl"],
    ["dd2", "application/vnd.oma.dd2+xml"],
    ["ddd", "application/vnd.fujixerox.ddd"],
    ["deb", "application/x-debian-package"],
    ["deepv", "application/x-deepv"],
    ["def", "text/plain"],
    ["der", "application/x-x509-ca-cert"],
    ["dfac", "application/vnd.dreamfactory"],
    ["dif", "video/x-dv"],
    ["dir", "application/x-director"],
    ["dis", "application/vnd.mobius.dis"],
    ["djvu", "image/vnd.djvu"],
    ["dl", ["video/dl", "video/x-dl"]],
    ["dll", "application/x-msdownload"],
    ["dms", "application/octet-stream"],
    ["dna", "application/vnd.dna"],
    ["doc", "application/msword"],
    ["docm", "application/vnd.ms-word.document.macroenabled.12"],
    ["docx", "application/vnd.openxmlformats-officedocument.wordprocessingml.document"],
    ["dot", "application/msword"],
    ["dotm", "application/vnd.ms-word.template.macroenabled.12"],
    ["dotx", "application/vnd.openxmlformats-officedocument.wordprocessingml.template"],
    ["dp", ["application/commonground", "application/vnd.osgi.dp"]],
    ["dpg", "application/vnd.dpgraph"],
    ["dra", "audio/vnd.dra"],
    ["drw", "application/drafting"],
    ["dsc", "text/prs.lines.tag"],
    ["dssc", "application/dssc+der"],
    ["dtb", "application/x-dtbook+xml"],
    ["dtd", "application/xml-dtd"],
    ["dts", "audio/vnd.dts"],
    ["dtshd", "audio/vnd.dts.hd"],
    ["dump", "application/octet-stream"],
    ["dv", "video/x-dv"],
    ["dvi", "application/x-dvi"],
    ["dwf", ["model/vnd.dwf", "drawing/x-dwf"]],
    ["dwg", ["application/acad", "image/vnd.dwg", "image/x-dwg"]],
    ["dxf", ["application/dxf", "image/vnd.dwg", "image/vnd.dxf", "image/x-dwg"]],
    ["dxp", "application/vnd.spotfire.dxp"],
    ["dxr", "application/x-director"],
    ["ecelp4800", "audio/vnd.nuera.ecelp4800"],
    ["ecelp7470", "audio/vnd.nuera.ecelp7470"],
    ["ecelp9600", "audio/vnd.nuera.ecelp9600"],
    ["edm", "application/vnd.novadigm.edm"],
    ["edx", "application/vnd.novadigm.edx"],
    ["efif", "application/vnd.picsel"],
    ["ei6", "application/vnd.pg.osasli"],
    ["el", "text/x-script.elisp"],
    ["elc", ["application/x-elc", "application/x-bytecode.elisp"]],
    ["eml", "message/rfc822"],
    ["emma", "application/emma+xml"],
    ["env", "application/x-envoy"],
    ["eol", "audio/vnd.digital-winds"],
    ["eot", "application/vnd.ms-fontobject"],
    ["eps", "application/postscript"],
    ["epub", "application/epub+zip"],
    ["es", ["application/ecmascript", "application/x-esrehber"]],
    ["es3", "application/vnd.eszigno3+xml"],
    ["esf", "application/vnd.epson.esf"],
    ["etx", "text/x-setext"],
    ["evy", ["application/envoy", "application/x-envoy"]],
    ["exe", ["application/octet-stream", "application/x-msdownload"]],
    ["exi", "application/exi"],
    ["ext", "application/vnd.novadigm.ext"],
    ["ez2", "application/vnd.ezpix-album"],
    ["ez3", "application/vnd.ezpix-package"],
    ["f", ["text/plain", "text/x-fortran"]],
    ["f4v", "video/x-f4v"],
    ["f77", "text/x-fortran"],
    ["f90", ["text/plain", "text/x-fortran"]],
    ["fbs", "image/vnd.fastbidsheet"],
    ["fcs", "application/vnd.isac.fcs"],
    ["fdf", "application/vnd.fdf"],
    ["fe_launch", "application/vnd.denovo.fcselayout-link"],
    ["fg5", "application/vnd.fujitsu.oasysgp"],
    ["fh", "image/x-freehand"],
    ["fif", ["application/fractals", "image/fif"]],
    ["fig", "application/x-xfig"],
    ["fli", ["video/fli", "video/x-fli"]],
    ["flo", ["image/florian", "application/vnd.micrografx.flo"]],
    ["flr", "x-world/x-vrml"],
    ["flv", "video/x-flv"],
    ["flw", "application/vnd.kde.kivio"],
    ["flx", "text/vnd.fmi.flexstor"],
    ["fly", "text/vnd.fly"],
    ["fm", "application/vnd.framemaker"],
    ["fmf", "video/x-atomic3d-feature"],
    ["fnc", "application/vnd.frogans.fnc"],
    ["for", ["text/plain", "text/x-fortran"]],
    ["fpx", ["image/vnd.fpx", "image/vnd.net-fpx"]],
    ["frl", "application/freeloader"],
    ["fsc", "application/vnd.fsc.weblaunch"],
    ["fst", "image/vnd.fst"],
    ["ftc", "application/vnd.fluxtime.clip"],
    ["fti", "application/vnd.anser-web-funds-transfer-initiation"],
    ["funk", "audio/make"],
    ["fvt", "video/vnd.fvt"],
    ["fxp", "application/vnd.adobe.fxp"],
    ["fzs", "application/vnd.fuzzysheet"],
    ["g", "text/plain"],
    ["g2w", "application/vnd.geoplan"],
    ["g3", "image/g3fax"],
    ["g3w", "application/vnd.geospace"],
    ["gac", "application/vnd.groove-account"],
    ["gdl", "model/vnd.gdl"],
    ["geo", "application/vnd.dynageo"],
    ["geojson", "application/geo+json"],
    ["gex", "application/vnd.geometry-explorer"],
    ["ggb", "application/vnd.geogebra.file"],
    ["ggt", "application/vnd.geogebra.tool"],
    ["ghf", "application/vnd.groove-help"],
    ["gif", "image/gif"],
    ["gim", "application/vnd.groove-identity-message"],
    ["gl", ["video/gl", "video/x-gl"]],
    ["gmx", "application/vnd.gmx"],
    ["gnumeric", "application/x-gnumeric"],
    ["gph", "application/vnd.flographit"],
    ["gqf", "application/vnd.grafeq"],
    ["gram", "application/srgs"],
    ["grv", "application/vnd.groove-injector"],
    ["grxml", "application/srgs+xml"],
    ["gsd", "audio/x-gsm"],
    ["gsf", "application/x-font-ghostscript"],
    ["gsm", "audio/x-gsm"],
    ["gsp", "application/x-gsp"],
    ["gss", "application/x-gss"],
    ["gtar", "application/x-gtar"],
    ["gtm", "application/vnd.groove-tool-message"],
    ["gtw", "model/vnd.gtw"],
    ["gv", "text/vnd.graphviz"],
    ["gxt", "application/vnd.geonext"],
    ["gz", ["application/x-gzip", "application/x-compressed"]],
    ["gzip", ["multipart/x-gzip", "application/x-gzip"]],
    ["h", ["text/plain", "text/x-h"]],
    ["h261", "video/h261"],
    ["h263", "video/h263"],
    ["h264", "video/h264"],
    ["hal", "application/vnd.hal+xml"],
    ["hbci", "application/vnd.hbci"],
    ["hdf", "application/x-hdf"],
    ["help", "application/x-helpfile"],
    ["hgl", "application/vnd.hp-hpgl"],
    ["hh", ["text/plain", "text/x-h"]],
    ["hlb", "text/x-script"],
    ["hlp", ["application/winhlp", "application/hlp", "application/x-helpfile", "application/x-winhelp"]],
    ["hpg", "application/vnd.hp-hpgl"],
    ["hpgl", "application/vnd.hp-hpgl"],
    ["hpid", "application/vnd.hp-hpid"],
    ["hps", "application/vnd.hp-hps"],
    [
      "hqx",
      [
        "application/mac-binhex40",
        "application/binhex",
        "application/binhex4",
        "application/mac-binhex",
        "application/x-binhex40",
        "application/x-mac-binhex40"
      ]
    ],
    ["hta", "application/hta"],
    ["htc", "text/x-component"],
    ["htke", "application/vnd.kenameaapp"],
    ["htm", "text/html"],
    ["html", "text/html"],
    ["htmls", "text/html"],
    ["htt", "text/webviewhtml"],
    ["htx", "text/html"],
    ["hvd", "application/vnd.yamaha.hv-dic"],
    ["hvp", "application/vnd.yamaha.hv-voice"],
    ["hvs", "application/vnd.yamaha.hv-script"],
    ["i2g", "application/vnd.intergeo"],
    ["icc", "application/vnd.iccprofile"],
    ["ice", "x-conference/x-cooltalk"],
    ["ico", "image/x-icon"],
    ["ics", "text/calendar"],
    ["idc", "text/plain"],
    ["ief", "image/ief"],
    ["iefs", "image/ief"],
    ["ifm", "application/vnd.shana.informed.formdata"],
    ["iges", ["application/iges", "model/iges"]],
    ["igl", "application/vnd.igloader"],
    ["igm", "application/vnd.insors.igm"],
    ["igs", ["application/iges", "model/iges"]],
    ["igx", "application/vnd.micrografx.igx"],
    ["iif", "application/vnd.shana.informed.interchange"],
    ["iii", "application/x-iphone"],
    ["ima", "application/x-ima"],
    ["imap", "application/x-httpd-imap"],
    ["imp", "application/vnd.accpac.simply.imp"],
    ["ims", "application/vnd.ms-ims"],
    ["inf", "application/inf"],
    ["ins", ["application/x-internet-signup", "application/x-internett-signup"]],
    ["ip", "application/x-ip2"],
    ["ipfix", "application/ipfix"],
    ["ipk", "application/vnd.shana.informed.package"],
    ["irm", "application/vnd.ibm.rights-management"],
    ["irp", "application/vnd.irepository.package+xml"],
    ["isp", "application/x-internet-signup"],
    ["isu", "video/x-isvideo"],
    ["it", "audio/it"],
    ["itp", "application/vnd.shana.informed.formtemplate"],
    ["iv", "application/x-inventor"],
    ["ivp", "application/vnd.immervision-ivp"],
    ["ivr", "i-world/i-vrml"],
    ["ivu", "application/vnd.immervision-ivu"],
    ["ivy", "application/x-livescreen"],
    ["jad", "text/vnd.sun.j2me.app-descriptor"],
    ["jam", ["application/vnd.jam", "audio/x-jam"]],
    ["jar", "application/java-archive"],
    ["jav", ["text/plain", "text/x-java-source"]],
    ["java", ["text/plain", "text/x-java-source,java", "text/x-java-source"]],
    ["jcm", "application/x-java-commerce"],
    ["jfif", ["image/pipeg", "image/jpeg", "image/pjpeg"]],
    ["jfif-tbnl", "image/jpeg"],
    ["jisp", "application/vnd.jisp"],
    ["jlt", "application/vnd.hp-jlyt"],
    ["jnlp", "application/x-java-jnlp-file"],
    ["joda", "application/vnd.joost.joda-archive"],
    ["jpe", ["image/jpeg", "image/pjpeg"]],
    ["jpeg", ["image/jpeg", "image/pjpeg"]],
    ["jpg", ["image/jpeg", "image/pjpeg"]],
    ["jpgv", "video/jpeg"],
    ["jpm", "video/jpm"],
    ["jps", "image/x-jps"],
    ["js", ["application/javascript", "application/ecmascript", "text/javascript", "text/ecmascript", "application/x-javascript"]],
    ["json", "application/json"],
    ["jut", "image/jutvision"],
    ["kar", ["audio/midi", "music/x-karaoke"]],
    ["karbon", "application/vnd.kde.karbon"],
    ["kfo", "application/vnd.kde.kformula"],
    ["kia", "application/vnd.kidspiration"],
    ["kml", "application/vnd.google-earth.kml+xml"],
    ["kmz", "application/vnd.google-earth.kmz"],
    ["kne", "application/vnd.kinar"],
    ["kon", "application/vnd.kde.kontour"],
    ["kpr", "application/vnd.kde.kpresenter"],
    ["ksh", ["application/x-ksh", "text/x-script.ksh"]],
    ["ksp", "application/vnd.kde.kspread"],
    ["ktx", "image/ktx"],
    ["ktz", "application/vnd.kahootz"],
    ["kwd", "application/vnd.kde.kword"],
    ["la", ["audio/nspaudio", "audio/x-nspaudio"]],
    ["lam", "audio/x-liveaudio"],
    ["lasxml", "application/vnd.las.las+xml"],
    ["latex", "application/x-latex"],
    ["lbd", "application/vnd.llamagraphics.life-balance.desktop"],
    ["lbe", "application/vnd.llamagraphics.life-balance.exchange+xml"],
    ["les", "application/vnd.hhe.lesson-player"],
    ["lha", ["application/octet-stream", "application/lha", "application/x-lha"]],
    ["lhx", "application/octet-stream"],
    ["link66", "application/vnd.route66.link66+xml"],
    ["list", "text/plain"],
    ["lma", ["audio/nspaudio", "audio/x-nspaudio"]],
    ["log", "text/plain"],
    ["lrm", "application/vnd.ms-lrm"],
    ["lsf", "video/x-la-asf"],
    ["lsp", ["application/x-lisp", "text/x-script.lisp"]],
    ["lst", "text/plain"],
    ["lsx", ["video/x-la-asf", "text/x-la-asf"]],
    ["ltf", "application/vnd.frogans.ltf"],
    ["ltx", "application/x-latex"],
    ["lvp", "audio/vnd.lucent.voice"],
    ["lwp", "application/vnd.lotus-wordpro"],
    ["lzh", ["application/octet-stream", "application/x-lzh"]],
    ["lzx", ["application/lzx", "application/octet-stream", "application/x-lzx"]],
    ["m", ["text/plain", "text/x-m"]],
    ["m13", "application/x-msmediaview"],
    ["m14", "application/x-msmediaview"],
    ["m1v", "video/mpeg"],
    ["m21", "application/mp21"],
    ["m2a", "audio/mpeg"],
    ["m2v", "video/mpeg"],
    ["m3u", ["audio/x-mpegurl", "audio/x-mpequrl"]],
    ["m3u8", "application/vnd.apple.mpegurl"],
    ["m4v", "video/x-m4v"],
    ["ma", "application/mathematica"],
    ["mads", "application/mads+xml"],
    ["mag", "application/vnd.ecowin.chart"],
    ["man", "application/x-troff-man"],
    ["map", "application/x-navimap"],
    ["mar", "text/plain"],
    ["mathml", "application/mathml+xml"],
    ["mbd", "application/mbedlet"],
    ["mbk", "application/vnd.mobius.mbk"],
    ["mbox", "application/mbox"],
    ["mc$", "application/x-magic-cap-package-1.0"],
    ["mc1", "application/vnd.medcalcdata"],
    ["mcd", ["application/mcad", "application/vnd.mcd", "application/x-mathcad"]],
    ["mcf", ["image/vasa", "text/mcf"]],
    ["mcp", "application/netmc"],
    ["mcurl", "text/vnd.curl.mcurl"],
    ["mdb", "application/x-msaccess"],
    ["mdi", "image/vnd.ms-modi"],
    ["me", "application/x-troff-me"],
    ["meta4", "application/metalink4+xml"],
    ["mets", "application/mets+xml"],
    ["mfm", "application/vnd.mfmp"],
    ["mgp", "application/vnd.osgeo.mapguide.package"],
    ["mgz", "application/vnd.proteus.magazine"],
    ["mht", "message/rfc822"],
    ["mhtml", "message/rfc822"],
    ["mid", ["audio/mid", "audio/midi", "music/crescendo", "x-music/x-midi", "audio/x-midi", "application/x-midi", "audio/x-mid"]],
    ["midi", ["audio/midi", "music/crescendo", "x-music/x-midi", "audio/x-midi", "application/x-midi", "audio/x-mid"]],
    ["mif", ["application/vnd.mif", "application/x-mif", "application/x-frame"]],
    ["mime", ["message/rfc822", "www/mime"]],
    ["mj2", "video/mj2"],
    ["mjf", "audio/x-vnd.audioexplosion.mjuicemediafile"],
    ["mjpg", "video/x-motion-jpeg"],
    ["mlp", "application/vnd.dolby.mlp"],
    ["mm", ["application/base64", "application/x-meme"]],
    ["mmd", "application/vnd.chipnuts.karaoke-mmd"],
    ["mme", "application/base64"],
    ["mmf", "application/vnd.smaf"],
    ["mmr", "image/vnd.fujixerox.edmics-mmr"],
    ["mny", "application/x-msmoney"],
    ["mod", ["audio/mod", "audio/x-mod"]],
    ["mods", "application/mods+xml"],
    ["moov", "video/quicktime"],
    ["mov", "video/quicktime"],
    ["movie", "video/x-sgi-movie"],
    ["mp2", ["video/mpeg", "audio/mpeg", "video/x-mpeg", "audio/x-mpeg", "video/x-mpeq2a"]],
    ["mp3", ["audio/mpeg", "audio/mpeg3", "video/mpeg", "audio/x-mpeg-3", "video/x-mpeg"]],
    ["mp4", ["video/mp4", "application/mp4"]],
    ["mp4a", "audio/mp4"],
    ["mpa", ["video/mpeg", "audio/mpeg"]],
    ["mpc", ["application/vnd.mophun.certificate", "application/x-project"]],
    ["mpe", "video/mpeg"],
    ["mpeg", "video/mpeg"],
    ["mpg", ["video/mpeg", "audio/mpeg"]],
    ["mpga", "audio/mpeg"],
    ["mpkg", "application/vnd.apple.installer+xml"],
    ["mpm", "application/vnd.blueice.multipass"],
    ["mpn", "application/vnd.mophun.application"],
    ["mpp", "application/vnd.ms-project"],
    ["mpt", "application/x-project"],
    ["mpv", "application/x-project"],
    ["mpv2", "video/mpeg"],
    ["mpx", "application/x-project"],
    ["mpy", "application/vnd.ibm.minipay"],
    ["mqy", "application/vnd.mobius.mqy"],
    ["mrc", "application/marc"],
    ["mrcx", "application/marcxml+xml"],
    ["ms", "application/x-troff-ms"],
    ["mscml", "application/mediaservercontrol+xml"],
    ["mseq", "application/vnd.mseq"],
    ["msf", "application/vnd.epson.msf"],
    ["msg", "application/vnd.ms-outlook"],
    ["msh", "model/mesh"],
    ["msl", "application/vnd.mobius.msl"],
    ["msty", "application/vnd.muvee.style"],
    ["mts", "model/vnd.mts"],
    ["mus", "application/vnd.musician"],
    ["musicxml", "application/vnd.recordare.musicxml+xml"],
    ["mv", "video/x-sgi-movie"],
    ["mvb", "application/x-msmediaview"],
    ["mwf", "application/vnd.mfer"],
    ["mxf", "application/mxf"],
    ["mxl", "application/vnd.recordare.musicxml"],
    ["mxml", "application/xv+xml"],
    ["mxs", "application/vnd.triscape.mxs"],
    ["mxu", "video/vnd.mpegurl"],
    ["my", "audio/make"],
    ["mzz", "application/x-vnd.audioexplosion.mzz"],
    ["n-gage", "application/vnd.nokia.n-gage.symbian.install"],
    ["n3", "text/n3"],
    ["nap", "image/naplps"],
    ["naplps", "image/naplps"],
    ["nbp", "application/vnd.wolfram.player"],
    ["nc", "application/x-netcdf"],
    ["ncm", "application/vnd.nokia.configuration-message"],
    ["ncx", "application/x-dtbncx+xml"],
    ["ngdat", "application/vnd.nokia.n-gage.data"],
    ["nif", "image/x-niff"],
    ["niff", "image/x-niff"],
    ["nix", "application/x-mix-transfer"],
    ["nlu", "application/vnd.neurolanguage.nlu"],
    ["nml", "application/vnd.enliven"],
    ["nnd", "application/vnd.noblenet-directory"],
    ["nns", "application/vnd.noblenet-sealer"],
    ["nnw", "application/vnd.noblenet-web"],
    ["npx", "image/vnd.net-fpx"],
    ["nsc", "application/x-conference"],
    ["nsf", "application/vnd.lotus-notes"],
    ["nvd", "application/x-navidoc"],
    ["nws", "message/rfc822"],
    ["o", "application/octet-stream"],
    ["oa2", "application/vnd.fujitsu.oasys2"],
    ["oa3", "application/vnd.fujitsu.oasys3"],
    ["oas", "application/vnd.fujitsu.oasys"],
    ["obd", "application/x-msbinder"],
    ["oda", "application/oda"],
    ["odb", "application/vnd.oasis.opendocument.database"],
    ["odc", "application/vnd.oasis.opendocument.chart"],
    ["odf", "application/vnd.oasis.opendocument.formula"],
    ["odft", "application/vnd.oasis.opendocument.formula-template"],
    ["odg", "application/vnd.oasis.opendocument.graphics"],
    ["odi", "application/vnd.oasis.opendocument.image"],
    ["odm", "application/vnd.oasis.opendocument.text-master"],
    ["odp", "application/vnd.oasis.opendocument.presentation"],
    ["ods", "application/vnd.oasis.opendocument.spreadsheet"],
    ["odt", "application/vnd.oasis.opendocument.text"],
    ["oga", "audio/ogg"],
    ["ogv", "video/ogg"],
    ["ogx", "application/ogg"],
    ["omc", "application/x-omc"],
    ["omcd", "application/x-omcdatamaker"],
    ["omcr", "application/x-omcregerator"],
    ["onetoc", "application/onenote"],
    ["opf", "application/oebps-package+xml"],
    ["org", "application/vnd.lotus-organizer"],
    ["osf", "application/vnd.yamaha.openscoreformat"],
    ["osfpvg", "application/vnd.yamaha.openscoreformat.osfpvg+xml"],
    ["otc", "application/vnd.oasis.opendocument.chart-template"],
    ["otf", "application/x-font-otf"],
    ["otg", "application/vnd.oasis.opendocument.graphics-template"],
    ["oth", "application/vnd.oasis.opendocument.text-web"],
    ["oti", "application/vnd.oasis.opendocument.image-template"],
    ["otp", "application/vnd.oasis.opendocument.presentation-template"],
    ["ots", "application/vnd.oasis.opendocument.spreadsheet-template"],
    ["ott", "application/vnd.oasis.opendocument.text-template"],
    ["oxt", "application/vnd.openofficeorg.extension"],
    ["p", "text/x-pascal"],
    ["p10", ["application/pkcs10", "application/x-pkcs10"]],
    ["p12", ["application/pkcs-12", "application/x-pkcs12"]],
    ["p7a", "application/x-pkcs7-signature"],
    ["p7b", "application/x-pkcs7-certificates"],
    ["p7c", ["application/pkcs7-mime", "application/x-pkcs7-mime"]],
    ["p7m", ["application/pkcs7-mime", "application/x-pkcs7-mime"]],
    ["p7r", "application/x-pkcs7-certreqresp"],
    ["p7s", ["application/pkcs7-signature", "application/x-pkcs7-signature"]],
    ["p8", "application/pkcs8"],
    ["par", "text/plain-bas"],
    ["part", "application/pro_eng"],
    ["pas", "text/pascal"],
    ["paw", "application/vnd.pawaafile"],
    ["pbd", "application/vnd.powerbuilder6"],
    ["pbm", "image/x-portable-bitmap"],
    ["pcf", "application/x-font-pcf"],
    ["pcl", ["application/vnd.hp-pcl", "application/x-pcl"]],
    ["pclxl", "application/vnd.hp-pclxl"],
    ["pct", "image/x-pict"],
    ["pcurl", "application/vnd.curl.pcurl"],
    ["pcx", "image/x-pcx"],
    ["pdb", ["application/vnd.palm", "chemical/x-pdb"]],
    ["pdf", "application/pdf"],
    ["pfa", "application/x-font-type1"],
    ["pfr", "application/font-tdpfr"],
    ["pfunk", ["audio/make", "audio/make.my.funk"]],
    ["pfx", "application/x-pkcs12"],
    ["pgm", ["image/x-portable-graymap", "image/x-portable-greymap"]],
    ["pgn", "application/x-chess-pgn"],
    ["pgp", "application/pgp-signature"],
    ["pic", ["image/pict", "image/x-pict"]],
    ["pict", "image/pict"],
    ["pkg", "application/x-newton-compatible-pkg"],
    ["pki", "application/pkixcmp"],
    ["pkipath", "application/pkix-pkipath"],
    ["pko", ["application/ynd.ms-pkipko", "application/vnd.ms-pki.pko"]],
    ["pl", ["text/plain", "text/x-script.perl"]],
    ["plb", "application/vnd.3gpp.pic-bw-large"],
    ["plc", "application/vnd.mobius.plc"],
    ["plf", "application/vnd.pocketlearn"],
    ["pls", "application/pls+xml"],
    ["plx", "application/x-pixclscript"],
    ["pm", ["text/x-script.perl-module", "image/x-xpixmap"]],
    ["pm4", "application/x-pagemaker"],
    ["pm5", "application/x-pagemaker"],
    ["pma", "application/x-perfmon"],
    ["pmc", "application/x-perfmon"],
    ["pml", ["application/vnd.ctc-posml", "application/x-perfmon"]],
    ["pmr", "application/x-perfmon"],
    ["pmw", "application/x-perfmon"],
    ["png", "image/png"],
    ["pnm", ["application/x-portable-anymap", "image/x-portable-anymap"]],
    ["portpkg", "application/vnd.macports.portpkg"],
    ["pot", ["application/vnd.ms-powerpoint", "application/mspowerpoint"]],
    ["potm", "application/vnd.ms-powerpoint.template.macroenabled.12"],
    ["potx", "application/vnd.openxmlformats-officedocument.presentationml.template"],
    ["pov", "model/x-pov"],
    ["ppa", "application/vnd.ms-powerpoint"],
    ["ppam", "application/vnd.ms-powerpoint.addin.macroenabled.12"],
    ["ppd", "application/vnd.cups-ppd"],
    ["ppm", "image/x-portable-pixmap"],
    ["pps", ["application/vnd.ms-powerpoint", "application/mspowerpoint"]],
    ["ppsm", "application/vnd.ms-powerpoint.slideshow.macroenabled.12"],
    ["ppsx", "application/vnd.openxmlformats-officedocument.presentationml.slideshow"],
    ["ppt", ["application/vnd.ms-powerpoint", "application/mspowerpoint", "application/powerpoint", "application/x-mspowerpoint"]],
    ["pptm", "application/vnd.ms-powerpoint.presentation.macroenabled.12"],
    ["pptx", "application/vnd.openxmlformats-officedocument.presentationml.presentation"],
    ["ppz", "application/mspowerpoint"],
    ["prc", "application/x-mobipocket-ebook"],
    ["pre", ["application/vnd.lotus-freelance", "application/x-freelance"]],
    ["prf", "application/pics-rules"],
    ["prt", "application/pro_eng"],
    ["ps", "application/postscript"],
    ["psb", "application/vnd.3gpp.pic-bw-small"],
    ["psd", ["application/octet-stream", "image/vnd.adobe.photoshop"]],
    ["psf", "application/x-font-linux-psf"],
    ["pskcxml", "application/pskc+xml"],
    ["ptid", "application/vnd.pvi.ptid1"],
    ["pub", "application/x-mspublisher"],
    ["pvb", "application/vnd.3gpp.pic-bw-var"],
    ["pvu", "paleovu/x-pv"],
    ["pwn", "application/vnd.3m.post-it-notes"],
    ["pwz", "application/vnd.ms-powerpoint"],
    ["py", "text/x-script.phyton"],
    ["pya", "audio/vnd.ms-playready.media.pya"],
    ["pyc", "application/x-bytecode.python"],
    ["pyv", "video/vnd.ms-playready.media.pyv"],
    ["qam", "application/vnd.epson.quickanime"],
    ["qbo", "application/vnd.intu.qbo"],
    ["qcp", "audio/vnd.qcelp"],
    ["qd3", "x-world/x-3dmf"],
    ["qd3d", "x-world/x-3dmf"],
    ["qfx", "application/vnd.intu.qfx"],
    ["qif", "image/x-quicktime"],
    ["qps", "application/vnd.publishare-delta-tree"],
    ["qt", "video/quicktime"],
    ["qtc", "video/x-qtc"],
    ["qti", "image/x-quicktime"],
    ["qtif", "image/x-quicktime"],
    ["qxd", "application/vnd.quark.quarkxpress"],
    ["ra", ["audio/x-realaudio", "audio/x-pn-realaudio", "audio/x-pn-realaudio-plugin"]],
    ["ram", "audio/x-pn-realaudio"],
    ["rar", "application/x-rar-compressed"],
    ["ras", ["image/cmu-raster", "application/x-cmu-raster", "image/x-cmu-raster"]],
    ["rast", "image/cmu-raster"],
    ["rcprofile", "application/vnd.ipunplugged.rcprofile"],
    ["rdf", "application/rdf+xml"],
    ["rdz", "application/vnd.data-vision.rdz"],
    ["rep", "application/vnd.businessobjects"],
    ["res", "application/x-dtbresource+xml"],
    ["rexx", "text/x-script.rexx"],
    ["rf", "image/vnd.rn-realflash"],
    ["rgb", "image/x-rgb"],
    ["rif", "application/reginfo+xml"],
    ["rip", "audio/vnd.rip"],
    ["rl", "application/resource-lists+xml"],
    ["rlc", "image/vnd.fujixerox.edmics-rlc"],
    ["rld", "application/resource-lists-diff+xml"],
    ["rm", ["application/vnd.rn-realmedia", "audio/x-pn-realaudio"]],
    ["rmi", "audio/mid"],
    ["rmm", "audio/x-pn-realaudio"],
    ["rmp", ["audio/x-pn-realaudio-plugin", "audio/x-pn-realaudio"]],
    ["rms", "application/vnd.jcp.javame.midlet-rms"],
    ["rnc", "application/relax-ng-compact-syntax"],
    ["rng", ["application/ringing-tones", "application/vnd.nokia.ringing-tone"]],
    ["rnx", "application/vnd.rn-realplayer"],
    ["roff", "application/x-troff"],
    ["rp", "image/vnd.rn-realpix"],
    ["rp9", "application/vnd.cloanto.rp9"],
    ["rpm", "audio/x-pn-realaudio-plugin"],
    ["rpss", "application/vnd.nokia.radio-presets"],
    ["rpst", "application/vnd.nokia.radio-preset"],
    ["rq", "application/sparql-query"],
    ["rs", "application/rls-services+xml"],
    ["rsd", "application/rsd+xml"],
    ["rt", ["text/richtext", "text/vnd.rn-realtext"]],
    ["rtf", ["application/rtf", "text/richtext", "application/x-rtf"]],
    ["rtx", ["text/richtext", "application/rtf"]],
    ["rv", "video/vnd.rn-realvideo"],
    ["s", "text/x-asm"],
    ["s3m", "audio/s3m"],
    ["saf", "application/vnd.yamaha.smaf-audio"],
    ["saveme", "application/octet-stream"],
    ["sbk", "application/x-tbook"],
    ["sbml", "application/sbml+xml"],
    ["sc", "application/vnd.ibm.secure-container"],
    ["scd", "application/x-msschedule"],
    [
      "scm",
      ["application/vnd.lotus-screencam", "video/x-scm", "text/x-script.guile", "application/x-lotusscreencam", "text/x-script.scheme"]
    ],
    ["scq", "application/scvp-cv-request"],
    ["scs", "application/scvp-cv-response"],
    ["sct", "text/scriptlet"],
    ["scurl", "text/vnd.curl.scurl"],
    ["sda", "application/vnd.stardivision.draw"],
    ["sdc", "application/vnd.stardivision.calc"],
    ["sdd", "application/vnd.stardivision.impress"],
    ["sdkm", "application/vnd.solent.sdkm+xml"],
    ["sdml", "text/plain"],
    ["sdp", ["application/sdp", "application/x-sdp"]],
    ["sdr", "application/sounder"],
    ["sdw", "application/vnd.stardivision.writer"],
    ["sea", ["application/sea", "application/x-sea"]],
    ["see", "application/vnd.seemail"],
    ["seed", "application/vnd.fdsn.seed"],
    ["sema", "application/vnd.sema"],
    ["semd", "application/vnd.semd"],
    ["semf", "application/vnd.semf"],
    ["ser", "application/java-serialized-object"],
    ["set", "application/set"],
    ["setpay", "application/set-payment-initiation"],
    ["setreg", "application/set-registration-initiation"],
    ["sfd-hdstx", "application/vnd.hydrostatix.sof-data"],
    ["sfs", "application/vnd.spotfire.sfs"],
    ["sgl", "application/vnd.stardivision.writer-global"],
    ["sgm", ["text/sgml", "text/x-sgml"]],
    ["sgml", ["text/sgml", "text/x-sgml"]],
    ["sh", ["application/x-shar", "application/x-bsh", "application/x-sh", "text/x-script.sh"]],
    ["shar", ["application/x-bsh", "application/x-shar"]],
    ["shf", "application/shf+xml"],
    ["shtml", ["text/html", "text/x-server-parsed-html"]],
    ["sid", "audio/x-psid"],
    ["sis", "application/vnd.symbian.install"],
    ["sit", ["application/x-stuffit", "application/x-sit"]],
    ["sitx", "application/x-stuffitx"],
    ["skd", "application/x-koan"],
    ["skm", "application/x-koan"],
    ["skp", ["application/vnd.koan", "application/x-koan"]],
    ["skt", "application/x-koan"],
    ["sl", "application/x-seelogo"],
    ["sldm", "application/vnd.ms-powerpoint.slide.macroenabled.12"],
    ["sldx", "application/vnd.openxmlformats-officedocument.presentationml.slide"],
    ["slt", "application/vnd.epson.salt"],
    ["sm", "application/vnd.stepmania.stepchart"],
    ["smf", "application/vnd.stardivision.math"],
    ["smi", ["application/smil", "application/smil+xml"]],
    ["smil", "application/smil"],
    ["snd", ["audio/basic", "audio/x-adpcm"]],
    ["snf", "application/x-font-snf"],
    ["sol", "application/solids"],
    ["spc", ["text/x-speech", "application/x-pkcs7-certificates"]],
    ["spf", "application/vnd.yamaha.smaf-phrase"],
    ["spl", ["application/futuresplash", "application/x-futuresplash"]],
    ["spot", "text/vnd.in3d.spot"],
    ["spp", "application/scvp-vp-response"],
    ["spq", "application/scvp-vp-request"],
    ["spr", "application/x-sprite"],
    ["sprite", "application/x-sprite"],
    ["src", "application/x-wais-source"],
    ["sru", "application/sru+xml"],
    ["srx", "application/sparql-results+xml"],
    ["sse", "application/vnd.kodak-descriptor"],
    ["ssf", "application/vnd.epson.ssf"],
    ["ssi", "text/x-server-parsed-html"],
    ["ssm", "application/streamingmedia"],
    ["ssml", "application/ssml+xml"],
    ["sst", ["application/vnd.ms-pkicertstore", "application/vnd.ms-pki.certstore"]],
    ["st", "application/vnd.sailingtracker.track"],
    ["stc", "application/vnd.sun.xml.calc.template"],
    ["std", "application/vnd.sun.xml.draw.template"],
    ["step", "application/step"],
    ["stf", "application/vnd.wt.stf"],
    ["sti", "application/vnd.sun.xml.impress.template"],
    ["stk", "application/hyperstudio"],
    ["stl", ["application/vnd.ms-pkistl", "application/sla", "application/vnd.ms-pki.stl", "application/x-navistyle"]],
    ["stm", "text/html"],
    ["stp", "application/step"],
    ["str", "application/vnd.pg.format"],
    ["stw", "application/vnd.sun.xml.writer.template"],
    ["sub", "image/vnd.dvb.subtitle"],
    ["sus", "application/vnd.sus-calendar"],
    ["sv4cpio", "application/x-sv4cpio"],
    ["sv4crc", "application/x-sv4crc"],
    ["svc", "application/vnd.dvb.service"],
    ["svd", "application/vnd.svd"],
    ["svf", ["image/vnd.dwg", "image/x-dwg"]],
    ["svg", "image/svg+xml"],
    ["svr", ["x-world/x-svr", "application/x-world"]],
    ["swf", "application/x-shockwave-flash"],
    ["swi", "application/vnd.aristanetworks.swi"],
    ["sxc", "application/vnd.sun.xml.calc"],
    ["sxd", "application/vnd.sun.xml.draw"],
    ["sxg", "application/vnd.sun.xml.writer.global"],
    ["sxi", "application/vnd.sun.xml.impress"],
    ["sxm", "application/vnd.sun.xml.math"],
    ["sxw", "application/vnd.sun.xml.writer"],
    ["t", ["text/troff", "application/x-troff"]],
    ["talk", "text/x-speech"],
    ["tao", "application/vnd.tao.intent-module-archive"],
    ["tar", "application/x-tar"],
    ["tbk", ["application/toolbook", "application/x-tbook"]],
    ["tcap", "application/vnd.3gpp2.tcap"],
    ["tcl", ["text/x-script.tcl", "application/x-tcl"]],
    ["tcsh", "text/x-script.tcsh"],
    ["teacher", "application/vnd.smart.teacher"],
    ["tei", "application/tei+xml"],
    ["tex", "application/x-tex"],
    ["texi", "application/x-texinfo"],
    ["texinfo", "application/x-texinfo"],
    ["text", ["application/plain", "text/plain"]],
    ["tfi", "application/thraud+xml"],
    ["tfm", "application/x-tex-tfm"],
    ["tgz", ["application/gnutar", "application/x-compressed"]],
    ["thmx", "application/vnd.ms-officetheme"],
    ["tif", ["image/tiff", "image/x-tiff"]],
    ["tiff", ["image/tiff", "image/x-tiff"]],
    ["tmo", "application/vnd.tmobile-livetv"],
    ["torrent", "application/x-bittorrent"],
    ["tpl", "application/vnd.groove-tool-template"],
    ["tpt", "application/vnd.trid.tpt"],
    ["tr", "application/x-troff"],
    ["tra", "application/vnd.trueapp"],
    ["trm", "application/x-msterminal"],
    ["tsd", "application/timestamped-data"],
    ["tsi", "audio/tsp-audio"],
    ["tsp", ["application/dsptype", "audio/tsplayer"]],
    ["tsv", "text/tab-separated-values"],
    ["ttf", "application/x-font-ttf"],
    ["ttl", "text/turtle"],
    ["turbot", "image/florian"],
    ["twd", "application/vnd.simtech-mindmapper"],
    ["txd", "application/vnd.genomatix.tuxedo"],
    ["txf", "application/vnd.mobius.txf"],
    ["txt", "text/plain"],
    ["ufd", "application/vnd.ufdl"],
    ["uil", "text/x-uil"],
    ["uls", "text/iuls"],
    ["umj", "application/vnd.umajin"],
    ["uni", "text/uri-list"],
    ["unis", "text/uri-list"],
    ["unityweb", "application/vnd.unity"],
    ["unv", "application/i-deas"],
    ["uoml", "application/vnd.uoml+xml"],
    ["uri", "text/uri-list"],
    ["uris", "text/uri-list"],
    ["ustar", ["application/x-ustar", "multipart/x-ustar"]],
    ["utz", "application/vnd.uiq.theme"],
    ["uu", ["application/octet-stream", "text/x-uuencode"]],
    ["uue", "text/x-uuencode"],
    ["uva", "audio/vnd.dece.audio"],
    ["uvh", "video/vnd.dece.hd"],
    ["uvi", "image/vnd.dece.graphic"],
    ["uvm", "video/vnd.dece.mobile"],
    ["uvp", "video/vnd.dece.pd"],
    ["uvs", "video/vnd.dece.sd"],
    ["uvu", "video/vnd.uvvu.mp4"],
    ["uvv", "video/vnd.dece.video"],
    ["vcd", "application/x-cdlink"],
    ["vcf", "text/x-vcard"],
    ["vcg", "application/vnd.groove-vcard"],
    ["vcs", "text/x-vcalendar"],
    ["vcx", "application/vnd.vcx"],
    ["vda", "application/vda"],
    ["vdo", "video/vdo"],
    ["vew", "application/groupwise"],
    ["vis", "application/vnd.visionary"],
    ["viv", ["video/vivo", "video/vnd.vivo"]],
    ["vivo", ["video/vivo", "video/vnd.vivo"]],
    ["vmd", "application/vocaltec-media-desc"],
    ["vmf", "application/vocaltec-media-file"],
    ["voc", ["audio/voc", "audio/x-voc"]],
    ["vos", "video/vosaic"],
    ["vox", "audio/voxware"],
    ["vqe", "audio/x-twinvq-plugin"],
    ["vqf", "audio/x-twinvq"],
    ["vql", "audio/x-twinvq-plugin"],
    ["vrml", ["model/vrml", "x-world/x-vrml", "application/x-vrml"]],
    ["vrt", "x-world/x-vrt"],
    ["vsd", ["application/vnd.visio", "application/x-visio"]],
    ["vsf", "application/vnd.vsf"],
    ["vst", "application/x-visio"],
    ["vsw", "application/x-visio"],
    ["vtu", "model/vnd.vtu"],
    ["vxml", "application/voicexml+xml"],
    ["w60", "application/wordperfect6.0"],
    ["w61", "application/wordperfect6.1"],
    ["w6w", "application/msword"],
    ["wad", "application/x-doom"],
    ["wav", ["audio/wav", "audio/x-wav"]],
    ["wax", "audio/x-ms-wax"],
    ["wb1", "application/x-qpro"],
    ["wbmp", "image/vnd.wap.wbmp"],
    ["wbs", "application/vnd.criticaltools.wbs+xml"],
    ["wbxml", "application/vnd.wap.wbxml"],
    ["wcm", "application/vnd.ms-works"],
    ["wdb", "application/vnd.ms-works"],
    ["web", "application/vnd.xara"],
    ["weba", "audio/webm"],
    ["webm", "video/webm"],
    ["webp", "image/webp"],
    ["wg", "application/vnd.pmi.widget"],
    ["wgt", "application/widget"],
    ["wiz", "application/msword"],
    ["wk1", "application/x-123"],
    ["wks", "application/vnd.ms-works"],
    ["wm", "video/x-ms-wm"],
    ["wma", "audio/x-ms-wma"],
    ["wmd", "application/x-ms-wmd"],
    ["wmf", ["windows/metafile", "application/x-msmetafile"]],
    ["wml", "text/vnd.wap.wml"],
    ["wmlc", "application/vnd.wap.wmlc"],
    ["wmls", "text/vnd.wap.wmlscript"],
    ["wmlsc", "application/vnd.wap.wmlscriptc"],
    ["wmv", "video/x-ms-wmv"],
    ["wmx", "video/x-ms-wmx"],
    ["wmz", "application/x-ms-wmz"],
    ["woff", "application/x-font-woff"],
    ["word", "application/msword"],
    ["wp", "application/wordperfect"],
    ["wp5", ["application/wordperfect", "application/wordperfect6.0"]],
    ["wp6", "application/wordperfect"],
    ["wpd", ["application/wordperfect", "application/vnd.wordperfect", "application/x-wpwin"]],
    ["wpl", "application/vnd.ms-wpl"],
    ["wps", "application/vnd.ms-works"],
    ["wq1", "application/x-lotus"],
    ["wqd", "application/vnd.wqd"],
    ["wri", ["application/mswrite", "application/x-wri", "application/x-mswrite"]],
    ["wrl", ["model/vrml", "x-world/x-vrml", "application/x-world"]],
    ["wrz", ["model/vrml", "x-world/x-vrml"]],
    ["wsc", "text/scriplet"],
    ["wsdl", "application/wsdl+xml"],
    ["wspolicy", "application/wspolicy+xml"],
    ["wsrc", "application/x-wais-source"],
    ["wtb", "application/vnd.webturbo"],
    ["wtk", "application/x-wintalk"],
    ["wvx", "video/x-ms-wvx"],
    ["x-png", "image/png"],
    ["x3d", "application/vnd.hzn-3d-crossword"],
    ["xaf", "x-world/x-vrml"],
    ["xap", "application/x-silverlight-app"],
    ["xar", "application/vnd.xara"],
    ["xbap", "application/x-ms-xbap"],
    ["xbd", "application/vnd.fujixerox.docuworks.binder"],
    ["xbm", ["image/xbm", "image/x-xbm", "image/x-xbitmap"]],
    ["xdf", "application/xcap-diff+xml"],
    ["xdm", "application/vnd.syncml.dm+xml"],
    ["xdp", "application/vnd.adobe.xdp+xml"],
    ["xdr", "video/x-amt-demorun"],
    ["xdssc", "application/dssc+xml"],
    ["xdw", "application/vnd.fujixerox.docuworks"],
    ["xenc", "application/xenc+xml"],
    ["xer", "application/patch-ops-error+xml"],
    ["xfdf", "application/vnd.adobe.xfdf"],
    ["xfdl", "application/vnd.xfdl"],
    ["xgz", "xgl/drawing"],
    ["xhtml", "application/xhtml+xml"],
    ["xif", "image/vnd.xiff"],
    ["xl", "application/excel"],
    ["xla", ["application/vnd.ms-excel", "application/excel", "application/x-msexcel", "application/x-excel"]],
    ["xlam", "application/vnd.ms-excel.addin.macroenabled.12"],
    ["xlb", ["application/excel", "application/vnd.ms-excel", "application/x-excel"]],
    ["xlc", ["application/vnd.ms-excel", "application/excel", "application/x-excel"]],
    ["xld", ["application/excel", "application/x-excel"]],
    ["xlk", ["application/excel", "application/x-excel"]],
    ["xll", ["application/excel", "application/vnd.ms-excel", "application/x-excel"]],
    ["xlm", ["application/vnd.ms-excel", "application/excel", "application/x-excel"]],
    ["xls", ["application/vnd.ms-excel", "application/excel", "application/x-msexcel", "application/x-excel"]],
    ["xlsb", "application/vnd.ms-excel.sheet.binary.macroenabled.12"],
    ["xlsm", "application/vnd.ms-excel.sheet.macroenabled.12"],
    ["xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"],
    ["xlt", ["application/vnd.ms-excel", "application/excel", "application/x-excel"]],
    ["xltm", "application/vnd.ms-excel.template.macroenabled.12"],
    ["xltx", "application/vnd.openxmlformats-officedocument.spreadsheetml.template"],
    ["xlv", ["application/excel", "application/x-excel"]],
    ["xlw", ["application/vnd.ms-excel", "application/excel", "application/x-msexcel", "application/x-excel"]],
    ["xm", "audio/xm"],
    ["xml", ["application/xml", "text/xml", "application/atom+xml", "application/rss+xml"]],
    ["xmz", "xgl/movie"],
    ["xo", "application/vnd.olpc-sugar"],
    ["xof", "x-world/x-vrml"],
    ["xop", "application/xop+xml"],
    ["xpi", "application/x-xpinstall"],
    ["xpix", "application/x-vnd.ls-xpix"],
    ["xpm", ["image/xpm", "image/x-xpixmap"]],
    ["xpr", "application/vnd.is-xpr"],
    ["xps", "application/vnd.ms-xpsdocument"],
    ["xpw", "application/vnd.intercon.formnet"],
    ["xslt", "application/xslt+xml"],
    ["xsm", "application/vnd.syncml+xml"],
    ["xspf", "application/xspf+xml"],
    ["xsr", "video/x-amt-showrun"],
    ["xul", "application/vnd.mozilla.xul+xml"],
    ["xwd", ["image/x-xwd", "image/x-xwindowdump"]],
    ["xyz", ["chemical/x-xyz", "chemical/x-pdb"]],
    ["yang", "application/yang"],
    ["yin", "application/yin+xml"],
    ["z", ["application/x-compressed", "application/x-compress"]],
    ["zaz", "application/vnd.zzazz.deck+xml"],
    ["zip", ["application/zip", "multipart/x-zip", "application/x-zip-compressed", "application/x-compressed"]],
    ["zir", "application/vnd.zul"],
    ["zmm", "application/vnd.handheld-entertainment+xml"],
    ["zoo", "application/octet-stream"],
    ["zsh", "text/x-script.zsh"]
  ]);
  mimeTypes_1 = {
    detectMimeType(filename) {
      if (!filename) {
        return defaultMimeType;
      }
      let parsed = path.parse(filename);
      let extension = (parsed.ext.substr(1) || parsed.name || "").split("?").shift().trim().toLowerCase();
      let value = defaultMimeType;
      if (extensions.has(extension)) {
        value = extensions.get(extension);
      }
      if (Array.isArray(value)) {
        return value[0];
      }
      return value;
    },
    detectExtension(mimeType) {
      if (!mimeType) {
        return defaultExtension;
      }
      let parts = (mimeType || "").toLowerCase().trim().split("/");
      let rootType = parts.shift().trim();
      let subType = parts.join("/").trim();
      if (mimeTypes2.has(rootType + "/" + subType)) {
        let value = mimeTypes2.get(rootType + "/" + subType);
        if (Array.isArray(value)) {
          return value[0];
        }
        return value;
      }
      switch (rootType) {
        case "text":
          return "txt";
        default:
          return "bin";
      }
    }
  };
  return mimeTypes_1;
}
var punycode_1;
var hasRequiredPunycode;
function requirePunycode() {
  if (hasRequiredPunycode) return punycode_1;
  hasRequiredPunycode = 1;
  const maxInt = 2147483647;
  const base = 36;
  const tMin = 1;
  const tMax = 26;
  const skew = 38;
  const damp = 700;
  const initialBias = 72;
  const initialN = 128;
  const delimiter = "-";
  const regexPunycode = /^xn--/;
  const regexNonASCII = /[^\0-\x7F]/;
  const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
  const errors = {
    overflow: "Overflow: input needs wider integers to process",
    "not-basic": "Illegal input >= 0x80 (not a basic code point)",
    "invalid-input": "Invalid input"
  };
  const baseMinusTMin = base - tMin;
  const floor2 = Math.floor;
  const stringFromCharCode = String.fromCharCode;
  function error2(type2) {
    throw new RangeError(errors[type2]);
  }
  function map2(array, callback) {
    const result2 = [];
    let length = array.length;
    while (length--) {
      result2[length] = callback(array[length]);
    }
    return result2;
  }
  function mapDomain(domain, callback) {
    const parts = domain.split("@");
    let result2 = "";
    if (parts.length > 1) {
      result2 = parts[0] + "@";
      domain = parts[1];
    }
    domain = domain.replace(regexSeparators, ".");
    const labels = domain.split(".");
    const encoded = map2(labels, callback).join(".");
    return result2 + encoded;
  }
  function ucs2decode(string) {
    const output = [];
    let counter = 0;
    const length = string.length;
    while (counter < length) {
      const value = string.charCodeAt(counter++);
      if (value >= 55296 && value <= 56319 && counter < length) {
        const extra = string.charCodeAt(counter++);
        if ((extra & 64512) == 56320) {
          output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
        } else {
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }
    return output;
  }
  const ucs2encode = (codePoints) => String.fromCodePoint(...codePoints);
  const basicToDigit = function(codePoint) {
    if (codePoint >= 48 && codePoint < 58) {
      return 26 + (codePoint - 48);
    }
    if (codePoint >= 65 && codePoint < 91) {
      return codePoint - 65;
    }
    if (codePoint >= 97 && codePoint < 123) {
      return codePoint - 97;
    }
    return base;
  };
  const digitToBasic = function(digit, flag) {
    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
  };
  const adapt = function(delta, numPoints, firstTime) {
    let k = 0;
    delta = firstTime ? floor2(delta / damp) : delta >> 1;
    delta += floor2(delta / numPoints);
    for (
      ;
      /* no initialization */
      delta > baseMinusTMin * tMax >> 1;
      k += base
    ) {
      delta = floor2(delta / baseMinusTMin);
    }
    return floor2(k + (baseMinusTMin + 1) * delta / (delta + skew));
  };
  const decode2 = function(input) {
    const output = [];
    const inputLength = input.length;
    let i = 0;
    let n2 = initialN;
    let bias = initialBias;
    let basic = input.lastIndexOf(delimiter);
    if (basic < 0) {
      basic = 0;
    }
    for (let j = 0; j < basic; ++j) {
      if (input.charCodeAt(j) >= 128) {
        error2("not-basic");
      }
      output.push(input.charCodeAt(j));
    }
    for (let index2 = basic > 0 ? basic + 1 : 0; index2 < inputLength; ) {
      const oldi = i;
      for (let w = 1, k = base; ; k += base) {
        if (index2 >= inputLength) {
          error2("invalid-input");
        }
        const digit = basicToDigit(input.charCodeAt(index2++));
        if (digit >= base) {
          error2("invalid-input");
        }
        if (digit > floor2((maxInt - i) / w)) {
          error2("overflow");
        }
        i += digit * w;
        const t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
        if (digit < t2) {
          break;
        }
        const baseMinusT = base - t2;
        if (w > floor2(maxInt / baseMinusT)) {
          error2("overflow");
        }
        w *= baseMinusT;
      }
      const out = output.length + 1;
      bias = adapt(i - oldi, out, oldi == 0);
      if (floor2(i / out) > maxInt - n2) {
        error2("overflow");
      }
      n2 += floor2(i / out);
      i %= out;
      output.splice(i++, 0, n2);
    }
    return String.fromCodePoint(...output);
  };
  const encode2 = function(input) {
    const output = [];
    input = ucs2decode(input);
    const inputLength = input.length;
    let n2 = initialN;
    let delta = 0;
    let bias = initialBias;
    for (const currentValue of input) {
      if (currentValue < 128) {
        output.push(stringFromCharCode(currentValue));
      }
    }
    const basicLength = output.length;
    let handledCPCount = basicLength;
    if (basicLength) {
      output.push(delimiter);
    }
    while (handledCPCount < inputLength) {
      let m = maxInt;
      for (const currentValue of input) {
        if (currentValue >= n2 && currentValue < m) {
          m = currentValue;
        }
      }
      const handledCPCountPlusOne = handledCPCount + 1;
      if (m - n2 > floor2((maxInt - delta) / handledCPCountPlusOne)) {
        error2("overflow");
      }
      delta += (m - n2) * handledCPCountPlusOne;
      n2 = m;
      for (const currentValue of input) {
        if (currentValue < n2 && ++delta > maxInt) {
          error2("overflow");
        }
        if (currentValue === n2) {
          let q2 = delta;
          for (let k = base; ; k += base) {
            const t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (q2 < t2) {
              break;
            }
            const qMinusT = q2 - t2;
            const baseMinusT = base - t2;
            output.push(stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0)));
            q2 = floor2(qMinusT / baseMinusT);
          }
          output.push(stringFromCharCode(digitToBasic(q2, 0)));
          bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
          delta = 0;
          ++handledCPCount;
        }
      }
      ++delta;
      ++n2;
    }
    return output.join("");
  };
  const toUnicode = function(input) {
    return mapDomain(input, function(string) {
      return regexPunycode.test(string) ? decode2(string.slice(4).toLowerCase()) : string;
    });
  };
  const toASCII = function(input) {
    return mapDomain(input, function(string) {
      return regexNonASCII.test(string) ? "xn--" + encode2(string) : string;
    });
  };
  const punycode = {
    /**
     * A string representing the current Punycode.js version number.
     * @memberOf punycode
     * @type String
     */
    version: "2.3.1",
    /**
     * An object of methods to convert from JavaScript's internal character
     * representation (UCS-2) to Unicode code points, and back.
     * @see <https://mathiasbynens.be/notes/javascript-encoding>
     * @memberOf punycode
     * @type Object
     */
    ucs2: {
      decode: ucs2decode,
      encode: ucs2encode
    },
    decode: decode2,
    encode: encode2,
    toASCII,
    toUnicode
  };
  punycode_1 = punycode;
  return punycode_1;
}
var base64;
var hasRequiredBase64;
function requireBase64() {
  if (hasRequiredBase64) return base64;
  hasRequiredBase64 = 1;
  const Transform = require$$0$c.Transform;
  function encode2(buffer) {
    if (typeof buffer === "string") {
      buffer = Buffer.from(buffer, "utf-8");
    }
    return buffer.toString("base64");
  }
  function wrap2(str, lineLength) {
    str = (str || "").toString();
    lineLength = lineLength || 76;
    if (str.length <= lineLength) {
      return str;
    }
    let result2 = [];
    let pos = 0;
    let chunkLength = lineLength * 1024;
    while (pos < str.length) {
      let wrappedLines = str.substr(pos, chunkLength).replace(new RegExp(".{" + lineLength + "}", "g"), "$&\r\n");
      result2.push(wrappedLines);
      pos += chunkLength;
    }
    return result2.join("");
  }
  class Encoder extends Transform {
    constructor(options) {
      super();
      this.options = options || {};
      if (this.options.lineLength !== false) {
        this.options.lineLength = this.options.lineLength || 76;
      }
      this._curLine = "";
      this._remainingBytes = false;
      this.inputBytes = 0;
      this.outputBytes = 0;
    }
    _transform(chunk, encoding, done) {
      if (encoding !== "buffer") {
        chunk = Buffer.from(chunk, encoding);
      }
      if (!chunk || !chunk.length) {
        return setImmediate(done);
      }
      this.inputBytes += chunk.length;
      if (this._remainingBytes && this._remainingBytes.length) {
        chunk = Buffer.concat([this._remainingBytes, chunk], this._remainingBytes.length + chunk.length);
        this._remainingBytes = false;
      }
      if (chunk.length % 3) {
        this._remainingBytes = chunk.slice(chunk.length - chunk.length % 3);
        chunk = chunk.slice(0, chunk.length - chunk.length % 3);
      } else {
        this._remainingBytes = false;
      }
      let b64 = this._curLine + encode2(chunk);
      if (this.options.lineLength) {
        b64 = wrap2(b64, this.options.lineLength);
        let lastLF = b64.lastIndexOf("\n");
        if (lastLF < 0) {
          this._curLine = b64;
          b64 = "";
        } else {
          this._curLine = b64.substring(lastLF + 1);
          b64 = b64.substring(0, lastLF + 1);
          if (b64 && !b64.endsWith("\r\n")) {
            b64 += "\r\n";
          }
        }
      } else {
        this._curLine = "";
      }
      if (b64) {
        this.outputBytes += b64.length;
        this.push(Buffer.from(b64, "ascii"));
      }
      setImmediate(done);
    }
    _flush(done) {
      if (this._remainingBytes && this._remainingBytes.length) {
        this._curLine += encode2(this._remainingBytes);
      }
      if (this._curLine) {
        this.outputBytes += this._curLine.length;
        this.push(Buffer.from(this._curLine, "ascii"));
        this._curLine = "";
      }
      done();
    }
  }
  base64 = {
    encode: encode2,
    wrap: wrap2,
    Encoder
  };
  return base64;
}
var qp;
var hasRequiredQp;
function requireQp() {
  if (hasRequiredQp) return qp;
  hasRequiredQp = 1;
  const Transform = require$$0$c.Transform;
  function encode2(buffer) {
    if (typeof buffer === "string") {
      buffer = Buffer.from(buffer, "utf-8");
    }
    let ranges = [
      // https://tools.ietf.org/html/rfc2045#section-6.7
      [9],
      // <TAB>
      [10],
      // <LF>
      [13],
      // <CR>
      [32, 60],
      // <SP>!"#$%&'()*+,-./0123456789:;
      [62, 126]
      // >?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}
    ];
    let result2 = "";
    let ord;
    for (let i = 0, len = buffer.length; i < len; i++) {
      ord = buffer[i];
      if (checkRanges(ord, ranges) && !((ord === 32 || ord === 9) && (i === len - 1 || buffer[i + 1] === 10 || buffer[i + 1] === 13))) {
        result2 += String.fromCharCode(ord);
        continue;
      }
      result2 += "=" + (ord < 16 ? "0" : "") + ord.toString(16).toUpperCase();
    }
    return result2;
  }
  function wrap2(str, lineLength) {
    str = (str || "").toString();
    lineLength = lineLength || 76;
    if (str.length <= lineLength) {
      return str;
    }
    let pos = 0;
    let len = str.length;
    let match2, code, line2;
    let lineMargin = Math.floor(lineLength / 3);
    let result2 = "";
    while (pos < len) {
      line2 = str.substr(pos, lineLength);
      if (match2 = line2.match(/\r\n/)) {
        line2 = line2.substr(0, match2.index + match2[0].length);
        result2 += line2;
        pos += line2.length;
        continue;
      }
      if (line2.substr(-1) === "\n") {
        result2 += line2;
        pos += line2.length;
        continue;
      } else if (match2 = line2.substr(-lineMargin).match(/\n.*?$/)) {
        line2 = line2.substr(0, line2.length - (match2[0].length - 1));
        result2 += line2;
        pos += line2.length;
        continue;
      } else if (line2.length > lineLength - lineMargin && (match2 = line2.substr(-lineMargin).match(/[ \t.,!?][^ \t.,!?]*$/))) {
        line2 = line2.substr(0, line2.length - (match2[0].length - 1));
      } else if (line2.match(/[=][\da-f]{0,2}$/i)) {
        if (match2 = line2.match(/[=][\da-f]{0,1}$/i)) {
          line2 = line2.substr(0, line2.length - match2[0].length);
        }
        while (line2.length > 3 && line2.length < len - pos && !line2.match(/^(?:=[\da-f]{2}){1,4}$/i) && (match2 = line2.match(/[=][\da-f]{2}$/gi))) {
          code = parseInt(match2[0].substr(1, 2), 16);
          if (code < 128) {
            break;
          }
          line2 = line2.substr(0, line2.length - 3);
          if (code >= 192) {
            break;
          }
        }
      }
      if (pos + line2.length < len && line2.substr(-1) !== "\n") {
        if (line2.length === lineLength && line2.match(/[=][\da-f]{2}$/i)) {
          line2 = line2.substr(0, line2.length - 3);
        } else if (line2.length === lineLength) {
          line2 = line2.substr(0, line2.length - 1);
        }
        pos += line2.length;
        line2 += "=\r\n";
      } else {
        pos += line2.length;
      }
      result2 += line2;
    }
    return result2;
  }
  function checkRanges(nr, ranges) {
    for (let i = ranges.length - 1; i >= 0; i--) {
      if (!ranges[i].length) {
        continue;
      }
      if (ranges[i].length === 1 && nr === ranges[i][0]) {
        return true;
      }
      if (ranges[i].length === 2 && nr >= ranges[i][0] && nr <= ranges[i][1]) {
        return true;
      }
    }
    return false;
  }
  class Encoder extends Transform {
    constructor(options) {
      super();
      this.options = options || {};
      if (this.options.lineLength !== false) {
        this.options.lineLength = this.options.lineLength || 76;
      }
      this._curLine = "";
      this.inputBytes = 0;
      this.outputBytes = 0;
    }
    _transform(chunk, encoding, done) {
      let qp2;
      if (encoding !== "buffer") {
        chunk = Buffer.from(chunk, encoding);
      }
      if (!chunk || !chunk.length) {
        return done();
      }
      this.inputBytes += chunk.length;
      if (this.options.lineLength) {
        qp2 = this._curLine + encode2(chunk);
        qp2 = wrap2(qp2, this.options.lineLength);
        qp2 = qp2.replace(/(^|\n)([^\n]*)$/, (match2, lineBreak, lastLine) => {
          this._curLine = lastLine;
          return lineBreak;
        });
        if (qp2) {
          this.outputBytes += qp2.length;
          this.push(qp2);
        }
      } else {
        qp2 = encode2(chunk);
        this.outputBytes += qp2.length;
        this.push(qp2, "ascii");
      }
      done();
    }
    _flush(done) {
      if (this._curLine) {
        this.outputBytes += this._curLine.length;
        this.push(this._curLine, "ascii");
      }
      done();
    }
  }
  qp = {
    encode: encode2,
    wrap: wrap2,
    Encoder
  };
  return qp;
}
var mimeFuncs;
var hasRequiredMimeFuncs;
function requireMimeFuncs() {
  if (hasRequiredMimeFuncs) return mimeFuncs;
  hasRequiredMimeFuncs = 1;
  const base642 = requireBase64();
  const qp2 = requireQp();
  const mimeTypes2 = requireMimeTypes();
  mimeFuncs = {
    /**
     * Checks if a value is plaintext string (uses only printable 7bit chars)
     *
     * @param {String} value String to be tested
     * @returns {Boolean} true if it is a plaintext string
     */
    isPlainText(value, isParam) {
      const re = isParam ? /[\x00-\x08\x0b\x0c\x0e-\x1f"\u0080-\uFFFF]/ : /[\x00-\x08\x0b\x0c\x0e-\x1f\u0080-\uFFFF]/;
      if (typeof value !== "string" || re.test(value)) {
        return false;
      } else {
        return true;
      }
    },
    /**
     * Checks if a multi line string containes lines longer than the selected value.
     *
     * Useful when detecting if a mail message needs any processing at all 
     * if only plaintext characters are used and lines are short, then there is
     * no need to encode the values in any way. If the value is plaintext but has
     * longer lines then allowed, then use format=flowed
     *
     * @param {Number} lineLength Max line length to check for
     * @returns {Boolean} Returns true if there is at least one line longer than lineLength chars
     */
    hasLongerLines(str, lineLength) {
      if (str.length > 128 * 1024) {
        return true;
      }
      return new RegExp("^.{" + (lineLength + 1) + ",}", "m").test(str);
    },
    /**
     * Encodes a string or an Buffer to an UTF-8 MIME Word (rfc2047)
     *
     * @param {String|Buffer} data String to be encoded
     * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B
     * @param {Number} [maxLength=0] If set, split mime words into several chunks if needed
     * @return {String} Single or several mime words joined together
     */
    encodeWord(data, mimeWordEncoding, maxLength) {
      mimeWordEncoding = (mimeWordEncoding || "Q").toString().toUpperCase().trim().charAt(0);
      maxLength = maxLength || 0;
      let encodedStr;
      let toCharset = "UTF-8";
      if (maxLength && maxLength > 7 + toCharset.length) {
        maxLength -= 7 + toCharset.length;
      }
      if (mimeWordEncoding === "Q") {
        encodedStr = qp2.encode(data).replace(/[^a-z0-9!*+\-/=]/gi, (chr) => {
          let ord = chr.charCodeAt(0).toString(16).toUpperCase();
          if (chr === " ") {
            return "_";
          } else {
            return "=" + (ord.length === 1 ? "0" + ord : ord);
          }
        });
      } else if (mimeWordEncoding === "B") {
        encodedStr = typeof data === "string" ? data : base642.encode(data);
        maxLength = maxLength ? Math.max(3, (maxLength - maxLength % 4) / 4 * 3) : 0;
      }
      if (maxLength && (mimeWordEncoding !== "B" ? encodedStr : base642.encode(data)).length > maxLength) {
        if (mimeWordEncoding === "Q") {
          encodedStr = this.splitMimeEncodedString(encodedStr, maxLength).join("?= =?" + toCharset + "?" + mimeWordEncoding + "?");
        } else {
          let parts = [];
          let lpart = "";
          for (let i = 0, len = encodedStr.length; i < len; i++) {
            let chr = encodedStr.charAt(i);
            if (/[\ud83c\ud83d\ud83e]/.test(chr) && i < len - 1) {
              chr += encodedStr.charAt(++i);
            }
            if (Buffer.byteLength(lpart + chr) <= maxLength || i === 0) {
              lpart += chr;
            } else {
              parts.push(base642.encode(lpart));
              lpart = chr;
            }
          }
          if (lpart) {
            parts.push(base642.encode(lpart));
          }
          if (parts.length > 1) {
            encodedStr = parts.join("?= =?" + toCharset + "?" + mimeWordEncoding + "?");
          } else {
            encodedStr = parts.join("");
          }
        }
      } else if (mimeWordEncoding === "B") {
        encodedStr = base642.encode(data);
      }
      return "=?" + toCharset + "?" + mimeWordEncoding + "?" + encodedStr + (encodedStr.substr(-2) === "?=" ? "" : "?=");
    },
    /**
     * Finds word sequences with non ascii text and converts these to mime words
     *
     * @param {String} value String to be encoded
     * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B
     * @param {Number} [maxLength=0] If set, split mime words into several chunks if needed
     * @param {Boolean} [encodeAll=false] If true and the value needs encoding then encodes entire string, not just the smallest match
     * @return {String} String with possible mime words
     */
    encodeWords(value, mimeWordEncoding, maxLength, encodeAll) {
      maxLength = maxLength || 0;
      let encodedValue;
      let firstMatch = value.match(/(?:^|\s)([^\s]*["\u0080-\uFFFF])/);
      if (!firstMatch) {
        return value;
      }
      if (encodeAll) {
        return this.encodeWord(value, mimeWordEncoding, maxLength);
      }
      let lastMatch = value.match(/(["\u0080-\uFFFF][^\s]*)[^"\u0080-\uFFFF]*$/);
      if (!lastMatch) {
        return value;
      }
      let startIndex = firstMatch.index + (firstMatch[0].match(/[^\s]/) || {
        index: 0
      }).index;
      let endIndex = lastMatch.index + (lastMatch[1] || "").length;
      encodedValue = (startIndex ? value.substr(0, startIndex) : "") + this.encodeWord(value.substring(startIndex, endIndex), mimeWordEncoding || "Q", maxLength) + (endIndex < value.length ? value.substr(endIndex) : "");
      return encodedValue;
    },
    /**
     * Joins parsed header value together as 'value; param1=value1; param2=value2'
     * PS: We are following RFC 822 for the list of special characters that we need to keep in quotes.
     *      Refer: https://www.w3.org/Protocols/rfc1341/4_Content-Type.html
     * @param {Object} structured Parsed header value
     * @return {String} joined header value
     */
    buildHeaderValue(structured) {
      let paramsArray = [];
      Object.keys(structured.params || {}).forEach((param) => {
        let value = structured.params[param];
        if (!this.isPlainText(value, true) || value.length >= 75) {
          this.buildHeaderParam(param, value, 50).forEach((encodedParam) => {
            if (!/[\s"\\;:/=(),<>@[\]?]|^[-']|'$/.test(encodedParam.value) || encodedParam.key.substr(-1) === "*") {
              paramsArray.push(encodedParam.key + "=" + encodedParam.value);
            } else {
              paramsArray.push(encodedParam.key + "=" + JSON.stringify(encodedParam.value));
            }
          });
        } else if (/[\s'"\\;:/=(),<>@[\]?]|^-/.test(value)) {
          paramsArray.push(param + "=" + JSON.stringify(value));
        } else {
          paramsArray.push(param + "=" + value);
        }
      });
      return structured.value + (paramsArray.length ? "; " + paramsArray.join("; ") : "");
    },
    /**
     * Encodes a string or an Buffer to an UTF-8 Parameter Value Continuation encoding (rfc2231)
     * Useful for splitting long parameter values.
     *
     * For example
     *      title="unicode string"
     * becomes
     *     title*0*=utf-8''unicode
     *     title*1*=%20string
     *
     * @param {String|Buffer} data String to be encoded
     * @param {Number} [maxLength=50] Max length for generated chunks
     * @param {String} [fromCharset='UTF-8'] Source sharacter set
     * @return {Array} A list of encoded keys and headers
     */
    buildHeaderParam(key, data, maxLength) {
      let list = [];
      let encodedStr = typeof data === "string" ? data : (data || "").toString();
      let encodedStrArr;
      let chr, ord;
      let line2;
      let startPos = 0;
      let i, len;
      maxLength = maxLength || 50;
      if (this.isPlainText(data, true)) {
        if (encodedStr.length <= maxLength) {
          return [
            {
              key,
              value: encodedStr
            }
          ];
        }
        encodedStr = encodedStr.replace(new RegExp(".{" + maxLength + "}", "g"), (str) => {
          list.push({
            line: str
          });
          return "";
        });
        if (encodedStr) {
          list.push({
            line: encodedStr
          });
        }
      } else {
        if (/[\uD800-\uDBFF]/.test(encodedStr)) {
          encodedStrArr = [];
          for (i = 0, len = encodedStr.length; i < len; i++) {
            chr = encodedStr.charAt(i);
            ord = chr.charCodeAt(0);
            if (ord >= 55296 && ord <= 56319 && i < len - 1) {
              chr += encodedStr.charAt(i + 1);
              encodedStrArr.push(chr);
              i++;
            } else {
              encodedStrArr.push(chr);
            }
          }
          encodedStr = encodedStrArr;
        }
        line2 = "utf-8''";
        let encoded = true;
        startPos = 0;
        for (i = 0, len = encodedStr.length; i < len; i++) {
          chr = encodedStr[i];
          if (encoded) {
            chr = this.safeEncodeURIComponent(chr);
          } else {
            chr = chr === " " ? chr : this.safeEncodeURIComponent(chr);
            if (chr !== encodedStr[i]) {
              if ((this.safeEncodeURIComponent(line2) + chr).length >= maxLength) {
                list.push({
                  line: line2,
                  encoded
                });
                line2 = "";
                startPos = i - 1;
              } else {
                encoded = true;
                i = startPos;
                line2 = "";
                continue;
              }
            }
          }
          if ((line2 + chr).length >= maxLength) {
            list.push({
              line: line2,
              encoded
            });
            line2 = chr = encodedStr[i] === " " ? " " : this.safeEncodeURIComponent(encodedStr[i]);
            if (chr === encodedStr[i]) {
              encoded = false;
              startPos = i - 1;
            } else {
              encoded = true;
            }
          } else {
            line2 += chr;
          }
        }
        if (line2) {
          list.push({
            line: line2,
            encoded
          });
        }
      }
      return list.map((item, i2) => ({
        // encoded lines: {name}*{part}*
        // unencoded lines: {name}*{part}
        // if any line needs to be encoded then the first line (part==0) is always encoded
        key: key + "*" + i2 + (item.encoded ? "*" : ""),
        value: item.line
      }));
    },
    /**
     * Parses a header value with key=value arguments into a structured
     * object.
     *
     *   parseHeaderValue('content-type: text/plain; CHARSET='UTF-8'') ->
     *   {
     *     'value': 'text/plain',
     *     'params': {
     *       'charset': 'UTF-8'
     *     }
     *   }
     *
     * @param {String} str Header value
     * @return {Object} Header value as a parsed structure
     */
    parseHeaderValue(str) {
      let response = {
        value: false,
        params: {}
      };
      let key = false;
      let value = "";
      let type2 = "value";
      let quote = false;
      let escaped = false;
      let chr;
      for (let i = 0, len = str.length; i < len; i++) {
        chr = str.charAt(i);
        if (type2 === "key") {
          if (chr === "=") {
            key = value.trim().toLowerCase();
            type2 = "value";
            value = "";
            continue;
          }
          value += chr;
        } else {
          if (escaped) {
            value += chr;
          } else if (chr === "\\") {
            escaped = true;
            continue;
          } else if (quote && chr === quote) {
            quote = false;
          } else if (!quote && chr === '"') {
            quote = chr;
          } else if (!quote && chr === ";") {
            if (key === false) {
              response.value = value.trim();
            } else {
              response.params[key] = value.trim();
            }
            type2 = "key";
            value = "";
          } else {
            value += chr;
          }
          escaped = false;
        }
      }
      if (type2 === "value") {
        if (key === false) {
          response.value = value.trim();
        } else {
          response.params[key] = value.trim();
        }
      } else if (value.trim()) {
        response.params[value.trim().toLowerCase()] = "";
      }
      Object.keys(response.params).forEach((key2) => {
        let actualKey, nr, match2, value2;
        if (match2 = key2.match(/(\*(\d+)|\*(\d+)\*|\*)$/)) {
          actualKey = key2.substr(0, match2.index);
          nr = Number(match2[2] || match2[3]) || 0;
          if (!response.params[actualKey] || typeof response.params[actualKey] !== "object") {
            response.params[actualKey] = {
              charset: false,
              values: []
            };
          }
          value2 = response.params[key2];
          if (nr === 0 && match2[0].substr(-1) === "*" && (match2 = value2.match(/^([^']*)'[^']*'(.*)$/))) {
            response.params[actualKey].charset = match2[1] || "iso-8859-1";
            value2 = match2[2];
          }
          response.params[actualKey].values[nr] = value2;
          delete response.params[key2];
        }
      });
      Object.keys(response.params).forEach((key2) => {
        let value2;
        if (response.params[key2] && Array.isArray(response.params[key2].values)) {
          value2 = response.params[key2].values.map((val) => val || "").join("");
          if (response.params[key2].charset) {
            response.params[key2] = "=?" + response.params[key2].charset + "?Q?" + value2.replace(/[=?_\s]/g, (s2) => {
              let c2 = s2.charCodeAt(0).toString(16);
              if (s2 === " ") {
                return "_";
              } else {
                return "%" + (c2.length < 2 ? "0" : "") + c2;
              }
            }).replace(/%/g, "=") + "?=";
          } else {
            response.params[key2] = value2;
          }
        }
      });
      return response;
    },
    /**
     * Returns file extension for a content type string. If no suitable extensions
     * are found, 'bin' is used as the default extension
     *
     * @param {String} mimeType Content type to be checked for
     * @return {String} File extension
     */
    detectExtension: (mimeType) => mimeTypes2.detectExtension(mimeType),
    /**
     * Returns content type for a file extension. If no suitable content types
     * are found, 'application/octet-stream' is used as the default content type
     *
     * @param {String} extension Extension to be checked for
     * @return {String} File extension
     */
    detectMimeType: (extension) => mimeTypes2.detectMimeType(extension),
    /**
     * Folds long lines, useful for folding header lines (afterSpace=false) and
     * flowed text (afterSpace=true)
     *
     * @param {String} str String to be folded
     * @param {Number} [lineLength=76] Maximum length of a line
     * @param {Boolean} afterSpace If true, leave a space in th end of a line
     * @return {String} String with folded lines
     */
    foldLines(str, lineLength, afterSpace) {
      str = (str || "").toString();
      lineLength = lineLength || 76;
      let pos = 0, len = str.length, result2 = "", line2, match2;
      while (pos < len) {
        line2 = str.substr(pos, lineLength);
        if (line2.length < lineLength) {
          result2 += line2;
          break;
        }
        if (match2 = line2.match(/^[^\n\r]*(\r?\n|\r)/)) {
          line2 = match2[0];
          result2 += line2;
          pos += line2.length;
          continue;
        } else if ((match2 = line2.match(/(\s+)[^\s]*$/)) && match2[0].length - (afterSpace ? (match2[1] || "").length : 0) < line2.length) {
          line2 = line2.substr(0, line2.length - (match2[0].length - (afterSpace ? (match2[1] || "").length : 0)));
        } else if (match2 = str.substr(pos + line2.length).match(/^[^\s]+(\s*)/)) {
          line2 = line2 + match2[0].substr(0, match2[0].length - (!afterSpace ? (match2[1] || "").length : 0));
        }
        result2 += line2;
        pos += line2.length;
        if (pos < len) {
          result2 += "\r\n";
        }
      }
      return result2;
    },
    /**
     * Splits a mime encoded string. Needed for dividing mime words into smaller chunks
     *
     * @param {String} str Mime encoded string to be split up
     * @param {Number} maxlen Maximum length of characters for one part (minimum 12)
     * @return {Array} Split string
     */
    splitMimeEncodedString: (str, maxlen) => {
      let curLine, match2, chr, done, lines = [];
      maxlen = Math.max(maxlen || 0, 12);
      while (str.length) {
        curLine = str.substr(0, maxlen);
        if (match2 = curLine.match(/[=][0-9A-F]?$/i)) {
          curLine = curLine.substr(0, match2.index);
        }
        done = false;
        while (!done) {
          done = true;
          if (match2 = str.substr(curLine.length).match(/^[=]([0-9A-F]{2})/i)) {
            chr = parseInt(match2[1], 16);
            if (chr < 194 && chr > 127) {
              curLine = curLine.substr(0, curLine.length - 3);
              done = false;
            }
          }
        }
        if (curLine.length) {
          lines.push(curLine);
        }
        str = str.substr(curLine.length);
      }
      return lines;
    },
    encodeURICharComponent: (chr) => {
      let res2 = "";
      let ord = chr.charCodeAt(0).toString(16).toUpperCase();
      if (ord.length % 2) {
        ord = "0" + ord;
      }
      if (ord.length > 2) {
        for (let i = 0, len = ord.length / 2; i < len; i++) {
          res2 += "%" + ord.substr(i, 2);
        }
      } else {
        res2 += "%" + ord;
      }
      return res2;
    },
    safeEncodeURIComponent(str) {
      str = (str || "").toString();
      try {
        str = encodeURIComponent(str);
      } catch (_E) {
        return str.replace(/[^\x00-\x1F *'()<>@,;:\\"[\]?=\u007F-\uFFFF]+/g, "");
      }
      return str.replace(/[\x00-\x1F *'()<>@,;:\\"[\]?=\u007F-\uFFFF]/g, (chr) => this.encodeURICharComponent(chr));
    }
  };
  return mimeFuncs;
}
var addressparser_1;
var hasRequiredAddressparser;
function requireAddressparser() {
  if (hasRequiredAddressparser) return addressparser_1;
  hasRequiredAddressparser = 1;
  function _handleAddress(tokens, depth) {
    let isGroup = false;
    let state = "text";
    let address;
    let addresses = [];
    let data = {
      address: [],
      comment: [],
      group: [],
      text: [],
      textWasQuoted: []
      // Track which text tokens came from inside quotes
    };
    let i;
    let len;
    let insideQuotes = false;
    for (i = 0, len = tokens.length; i < len; i++) {
      let token2 = tokens[i];
      let prevToken = i ? tokens[i - 1] : null;
      if (token2.type === "operator") {
        switch (token2.value) {
          case "<":
            state = "address";
            insideQuotes = false;
            break;
          case "(":
            state = "comment";
            insideQuotes = false;
            break;
          case ":":
            state = "group";
            isGroup = true;
            insideQuotes = false;
            break;
          case '"':
            insideQuotes = !insideQuotes;
            state = "text";
            break;
          default:
            state = "text";
            insideQuotes = false;
            break;
        }
      } else if (token2.value) {
        if (state === "address") {
          token2.value = token2.value.replace(/^[^<]*<\s*/, "");
        }
        if (prevToken && prevToken.noBreak && data[state].length) {
          data[state][data[state].length - 1] += token2.value;
          if (state === "text" && insideQuotes) {
            data.textWasQuoted[data.textWasQuoted.length - 1] = true;
          }
        } else {
          data[state].push(token2.value);
          if (state === "text") {
            data.textWasQuoted.push(insideQuotes);
          }
        }
      }
    }
    if (!data.text.length && data.comment.length) {
      data.text = data.comment;
      data.comment = [];
    }
    if (isGroup) {
      data.text = data.text.join(" ");
      let groupMembers = [];
      if (data.group.length) {
        let parsedGroup = addressparser(data.group.join(","), { _depth: depth + 1 });
        parsedGroup.forEach((member) => {
          if (member.group) {
            groupMembers = groupMembers.concat(member.group);
          } else {
            groupMembers.push(member);
          }
        });
      }
      addresses.push({
        name: data.text || address && address.name,
        group: groupMembers
      });
    } else {
      if (!data.address.length && data.text.length) {
        for (i = data.text.length - 1; i >= 0; i--) {
          if (!data.textWasQuoted[i] && data.text[i].match(/^[^@\s]+@[^@\s]+$/)) {
            data.address = data.text.splice(i, 1);
            data.textWasQuoted.splice(i, 1);
            break;
          }
        }
        let _regexHandler = function(address2) {
          if (!data.address.length) {
            data.address = [address2.trim()];
            return " ";
          } else {
            return address2;
          }
        };
        if (!data.address.length) {
          for (i = data.text.length - 1; i >= 0; i--) {
            if (!data.textWasQuoted[i]) {
              data.text[i] = data.text[i].replace(/\s*\b[^@\s]+@[^\s]+\b\s*/, _regexHandler).trim();
              if (data.address.length) {
                break;
              }
            }
          }
        }
      }
      if (!data.text.length && data.comment.length) {
        data.text = data.comment;
        data.comment = [];
      }
      if (data.address.length > 1) {
        data.text = data.text.concat(data.address.splice(1));
      }
      data.text = data.text.join(" ");
      data.address = data.address.join(" ");
      if (!data.address && isGroup) {
        return [];
      } else {
        address = {
          address: data.address || data.text || "",
          name: data.text || data.address || ""
        };
        if (address.address === address.name) {
          if ((address.address || "").match(/@/)) {
            address.name = "";
          } else {
            address.address = "";
          }
        }
        addresses.push(address);
      }
    }
    return addresses;
  }
  class Tokenizer2 {
    constructor(str) {
      this.str = (str || "").toString();
      this.operatorCurrent = "";
      this.operatorExpecting = "";
      this.node = null;
      this.escaped = false;
      this.list = [];
      this.operators = {
        '"': '"',
        "(": ")",
        "<": ">",
        ",": "",
        ":": ";",
        // Semicolons are not a legal delimiter per the RFC2822 grammar other
        // than for terminating a group, but they are also not valid for any
        // other use in this context.  Given that some mail clients have
        // historically allowed the semicolon as a delimiter equivalent to the
        // comma in their UI, it makes sense to treat them the same as a comma
        // when used outside of a group.
        ";": ""
      };
    }
    /**
     * Tokenizes the original input string
     *
     * @return {Array} An array of operator|text tokens
     */
    tokenize() {
      let list = [];
      for (let i = 0, len = this.str.length; i < len; i++) {
        let chr = this.str.charAt(i);
        let nextChr = i < len - 1 ? this.str.charAt(i + 1) : null;
        this.checkChar(chr, nextChr);
      }
      this.list.forEach((node) => {
        node.value = (node.value || "").toString().trim();
        if (node.value) {
          list.push(node);
        }
      });
      return list;
    }
    /**
     * Checks if a character is an operator or text and acts accordingly
     *
     * @param {String} chr Character from the address field
     */
    checkChar(chr, nextChr) {
      if (this.escaped) ;
      else if (chr === this.operatorExpecting) {
        this.node = {
          type: "operator",
          value: chr
        };
        if (nextChr && ![" ", "	", "\r", "\n", ",", ";"].includes(nextChr)) {
          this.node.noBreak = true;
        }
        this.list.push(this.node);
        this.node = null;
        this.operatorExpecting = "";
        this.escaped = false;
        return;
      } else if (!this.operatorExpecting && chr in this.operators) {
        this.node = {
          type: "operator",
          value: chr
        };
        this.list.push(this.node);
        this.node = null;
        this.operatorExpecting = this.operators[chr];
        this.escaped = false;
        return;
      } else if (['"', "'"].includes(this.operatorExpecting) && chr === "\\") {
        this.escaped = true;
        return;
      }
      if (!this.node) {
        this.node = {
          type: "text",
          value: ""
        };
        this.list.push(this.node);
      }
      if (chr === "\n") {
        chr = " ";
      }
      if (chr.charCodeAt(0) >= 33 || [" ", "	"].includes(chr)) {
        this.node.value += chr;
      }
      this.escaped = false;
    }
  }
  const MAX_NESTED_GROUP_DEPTH = 50;
  function addressparser(str, options) {
    options = options || {};
    let depth = options._depth || 0;
    if (depth > MAX_NESTED_GROUP_DEPTH) {
      return [];
    }
    let tokenizer = new Tokenizer2(str);
    let tokens = tokenizer.tokenize();
    let addresses = [];
    let address = [];
    let parsedAddresses = [];
    tokens.forEach((token2) => {
      if (token2.type === "operator" && (token2.value === "," || token2.value === ";")) {
        if (address.length) {
          addresses.push(address);
        }
        address = [];
      } else {
        address.push(token2);
      }
    });
    if (address.length) {
      addresses.push(address);
    }
    addresses.forEach((address2) => {
      address2 = _handleAddress(address2, depth);
      if (address2.length) {
        parsedAddresses = parsedAddresses.concat(address2);
      }
    });
    if (options.flatten) {
      let addresses2 = [];
      let walkAddressList = (list) => {
        list.forEach((address2) => {
          if (address2.group) {
            return walkAddressList(address2.group);
          } else {
            addresses2.push(address2);
          }
        });
      };
      walkAddressList(parsedAddresses);
      return addresses2;
    }
    return parsedAddresses;
  }
  addressparser_1 = addressparser;
  return addressparser_1;
}
var lastNewline;
var hasRequiredLastNewline;
function requireLastNewline() {
  if (hasRequiredLastNewline) return lastNewline;
  hasRequiredLastNewline = 1;
  const Transform = require$$0$c.Transform;
  class LastNewline extends Transform {
    constructor() {
      super();
      this.lastByte = false;
    }
    _transform(chunk, encoding, done) {
      if (chunk.length) {
        this.lastByte = chunk[chunk.length - 1];
      }
      this.push(chunk);
      done();
    }
    _flush(done) {
      if (this.lastByte === 10) {
        return done();
      }
      if (this.lastByte === 13) {
        this.push(Buffer.from("\n"));
        return done();
      }
      this.push(Buffer.from("\r\n"));
      return done();
    }
  }
  lastNewline = LastNewline;
  return lastNewline;
}
var leWindows;
var hasRequiredLeWindows;
function requireLeWindows() {
  if (hasRequiredLeWindows) return leWindows;
  hasRequiredLeWindows = 1;
  const stream2 = require$$0$c;
  const Transform = stream2.Transform;
  class LeWindows extends Transform {
    constructor(options) {
      super(options);
      this.options = options || {};
      this.lastByte = false;
    }
    /**
     * Escapes dots
     */
    _transform(chunk, encoding, done) {
      let buf;
      let lastPos = 0;
      for (let i = 0, len = chunk.length; i < len; i++) {
        if (chunk[i] === 10) {
          if (i && chunk[i - 1] !== 13 || !i && this.lastByte !== 13) {
            if (i > lastPos) {
              buf = chunk.slice(lastPos, i);
              this.push(buf);
            }
            this.push(Buffer.from("\r\n"));
            lastPos = i + 1;
          }
        }
      }
      if (lastPos && lastPos < chunk.length) {
        buf = chunk.slice(lastPos);
        this.push(buf);
      } else if (!lastPos) {
        this.push(chunk);
      }
      this.lastByte = chunk[chunk.length - 1];
      done();
    }
  }
  leWindows = LeWindows;
  return leWindows;
}
var leUnix;
var hasRequiredLeUnix;
function requireLeUnix() {
  if (hasRequiredLeUnix) return leUnix;
  hasRequiredLeUnix = 1;
  const stream2 = require$$0$c;
  const Transform = stream2.Transform;
  class LeWindows extends Transform {
    constructor(options) {
      super(options);
      this.options = options || {};
    }
    /**
     * Escapes dots
     */
    _transform(chunk, encoding, done) {
      let buf;
      let lastPos = 0;
      for (let i = 0, len = chunk.length; i < len; i++) {
        if (chunk[i] === 13) {
          buf = chunk.slice(lastPos, i);
          lastPos = i + 1;
          this.push(buf);
        }
      }
      if (lastPos && lastPos < chunk.length) {
        buf = chunk.slice(lastPos);
        this.push(buf);
      } else if (!lastPos) {
        this.push(chunk);
      }
      done();
    }
  }
  leUnix = LeWindows;
  return leUnix;
}
var mimeNode;
var hasRequiredMimeNode;
function requireMimeNode() {
  if (hasRequiredMimeNode) return mimeNode;
  hasRequiredMimeNode = 1;
  const crypto2 = require$$0$5;
  const fs = require$$1$2;
  const punycode = requirePunycode();
  const PassThrough = require$$0$c.PassThrough;
  const shared2 = requireShared();
  const mimeFuncs2 = requireMimeFuncs();
  const qp2 = requireQp();
  const base642 = requireBase64();
  const addressparser = requireAddressparser();
  const nmfetch = requireFetch();
  const LastNewline = requireLastNewline();
  const LeWindows = requireLeWindows();
  const LeUnix = requireLeUnix();
  class MimeNode {
    constructor(contentType, options) {
      this.nodeCounter = 0;
      options = options || {};
      this.baseBoundary = options.baseBoundary || crypto2.randomBytes(8).toString("hex");
      this.boundaryPrefix = options.boundaryPrefix || "--_NmP";
      this.disableFileAccess = !!options.disableFileAccess;
      this.disableUrlAccess = !!options.disableUrlAccess;
      this.normalizeHeaderKey = options.normalizeHeaderKey;
      this.date = /* @__PURE__ */ new Date();
      this.rootNode = options.rootNode || this;
      this.keepBcc = !!options.keepBcc;
      if (options.filename) {
        this.filename = options.filename;
        if (!contentType) {
          contentType = mimeFuncs2.detectMimeType(this.filename.split(".").pop());
        }
      }
      this.textEncoding = (options.textEncoding || "").toString().trim().charAt(0).toUpperCase();
      this.parentNode = options.parentNode;
      this.hostname = options.hostname;
      this.newline = options.newline;
      this.childNodes = [];
      this._nodeId = ++this.rootNode.nodeCounter;
      this._headers = [];
      this._isPlainText = false;
      this._hasLongLines = false;
      this._envelope = false;
      this._raw = false;
      this._transforms = [];
      this._processFuncs = [];
      if (contentType) {
        this.setHeader("Content-Type", contentType);
      }
    }
    /////// PUBLIC METHODS
    /**
     * Creates and appends a child node.Arguments provided are passed to MimeNode constructor
     *
     * @param {String} [contentType] Optional content type
     * @param {Object} [options] Optional options object
     * @return {Object} Created node object
     */
    createChild(contentType, options) {
      if (!options && typeof contentType === "object") {
        options = contentType;
        contentType = void 0;
      }
      let node = new MimeNode(contentType, options);
      this.appendChild(node);
      return node;
    }
    /**
     * Appends an existing node to the mime tree. Removes the node from an existing
     * tree if needed
     *
     * @param {Object} childNode node to be appended
     * @return {Object} Appended node object
     */
    appendChild(childNode) {
      if (childNode.rootNode !== this.rootNode) {
        childNode.rootNode = this.rootNode;
        childNode._nodeId = ++this.rootNode.nodeCounter;
      }
      childNode.parentNode = this;
      this.childNodes.push(childNode);
      return childNode;
    }
    /**
     * Replaces current node with another node
     *
     * @param {Object} node Replacement node
     * @return {Object} Replacement node
     */
    replace(node) {
      if (node === this) {
        return this;
      }
      this.parentNode.childNodes.forEach((childNode, i) => {
        if (childNode === this) {
          node.rootNode = this.rootNode;
          node.parentNode = this.parentNode;
          node._nodeId = this._nodeId;
          this.rootNode = this;
          this.parentNode = void 0;
          node.parentNode.childNodes[i] = node;
        }
      });
      return node;
    }
    /**
     * Removes current node from the mime tree
     *
     * @return {Object} removed node
     */
    remove() {
      if (!this.parentNode) {
        return this;
      }
      for (let i = this.parentNode.childNodes.length - 1; i >= 0; i--) {
        if (this.parentNode.childNodes[i] === this) {
          this.parentNode.childNodes.splice(i, 1);
          this.parentNode = void 0;
          this.rootNode = this;
          return this;
        }
      }
    }
    /**
     * Sets a header value. If the value for selected key exists, it is overwritten.
     * You can set multiple values as well by using [{key:'', value:''}] or
     * {key: 'value'} as the first argument.
     *
     * @param {String|Array|Object} key Header key or a list of key value pairs
     * @param {String} value Header value
     * @return {Object} current node
     */
    setHeader(key, value) {
      let added = false, headerValue;
      if (!value && key && typeof key === "object") {
        if (key.key && "value" in key) {
          this.setHeader(key.key, key.value);
        } else if (Array.isArray(key)) {
          key.forEach((i) => {
            this.setHeader(i.key, i.value);
          });
        } else {
          Object.keys(key).forEach((i) => {
            this.setHeader(i, key[i]);
          });
        }
        return this;
      }
      key = this._normalizeHeaderKey(key);
      headerValue = {
        key,
        value
      };
      for (let i = 0, len = this._headers.length; i < len; i++) {
        if (this._headers[i].key === key) {
          if (!added) {
            this._headers[i] = headerValue;
            added = true;
          } else {
            this._headers.splice(i, 1);
            i--;
            len--;
          }
        }
      }
      if (!added) {
        this._headers.push(headerValue);
      }
      return this;
    }
    /**
     * Adds a header value. If the value for selected key exists, the value is appended
     * as a new field and old one is not touched.
     * You can set multiple values as well by using [{key:'', value:''}] or
     * {key: 'value'} as the first argument.
     *
     * @param {String|Array|Object} key Header key or a list of key value pairs
     * @param {String} value Header value
     * @return {Object} current node
     */
    addHeader(key, value) {
      if (!value && key && typeof key === "object") {
        if (key.key && key.value) {
          this.addHeader(key.key, key.value);
        } else if (Array.isArray(key)) {
          key.forEach((i) => {
            this.addHeader(i.key, i.value);
          });
        } else {
          Object.keys(key).forEach((i) => {
            this.addHeader(i, key[i]);
          });
        }
        return this;
      } else if (Array.isArray(value)) {
        value.forEach((val) => {
          this.addHeader(key, val);
        });
        return this;
      }
      this._headers.push({
        key: this._normalizeHeaderKey(key),
        value
      });
      return this;
    }
    /**
     * Retrieves the first mathcing value of a selected key
     *
     * @param {String} key Key to search for
     * @retun {String} Value for the key
     */
    getHeader(key) {
      key = this._normalizeHeaderKey(key);
      for (let i = 0, len = this._headers.length; i < len; i++) {
        if (this._headers[i].key === key) {
          return this._headers[i].value;
        }
      }
    }
    /**
     * Sets body content for current node. If the value is a string, charset is added automatically
     * to Content-Type (if it is text/*). If the value is a Buffer, you need to specify
     * the charset yourself
     *
     * @param (String|Buffer) content Body content
     * @return {Object} current node
     */
    setContent(content2) {
      this.content = content2;
      if (typeof this.content.pipe === "function") {
        this._contentErrorHandler = (err2) => {
          this.content.removeListener("error", this._contentErrorHandler);
          this.content = err2;
        };
        this.content.once("error", this._contentErrorHandler);
      } else if (typeof this.content === "string") {
        this._isPlainText = mimeFuncs2.isPlainText(this.content);
        if (this._isPlainText && mimeFuncs2.hasLongerLines(this.content, 76)) {
          this._hasLongLines = true;
        }
      }
      return this;
    }
    build(callback) {
      let promise;
      if (!callback) {
        promise = new Promise((resolve2, reject) => {
          callback = shared2.callbackPromise(resolve2, reject);
        });
      }
      let stream2 = this.createReadStream();
      let buf = [];
      let buflen = 0;
      let returned = false;
      stream2.on("readable", () => {
        let chunk;
        while ((chunk = stream2.read()) !== null) {
          buf.push(chunk);
          buflen += chunk.length;
        }
      });
      stream2.once("error", (err2) => {
        if (returned) {
          return;
        }
        returned = true;
        return callback(err2);
      });
      stream2.once("end", (chunk) => {
        if (returned) {
          return;
        }
        returned = true;
        if (chunk && chunk.length) {
          buf.push(chunk);
          buflen += chunk.length;
        }
        return callback(null, Buffer.concat(buf, buflen));
      });
      return promise;
    }
    getTransferEncoding() {
      let transferEncoding = false;
      let contentType = (this.getHeader("Content-Type") || "").toString().toLowerCase().trim();
      if (this.content) {
        transferEncoding = (this.getHeader("Content-Transfer-Encoding") || "").toString().toLowerCase().trim();
        if (!transferEncoding || !["base64", "quoted-printable"].includes(transferEncoding)) {
          if (/^text\//i.test(contentType)) {
            if (this._isPlainText && !this._hasLongLines) {
              transferEncoding = "7bit";
            } else if (typeof this.content === "string" || this.content instanceof Buffer) {
              transferEncoding = this._getTextEncoding(this.content) === "Q" ? "quoted-printable" : "base64";
            } else {
              transferEncoding = this.textEncoding === "B" ? "base64" : "quoted-printable";
            }
          } else if (!/^(multipart|message)\//i.test(contentType)) {
            transferEncoding = transferEncoding || "base64";
          }
        }
      }
      return transferEncoding;
    }
    /**
     * Builds the header block for the mime node. Append \r\n\r\n before writing the content
     *
     * @returns {String} Headers
     */
    buildHeaders() {
      let transferEncoding = this.getTransferEncoding();
      let headers = [];
      if (transferEncoding) {
        this.setHeader("Content-Transfer-Encoding", transferEncoding);
      }
      if (this.filename && !this.getHeader("Content-Disposition")) {
        this.setHeader("Content-Disposition", "attachment");
      }
      if (this.rootNode === this) {
        if (!this.getHeader("Date")) {
          this.setHeader("Date", this.date.toUTCString().replace(/GMT/, "+0000"));
        }
        this.messageId();
        if (!this.getHeader("MIME-Version")) {
          this.setHeader("MIME-Version", "1.0");
        }
        for (let i = this._headers.length - 2; i >= 0; i--) {
          let header = this._headers[i];
          if (header.key === "Content-Type") {
            this._headers.splice(i, 1);
            this._headers.push(header);
          }
        }
      }
      this._headers.forEach((header) => {
        let key = header.key;
        let value = header.value;
        let structured;
        let param;
        let options = {};
        let formattedHeaders = ["From", "Sender", "To", "Cc", "Bcc", "Reply-To", "Date", "References"];
        if (value && typeof value === "object" && !formattedHeaders.includes(key)) {
          Object.keys(value).forEach((key2) => {
            if (key2 !== "value") {
              options[key2] = value[key2];
            }
          });
          value = (value.value || "").toString();
          if (!value.trim()) {
            return;
          }
        }
        if (options.prepared) {
          if (options.foldLines) {
            headers.push(mimeFuncs2.foldLines(key + ": " + value));
          } else {
            headers.push(key + ": " + value);
          }
          return;
        }
        switch (header.key) {
          case "Content-Disposition":
            structured = mimeFuncs2.parseHeaderValue(value);
            if (this.filename) {
              structured.params.filename = this.filename;
            }
            value = mimeFuncs2.buildHeaderValue(structured);
            break;
          case "Content-Type":
            structured = mimeFuncs2.parseHeaderValue(value);
            this._handleContentType(structured);
            if (structured.value.match(/^text\/plain\b/) && typeof this.content === "string" && /[\u0080-\uFFFF]/.test(this.content)) {
              structured.params.charset = "utf-8";
            }
            value = mimeFuncs2.buildHeaderValue(structured);
            if (this.filename) {
              param = this._encodeWords(this.filename);
              if (param !== this.filename || /[\s'"\\;:/=(),<>@[\]?]|^-/.test(param)) {
                param = '"' + param + '"';
              }
              value += "; name=" + param;
            }
            break;
          case "Bcc":
            if (!this.keepBcc) {
              return;
            }
            break;
        }
        value = this._encodeHeaderValue(key, value);
        if (!(value || "").toString().trim()) {
          return;
        }
        if (typeof this.normalizeHeaderKey === "function") {
          let normalized = this.normalizeHeaderKey(key, value);
          if (normalized && typeof normalized === "string" && normalized.length) {
            key = normalized;
          }
        }
        headers.push(mimeFuncs2.foldLines(key + ": " + value, 76));
      });
      return headers.join("\r\n");
    }
    /**
     * Streams the rfc2822 message from the current node. If this is a root node,
     * mandatory header fields are set if missing (Date, Message-Id, MIME-Version)
     *
     * @return {String} Compiled message
     */
    createReadStream(options) {
      options = options || {};
      let stream2 = new PassThrough(options);
      let outputStream = stream2;
      let transform2;
      this.stream(stream2, options, (err2) => {
        if (err2) {
          outputStream.emit("error", err2);
          return;
        }
        stream2.end();
      });
      for (let i = 0, len = this._transforms.length; i < len; i++) {
        transform2 = typeof this._transforms[i] === "function" ? this._transforms[i]() : this._transforms[i];
        outputStream.once("error", (err2) => {
          transform2.emit("error", err2);
        });
        outputStream = outputStream.pipe(transform2);
      }
      transform2 = new LastNewline();
      outputStream.once("error", (err2) => {
        transform2.emit("error", err2);
      });
      outputStream = outputStream.pipe(transform2);
      for (let i = 0, len = this._processFuncs.length; i < len; i++) {
        transform2 = this._processFuncs[i];
        outputStream = transform2(outputStream);
      }
      if (this.newline) {
        const winbreak = ["win", "windows", "dos", "\r\n"].includes(this.newline.toString().toLowerCase());
        const newlineTransform = winbreak ? new LeWindows() : new LeUnix();
        const stream3 = outputStream.pipe(newlineTransform);
        outputStream.on("error", (err2) => stream3.emit("error", err2));
        return stream3;
      }
      return outputStream;
    }
    /**
     * Appends a transform stream object to the transforms list. Final output
     * is passed through this stream before exposing
     *
     * @param {Object} transform Read-Write stream
     */
    transform(transform2) {
      this._transforms.push(transform2);
    }
    /**
     * Appends a post process function. The functon is run after transforms and
     * uses the following syntax
     *
     *   processFunc(input) -> outputStream
     *
     * @param {Object} processFunc Read-Write stream
     */
    processFunc(processFunc) {
      this._processFuncs.push(processFunc);
    }
    stream(outputStream, options, done) {
      let transferEncoding = this.getTransferEncoding();
      let contentStream;
      let localStream;
      let returned = false;
      let callback = (err2) => {
        if (returned) {
          return;
        }
        returned = true;
        done(err2);
      };
      let finalize = () => {
        let childId = 0;
        let processChildNode = () => {
          if (childId >= this.childNodes.length) {
            outputStream.write("\r\n--" + this.boundary + "--\r\n");
            return callback();
          }
          let child = this.childNodes[childId++];
          outputStream.write((childId > 1 ? "\r\n" : "") + "--" + this.boundary + "\r\n");
          child.stream(outputStream, options, (err2) => {
            if (err2) {
              return callback(err2);
            }
            setImmediate(processChildNode);
          });
        };
        if (this.multipart) {
          setImmediate(processChildNode);
        } else {
          return callback();
        }
      };
      let sendContent = () => {
        if (this.content) {
          if (Object.prototype.toString.call(this.content) === "[object Error]") {
            return callback(this.content);
          }
          if (typeof this.content.pipe === "function") {
            this.content.removeListener("error", this._contentErrorHandler);
            this._contentErrorHandler = (err2) => callback(err2);
            this.content.once("error", this._contentErrorHandler);
          }
          let createStream = () => {
            if (["quoted-printable", "base64"].includes(transferEncoding)) {
              contentStream = new (transferEncoding === "base64" ? base642 : qp2).Encoder(options);
              contentStream.pipe(outputStream, {
                end: false
              });
              contentStream.once("end", finalize);
              contentStream.once("error", (err2) => callback(err2));
              localStream = this._getStream(this.content);
              localStream.pipe(contentStream);
            } else {
              localStream = this._getStream(this.content);
              localStream.pipe(outputStream, {
                end: false
              });
              localStream.once("end", finalize);
            }
            localStream.once("error", (err2) => callback(err2));
          };
          if (this.content._resolve) {
            let chunks = [];
            let chunklen = 0;
            let returned2 = false;
            let sourceStream = this._getStream(this.content);
            sourceStream.on("error", (err2) => {
              if (returned2) {
                return;
              }
              returned2 = true;
              callback(err2);
            });
            sourceStream.on("readable", () => {
              let chunk;
              while ((chunk = sourceStream.read()) !== null) {
                chunks.push(chunk);
                chunklen += chunk.length;
              }
            });
            sourceStream.on("end", () => {
              if (returned2) {
                return;
              }
              returned2 = true;
              this.content._resolve = false;
              this.content._resolvedValue = Buffer.concat(chunks, chunklen);
              setImmediate(createStream);
            });
          } else {
            setImmediate(createStream);
          }
          return;
        } else {
          return setImmediate(finalize);
        }
      };
      if (this._raw) {
        setImmediate(() => {
          if (Object.prototype.toString.call(this._raw) === "[object Error]") {
            return callback(this._raw);
          }
          if (typeof this._raw.pipe === "function") {
            this._raw.removeListener("error", this._contentErrorHandler);
          }
          let raw = this._getStream(this._raw);
          raw.pipe(outputStream, {
            end: false
          });
          raw.on("error", (err2) => outputStream.emit("error", err2));
          raw.on("end", finalize);
        });
      } else {
        outputStream.write(this.buildHeaders() + "\r\n\r\n");
        setImmediate(sendContent);
      }
    }
    /**
     * Sets envelope to be used instead of the generated one
     *
     * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}
     */
    setEnvelope(envelope) {
      let list;
      this._envelope = {
        from: false,
        to: []
      };
      if (envelope.from) {
        list = [];
        this._convertAddresses(this._parseAddresses(envelope.from), list);
        list = list.filter((address) => address && address.address);
        if (list.length && list[0]) {
          this._envelope.from = list[0].address;
        }
      }
      ["to", "cc", "bcc"].forEach((key) => {
        if (envelope[key]) {
          this._convertAddresses(this._parseAddresses(envelope[key]), this._envelope.to);
        }
      });
      this._envelope.to = this._envelope.to.map((to) => to.address).filter((address) => address);
      let standardFields = ["to", "cc", "bcc", "from"];
      Object.keys(envelope).forEach((key) => {
        if (!standardFields.includes(key)) {
          this._envelope[key] = envelope[key];
        }
      });
      return this;
    }
    /**
     * Generates and returns an object with parsed address fields
     *
     * @return {Object} Address object
     */
    getAddresses() {
      let addresses = {};
      this._headers.forEach((header) => {
        let key = header.key.toLowerCase();
        if (["from", "sender", "reply-to", "to", "cc", "bcc"].includes(key)) {
          if (!Array.isArray(addresses[key])) {
            addresses[key] = [];
          }
          this._convertAddresses(this._parseAddresses(header.value), addresses[key]);
        }
      });
      return addresses;
    }
    /**
     * Generates and returns SMTP envelope with the sender address and a list of recipients addresses
     *
     * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}
     */
    getEnvelope() {
      if (this._envelope) {
        return this._envelope;
      }
      let envelope = {
        from: false,
        to: []
      };
      this._headers.forEach((header) => {
        let list = [];
        if (header.key === "From" || !envelope.from && ["Reply-To", "Sender"].includes(header.key)) {
          this._convertAddresses(this._parseAddresses(header.value), list);
          if (list.length && list[0]) {
            envelope.from = list[0].address;
          }
        } else if (["To", "Cc", "Bcc"].includes(header.key)) {
          this._convertAddresses(this._parseAddresses(header.value), envelope.to);
        }
      });
      envelope.to = envelope.to.map((to) => to.address);
      return envelope;
    }
    /**
     * Returns Message-Id value. If it does not exist, then creates one
     *
     * @return {String} Message-Id value
     */
    messageId() {
      let messageId = this.getHeader("Message-ID");
      if (!messageId) {
        messageId = this._generateMessageId();
        this.setHeader("Message-ID", messageId);
      }
      return messageId;
    }
    /**
     * Sets pregenerated content that will be used as the output of this node
     *
     * @param {String|Buffer|Stream} Raw MIME contents
     */
    setRaw(raw) {
      this._raw = raw;
      if (this._raw && typeof this._raw.pipe === "function") {
        this._contentErrorHandler = (err2) => {
          this._raw.removeListener("error", this._contentErrorHandler);
          this._raw = err2;
        };
        this._raw.once("error", this._contentErrorHandler);
      }
      return this;
    }
    /////// PRIVATE METHODS
    /**
     * Detects and returns handle to a stream related with the content.
     *
     * @param {Mixed} content Node content
     * @returns {Object} Stream object
     */
    _getStream(content2) {
      let contentStream;
      if (content2._resolvedValue) {
        contentStream = new PassThrough();
        setImmediate(() => {
          try {
            contentStream.end(content2._resolvedValue);
          } catch (_err) {
            contentStream.emit("error", _err);
          }
        });
        return contentStream;
      } else if (typeof content2.pipe === "function") {
        return content2;
      } else if (content2 && typeof content2.path === "string" && !content2.href) {
        if (this.disableFileAccess) {
          contentStream = new PassThrough();
          setImmediate(() => contentStream.emit("error", new Error("File access rejected for " + content2.path)));
          return contentStream;
        }
        return fs.createReadStream(content2.path);
      } else if (content2 && typeof content2.href === "string") {
        if (this.disableUrlAccess) {
          contentStream = new PassThrough();
          setImmediate(() => contentStream.emit("error", new Error("Url access rejected for " + content2.href)));
          return contentStream;
        }
        return nmfetch(content2.href, { headers: content2.httpHeaders });
      } else {
        contentStream = new PassThrough();
        setImmediate(() => {
          try {
            contentStream.end(content2 || "");
          } catch (_err) {
            contentStream.emit("error", _err);
          }
        });
        return contentStream;
      }
    }
    /**
     * Parses addresses. Takes in a single address or an array or an
     * array of address arrays (eg. To: [[first group], [second group],...])
     *
     * @param {Mixed} addresses Addresses to be parsed
     * @return {Array} An array of address objects
     */
    _parseAddresses(addresses) {
      return [].concat.apply(
        [],
        [].concat(addresses).map((address) => {
          if (address && address.address) {
            address.address = this._normalizeAddress(address.address);
            address.name = address.name || "";
            return [address];
          }
          return addressparser(address);
        })
      );
    }
    /**
     * Normalizes a header key, uses Camel-Case form, except for uppercase MIME-
     *
     * @param {String} key Key to be normalized
     * @return {String} key in Camel-Case form
     */
    _normalizeHeaderKey(key) {
      key = (key || "").toString().replace(/\r?\n|\r/g, " ").trim().toLowerCase().replace(/^X-SMTPAPI$|^(MIME|DKIM|ARC|BIMI)\b|^[a-z]|-(SPF|FBL|ID|MD5)$|-[a-z]/gi, (c2) => c2.toUpperCase()).replace(/^Content-Features$/i, "Content-features");
      return key;
    }
    /**
     * Checks if the content type is multipart and defines boundary if needed.
     * Doesn't return anything, modifies object argument instead.
     *
     * @param {Object} structured Parsed header value for 'Content-Type' key
     */
    _handleContentType(structured) {
      this.contentType = structured.value.trim().toLowerCase();
      this.multipart = /^multipart\//i.test(this.contentType) ? this.contentType.substr(this.contentType.indexOf("/") + 1) : false;
      if (this.multipart) {
        this.boundary = structured.params.boundary = structured.params.boundary || this.boundary || this._generateBoundary();
      } else {
        this.boundary = false;
      }
    }
    /**
     * Generates a multipart boundary value
     *
     * @return {String} boundary value
     */
    _generateBoundary() {
      return this.rootNode.boundaryPrefix + "-" + this.rootNode.baseBoundary + "-Part_" + this._nodeId;
    }
    /**
     * Encodes a header value for use in the generated rfc2822 email.
     *
     * @param {String} key Header key
     * @param {String} value Header value
     */
    _encodeHeaderValue(key, value) {
      key = this._normalizeHeaderKey(key);
      switch (key) {
        // Structured headers
        case "From":
        case "Sender":
        case "To":
        case "Cc":
        case "Bcc":
        case "Reply-To":
          return this._convertAddresses(this._parseAddresses(value));
        // values enclosed in <>
        case "Message-ID":
        case "In-Reply-To":
        case "Content-Id":
          value = (value || "").toString().replace(/\r?\n|\r/g, " ");
          if (value.charAt(0) !== "<") {
            value = "<" + value;
          }
          if (value.charAt(value.length - 1) !== ">") {
            value = value + ">";
          }
          return value;
        // space separated list of values enclosed in <>
        case "References":
          value = [].concat.apply(
            [],
            [].concat(value || "").map((elm) => {
              elm = (elm || "").toString().replace(/\r?\n|\r/g, " ").trim();
              return elm.replace(/<[^>]*>/g, (str) => str.replace(/\s/g, "")).split(/\s+/);
            })
          ).map((elm) => {
            if (elm.charAt(0) !== "<") {
              elm = "<" + elm;
            }
            if (elm.charAt(elm.length - 1) !== ">") {
              elm = elm + ">";
            }
            return elm;
          });
          return value.join(" ").trim();
        case "Date":
          if (Object.prototype.toString.call(value) === "[object Date]") {
            return value.toUTCString().replace(/GMT/, "+0000");
          }
          value = (value || "").toString().replace(/\r?\n|\r/g, " ");
          return this._encodeWords(value);
        case "Content-Type":
        case "Content-Disposition":
          return (value || "").toString().replace(/\r?\n|\r/g, " ");
        default:
          value = (value || "").toString().replace(/\r?\n|\r/g, " ");
          return this._encodeWords(value);
      }
    }
    /**
     * Rebuilds address object using punycode and other adjustments
     *
     * @param {Array} addresses An array of address objects
     * @param {Array} [uniqueList] An array to be populated with addresses
     * @return {String} address string
     */
    _convertAddresses(addresses, uniqueList) {
      let values = [];
      uniqueList = uniqueList || [];
      [].concat(addresses || []).forEach((address) => {
        if (address.address) {
          address.address = this._normalizeAddress(address.address);
          if (!address.name) {
            values.push(address.address.indexOf(" ") >= 0 ? `<${address.address}>` : `${address.address}`);
          } else if (address.name) {
            values.push(`${this._encodeAddressName(address.name)} <${address.address}>`);
          }
          if (address.address) {
            if (!uniqueList.filter((a) => a.address === address.address).length) {
              uniqueList.push(address);
            }
          }
        } else if (address.group) {
          let groupListAddresses = (address.group.length ? this._convertAddresses(address.group, uniqueList) : "").trim();
          values.push(`${this._encodeAddressName(address.name)}:${groupListAddresses};`);
        }
      });
      return values.join(", ");
    }
    /**
     * Normalizes an email address
     *
     * @param {Array} address An array of address objects
     * @return {String} address string
     */
    _normalizeAddress(address) {
      address = (address || "").toString().replace(/[\x00-\x1F<>]+/g, " ").trim();
      let lastAt = address.lastIndexOf("@");
      if (lastAt < 0) {
        return address;
      }
      let user = address.substr(0, lastAt);
      let domain = address.substr(lastAt + 1);
      let encodedDomain;
      try {
        encodedDomain = punycode.toASCII(domain.toLowerCase());
      } catch (_err) {
      }
      if (user.indexOf(" ") >= 0) {
        if (user.charAt(0) !== '"') {
          user = '"' + user;
        }
        if (user.substr(-1) !== '"') {
          user = user + '"';
        }
      }
      return `${user}@${encodedDomain}`;
    }
    /**
     * If needed, mime encodes the name part
     *
     * @param {String} name Name part of an address
     * @returns {String} Mime word encoded string if needed
     */
    _encodeAddressName(name2) {
      if (!/^[\w ]*$/.test(name2)) {
        if (/^[\x20-\x7e]*$/.test(name2)) {
          return '"' + name2.replace(/([\\"])/g, "\\$1") + '"';
        } else {
          return mimeFuncs2.encodeWord(name2, this._getTextEncoding(name2), 52);
        }
      }
      return name2;
    }
    /**
     * If needed, mime encodes the name part
     *
     * @param {String} name Name part of an address
     * @returns {String} Mime word encoded string if needed
     */
    _encodeWords(value) {
      return mimeFuncs2.encodeWords(value, this._getTextEncoding(value), 52, true);
    }
    /**
     * Detects best mime encoding for a text value
     *
     * @param {String} value Value to check for
     * @return {String} either 'Q' or 'B'
     */
    _getTextEncoding(value) {
      value = (value || "").toString();
      let encoding = this.textEncoding;
      let latinLen;
      let nonLatinLen;
      if (!encoding) {
        nonLatinLen = (value.match(/[\x00-\x08\x0B\x0C\x0E-\x1F\u0080-\uFFFF]/g) || []).length;
        latinLen = (value.match(/[a-z]/gi) || []).length;
        encoding = nonLatinLen < latinLen ? "Q" : "B";
      }
      return encoding;
    }
    /**
     * Generates a message id
     *
     * @return {String} Random Message-ID value
     */
    _generateMessageId() {
      return "<" + [2, 2, 2, 6].reduce(
        // crux to generate UUID-like random strings
        (prev, len) => prev + "-" + crypto2.randomBytes(len).toString("hex"),
        crypto2.randomBytes(4).toString("hex")
      ) + "@" + // try to use the domain of the FROM address or fallback to server hostname
      (this.getEnvelope().from || this.hostname || "localhost").split("@").pop() + ">";
    }
  }
  mimeNode = MimeNode;
  return mimeNode;
}
var mailComposer;
var hasRequiredMailComposer;
function requireMailComposer() {
  if (hasRequiredMailComposer) return mailComposer;
  hasRequiredMailComposer = 1;
  const MimeNode = requireMimeNode();
  const mimeFuncs2 = requireMimeFuncs();
  const parseDataURI = requireShared().parseDataURI;
  class MailComposer {
    constructor(mail) {
      this.mail = mail || {};
      this.message = false;
    }
    /**
     * Builds MimeNode instance
     */
    compile() {
      this._alternatives = this.getAlternatives();
      this._htmlNode = this._alternatives.filter((alternative) => /^text\/html\b/i.test(alternative.contentType)).pop();
      this._attachments = this.getAttachments(!!this._htmlNode);
      this._useRelated = !!(this._htmlNode && this._attachments.related.length);
      this._useAlternative = this._alternatives.length > 1;
      this._useMixed = this._attachments.attached.length > 1 || this._alternatives.length && this._attachments.attached.length === 1;
      if (this.mail.raw) {
        this.message = new MimeNode("message/rfc822", { newline: this.mail.newline }).setRaw(this.mail.raw);
      } else if (this._useMixed) {
        this.message = this._createMixed();
      } else if (this._useAlternative) {
        this.message = this._createAlternative();
      } else if (this._useRelated) {
        this.message = this._createRelated();
      } else {
        this.message = this._createContentNode(
          false,
          [].concat(this._alternatives || []).concat(this._attachments.attached || []).shift() || {
            contentType: "text/plain",
            content: ""
          }
        );
      }
      if (this.mail.headers) {
        this.message.addHeader(this.mail.headers);
      }
      ["from", "sender", "to", "cc", "bcc", "reply-to", "in-reply-to", "references", "subject", "message-id", "date"].forEach((header) => {
        let key = header.replace(/-(\w)/g, (o2, c2) => c2.toUpperCase());
        if (this.mail[key]) {
          this.message.setHeader(header, this.mail[key]);
        }
      });
      if (this.mail.envelope) {
        this.message.setEnvelope(this.mail.envelope);
      }
      this.message.messageId();
      return this.message;
    }
    /**
     * List all attachments. Resulting attachment objects can be used as input for MimeNode nodes
     *
     * @param {Boolean} findRelated If true separate related attachments from attached ones
     * @returns {Object} An object of arrays (`related` and `attached`)
     */
    getAttachments(findRelated) {
      let icalEvent, eventObject;
      let attachments = [].concat(this.mail.attachments || []).map((attachment, i) => {
        let data;
        if (/^data:/i.test(attachment.path || attachment.href)) {
          attachment = this._processDataUrl(attachment);
        }
        let contentType = attachment.contentType || mimeFuncs2.detectMimeType(attachment.filename || attachment.path || attachment.href || "bin");
        let isImage = /^image\//i.test(contentType);
        let isMessageNode = /^message\//i.test(contentType);
        let contentDisposition = attachment.contentDisposition || (isMessageNode || isImage && attachment.cid ? "inline" : "attachment");
        let contentTransferEncoding;
        if ("contentTransferEncoding" in attachment) {
          contentTransferEncoding = attachment.contentTransferEncoding;
        } else if (isMessageNode) {
          contentTransferEncoding = "8bit";
        } else {
          contentTransferEncoding = "base64";
        }
        data = {
          contentType,
          contentDisposition,
          contentTransferEncoding
        };
        if (attachment.filename) {
          data.filename = attachment.filename;
        } else if (!isMessageNode && attachment.filename !== false) {
          data.filename = (attachment.path || attachment.href || "").split("/").pop().split("?").shift() || "attachment-" + (i + 1);
          if (data.filename.indexOf(".") < 0) {
            data.filename += "." + mimeFuncs2.detectExtension(data.contentType);
          }
        }
        if (/^https?:\/\//i.test(attachment.path)) {
          attachment.href = attachment.path;
          attachment.path = void 0;
        }
        if (attachment.cid) {
          data.cid = attachment.cid;
        }
        if (attachment.raw) {
          data.raw = attachment.raw;
        } else if (attachment.path) {
          data.content = {
            path: attachment.path
          };
        } else if (attachment.href) {
          data.content = {
            href: attachment.href,
            httpHeaders: attachment.httpHeaders
          };
        } else {
          data.content = attachment.content || "";
        }
        if (attachment.encoding) {
          data.encoding = attachment.encoding;
        }
        if (attachment.headers) {
          data.headers = attachment.headers;
        }
        return data;
      });
      if (this.mail.icalEvent) {
        if (typeof this.mail.icalEvent === "object" && (this.mail.icalEvent.content || this.mail.icalEvent.path || this.mail.icalEvent.href || this.mail.icalEvent.raw)) {
          icalEvent = this.mail.icalEvent;
        } else {
          icalEvent = {
            content: this.mail.icalEvent
          };
        }
        eventObject = {};
        Object.keys(icalEvent).forEach((key) => {
          eventObject[key] = icalEvent[key];
        });
        eventObject.contentType = "application/ics";
        if (!eventObject.headers) {
          eventObject.headers = {};
        }
        eventObject.filename = eventObject.filename || "invite.ics";
        eventObject.headers["Content-Disposition"] = "attachment";
        eventObject.headers["Content-Transfer-Encoding"] = "base64";
      }
      if (!findRelated) {
        return {
          attached: attachments.concat(eventObject || []),
          related: []
        };
      } else {
        return {
          attached: attachments.filter((attachment) => !attachment.cid).concat(eventObject || []),
          related: attachments.filter((attachment) => !!attachment.cid)
        };
      }
    }
    /**
     * List alternatives. Resulting objects can be used as input for MimeNode nodes
     *
     * @returns {Array} An array of alternative elements. Includes the `text` and `html` values as well
     */
    getAlternatives() {
      let alternatives = [], text2, html2, watchHtml, amp, icalEvent, eventObject;
      if (this.mail.text) {
        if (typeof this.mail.text === "object" && (this.mail.text.content || this.mail.text.path || this.mail.text.href || this.mail.text.raw)) {
          text2 = this.mail.text;
        } else {
          text2 = {
            content: this.mail.text
          };
        }
        text2.contentType = "text/plain; charset=utf-8";
      }
      if (this.mail.watchHtml) {
        if (typeof this.mail.watchHtml === "object" && (this.mail.watchHtml.content || this.mail.watchHtml.path || this.mail.watchHtml.href || this.mail.watchHtml.raw)) {
          watchHtml = this.mail.watchHtml;
        } else {
          watchHtml = {
            content: this.mail.watchHtml
          };
        }
        watchHtml.contentType = "text/watch-html; charset=utf-8";
      }
      if (this.mail.amp) {
        if (typeof this.mail.amp === "object" && (this.mail.amp.content || this.mail.amp.path || this.mail.amp.href || this.mail.amp.raw)) {
          amp = this.mail.amp;
        } else {
          amp = {
            content: this.mail.amp
          };
        }
        amp.contentType = "text/x-amp-html; charset=utf-8";
      }
      if (this.mail.icalEvent) {
        if (typeof this.mail.icalEvent === "object" && (this.mail.icalEvent.content || this.mail.icalEvent.path || this.mail.icalEvent.href || this.mail.icalEvent.raw)) {
          icalEvent = this.mail.icalEvent;
        } else {
          icalEvent = {
            content: this.mail.icalEvent
          };
        }
        eventObject = {};
        Object.keys(icalEvent).forEach((key) => {
          eventObject[key] = icalEvent[key];
        });
        if (eventObject.content && typeof eventObject.content === "object") {
          eventObject.content._resolve = true;
        }
        eventObject.filename = false;
        eventObject.contentType = "text/calendar; charset=utf-8; method=" + (eventObject.method || "PUBLISH").toString().trim().toUpperCase();
        if (!eventObject.headers) {
          eventObject.headers = {};
        }
      }
      if (this.mail.html) {
        if (typeof this.mail.html === "object" && (this.mail.html.content || this.mail.html.path || this.mail.html.href || this.mail.html.raw)) {
          html2 = this.mail.html;
        } else {
          html2 = {
            content: this.mail.html
          };
        }
        html2.contentType = "text/html; charset=utf-8";
      }
      [].concat(text2 || []).concat(watchHtml || []).concat(amp || []).concat(html2 || []).concat(eventObject || []).concat(this.mail.alternatives || []).forEach((alternative) => {
        let data;
        if (/^data:/i.test(alternative.path || alternative.href)) {
          alternative = this._processDataUrl(alternative);
        }
        data = {
          contentType: alternative.contentType || mimeFuncs2.detectMimeType(alternative.filename || alternative.path || alternative.href || "txt"),
          contentTransferEncoding: alternative.contentTransferEncoding
        };
        if (alternative.filename) {
          data.filename = alternative.filename;
        }
        if (/^https?:\/\//i.test(alternative.path)) {
          alternative.href = alternative.path;
          alternative.path = void 0;
        }
        if (alternative.raw) {
          data.raw = alternative.raw;
        } else if (alternative.path) {
          data.content = {
            path: alternative.path
          };
        } else if (alternative.href) {
          data.content = {
            href: alternative.href
          };
        } else {
          data.content = alternative.content || "";
        }
        if (alternative.encoding) {
          data.encoding = alternative.encoding;
        }
        if (alternative.headers) {
          data.headers = alternative.headers;
        }
        alternatives.push(data);
      });
      return alternatives;
    }
    /**
     * Builds multipart/mixed node. It should always contain different type of elements on the same level
     * eg. text + attachments
     *
     * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created
     * @returns {Object} MimeNode node element
     */
    _createMixed(parentNode) {
      let node;
      if (!parentNode) {
        node = new MimeNode("multipart/mixed", {
          baseBoundary: this.mail.baseBoundary,
          textEncoding: this.mail.textEncoding,
          boundaryPrefix: this.mail.boundaryPrefix,
          disableUrlAccess: this.mail.disableUrlAccess,
          disableFileAccess: this.mail.disableFileAccess,
          normalizeHeaderKey: this.mail.normalizeHeaderKey,
          newline: this.mail.newline
        });
      } else {
        node = parentNode.createChild("multipart/mixed", {
          disableUrlAccess: this.mail.disableUrlAccess,
          disableFileAccess: this.mail.disableFileAccess,
          normalizeHeaderKey: this.mail.normalizeHeaderKey,
          newline: this.mail.newline
        });
      }
      if (this._useAlternative) {
        this._createAlternative(node);
      } else if (this._useRelated) {
        this._createRelated(node);
      }
      [].concat(!this._useAlternative && this._alternatives || []).concat(this._attachments.attached || []).forEach((element) => {
        if (!this._useRelated || element !== this._htmlNode) {
          this._createContentNode(node, element);
        }
      });
      return node;
    }
    /**
     * Builds multipart/alternative node. It should always contain same type of elements on the same level
     * eg. text + html view of the same data
     *
     * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created
     * @returns {Object} MimeNode node element
     */
    _createAlternative(parentNode) {
      let node;
      if (!parentNode) {
        node = new MimeNode("multipart/alternative", {
          baseBoundary: this.mail.baseBoundary,
          textEncoding: this.mail.textEncoding,
          boundaryPrefix: this.mail.boundaryPrefix,
          disableUrlAccess: this.mail.disableUrlAccess,
          disableFileAccess: this.mail.disableFileAccess,
          normalizeHeaderKey: this.mail.normalizeHeaderKey,
          newline: this.mail.newline
        });
      } else {
        node = parentNode.createChild("multipart/alternative", {
          disableUrlAccess: this.mail.disableUrlAccess,
          disableFileAccess: this.mail.disableFileAccess,
          normalizeHeaderKey: this.mail.normalizeHeaderKey,
          newline: this.mail.newline
        });
      }
      this._alternatives.forEach((alternative) => {
        if (this._useRelated && this._htmlNode === alternative) {
          this._createRelated(node);
        } else {
          this._createContentNode(node, alternative);
        }
      });
      return node;
    }
    /**
     * Builds multipart/related node. It should always contain html node with related attachments
     *
     * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created
     * @returns {Object} MimeNode node element
     */
    _createRelated(parentNode) {
      let node;
      if (!parentNode) {
        node = new MimeNode('multipart/related; type="text/html"', {
          baseBoundary: this.mail.baseBoundary,
          textEncoding: this.mail.textEncoding,
          boundaryPrefix: this.mail.boundaryPrefix,
          disableUrlAccess: this.mail.disableUrlAccess,
          disableFileAccess: this.mail.disableFileAccess,
          normalizeHeaderKey: this.mail.normalizeHeaderKey,
          newline: this.mail.newline
        });
      } else {
        node = parentNode.createChild('multipart/related; type="text/html"', {
          disableUrlAccess: this.mail.disableUrlAccess,
          disableFileAccess: this.mail.disableFileAccess,
          normalizeHeaderKey: this.mail.normalizeHeaderKey,
          newline: this.mail.newline
        });
      }
      this._createContentNode(node, this._htmlNode);
      this._attachments.related.forEach((alternative) => this._createContentNode(node, alternative));
      return node;
    }
    /**
     * Creates a regular node with contents
     *
     * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created
     * @param {Object} element Node data
     * @returns {Object} MimeNode node element
     */
    _createContentNode(parentNode, element) {
      element = element || {};
      element.content = element.content || "";
      let node;
      let encoding = (element.encoding || "utf8").toString().toLowerCase().replace(/[-_\s]/g, "");
      if (!parentNode) {
        node = new MimeNode(element.contentType, {
          filename: element.filename,
          baseBoundary: this.mail.baseBoundary,
          textEncoding: this.mail.textEncoding,
          boundaryPrefix: this.mail.boundaryPrefix,
          disableUrlAccess: this.mail.disableUrlAccess,
          disableFileAccess: this.mail.disableFileAccess,
          normalizeHeaderKey: this.mail.normalizeHeaderKey,
          newline: this.mail.newline
        });
      } else {
        node = parentNode.createChild(element.contentType, {
          filename: element.filename,
          textEncoding: this.mail.textEncoding,
          disableUrlAccess: this.mail.disableUrlAccess,
          disableFileAccess: this.mail.disableFileAccess,
          normalizeHeaderKey: this.mail.normalizeHeaderKey,
          newline: this.mail.newline
        });
      }
      if (element.headers) {
        node.addHeader(element.headers);
      }
      if (element.cid) {
        node.setHeader("Content-Id", "<" + element.cid.replace(/[<>]/g, "") + ">");
      }
      if (element.contentTransferEncoding) {
        node.setHeader("Content-Transfer-Encoding", element.contentTransferEncoding);
      } else if (this.mail.encoding && /^text\//i.test(element.contentType)) {
        node.setHeader("Content-Transfer-Encoding", this.mail.encoding);
      }
      if (!/^text\//i.test(element.contentType) || element.contentDisposition) {
        node.setHeader(
          "Content-Disposition",
          element.contentDisposition || (element.cid && /^image\//i.test(element.contentType) ? "inline" : "attachment")
        );
      }
      if (typeof element.content === "string" && !["utf8", "usascii", "ascii"].includes(encoding)) {
        element.content = Buffer.from(element.content, encoding);
      }
      if (element.raw) {
        node.setRaw(element.raw);
      } else {
        node.setContent(element.content);
      }
      return node;
    }
    /**
     * Parses data uri and converts it to a Buffer
     *
     * @param {Object} element Content element
     * @return {Object} Parsed element
     */
    _processDataUrl(element) {
      const dataUrl = element.path || element.href;
      if (!dataUrl || typeof dataUrl !== "string") {
        return element;
      }
      if (!dataUrl.startsWith("data:")) {
        return element;
      }
      if (dataUrl.length > 52428800) {
        let detectedType = "application/octet-stream";
        const commaPos = dataUrl.indexOf(",");
        if (commaPos > 0 && commaPos < 200) {
          const header = dataUrl.substring(5, commaPos);
          const parts = header.split(";");
          if (parts[0] && parts[0].includes("/")) {
            detectedType = parts[0].trim();
          }
        }
        return Object.assign({}, element, {
          path: false,
          href: false,
          content: Buffer.alloc(0),
          contentType: element.contentType || detectedType
        });
      }
      let parsedDataUri;
      try {
        parsedDataUri = parseDataURI(dataUrl);
      } catch (_err) {
        return element;
      }
      if (!parsedDataUri) {
        return element;
      }
      element.content = parsedDataUri.data;
      element.contentType = element.contentType || parsedDataUri.contentType;
      if ("path" in element) {
        element.path = false;
      }
      if ("href" in element) {
        element.href = false;
      }
      return element;
    }
  }
  mailComposer = MailComposer;
  return mailComposer;
}
var messageParser;
var hasRequiredMessageParser;
function requireMessageParser() {
  if (hasRequiredMessageParser) return messageParser;
  hasRequiredMessageParser = 1;
  const Transform = require$$0$c.Transform;
  class MessageParser extends Transform {
    constructor(options) {
      super(options);
      this.lastBytes = Buffer.alloc(4);
      this.headersParsed = false;
      this.headerBytes = 0;
      this.headerChunks = [];
      this.rawHeaders = false;
      this.bodySize = 0;
    }
    /**
     * Keeps count of the last 4 bytes in order to detect line breaks on chunk boundaries
     *
     * @param {Buffer} data Next data chunk from the stream
     */
    updateLastBytes(data) {
      let lblen = this.lastBytes.length;
      let nblen = Math.min(data.length, lblen);
      for (let i = 0, len = lblen - nblen; i < len; i++) {
        this.lastBytes[i] = this.lastBytes[i + nblen];
      }
      for (let i = 1; i <= nblen; i++) {
        this.lastBytes[lblen - i] = data[data.length - i];
      }
    }
    /**
     * Finds and removes message headers from the remaining body. We want to keep
     * headers separated until final delivery to be able to modify these
     *
     * @param {Buffer} data Next chunk of data
     * @return {Boolean} Returns true if headers are already found or false otherwise
     */
    checkHeaders(data) {
      if (this.headersParsed) {
        return true;
      }
      let lblen = this.lastBytes.length;
      let headerPos = 0;
      this.curLinePos = 0;
      for (let i = 0, len = this.lastBytes.length + data.length; i < len; i++) {
        let chr;
        if (i < lblen) {
          chr = this.lastBytes[i];
        } else {
          chr = data[i - lblen];
        }
        if (chr === 10 && i) {
          let pr1 = i - 1 < lblen ? this.lastBytes[i - 1] : data[i - 1 - lblen];
          let pr2 = i > 1 ? i - 2 < lblen ? this.lastBytes[i - 2] : data[i - 2 - lblen] : false;
          if (pr1 === 10) {
            this.headersParsed = true;
            headerPos = i - lblen + 1;
            this.headerBytes += headerPos;
            break;
          } else if (pr1 === 13 && pr2 === 10) {
            this.headersParsed = true;
            headerPos = i - lblen + 1;
            this.headerBytes += headerPos;
            break;
          }
        }
      }
      if (this.headersParsed) {
        this.headerChunks.push(data.slice(0, headerPos));
        this.rawHeaders = Buffer.concat(this.headerChunks, this.headerBytes);
        this.headerChunks = null;
        this.emit("headers", this.parseHeaders());
        if (data.length - 1 > headerPos) {
          let chunk = data.slice(headerPos);
          this.bodySize += chunk.length;
          setImmediate(() => this.push(chunk));
        }
        return false;
      } else {
        this.headerBytes += data.length;
        this.headerChunks.push(data);
      }
      this.updateLastBytes(data);
      return false;
    }
    _transform(chunk, encoding, callback) {
      if (!chunk || !chunk.length) {
        return callback();
      }
      if (typeof chunk === "string") {
        chunk = Buffer.from(chunk, encoding);
      }
      let headersFound;
      try {
        headersFound = this.checkHeaders(chunk);
      } catch (E) {
        return callback(E);
      }
      if (headersFound) {
        this.bodySize += chunk.length;
        this.push(chunk);
      }
      setImmediate(callback);
    }
    _flush(callback) {
      if (this.headerChunks) {
        let chunk = Buffer.concat(this.headerChunks, this.headerBytes);
        this.bodySize += chunk.length;
        this.push(chunk);
        this.headerChunks = null;
      }
      callback();
    }
    parseHeaders() {
      let lines = (this.rawHeaders || "").toString().split(/\r?\n/);
      for (let i = lines.length - 1; i > 0; i--) {
        if (/^\s/.test(lines[i])) {
          lines[i - 1] += "\n" + lines[i];
          lines.splice(i, 1);
        }
      }
      return lines.filter((line2) => line2.trim()).map((line2) => ({
        key: line2.substr(0, line2.indexOf(":")).trim().toLowerCase(),
        line: line2
      }));
    }
  }
  messageParser = MessageParser;
  return messageParser;
}
var relaxedBody;
var hasRequiredRelaxedBody;
function requireRelaxedBody() {
  if (hasRequiredRelaxedBody) return relaxedBody;
  hasRequiredRelaxedBody = 1;
  const Transform = require$$0$c.Transform;
  const crypto2 = require$$0$5;
  class RelaxedBody extends Transform {
    constructor(options) {
      super();
      options = options || {};
      this.chunkBuffer = [];
      this.chunkBufferLen = 0;
      this.bodyHash = crypto2.createHash(options.hashAlgo || "sha1");
      this.remainder = "";
      this.byteLength = 0;
      this.debug = options.debug;
      this._debugBody = options.debug ? [] : false;
    }
    updateHash(chunk) {
      let bodyStr;
      let nextRemainder = "";
      let state = "file";
      for (let i = chunk.length - 1; i >= 0; i--) {
        let c2 = chunk[i];
        if (state === "file" && (c2 === 10 || c2 === 13)) ;
        else if (state === "file" && (c2 === 9 || c2 === 32)) {
          state = "line";
        } else if (state === "line" && (c2 === 9 || c2 === 32)) ;
        else if (state === "file" || state === "line") {
          state = "body";
          if (i === chunk.length - 1) {
            break;
          }
        }
        if (i === 0) {
          if (state === "file" && (!this.remainder || /[\r\n]$/.test(this.remainder)) || state === "line" && (!this.remainder || /[ \t]$/.test(this.remainder))) {
            this.remainder += chunk.toString("binary");
            return;
          } else if (state === "line" || state === "file") {
            nextRemainder = chunk.toString("binary");
            chunk = false;
            break;
          }
        }
        if (state !== "body") {
          continue;
        }
        nextRemainder = chunk.slice(i + 1).toString("binary");
        chunk = chunk.slice(0, i + 1);
        break;
      }
      let needsFixing = !!this.remainder;
      if (chunk && !needsFixing) {
        for (let i = 0, len = chunk.length; i < len; i++) {
          if (i && chunk[i] === 10 && chunk[i - 1] !== 13) {
            needsFixing = true;
            break;
          } else if (i && chunk[i] === 13 && chunk[i - 1] === 32) {
            needsFixing = true;
            break;
          } else if (i && chunk[i] === 32 && chunk[i - 1] === 32) {
            needsFixing = true;
            break;
          } else if (chunk[i] === 9) {
            needsFixing = true;
            break;
          }
        }
      }
      if (needsFixing) {
        bodyStr = this.remainder + (chunk ? chunk.toString("binary") : "");
        this.remainder = nextRemainder;
        bodyStr = bodyStr.replace(/\r?\n/g, "\n").replace(/[ \t]*$/gm, "").replace(/[ \t]+/gm, " ").replace(/\n/g, "\r\n");
        chunk = Buffer.from(bodyStr, "binary");
      } else if (nextRemainder) {
        this.remainder = nextRemainder;
      }
      if (this.debug) {
        this._debugBody.push(chunk);
      }
      this.bodyHash.update(chunk);
    }
    _transform(chunk, encoding, callback) {
      if (!chunk || !chunk.length) {
        return callback();
      }
      if (typeof chunk === "string") {
        chunk = Buffer.from(chunk, encoding);
      }
      this.updateHash(chunk);
      this.byteLength += chunk.length;
      this.push(chunk);
      callback();
    }
    _flush(callback) {
      if (/[\r\n]$/.test(this.remainder) && this.byteLength > 2) {
        this.bodyHash.update(Buffer.from("\r\n"));
      }
      if (!this.byteLength) {
        this.push(Buffer.from("\r\n"));
      }
      this.emit("hash", this.bodyHash.digest("base64"), this.debug ? Buffer.concat(this._debugBody) : false);
      callback();
    }
  }
  relaxedBody = RelaxedBody;
  return relaxedBody;
}
var sign = { exports: {} };
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign) return sign.exports;
  hasRequiredSign = 1;
  const punycode = requirePunycode();
  const mimeFuncs2 = requireMimeFuncs();
  const crypto2 = require$$0$5;
  sign.exports = (headers, hashAlgo, bodyHash, options) => {
    options = options || {};
    let defaultFieldNames = "From:Sender:Reply-To:Subject:Date:Message-ID:To:Cc:MIME-Version:Content-Type:Content-Transfer-Encoding:Content-ID:Content-Description:Resent-Date:Resent-From:Resent-Sender:Resent-To:Resent-Cc:Resent-Message-ID:In-Reply-To:References:List-Id:List-Help:List-Unsubscribe:List-Subscribe:List-Post:List-Owner:List-Archive";
    let fieldNames = options.headerFieldNames || defaultFieldNames;
    let canonicalizedHeaderData = relaxedHeaders(headers, fieldNames, options.skipFields);
    let dkimHeader = generateDKIMHeader(options.domainName, options.keySelector, canonicalizedHeaderData.fieldNames, hashAlgo, bodyHash);
    let signer, signature;
    canonicalizedHeaderData.headers += "dkim-signature:" + relaxedHeaderLine(dkimHeader);
    signer = crypto2.createSign(("rsa-" + hashAlgo).toUpperCase());
    signer.update(canonicalizedHeaderData.headers);
    try {
      signature = signer.sign(options.privateKey, "base64");
    } catch (_E) {
      return false;
    }
    return dkimHeader + signature.replace(/(^.{73}|.{75}(?!\r?\n|\r))/g, "$&\r\n ").trim();
  };
  sign.exports.relaxedHeaders = relaxedHeaders;
  function generateDKIMHeader(domainName, keySelector, fieldNames, hashAlgo, bodyHash) {
    let dkim2 = [
      "v=1",
      "a=rsa-" + hashAlgo,
      "c=relaxed/relaxed",
      "d=" + punycode.toASCII(domainName),
      "q=dns/txt",
      "s=" + keySelector,
      "bh=" + bodyHash,
      "h=" + fieldNames
    ].join("; ");
    return mimeFuncs2.foldLines("DKIM-Signature: " + dkim2, 76) + ";\r\n b=";
  }
  function relaxedHeaders(headers, fieldNames, skipFields) {
    let includedFields = /* @__PURE__ */ new Set();
    let skip = /* @__PURE__ */ new Set();
    let headerFields = /* @__PURE__ */ new Map();
    (skipFields || "").toLowerCase().split(":").forEach((field) => {
      skip.add(field.trim());
    });
    (fieldNames || "").toLowerCase().split(":").filter((field) => !skip.has(field.trim())).forEach((field) => {
      includedFields.add(field.trim());
    });
    for (let i = headers.length - 1; i >= 0; i--) {
      let line2 = headers[i];
      if (includedFields.has(line2.key) && !headerFields.has(line2.key)) {
        headerFields.set(line2.key, relaxedHeaderLine(line2.line));
      }
    }
    let headersList = [];
    let fields2 = [];
    includedFields.forEach((field) => {
      if (headerFields.has(field)) {
        fields2.push(field);
        headersList.push(field + ":" + headerFields.get(field));
      }
    });
    return {
      headers: headersList.join("\r\n") + "\r\n",
      fieldNames: fields2.join(":")
    };
  }
  function relaxedHeaderLine(line2) {
    return line2.substr(line2.indexOf(":") + 1).replace(/\r?\n/g, "").replace(/\s+/g, " ").trim();
  }
  return sign.exports;
}
var dkim;
var hasRequiredDkim;
function requireDkim() {
  if (hasRequiredDkim) return dkim;
  hasRequiredDkim = 1;
  const MessageParser = requireMessageParser();
  const RelaxedBody = requireRelaxedBody();
  const sign2 = requireSign();
  const PassThrough = require$$0$c.PassThrough;
  const fs = require$$1$2;
  const path = require$$0$6;
  const crypto2 = require$$0$5;
  const DKIM_ALGO = "sha256";
  const MAX_MESSAGE_SIZE = 2 * 1024 * 1024;
  class DKIMSigner {
    constructor(options, keys, input, output) {
      this.options = options || {};
      this.keys = keys;
      this.cacheTreshold = Number(this.options.cacheTreshold) || MAX_MESSAGE_SIZE;
      this.hashAlgo = this.options.hashAlgo || DKIM_ALGO;
      this.cacheDir = this.options.cacheDir || false;
      this.chunks = [];
      this.chunklen = 0;
      this.readPos = 0;
      this.cachePath = this.cacheDir ? path.join(this.cacheDir, "message." + Date.now() + "-" + crypto2.randomBytes(14).toString("hex")) : false;
      this.cache = false;
      this.headers = false;
      this.bodyHash = false;
      this.parser = false;
      this.relaxedBody = false;
      this.input = input;
      this.output = output;
      this.output.usingCache = false;
      this.hasErrored = false;
      this.input.on("error", (err2) => {
        this.hasErrored = true;
        this.cleanup();
        output.emit("error", err2);
      });
    }
    cleanup() {
      if (!this.cache || !this.cachePath) {
        return;
      }
      fs.unlink(this.cachePath, () => false);
    }
    createReadCache() {
      this.cache = fs.createReadStream(this.cachePath);
      this.cache.once("error", (err2) => {
        this.cleanup();
        this.output.emit("error", err2);
      });
      this.cache.once("close", () => {
        this.cleanup();
      });
      this.cache.pipe(this.output);
    }
    sendNextChunk() {
      if (this.hasErrored) {
        return;
      }
      if (this.readPos >= this.chunks.length) {
        if (!this.cache) {
          return this.output.end();
        }
        return this.createReadCache();
      }
      let chunk = this.chunks[this.readPos++];
      if (this.output.write(chunk) === false) {
        return this.output.once("drain", () => {
          this.sendNextChunk();
        });
      }
      setImmediate(() => this.sendNextChunk());
    }
    sendSignedOutput() {
      let keyPos = 0;
      let signNextKey = () => {
        if (keyPos >= this.keys.length) {
          this.output.write(this.parser.rawHeaders);
          return setImmediate(() => this.sendNextChunk());
        }
        let key = this.keys[keyPos++];
        let dkimField = sign2(this.headers, this.hashAlgo, this.bodyHash, {
          domainName: key.domainName,
          keySelector: key.keySelector,
          privateKey: key.privateKey,
          headerFieldNames: this.options.headerFieldNames,
          skipFields: this.options.skipFields
        });
        if (dkimField) {
          this.output.write(Buffer.from(dkimField + "\r\n"));
        }
        return setImmediate(signNextKey);
      };
      if (this.bodyHash && this.headers) {
        return signNextKey();
      }
      this.output.write(this.parser.rawHeaders);
      this.sendNextChunk();
    }
    createWriteCache() {
      this.output.usingCache = true;
      this.cache = fs.createWriteStream(this.cachePath);
      this.cache.once("error", (err2) => {
        this.cleanup();
        this.relaxedBody.unpipe(this.cache);
        this.relaxedBody.on("readable", () => {
          while (this.relaxedBody.read() !== null) {
          }
        });
        this.hasErrored = true;
        this.output.emit("error", err2);
      });
      this.cache.once("close", () => {
        this.sendSignedOutput();
      });
      this.relaxedBody.removeAllListeners("readable");
      this.relaxedBody.pipe(this.cache);
    }
    signStream() {
      this.parser = new MessageParser();
      this.relaxedBody = new RelaxedBody({
        hashAlgo: this.hashAlgo
      });
      this.parser.on("headers", (value) => {
        this.headers = value;
      });
      this.relaxedBody.on("hash", (value) => {
        this.bodyHash = value;
      });
      this.relaxedBody.on("readable", () => {
        let chunk;
        if (this.cache) {
          return;
        }
        while ((chunk = this.relaxedBody.read()) !== null) {
          this.chunks.push(chunk);
          this.chunklen += chunk.length;
          if (this.chunklen >= this.cacheTreshold && this.cachePath) {
            return this.createWriteCache();
          }
        }
      });
      this.relaxedBody.on("end", () => {
        if (this.cache) {
          return;
        }
        this.sendSignedOutput();
      });
      this.parser.pipe(this.relaxedBody);
      setImmediate(() => this.input.pipe(this.parser));
    }
  }
  class DKIM {
    constructor(options) {
      this.options = options || {};
      this.keys = [].concat(
        this.options.keys || {
          domainName: options.domainName,
          keySelector: options.keySelector,
          privateKey: options.privateKey
        }
      );
    }
    sign(input, extraOptions) {
      let output = new PassThrough();
      let inputStream = input;
      let writeValue = false;
      if (Buffer.isBuffer(input)) {
        writeValue = input;
        inputStream = new PassThrough();
      } else if (typeof input === "string") {
        writeValue = Buffer.from(input);
        inputStream = new PassThrough();
      }
      let options = this.options;
      if (extraOptions && Object.keys(extraOptions).length) {
        options = {};
        Object.keys(this.options || {}).forEach((key) => {
          options[key] = this.options[key];
        });
        Object.keys(extraOptions || {}).forEach((key) => {
          if (!(key in options)) {
            options[key] = extraOptions[key];
          }
        });
      }
      let signer = new DKIMSigner(options, this.keys, inputStream, output);
      setImmediate(() => {
        signer.signStream();
        if (writeValue) {
          setImmediate(() => {
            inputStream.end(writeValue);
          });
        }
      });
      return output;
    }
  }
  dkim = DKIM;
  return dkim;
}
var httpProxyClient_1;
var hasRequiredHttpProxyClient;
function requireHttpProxyClient() {
  if (hasRequiredHttpProxyClient) return httpProxyClient_1;
  hasRequiredHttpProxyClient = 1;
  const net = require$$0$d;
  const tls = require$$1$4;
  const urllib = require$$0$8;
  function httpProxyClient(proxyUrl, destinationPort, destinationHost, callback) {
    let proxy = urllib.parse(proxyUrl);
    let options;
    let connect;
    let socket;
    options = {
      host: proxy.hostname,
      port: Number(proxy.port) ? Number(proxy.port) : proxy.protocol === "https:" ? 443 : 80
    };
    if (proxy.protocol === "https:") {
      options.rejectUnauthorized = false;
      connect = tls.connect.bind(tls);
    } else {
      connect = net.connect.bind(net);
    }
    let finished = false;
    let tempSocketErr = (err2) => {
      if (finished) {
        return;
      }
      finished = true;
      try {
        socket.destroy();
      } catch (_E) {
      }
      callback(err2);
    };
    let timeoutErr = () => {
      let err2 = new Error("Proxy socket timed out");
      err2.code = "ETIMEDOUT";
      tempSocketErr(err2);
    };
    socket = connect(options, () => {
      if (finished) {
        return;
      }
      let reqHeaders = {
        Host: destinationHost + ":" + destinationPort,
        Connection: "close"
      };
      if (proxy.auth) {
        reqHeaders["Proxy-Authorization"] = "Basic " + Buffer.from(proxy.auth).toString("base64");
      }
      socket.write(
        // HTTP method
        "CONNECT " + destinationHost + ":" + destinationPort + " HTTP/1.1\r\n" + // HTTP request headers
        Object.keys(reqHeaders).map((key) => key + ": " + reqHeaders[key]).join("\r\n") + // End request
        "\r\n\r\n"
      );
      let headers = "";
      let onSocketData = (chunk) => {
        let match2;
        let remainder;
        if (finished) {
          return;
        }
        headers += chunk.toString("binary");
        if (match2 = headers.match(/\r\n\r\n/)) {
          socket.removeListener("data", onSocketData);
          remainder = headers.substr(match2.index + match2[0].length);
          headers = headers.substr(0, match2.index);
          if (remainder) {
            socket.unshift(Buffer.from(remainder, "binary"));
          }
          finished = true;
          match2 = headers.match(/^HTTP\/\d+\.\d+ (\d+)/i);
          if (!match2 || (match2[1] || "").charAt(0) !== "2") {
            try {
              socket.destroy();
            } catch (_E) {
            }
            return callback(new Error("Invalid response from proxy" + (match2 && ": " + match2[1] || "")));
          }
          socket.removeListener("error", tempSocketErr);
          socket.removeListener("timeout", timeoutErr);
          socket.setTimeout(0);
          return callback(null, socket);
        }
      };
      socket.on("data", onSocketData);
    });
    socket.setTimeout(httpProxyClient.timeout || 30 * 1e3);
    socket.on("timeout", timeoutErr);
    socket.once("error", tempSocketErr);
  }
  httpProxyClient_1 = httpProxyClient;
  return httpProxyClient_1;
}
var mailMessage;
var hasRequiredMailMessage;
function requireMailMessage() {
  if (hasRequiredMailMessage) return mailMessage;
  hasRequiredMailMessage = 1;
  const shared2 = requireShared();
  const MimeNode = requireMimeNode();
  const mimeFuncs2 = requireMimeFuncs();
  class MailMessage {
    constructor(mailer2, data) {
      this.mailer = mailer2;
      this.data = {};
      this.message = null;
      data = data || {};
      let options = mailer2.options || {};
      let defaults2 = mailer2._defaults || {};
      Object.keys(data).forEach((key) => {
        this.data[key] = data[key];
      });
      this.data.headers = this.data.headers || {};
      Object.keys(defaults2).forEach((key) => {
        if (!(key in this.data)) {
          this.data[key] = defaults2[key];
        } else if (key === "headers") {
          Object.keys(defaults2.headers).forEach((key2) => {
            if (!(key2 in this.data.headers)) {
              this.data.headers[key2] = defaults2.headers[key2];
            }
          });
        }
      });
      ["disableFileAccess", "disableUrlAccess", "normalizeHeaderKey"].forEach((key) => {
        if (key in options) {
          this.data[key] = options[key];
        }
      });
    }
    resolveContent(...args) {
      return shared2.resolveContent(...args);
    }
    resolveAll(callback) {
      let keys = [
        [this.data, "html"],
        [this.data, "text"],
        [this.data, "watchHtml"],
        [this.data, "amp"],
        [this.data, "icalEvent"]
      ];
      if (this.data.alternatives && this.data.alternatives.length) {
        this.data.alternatives.forEach((alternative, i) => {
          keys.push([this.data.alternatives, i]);
        });
      }
      if (this.data.attachments && this.data.attachments.length) {
        this.data.attachments.forEach((attachment, i) => {
          if (!attachment.filename) {
            attachment.filename = (attachment.path || attachment.href || "").split("/").pop().split("?").shift() || "attachment-" + (i + 1);
            if (attachment.filename.indexOf(".") < 0) {
              attachment.filename += "." + mimeFuncs2.detectExtension(attachment.contentType);
            }
          }
          if (!attachment.contentType) {
            attachment.contentType = mimeFuncs2.detectMimeType(attachment.filename || attachment.path || attachment.href || "bin");
          }
          keys.push([this.data.attachments, i]);
        });
      }
      let mimeNode2 = new MimeNode();
      let addressKeys = ["from", "to", "cc", "bcc", "sender", "replyTo"];
      addressKeys.forEach((address) => {
        let value;
        if (this.message) {
          value = [].concat(mimeNode2._parseAddresses(this.message.getHeader(address === "replyTo" ? "reply-to" : address)) || []);
        } else if (this.data[address]) {
          value = [].concat(mimeNode2._parseAddresses(this.data[address]) || []);
        }
        if (value && value.length) {
          this.data[address] = value;
        } else if (address in this.data) {
          this.data[address] = null;
        }
      });
      let singleKeys = ["from", "sender"];
      singleKeys.forEach((address) => {
        if (this.data[address]) {
          this.data[address] = this.data[address].shift();
        }
      });
      let pos = 0;
      let resolveNext = () => {
        if (pos >= keys.length) {
          return callback(null, this.data);
        }
        let args = keys[pos++];
        if (!args[0] || !args[0][args[1]]) {
          return resolveNext();
        }
        shared2.resolveContent(...args, (err2, value) => {
          if (err2) {
            return callback(err2);
          }
          let node = {
            content: value
          };
          if (args[0][args[1]] && typeof args[0][args[1]] === "object" && !Buffer.isBuffer(args[0][args[1]])) {
            Object.keys(args[0][args[1]]).forEach((key) => {
              if (!(key in node) && !["content", "path", "href", "raw"].includes(key)) {
                node[key] = args[0][args[1]][key];
              }
            });
          }
          args[0][args[1]] = node;
          resolveNext();
        });
      };
      setImmediate(() => resolveNext());
    }
    normalize(callback) {
      let envelope = this.data.envelope || this.message.getEnvelope();
      let messageId = this.message.messageId();
      this.resolveAll((err2, data) => {
        if (err2) {
          return callback(err2);
        }
        data.envelope = envelope;
        data.messageId = messageId;
        ["html", "text", "watchHtml", "amp"].forEach((key) => {
          if (data[key] && data[key].content) {
            if (typeof data[key].content === "string") {
              data[key] = data[key].content;
            } else if (Buffer.isBuffer(data[key].content)) {
              data[key] = data[key].content.toString();
            }
          }
        });
        if (data.icalEvent && Buffer.isBuffer(data.icalEvent.content)) {
          data.icalEvent.content = data.icalEvent.content.toString("base64");
          data.icalEvent.encoding = "base64";
        }
        if (data.alternatives && data.alternatives.length) {
          data.alternatives.forEach((alternative) => {
            if (alternative && alternative.content && Buffer.isBuffer(alternative.content)) {
              alternative.content = alternative.content.toString("base64");
              alternative.encoding = "base64";
            }
          });
        }
        if (data.attachments && data.attachments.length) {
          data.attachments.forEach((attachment) => {
            if (attachment && attachment.content && Buffer.isBuffer(attachment.content)) {
              attachment.content = attachment.content.toString("base64");
              attachment.encoding = "base64";
            }
          });
        }
        data.normalizedHeaders = {};
        Object.keys(data.headers || {}).forEach((key) => {
          let value = [].concat(data.headers[key] || []).shift();
          value = value && value.value || value;
          if (value) {
            if (["references", "in-reply-to", "message-id", "content-id"].includes(key)) {
              value = this.message._encodeHeaderValue(key, value);
            }
            data.normalizedHeaders[key] = value;
          }
        });
        if (data.list && typeof data.list === "object") {
          let listHeaders = this._getListHeaders(data.list);
          listHeaders.forEach((entry) => {
            data.normalizedHeaders[entry.key] = entry.value.map((val) => val && val.value || val).join(", ");
          });
        }
        if (data.references) {
          data.normalizedHeaders.references = this.message._encodeHeaderValue("references", data.references);
        }
        if (data.inReplyTo) {
          data.normalizedHeaders["in-reply-to"] = this.message._encodeHeaderValue("in-reply-to", data.inReplyTo);
        }
        return callback(null, data);
      });
    }
    setMailerHeader() {
      if (!this.message || !this.data.xMailer) {
        return;
      }
      this.message.setHeader("X-Mailer", this.data.xMailer);
    }
    setPriorityHeaders() {
      if (!this.message || !this.data.priority) {
        return;
      }
      switch ((this.data.priority || "").toString().toLowerCase()) {
        case "high":
          this.message.setHeader("X-Priority", "1 (Highest)");
          this.message.setHeader("X-MSMail-Priority", "High");
          this.message.setHeader("Importance", "High");
          break;
        case "low":
          this.message.setHeader("X-Priority", "5 (Lowest)");
          this.message.setHeader("X-MSMail-Priority", "Low");
          this.message.setHeader("Importance", "Low");
          break;
      }
    }
    setListHeaders() {
      if (!this.message || !this.data.list || typeof this.data.list !== "object") {
        return;
      }
      if (this.data.list && typeof this.data.list === "object") {
        this._getListHeaders(this.data.list).forEach((listHeader) => {
          listHeader.value.forEach((value) => {
            this.message.addHeader(listHeader.key, value);
          });
        });
      }
    }
    _getListHeaders(listData) {
      return Object.keys(listData).map((key) => ({
        key: "list-" + key.toLowerCase().trim(),
        value: [].concat(listData[key] || []).map((value) => ({
          prepared: true,
          foldLines: true,
          value: [].concat(value || []).map((value2) => {
            if (typeof value2 === "string") {
              value2 = {
                url: value2
              };
            }
            if (value2 && value2.url) {
              if (key.toLowerCase().trim() === "id") {
                let comment2 = value2.comment || "";
                if (mimeFuncs2.isPlainText(comment2)) {
                  comment2 = '"' + comment2 + '"';
                } else {
                  comment2 = mimeFuncs2.encodeWord(comment2);
                }
                return (value2.comment ? comment2 + " " : "") + this._formatListUrl(value2.url).replace(/^<[^:]+\/{,2}/, "");
              }
              let comment = value2.comment || "";
              if (!mimeFuncs2.isPlainText(comment)) {
                comment = mimeFuncs2.encodeWord(comment);
              }
              return this._formatListUrl(value2.url) + (value2.comment ? " (" + comment + ")" : "");
            }
            return "";
          }).filter((value2) => value2).join(", ")
        }))
      }));
    }
    _formatListUrl(url) {
      url = url.replace(/[\s<]+|[\s>]+/g, "");
      if (/^(https?|mailto|ftp):/.test(url)) {
        return "<" + url + ">";
      }
      if (/^[^@]+@[^@]+$/.test(url)) {
        return "<mailto:" + url + ">";
      }
      return "<http://" + url + ">";
    }
  }
  mailMessage = MailMessage;
  return mailMessage;
}
var mailer;
var hasRequiredMailer;
function requireMailer() {
  if (hasRequiredMailer) return mailer;
  hasRequiredMailer = 1;
  const EventEmitter2 = require$$0$7;
  const shared2 = requireShared();
  const mimeTypes2 = requireMimeTypes();
  const MailComposer = requireMailComposer();
  const DKIM = requireDkim();
  const httpProxyClient = requireHttpProxyClient();
  const util = require$$1$1;
  const urllib = require$$0$8;
  const packageData = require$$9;
  const MailMessage = requireMailMessage();
  const net = require$$0$d;
  const dns = require$$4;
  const crypto2 = require$$0$5;
  class Mail extends EventEmitter2 {
    constructor(transporter, options, defaults2) {
      super();
      this.options = options || {};
      this._defaults = defaults2 || {};
      this._defaultPlugins = {
        compile: [(...args) => this._convertDataImages(...args)],
        stream: []
      };
      this._userPlugins = {
        compile: [],
        stream: []
      };
      this.meta = /* @__PURE__ */ new Map();
      this.dkim = this.options.dkim ? new DKIM(this.options.dkim) : false;
      this.transporter = transporter;
      this.transporter.mailer = this;
      this.logger = shared2.getLogger(this.options, {
        component: this.options.component || "mail"
      });
      this.logger.debug(
        {
          tnx: "create"
        },
        "Creating transport: %s",
        this.getVersionString()
      );
      if (typeof this.transporter.on === "function") {
        this.transporter.on("log", (log) => {
          this.logger.debug(
            {
              tnx: "transport"
            },
            "%s: %s",
            log.type,
            log.message
          );
        });
        this.transporter.on("error", (err2) => {
          this.logger.error(
            {
              err: err2,
              tnx: "transport"
            },
            "Transport Error: %s",
            err2.message
          );
          this.emit("error", err2);
        });
        this.transporter.on("idle", (...args) => {
          this.emit("idle", ...args);
        });
        this.transporter.on("clear", (...args) => {
          this.emit("clear", ...args);
        });
      }
      ["close", "isIdle", "verify"].forEach((method) => {
        this[method] = (...args) => {
          if (typeof this.transporter[method] === "function") {
            if (method === "verify" && typeof this.getSocket === "function") {
              this.transporter.getSocket = this.getSocket;
              this.getSocket = false;
            }
            return this.transporter[method](...args);
          } else {
            this.logger.warn(
              {
                tnx: "transport",
                methodName: method
              },
              "Non existing method %s called for transport",
              method
            );
            return false;
          }
        };
      });
      if (this.options.proxy && typeof this.options.proxy === "string") {
        this.setupProxy(this.options.proxy);
      }
    }
    use(step, plugin) {
      step = (step || "").toString();
      if (!this._userPlugins.hasOwnProperty(step)) {
        this._userPlugins[step] = [plugin];
      } else {
        this._userPlugins[step].push(plugin);
      }
      return this;
    }
    /**
     * Sends an email using the preselected transport object
     *
     * @param {Object} data E-data description
     * @param {Function?} callback Callback to run once the sending succeeded or failed
     */
    sendMail(data, callback = null) {
      let promise;
      if (!callback) {
        promise = new Promise((resolve2, reject) => {
          callback = shared2.callbackPromise(resolve2, reject);
        });
      }
      if (typeof this.getSocket === "function") {
        this.transporter.getSocket = this.getSocket;
        this.getSocket = false;
      }
      let mail = new MailMessage(this, data);
      this.logger.debug(
        {
          tnx: "transport",
          name: this.transporter.name,
          version: this.transporter.version,
          action: "send"
        },
        "Sending mail using %s/%s",
        this.transporter.name,
        this.transporter.version
      );
      this._processPlugins("compile", mail, (err2) => {
        if (err2) {
          this.logger.error(
            {
              err: err2,
              tnx: "plugin",
              action: "compile"
            },
            "PluginCompile Error: %s",
            err2.message
          );
          return callback(err2);
        }
        mail.message = new MailComposer(mail.data).compile();
        mail.setMailerHeader();
        mail.setPriorityHeaders();
        mail.setListHeaders();
        this._processPlugins("stream", mail, (err3) => {
          if (err3) {
            this.logger.error(
              {
                err: err3,
                tnx: "plugin",
                action: "stream"
              },
              "PluginStream Error: %s",
              err3.message
            );
            return callback(err3);
          }
          if (mail.data.dkim || this.dkim) {
            mail.message.processFunc((input) => {
              let dkim2 = mail.data.dkim ? new DKIM(mail.data.dkim) : this.dkim;
              this.logger.debug(
                {
                  tnx: "DKIM",
                  messageId: mail.message.messageId(),
                  dkimDomains: dkim2.keys.map((key) => key.keySelector + "." + key.domainName).join(", ")
                },
                "Signing outgoing message with %s keys",
                dkim2.keys.length
              );
              return dkim2.sign(input, mail.data._dkim);
            });
          }
          this.transporter.send(mail, (...args) => {
            if (args[0]) {
              this.logger.error(
                {
                  err: args[0],
                  tnx: "transport",
                  action: "send"
                },
                "Send Error: %s",
                args[0].message
              );
            }
            callback(...args);
          });
        });
      });
      return promise;
    }
    getVersionString() {
      return util.format(
        "%s (%s; +%s; %s/%s)",
        packageData.name,
        packageData.version,
        packageData.homepage,
        this.transporter.name,
        this.transporter.version
      );
    }
    _processPlugins(step, mail, callback) {
      step = (step || "").toString();
      if (!this._userPlugins.hasOwnProperty(step)) {
        return callback();
      }
      let userPlugins = this._userPlugins[step] || [];
      let defaultPlugins = this._defaultPlugins[step] || [];
      if (userPlugins.length) {
        this.logger.debug(
          {
            tnx: "transaction",
            pluginCount: userPlugins.length,
            step
          },
          "Using %s plugins for %s",
          userPlugins.length,
          step
        );
      }
      if (userPlugins.length + defaultPlugins.length === 0) {
        return callback();
      }
      let pos = 0;
      let block = "default";
      let processPlugins = () => {
        let curplugins = block === "default" ? defaultPlugins : userPlugins;
        if (pos >= curplugins.length) {
          if (block === "default" && userPlugins.length) {
            block = "user";
            pos = 0;
            curplugins = userPlugins;
          } else {
            return callback();
          }
        }
        let plugin = curplugins[pos++];
        plugin(mail, (err2) => {
          if (err2) {
            return callback(err2);
          }
          processPlugins();
        });
      };
      processPlugins();
    }
    /**
     * Sets up proxy handler for a Nodemailer object
     *
     * @param {String} proxyUrl Proxy configuration url
     */
    setupProxy(proxyUrl) {
      let proxy = urllib.parse(proxyUrl);
      this.getSocket = (options, callback) => {
        let protocol2 = proxy.protocol.replace(/:$/, "").toLowerCase();
        if (this.meta.has("proxy_handler_" + protocol2)) {
          return this.meta.get("proxy_handler_" + protocol2)(proxy, options, callback);
        }
        switch (protocol2) {
          // Connect using a HTTP CONNECT method
          case "http":
          case "https":
            httpProxyClient(proxy.href, options.port, options.host, (err2, socket) => {
              if (err2) {
                return callback(err2);
              }
              return callback(null, {
                connection: socket
              });
            });
            return;
          case "socks":
          case "socks5":
          case "socks4":
          case "socks4a": {
            if (!this.meta.has("proxy_socks_module")) {
              return callback(new Error("Socks module not loaded"));
            }
            let connect = (ipaddress) => {
              let proxyV2 = !!this.meta.get("proxy_socks_module").SocksClient;
              let socksClient = proxyV2 ? this.meta.get("proxy_socks_module").SocksClient : this.meta.get("proxy_socks_module");
              let proxyType = Number(proxy.protocol.replace(/\D/g, "")) || 5;
              let connectionOpts = {
                proxy: {
                  ipaddress,
                  port: Number(proxy.port),
                  type: proxyType
                },
                [proxyV2 ? "destination" : "target"]: {
                  host: options.host,
                  port: options.port
                },
                command: "connect"
              };
              if (proxy.auth) {
                let username = decodeURIComponent(proxy.auth.split(":").shift());
                let password = decodeURIComponent(proxy.auth.split(":").pop());
                if (proxyV2) {
                  connectionOpts.proxy.userId = username;
                  connectionOpts.proxy.password = password;
                } else if (proxyType === 4) {
                  connectionOpts.userid = username;
                } else {
                  connectionOpts.authentication = {
                    username,
                    password
                  };
                }
              }
              socksClient.createConnection(connectionOpts, (err2, info2) => {
                if (err2) {
                  return callback(err2);
                }
                return callback(null, {
                  connection: info2.socket || info2
                });
              });
            };
            if (net.isIP(proxy.hostname)) {
              return connect(proxy.hostname);
            }
            return dns.resolve(proxy.hostname, (err2, address) => {
              if (err2) {
                return callback(err2);
              }
              connect(Array.isArray(address) ? address[0] : address);
            });
          }
        }
        callback(new Error("Unknown proxy configuration"));
      };
    }
    _convertDataImages(mail, callback) {
      if (!this.options.attachDataUrls && !mail.data.attachDataUrls || !mail.data.html) {
        return callback();
      }
      mail.resolveContent(mail.data, "html", (err2, html2) => {
        if (err2) {
          return callback(err2);
        }
        let cidCounter = 0;
        html2 = (html2 || "").toString().replace(/(<img\b[^<>]{0,1024} src\s{0,20}=[\s"']{0,20})(data:([^;]+);[^"'>\s]+)/gi, (match2, prefix, dataUri, mimeType) => {
          let cid = crypto2.randomBytes(10).toString("hex") + "@localhost";
          if (!mail.data.attachments) {
            mail.data.attachments = [];
          }
          if (!Array.isArray(mail.data.attachments)) {
            mail.data.attachments = [].concat(mail.data.attachments || []);
          }
          mail.data.attachments.push({
            path: dataUri,
            cid,
            filename: "image-" + ++cidCounter + "." + mimeTypes2.detectExtension(mimeType)
          });
          return prefix + "cid:" + cid;
        });
        mail.data.html = html2;
        callback();
      });
    }
    set(key, value) {
      return this.meta.set(key, value);
    }
    get(key) {
      return this.meta.get(key);
    }
  }
  mailer = Mail;
  return mailer;
}
var dataStream;
var hasRequiredDataStream;
function requireDataStream() {
  if (hasRequiredDataStream) return dataStream;
  hasRequiredDataStream = 1;
  const stream2 = require$$0$c;
  const Transform = stream2.Transform;
  class DataStream extends Transform {
    constructor(options) {
      super(options);
      this.options = options || {};
      this._curLine = "";
      this.inByteCount = 0;
      this.outByteCount = 0;
      this.lastByte = false;
    }
    /**
     * Escapes dots
     */
    _transform(chunk, encoding, done) {
      let chunks = [];
      let chunklen = 0;
      let i, len, lastPos = 0;
      let buf;
      if (!chunk || !chunk.length) {
        return done();
      }
      if (typeof chunk === "string") {
        chunk = Buffer.from(chunk);
      }
      this.inByteCount += chunk.length;
      for (i = 0, len = chunk.length; i < len; i++) {
        if (chunk[i] === 46) {
          if (i && chunk[i - 1] === 10 || !i && (!this.lastByte || this.lastByte === 10)) {
            buf = chunk.slice(lastPos, i + 1);
            chunks.push(buf);
            chunks.push(Buffer.from("."));
            chunklen += buf.length + 1;
            lastPos = i + 1;
          }
        } else if (chunk[i] === 10) {
          if (i && chunk[i - 1] !== 13 || !i && this.lastByte !== 13) {
            if (i > lastPos) {
              buf = chunk.slice(lastPos, i);
              chunks.push(buf);
              chunklen += buf.length + 2;
            } else {
              chunklen += 2;
            }
            chunks.push(Buffer.from("\r\n"));
            lastPos = i + 1;
          }
        }
      }
      if (chunklen) {
        if (lastPos < chunk.length) {
          buf = chunk.slice(lastPos);
          chunks.push(buf);
          chunklen += buf.length;
        }
        this.outByteCount += chunklen;
        this.push(Buffer.concat(chunks, chunklen));
      } else {
        this.outByteCount += chunk.length;
        this.push(chunk);
      }
      this.lastByte = chunk[chunk.length - 1];
      done();
    }
    /**
     * Finalizes the stream with a dot on a single line
     */
    _flush(done) {
      let buf;
      if (this.lastByte === 10) {
        buf = Buffer.from(".\r\n");
      } else if (this.lastByte === 13) {
        buf = Buffer.from("\n.\r\n");
      } else {
        buf = Buffer.from("\r\n.\r\n");
      }
      this.outByteCount += buf.length;
      this.push(buf);
      done();
    }
  }
  dataStream = DataStream;
  return dataStream;
}
var smtpConnection;
var hasRequiredSmtpConnection;
function requireSmtpConnection() {
  if (hasRequiredSmtpConnection) return smtpConnection;
  hasRequiredSmtpConnection = 1;
  const packageInfo = require$$9;
  const EventEmitter2 = require$$0$7.EventEmitter;
  const net = require$$0$d;
  const tls = require$$1$4;
  const os = require$$6;
  const crypto2 = require$$0$5;
  const DataStream = requireDataStream();
  const PassThrough = require$$0$c.PassThrough;
  const shared2 = requireShared();
  const CONNECTION_TIMEOUT = 2 * 60 * 1e3;
  const SOCKET_TIMEOUT = 10 * 60 * 1e3;
  const GREETING_TIMEOUT = 30 * 1e3;
  const DNS_TIMEOUT = 30 * 1e3;
  class SMTPConnection extends EventEmitter2 {
    constructor(options) {
      super(options);
      this.id = crypto2.randomBytes(8).toString("base64").replace(/\W/g, "");
      this.stage = "init";
      this.options = options || {};
      this.secureConnection = !!this.options.secure;
      this.alreadySecured = !!this.options.secured;
      this.port = Number(this.options.port) || (this.secureConnection ? 465 : 587);
      this.host = this.options.host || "localhost";
      this.servername = this.options.servername ? this.options.servername : !net.isIP(this.host) ? this.host : false;
      this.allowInternalNetworkInterfaces = this.options.allowInternalNetworkInterfaces || false;
      if (typeof this.options.secure === "undefined" && this.port === 465) {
        this.secureConnection = true;
      }
      this.name = this.options.name || this._getHostname();
      this.logger = shared2.getLogger(this.options, {
        component: this.options.component || "smtp-connection",
        sid: this.id
      });
      this.customAuth = /* @__PURE__ */ new Map();
      Object.keys(this.options.customAuth || {}).forEach((key) => {
        let mapKey = (key || "").toString().trim().toUpperCase();
        if (!mapKey) {
          return;
        }
        this.customAuth.set(mapKey, this.options.customAuth[key]);
      });
      this.version = packageInfo.version;
      this.authenticated = false;
      this.destroyed = false;
      this.secure = !!this.secureConnection;
      this._remainder = "";
      this._responseQueue = [];
      this.lastServerResponse = false;
      this._socket = false;
      this._supportedAuth = [];
      this.allowsAuth = false;
      this._envelope = false;
      this._supportedExtensions = [];
      this._maxAllowedSize = 0;
      this._responseActions = [];
      this._recipientQueue = [];
      this._greetingTimeout = false;
      this._connectionTimeout = false;
      this._destroyed = false;
      this._closing = false;
      this._onSocketData = (chunk) => this._onData(chunk);
      this._onSocketError = (error2) => this._onError(error2, "ESOCKET", false, "CONN");
      this._onSocketClose = () => this._onClose();
      this._onSocketEnd = () => this._onEnd();
      this._onSocketTimeout = () => this._onTimeout();
    }
    /**
     * Creates a connection to a SMTP server and sets up connection
     * listener
     */
    connect(connectCallback) {
      if (typeof connectCallback === "function") {
        this.once("connect", () => {
          this.logger.debug(
            {
              tnx: "smtp"
            },
            "SMTP handshake finished"
          );
          connectCallback();
        });
        const isDestroyedMessage = this._isDestroyedMessage("connect");
        if (isDestroyedMessage) {
          return connectCallback(this._formatError(isDestroyedMessage, "ECONNECTION", false, "CONN"));
        }
      }
      let opts = {
        port: this.port,
        host: this.host,
        allowInternalNetworkInterfaces: this.allowInternalNetworkInterfaces,
        timeout: this.options.dnsTimeout || DNS_TIMEOUT
      };
      if (this.options.localAddress) {
        opts.localAddress = this.options.localAddress;
      }
      let setupConnectionHandlers = () => {
        this._connectionTimeout = setTimeout(() => {
          this._onError("Connection timeout", "ETIMEDOUT", false, "CONN");
        }, this.options.connectionTimeout || CONNECTION_TIMEOUT);
        this._socket.on("error", this._onSocketError);
      };
      if (this.options.connection) {
        this._socket = this.options.connection;
        setupConnectionHandlers();
        if (this.secureConnection && !this.alreadySecured) {
          setImmediate(
            () => this._upgradeConnection((err2) => {
              if (err2) {
                this._onError(new Error("Error initiating TLS - " + (err2.message || err2)), "ETLS", false, "CONN");
                return;
              }
              this._onConnect();
            })
          );
        } else {
          setImmediate(() => this._onConnect());
        }
        return;
      } else if (this.options.socket) {
        this._socket = this.options.socket;
        return shared2.resolveHostname(opts, (err2, resolved) => {
          if (err2) {
            return setImmediate(() => this._onError(err2, "EDNS", false, "CONN"));
          }
          this.logger.debug(
            {
              tnx: "dns",
              source: opts.host,
              resolved: resolved.host,
              cached: !!resolved.cached
            },
            "Resolved %s as %s [cache %s]",
            opts.host,
            resolved.host,
            resolved.cached ? "hit" : "miss"
          );
          Object.keys(resolved).forEach((key) => {
            if (key.charAt(0) !== "_" && resolved[key]) {
              opts[key] = resolved[key];
            }
          });
          try {
            this._socket.connect(this.port, this.host, () => {
              this._socket.setKeepAlive(true);
              this._onConnect();
            });
            setupConnectionHandlers();
          } catch (E) {
            return setImmediate(() => this._onError(E, "ECONNECTION", false, "CONN"));
          }
        });
      } else if (this.secureConnection) {
        if (this.options.tls) {
          Object.keys(this.options.tls).forEach((key) => {
            opts[key] = this.options.tls[key];
          });
        }
        if (this.servername && !opts.servername) {
          opts.servername = this.servername;
        }
        return shared2.resolveHostname(opts, (err2, resolved) => {
          if (err2) {
            return setImmediate(() => this._onError(err2, "EDNS", false, "CONN"));
          }
          this.logger.debug(
            {
              tnx: "dns",
              source: opts.host,
              resolved: resolved.host,
              cached: !!resolved.cached
            },
            "Resolved %s as %s [cache %s]",
            opts.host,
            resolved.host,
            resolved.cached ? "hit" : "miss"
          );
          Object.keys(resolved).forEach((key) => {
            if (key.charAt(0) !== "_" && resolved[key]) {
              opts[key] = resolved[key];
            }
          });
          try {
            this._socket = tls.connect(opts, () => {
              this._socket.setKeepAlive(true);
              this._onConnect();
            });
            setupConnectionHandlers();
          } catch (E) {
            return setImmediate(() => this._onError(E, "ECONNECTION", false, "CONN"));
          }
        });
      } else {
        return shared2.resolveHostname(opts, (err2, resolved) => {
          if (err2) {
            return setImmediate(() => this._onError(err2, "EDNS", false, "CONN"));
          }
          this.logger.debug(
            {
              tnx: "dns",
              source: opts.host,
              resolved: resolved.host,
              cached: !!resolved.cached
            },
            "Resolved %s as %s [cache %s]",
            opts.host,
            resolved.host,
            resolved.cached ? "hit" : "miss"
          );
          Object.keys(resolved).forEach((key) => {
            if (key.charAt(0) !== "_" && resolved[key]) {
              opts[key] = resolved[key];
            }
          });
          try {
            this._socket = net.connect(opts, () => {
              this._socket.setKeepAlive(true);
              this._onConnect();
            });
            setupConnectionHandlers();
          } catch (E) {
            return setImmediate(() => this._onError(E, "ECONNECTION", false, "CONN"));
          }
        });
      }
    }
    /**
     * Sends QUIT
     */
    quit() {
      this._sendCommand("QUIT");
      this._responseActions.push(this.close);
    }
    /**
     * Closes the connection to the server
     */
    close() {
      clearTimeout(this._connectionTimeout);
      clearTimeout(this._greetingTimeout);
      this._responseActions = [];
      if (this._closing) {
        return;
      }
      this._closing = true;
      let closeMethod = "end";
      if (this.stage === "init") {
        closeMethod = "destroy";
      }
      this.logger.debug(
        {
          tnx: "smtp"
        },
        'Closing connection to the server using "%s"',
        closeMethod
      );
      let socket = this._socket && this._socket.socket || this._socket;
      if (socket && !socket.destroyed) {
        try {
          socket[closeMethod]();
        } catch (_E) {
        }
      }
      this._destroy();
    }
    /**
     * Authenticate user
     */
    login(authData, callback) {
      const isDestroyedMessage = this._isDestroyedMessage("login");
      if (isDestroyedMessage) {
        return callback(this._formatError(isDestroyedMessage, "ECONNECTION", false, "API"));
      }
      this._auth = authData || {};
      this._authMethod = (this._auth.method || "").toString().trim().toUpperCase() || false;
      if (!this._authMethod && this._auth.oauth2 && !this._auth.credentials) {
        this._authMethod = "XOAUTH2";
      } else if (!this._authMethod || this._authMethod === "XOAUTH2" && !this._auth.oauth2) {
        this._authMethod = (this._supportedAuth[0] || "PLAIN").toUpperCase().trim();
      }
      if (this._authMethod !== "XOAUTH2" && (!this._auth.credentials || !this._auth.credentials.user || !this._auth.credentials.pass)) {
        if (this._auth.user && this._auth.pass || this.customAuth.has(this._authMethod)) {
          this._auth.credentials = {
            user: this._auth.user,
            pass: this._auth.pass,
            options: this._auth.options
          };
        } else {
          return callback(this._formatError('Missing credentials for "' + this._authMethod + '"', "EAUTH", false, "API"));
        }
      }
      if (this.customAuth.has(this._authMethod)) {
        let handler2 = this.customAuth.get(this._authMethod);
        let lastResponse;
        let returned = false;
        let resolve2 = () => {
          if (returned) {
            return;
          }
          returned = true;
          this.logger.info(
            {
              tnx: "smtp",
              username: this._auth.user,
              action: "authenticated",
              method: this._authMethod
            },
            "User %s authenticated",
            JSON.stringify(this._auth.user)
          );
          this.authenticated = true;
          callback(null, true);
        };
        let reject = (err2) => {
          if (returned) {
            return;
          }
          returned = true;
          callback(this._formatError(err2, "EAUTH", lastResponse, "AUTH " + this._authMethod));
        };
        let handlerResponse = handler2({
          auth: this._auth,
          method: this._authMethod,
          extensions: [].concat(this._supportedExtensions),
          authMethods: [].concat(this._supportedAuth),
          maxAllowedSize: this._maxAllowedSize || false,
          sendCommand: (cmd, done) => {
            let promise;
            if (!done) {
              promise = new Promise((resolve3, reject2) => {
                done = shared2.callbackPromise(resolve3, reject2);
              });
            }
            this._responseActions.push((str) => {
              lastResponse = str;
              let codes = str.match(/^(\d+)(?:\s(\d+\.\d+\.\d+))?\s/);
              let data = {
                command: cmd,
                response: str
              };
              if (codes) {
                data.status = Number(codes[1]) || 0;
                if (codes[2]) {
                  data.code = codes[2];
                }
                data.text = str.substr(codes[0].length);
              } else {
                data.text = str;
                data.status = 0;
              }
              done(null, data);
            });
            setImmediate(() => this._sendCommand(cmd));
            return promise;
          },
          resolve: resolve2,
          reject
        });
        if (handlerResponse && typeof handlerResponse.catch === "function") {
          handlerResponse.then(resolve2).catch(reject);
        }
        return;
      }
      switch (this._authMethod) {
        case "XOAUTH2":
          this._handleXOauth2Token(false, callback);
          return;
        case "LOGIN":
          this._responseActions.push((str) => {
            this._actionAUTH_LOGIN_USER(str, callback);
          });
          this._sendCommand("AUTH LOGIN");
          return;
        case "PLAIN":
          this._responseActions.push((str) => {
            this._actionAUTHComplete(str, callback);
          });
          this._sendCommand(
            "AUTH PLAIN " + Buffer.from(
              //this._auth.user+'\u0000'+
              "\0" + // skip authorization identity as it causes problems with some servers
              this._auth.credentials.user + "\0" + this._auth.credentials.pass,
              "utf-8"
            ).toString("base64"),
            // log entry without passwords
            "AUTH PLAIN " + Buffer.from(
              //this._auth.user+'\u0000'+
              "\0" + // skip authorization identity as it causes problems with some servers
              this._auth.credentials.user + "\0/* secret */",
              "utf-8"
            ).toString("base64")
          );
          return;
        case "CRAM-MD5":
          this._responseActions.push((str) => {
            this._actionAUTH_CRAM_MD5(str, callback);
          });
          this._sendCommand("AUTH CRAM-MD5");
          return;
      }
      return callback(this._formatError('Unknown authentication method "' + this._authMethod + '"', "EAUTH", false, "API"));
    }
    /**
     * Sends a message
     *
     * @param {Object} envelope Envelope object, {from: addr, to: [addr]}
     * @param {Object} message String, Buffer or a Stream
     * @param {Function} callback Callback to return once sending is completed
     */
    send(envelope, message2, done) {
      if (!message2) {
        return done(this._formatError("Empty message", "EMESSAGE", false, "API"));
      }
      const isDestroyedMessage = this._isDestroyedMessage("send message");
      if (isDestroyedMessage) {
        return done(this._formatError(isDestroyedMessage, "ECONNECTION", false, "API"));
      }
      if (this._maxAllowedSize && envelope.size > this._maxAllowedSize) {
        return setImmediate(() => {
          done(this._formatError("Message size larger than allowed " + this._maxAllowedSize, "EMESSAGE", false, "MAIL FROM"));
        });
      }
      let returned = false;
      let callback = function() {
        if (returned) {
          return;
        }
        returned = true;
        done(...arguments);
      };
      if (typeof message2.on === "function") {
        message2.on("error", (err2) => callback(this._formatError(err2, "ESTREAM", false, "API")));
      }
      let startTime = Date.now();
      this._setEnvelope(envelope, (err2, info2) => {
        if (err2) {
          let stream3 = new PassThrough();
          if (typeof message2.pipe === "function") {
            message2.pipe(stream3);
          } else {
            stream3.write(message2);
            stream3.end();
          }
          return callback(err2);
        }
        let envelopeTime = Date.now();
        let stream2 = this._createSendStream((err3, str) => {
          if (err3) {
            return callback(err3);
          }
          info2.envelopeTime = envelopeTime - startTime;
          info2.messageTime = Date.now() - envelopeTime;
          info2.messageSize = stream2.outByteCount;
          info2.response = str;
          return callback(null, info2);
        });
        if (typeof message2.pipe === "function") {
          message2.pipe(stream2);
        } else {
          stream2.write(message2);
          stream2.end();
        }
      });
    }
    /**
     * Resets connection state
     *
     * @param {Function} callback Callback to return once connection is reset
     */
    reset(callback) {
      this._sendCommand("RSET");
      this._responseActions.push((str) => {
        if (str.charAt(0) !== "2") {
          return callback(this._formatError("Could not reset session state. response=" + str, "EPROTOCOL", str, "RSET"));
        }
        this._envelope = false;
        return callback(null, true);
      });
    }
    /**
     * Connection listener that is run when the connection to
     * the server is opened
     *
     * @event
     */
    _onConnect() {
      clearTimeout(this._connectionTimeout);
      this.logger.info(
        {
          tnx: "network",
          localAddress: this._socket.localAddress,
          localPort: this._socket.localPort,
          remoteAddress: this._socket.remoteAddress,
          remotePort: this._socket.remotePort
        },
        "%s established to %s:%s",
        this.secure ? "Secure connection" : "Connection",
        this._socket.remoteAddress,
        this._socket.remotePort
      );
      if (this._destroyed) {
        this.close();
        return;
      }
      this.stage = "connected";
      this._socket.removeListener("data", this._onSocketData);
      this._socket.removeListener("timeout", this._onSocketTimeout);
      this._socket.removeListener("close", this._onSocketClose);
      this._socket.removeListener("end", this._onSocketEnd);
      this._socket.on("data", this._onSocketData);
      this._socket.once("close", this._onSocketClose);
      this._socket.once("end", this._onSocketEnd);
      this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT);
      this._socket.on("timeout", this._onSocketTimeout);
      this._greetingTimeout = setTimeout(() => {
        if (this._socket && !this._destroyed && this._responseActions[0] === this._actionGreeting) {
          this._onError("Greeting never received", "ETIMEDOUT", false, "CONN");
        }
      }, this.options.greetingTimeout || GREETING_TIMEOUT);
      this._responseActions.push(this._actionGreeting);
      this._socket.resume();
    }
    /**
     * 'data' listener for data coming from the server
     *
     * @event
     * @param {Buffer} chunk Data chunk coming from the server
     */
    _onData(chunk) {
      if (this._destroyed || !chunk || !chunk.length) {
        return;
      }
      let data = (chunk || "").toString("binary");
      let lines = (this._remainder + data).split(/\r?\n/);
      let lastline;
      this._remainder = lines.pop();
      for (let i = 0, len = lines.length; i < len; i++) {
        if (this._responseQueue.length) {
          lastline = this._responseQueue[this._responseQueue.length - 1];
          if (/^\d+-/.test(lastline.split("\n").pop())) {
            this._responseQueue[this._responseQueue.length - 1] += "\n" + lines[i];
            continue;
          }
        }
        this._responseQueue.push(lines[i]);
      }
      if (this._responseQueue.length) {
        lastline = this._responseQueue[this._responseQueue.length - 1];
        if (/^\d+-/.test(lastline.split("\n").pop())) {
          return;
        }
      }
      this._processResponse();
    }
    /**
     * 'error' listener for the socket
     *
     * @event
     * @param {Error} err Error object
     * @param {String} type Error name
     */
    _onError(err2, type2, data, command) {
      clearTimeout(this._connectionTimeout);
      clearTimeout(this._greetingTimeout);
      if (this._destroyed) {
        return;
      }
      err2 = this._formatError(err2, type2, data, command);
      const transientCodes = ["ETIMEDOUT", "ESOCKET", "ECONNECTION"];
      if (transientCodes.includes(err2.code)) {
        this.logger.warn(data, err2.message);
      } else {
        this.logger.error(data, err2.message);
      }
      this.emit("error", err2);
      this.close();
    }
    _formatError(message2, type2, response, command) {
      let err2;
      if (/Error\]$/i.test(Object.prototype.toString.call(message2))) {
        err2 = message2;
      } else {
        err2 = new Error(message2);
      }
      if (type2 && type2 !== "Error") {
        err2.code = type2;
      }
      if (response) {
        err2.response = response;
        err2.message += ": " + response;
      }
      let responseCode = typeof response === "string" && Number((response.match(/^\d+/) || [])[0]) || false;
      if (responseCode) {
        err2.responseCode = responseCode;
      }
      if (command) {
        err2.command = command;
      }
      return err2;
    }
    /**
     * 'close' listener for the socket
     *
     * @event
     */
    _onClose() {
      let serverResponse = false;
      if (this._remainder && this._remainder.trim()) {
        if (this.options.debug || this.options.transactionLog) {
          this.logger.debug(
            {
              tnx: "server"
            },
            this._remainder.replace(/\r?\n$/, "")
          );
        }
        this.lastServerResponse = serverResponse = this._remainder.trim();
      }
      this.logger.info(
        {
          tnx: "network"
        },
        "Connection closed"
      );
      if (this.upgrading && !this._destroyed) {
        return this._onError(new Error("Connection closed unexpectedly"), "ETLS", serverResponse, "CONN");
      } else if (![this._actionGreeting, this.close].includes(this._responseActions[0]) && !this._destroyed) {
        return this._onError(new Error("Connection closed unexpectedly"), "ECONNECTION", serverResponse, "CONN");
      } else if (/^[45]\d{2}\b/.test(serverResponse)) {
        return this._onError(new Error("Connection closed unexpectedly"), "ECONNECTION", serverResponse, "CONN");
      }
      this._destroy();
    }
    /**
     * 'end' listener for the socket
     *
     * @event
     */
    _onEnd() {
      if (this._socket && !this._socket.destroyed) {
        this._socket.destroy();
      }
    }
    /**
     * 'timeout' listener for the socket
     *
     * @event
     */
    _onTimeout() {
      return this._onError(new Error("Timeout"), "ETIMEDOUT", false, "CONN");
    }
    /**
     * Destroys the client, emits 'end'
     */
    _destroy() {
      if (this._destroyed) {
        return;
      }
      this._destroyed = true;
      this.emit("end");
    }
    /**
     * Upgrades the connection to TLS
     *
     * @param {Function} callback Callback function to run when the connection
     *        has been secured
     */
    _upgradeConnection(callback) {
      this._socket.removeListener("data", this._onSocketData);
      this._socket.removeListener("timeout", this._onSocketTimeout);
      let socketPlain = this._socket;
      let opts = {
        socket: this._socket,
        host: this.host
      };
      Object.keys(this.options.tls || {}).forEach((key) => {
        opts[key] = this.options.tls[key];
      });
      if (this.servername && !opts.servername) {
        opts.servername = this.servername;
      }
      this.upgrading = true;
      try {
        this._socket = tls.connect(opts, () => {
          this.secure = true;
          this.upgrading = false;
          this._socket.on("data", this._onSocketData);
          socketPlain.removeListener("close", this._onSocketClose);
          socketPlain.removeListener("end", this._onSocketEnd);
          return callback(null, true);
        });
      } catch (err2) {
        return callback(err2);
      }
      this._socket.on("error", this._onSocketError);
      this._socket.once("close", this._onSocketClose);
      this._socket.once("end", this._onSocketEnd);
      this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT);
      this._socket.on("timeout", this._onSocketTimeout);
      socketPlain.resume();
    }
    /**
     * Processes queued responses from the server
     *
     * @param {Boolean} force If true, ignores _processing flag
     */
    _processResponse() {
      if (!this._responseQueue.length) {
        return false;
      }
      let str = this.lastServerResponse = (this._responseQueue.shift() || "").toString();
      if (/^\d+-/.test(str.split("\n").pop())) {
        return;
      }
      if (this.options.debug || this.options.transactionLog) {
        this.logger.debug(
          {
            tnx: "server"
          },
          str.replace(/\r?\n$/, "")
        );
      }
      if (!str.trim()) {
        setImmediate(() => this._processResponse());
      }
      let action = this._responseActions.shift();
      if (typeof action === "function") {
        action.call(this, str);
        setImmediate(() => this._processResponse());
      } else {
        return this._onError(new Error("Unexpected Response"), "EPROTOCOL", str, "CONN");
      }
    }
    /**
     * Send a command to the server, append \r\n
     *
     * @param {String} str String to be sent to the server
     * @param {String} logStr Optional string to be used for logging instead of the actual string
     */
    _sendCommand(str, logStr) {
      if (this._destroyed) {
        return;
      }
      if (this._socket.destroyed) {
        return this.close();
      }
      if (this.options.debug || this.options.transactionLog) {
        this.logger.debug(
          {
            tnx: "client"
          },
          (logStr || str || "").toString().replace(/\r?\n$/, "")
        );
      }
      this._socket.write(Buffer.from(str + "\r\n", "utf-8"));
    }
    /**
     * Initiates a new message by submitting envelope data, starting with
     * MAIL FROM: command
     *
     * @param {Object} envelope Envelope object in the form of
     *        {from:'...', to:['...']}
     *        or
     *        {from:{address:'...',name:'...'}, to:[address:'...',name:'...']}
     */
    _setEnvelope(envelope, callback) {
      let args = [];
      let useSmtpUtf8 = false;
      this._envelope = envelope || {};
      this._envelope.from = (this._envelope.from && this._envelope.from.address || this._envelope.from || "").toString().trim();
      this._envelope.to = [].concat(this._envelope.to || []).map((to) => (to && to.address || to || "").toString().trim());
      if (!this._envelope.to.length) {
        return callback(this._formatError("No recipients defined", "EENVELOPE", false, "API"));
      }
      if (this._envelope.from && /[\r\n<>]/.test(this._envelope.from)) {
        return callback(this._formatError("Invalid sender " + JSON.stringify(this._envelope.from), "EENVELOPE", false, "API"));
      }
      if (/[\x80-\uFFFF]/.test(this._envelope.from)) {
        useSmtpUtf8 = true;
      }
      for (let i = 0, len = this._envelope.to.length; i < len; i++) {
        if (!this._envelope.to[i] || /[\r\n<>]/.test(this._envelope.to[i])) {
          return callback(this._formatError("Invalid recipient " + JSON.stringify(this._envelope.to[i]), "EENVELOPE", false, "API"));
        }
        if (/[\x80-\uFFFF]/.test(this._envelope.to[i])) {
          useSmtpUtf8 = true;
        }
      }
      this._envelope.rcptQueue = JSON.parse(JSON.stringify(this._envelope.to || []));
      this._envelope.rejected = [];
      this._envelope.rejectedErrors = [];
      this._envelope.accepted = [];
      if (this._envelope.dsn) {
        try {
          this._envelope.dsn = this._setDsnEnvelope(this._envelope.dsn);
        } catch (err2) {
          return callback(this._formatError("Invalid DSN " + err2.message, "EENVELOPE", false, "API"));
        }
      }
      this._responseActions.push((str) => {
        this._actionMAIL(str, callback);
      });
      if (useSmtpUtf8 && this._supportedExtensions.includes("SMTPUTF8")) {
        args.push("SMTPUTF8");
        this._usingSmtpUtf8 = true;
      }
      if (this._envelope.use8BitMime && this._supportedExtensions.includes("8BITMIME")) {
        args.push("BODY=8BITMIME");
        this._using8BitMime = true;
      }
      if (this._envelope.size && this._supportedExtensions.includes("SIZE")) {
        args.push("SIZE=" + this._envelope.size);
      }
      if (this._envelope.dsn && this._supportedExtensions.includes("DSN")) {
        if (this._envelope.dsn.ret) {
          args.push("RET=" + shared2.encodeXText(this._envelope.dsn.ret));
        }
        if (this._envelope.dsn.envid) {
          args.push("ENVID=" + shared2.encodeXText(this._envelope.dsn.envid));
        }
      }
      if (this._envelope.requireTLSExtensionEnabled) {
        if (!this.secure) {
          return callback(
            this._formatError("REQUIRETLS can only be used over TLS connections (RFC 8689)", "EREQUIRETLS", false, "MAIL FROM")
          );
        }
        if (!this._supportedExtensions.includes("REQUIRETLS")) {
          return callback(
            this._formatError("Server does not support REQUIRETLS extension (RFC 8689)", "EREQUIRETLS", false, "MAIL FROM")
          );
        }
        args.push("REQUIRETLS");
      }
      this._sendCommand("MAIL FROM:<" + this._envelope.from + ">" + (args.length ? " " + args.join(" ") : ""));
    }
    _setDsnEnvelope(params) {
      let ret = (params.ret || params.return || "").toString().toUpperCase() || null;
      if (ret) {
        switch (ret) {
          case "HDRS":
          case "HEADERS":
            ret = "HDRS";
            break;
          case "FULL":
          case "BODY":
            ret = "FULL";
            break;
        }
      }
      if (ret && !["FULL", "HDRS"].includes(ret)) {
        throw new Error("ret: " + JSON.stringify(ret));
      }
      let envid = (params.envid || params.id || "").toString() || null;
      let notify = params.notify || null;
      if (notify) {
        if (typeof notify === "string") {
          notify = notify.split(",");
        }
        notify = notify.map((n2) => n2.trim().toUpperCase());
        let validNotify = ["NEVER", "SUCCESS", "FAILURE", "DELAY"];
        let invalidNotify = notify.filter((n2) => !validNotify.includes(n2));
        if (invalidNotify.length || notify.length > 1 && notify.includes("NEVER")) {
          throw new Error("notify: " + JSON.stringify(notify.join(",")));
        }
        notify = notify.join(",");
      }
      let orcpt = (params.recipient || params.orcpt || "").toString() || null;
      if (orcpt && orcpt.indexOf(";") < 0) {
        orcpt = "rfc822;" + orcpt;
      }
      return {
        ret,
        envid,
        notify,
        orcpt
      };
    }
    _getDsnRcptToArgs() {
      let args = [];
      if (this._envelope.dsn && this._supportedExtensions.includes("DSN")) {
        if (this._envelope.dsn.notify) {
          args.push("NOTIFY=" + shared2.encodeXText(this._envelope.dsn.notify));
        }
        if (this._envelope.dsn.orcpt) {
          args.push("ORCPT=" + shared2.encodeXText(this._envelope.dsn.orcpt));
        }
      }
      return args.length ? " " + args.join(" ") : "";
    }
    _createSendStream(callback) {
      let dataStream2 = new DataStream();
      let logStream;
      if (this.options.lmtp) {
        this._envelope.accepted.forEach((recipient, i) => {
          let final = i === this._envelope.accepted.length - 1;
          this._responseActions.push((str) => {
            this._actionLMTPStream(recipient, final, str, callback);
          });
        });
      } else {
        this._responseActions.push((str) => {
          this._actionSMTPStream(str, callback);
        });
      }
      dataStream2.pipe(this._socket, {
        end: false
      });
      if (this.options.debug) {
        logStream = new PassThrough();
        logStream.on("readable", () => {
          let chunk;
          while (chunk = logStream.read()) {
            this.logger.debug(
              {
                tnx: "message"
              },
              chunk.toString("binary").replace(/\r?\n$/, "")
            );
          }
        });
        dataStream2.pipe(logStream);
      }
      dataStream2.once("end", () => {
        this.logger.info(
          {
            tnx: "message",
            inByteCount: dataStream2.inByteCount,
            outByteCount: dataStream2.outByteCount
          },
          "<%s bytes encoded mime message (source size %s bytes)>",
          dataStream2.outByteCount,
          dataStream2.inByteCount
        );
      });
      return dataStream2;
    }
    /** ACTIONS **/
    /**
     * Will be run after the connection is created and the server sends
     * a greeting. If the incoming message starts with 220 initiate
     * SMTP session by sending EHLO command
     *
     * @param {String} str Message from the server
     */
    _actionGreeting(str) {
      clearTimeout(this._greetingTimeout);
      if (str.substr(0, 3) !== "220") {
        this._onError(new Error("Invalid greeting. response=" + str), "EPROTOCOL", str, "CONN");
        return;
      }
      if (this.options.lmtp) {
        this._responseActions.push(this._actionLHLO);
        this._sendCommand("LHLO " + this.name);
      } else {
        this._responseActions.push(this._actionEHLO);
        this._sendCommand("EHLO " + this.name);
      }
    }
    /**
     * Handles server response for LHLO command. If it yielded in
     * error, emit 'error', otherwise treat this as an EHLO response
     *
     * @param {String} str Message from the server
     */
    _actionLHLO(str) {
      if (str.charAt(0) !== "2") {
        this._onError(new Error("Invalid LHLO. response=" + str), "EPROTOCOL", str, "LHLO");
        return;
      }
      this._actionEHLO(str);
    }
    /**
     * Handles server response for EHLO command. If it yielded in
     * error, try HELO instead, otherwise initiate TLS negotiation
     * if STARTTLS is supported by the server or move into the
     * authentication phase.
     *
     * @param {String} str Message from the server
     */
    _actionEHLO(str) {
      let match2;
      if (str.substr(0, 3) === "421") {
        this._onError(new Error("Server terminates connection. response=" + str), "ECONNECTION", str, "EHLO");
        return;
      }
      if (str.charAt(0) !== "2") {
        if (this.options.requireTLS) {
          this._onError(
            new Error("EHLO failed but HELO does not support required STARTTLS. response=" + str),
            "ECONNECTION",
            str,
            "EHLO"
          );
          return;
        }
        this._responseActions.push(this._actionHELO);
        this._sendCommand("HELO " + this.name);
        return;
      }
      this._ehloLines = str.split(/\r?\n/).map((line2) => line2.replace(/^\d+[ -]/, "").trim()).filter((line2) => line2).slice(1);
      if (!this.secure && !this.options.ignoreTLS && (/[ -]STARTTLS\b/im.test(str) || this.options.requireTLS)) {
        this._sendCommand("STARTTLS");
        this._responseActions.push(this._actionSTARTTLS);
        return;
      }
      if (/[ -]SMTPUTF8\b/im.test(str)) {
        this._supportedExtensions.push("SMTPUTF8");
      }
      if (/[ -]DSN\b/im.test(str)) {
        this._supportedExtensions.push("DSN");
      }
      if (/[ -]8BITMIME\b/im.test(str)) {
        this._supportedExtensions.push("8BITMIME");
      }
      if (/[ -]REQUIRETLS\b/im.test(str)) {
        this._supportedExtensions.push("REQUIRETLS");
      }
      if (/[ -]PIPELINING\b/im.test(str)) {
        this._supportedExtensions.push("PIPELINING");
      }
      if (/[ -]AUTH\b/i.test(str)) {
        this.allowsAuth = true;
      }
      if (/[ -]AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)PLAIN/i.test(str)) {
        this._supportedAuth.push("PLAIN");
      }
      if (/[ -]AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)LOGIN/i.test(str)) {
        this._supportedAuth.push("LOGIN");
      }
      if (/[ -]AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)CRAM-MD5/i.test(str)) {
        this._supportedAuth.push("CRAM-MD5");
      }
      if (/[ -]AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)XOAUTH2/i.test(str)) {
        this._supportedAuth.push("XOAUTH2");
      }
      if (match2 = str.match(/[ -]SIZE(?:[ \t]+(\d+))?/im)) {
        this._supportedExtensions.push("SIZE");
        this._maxAllowedSize = Number(match2[1]) || 0;
      }
      this.emit("connect");
    }
    /**
     * Handles server response for HELO command. If it yielded in
     * error, emit 'error', otherwise move into the authentication phase.
     *
     * @param {String} str Message from the server
     */
    _actionHELO(str) {
      if (str.charAt(0) !== "2") {
        this._onError(new Error("Invalid HELO. response=" + str), "EPROTOCOL", str, "HELO");
        return;
      }
      this.allowsAuth = true;
      this.emit("connect");
    }
    /**
     * Handles server response for STARTTLS command. If there's an error
     * try HELO instead, otherwise initiate TLS upgrade. If the upgrade
     * succeedes restart the EHLO
     *
     * @param {String} str Message from the server
     */
    _actionSTARTTLS(str) {
      if (str.charAt(0) !== "2") {
        if (this.options.opportunisticTLS) {
          this.logger.info(
            {
              tnx: "smtp"
            },
            "Failed STARTTLS upgrade, continuing unencrypted"
          );
          return this.emit("connect");
        }
        this._onError(new Error("Error upgrading connection with STARTTLS"), "ETLS", str, "STARTTLS");
        return;
      }
      this._upgradeConnection((err2, secured) => {
        if (err2) {
          this._onError(new Error("Error initiating TLS - " + (err2.message || err2)), "ETLS", false, "STARTTLS");
          return;
        }
        this.logger.info(
          {
            tnx: "smtp"
          },
          "Connection upgraded with STARTTLS"
        );
        if (secured) {
          if (this.options.lmtp) {
            this._responseActions.push(this._actionLHLO);
            this._sendCommand("LHLO " + this.name);
          } else {
            this._responseActions.push(this._actionEHLO);
            this._sendCommand("EHLO " + this.name);
          }
        } else {
          this.emit("connect");
        }
      });
    }
    /**
     * Handle the response for AUTH LOGIN command. We are expecting
     * '334 VXNlcm5hbWU6' (base64 for 'Username:'). Data to be sent as
     * response needs to be base64 encoded username. We do not need
     * exact match but settle with 334 response in general as some
     * hosts invalidly use a longer message than VXNlcm5hbWU6
     *
     * @param {String} str Message from the server
     */
    _actionAUTH_LOGIN_USER(str, callback) {
      if (!/^334[ -]/.test(str)) {
        callback(this._formatError('Invalid login sequence while waiting for "334 VXNlcm5hbWU6"', "EAUTH", str, "AUTH LOGIN"));
        return;
      }
      this._responseActions.push((str2) => {
        this._actionAUTH_LOGIN_PASS(str2, callback);
      });
      this._sendCommand(Buffer.from(this._auth.credentials.user + "", "utf-8").toString("base64"));
    }
    /**
     * Handle the response for AUTH CRAM-MD5 command. We are expecting
     * '334 <challenge string>'. Data to be sent as response needs to be
     * base64 decoded challenge string, MD5 hashed using the password as
     * a HMAC key, prefixed by the username and a space, and finally all
     * base64 encoded again.
     *
     * @param {String} str Message from the server
     */
    _actionAUTH_CRAM_MD5(str, callback) {
      let challengeMatch = str.match(/^334\s+(.+)$/);
      let challengeString = "";
      if (!challengeMatch) {
        return callback(
          this._formatError("Invalid login sequence while waiting for server challenge string", "EAUTH", str, "AUTH CRAM-MD5")
        );
      } else {
        challengeString = challengeMatch[1];
      }
      let base64decoded = Buffer.from(challengeString, "base64").toString("ascii"), hmacMD5 = crypto2.createHmac("md5", this._auth.credentials.pass);
      hmacMD5.update(base64decoded);
      let prepended = this._auth.credentials.user + " " + hmacMD5.digest("hex");
      this._responseActions.push((str2) => {
        this._actionAUTH_CRAM_MD5_PASS(str2, callback);
      });
      this._sendCommand(
        Buffer.from(prepended).toString("base64"),
        // hidden hash for logs
        Buffer.from(this._auth.credentials.user + " /* secret */").toString("base64")
      );
    }
    /**
     * Handles the response to CRAM-MD5 authentication, if there's no error,
     * the user can be considered logged in. Start waiting for a message to send
     *
     * @param {String} str Message from the server
     */
    _actionAUTH_CRAM_MD5_PASS(str, callback) {
      if (!str.match(/^235\s+/)) {
        return callback(this._formatError('Invalid login sequence while waiting for "235"', "EAUTH", str, "AUTH CRAM-MD5"));
      }
      this.logger.info(
        {
          tnx: "smtp",
          username: this._auth.user,
          action: "authenticated",
          method: this._authMethod
        },
        "User %s authenticated",
        JSON.stringify(this._auth.user)
      );
      this.authenticated = true;
      callback(null, true);
    }
    /**
     * Handle the response for AUTH LOGIN command. We are expecting
     * '334 UGFzc3dvcmQ6' (base64 for 'Password:'). Data to be sent as
     * response needs to be base64 encoded password.
     *
     * @param {String} str Message from the server
     */
    _actionAUTH_LOGIN_PASS(str, callback) {
      if (!/^334[ -]/.test(str)) {
        return callback(this._formatError('Invalid login sequence while waiting for "334 UGFzc3dvcmQ6"', "EAUTH", str, "AUTH LOGIN"));
      }
      this._responseActions.push((str2) => {
        this._actionAUTHComplete(str2, callback);
      });
      this._sendCommand(
        Buffer.from((this._auth.credentials.pass || "").toString(), "utf-8").toString("base64"),
        // Hidden pass for logs
        Buffer.from("/* secret */", "utf-8").toString("base64")
      );
    }
    /**
     * Handles the response for authentication, if there's no error,
     * the user can be considered logged in. Start waiting for a message to send
     *
     * @param {String} str Message from the server
     */
    _actionAUTHComplete(str, isRetry, callback) {
      if (!callback && typeof isRetry === "function") {
        callback = isRetry;
        isRetry = false;
      }
      if (str.substr(0, 3) === "334") {
        this._responseActions.push((str2) => {
          if (isRetry || this._authMethod !== "XOAUTH2") {
            this._actionAUTHComplete(str2, true, callback);
          } else {
            setImmediate(() => this._handleXOauth2Token(true, callback));
          }
        });
        this._sendCommand("");
        return;
      }
      if (str.charAt(0) !== "2") {
        this.logger.info(
          {
            tnx: "smtp",
            username: this._auth.user,
            action: "authfail",
            method: this._authMethod
          },
          "User %s failed to authenticate",
          JSON.stringify(this._auth.user)
        );
        return callback(this._formatError("Invalid login", "EAUTH", str, "AUTH " + this._authMethod));
      }
      this.logger.info(
        {
          tnx: "smtp",
          username: this._auth.user,
          action: "authenticated",
          method: this._authMethod
        },
        "User %s authenticated",
        JSON.stringify(this._auth.user)
      );
      this.authenticated = true;
      callback(null, true);
    }
    /**
     * Handle response for a MAIL FROM: command
     *
     * @param {String} str Message from the server
     */
    _actionMAIL(str, callback) {
      let message2, curRecipient;
      if (Number(str.charAt(0)) !== 2) {
        if (this._usingSmtpUtf8 && /^550 /.test(str) && /[\x80-\uFFFF]/.test(this._envelope.from)) {
          message2 = "Internationalized mailbox name not allowed";
        } else {
          message2 = "Mail command failed";
        }
        return callback(this._formatError(message2, "EENVELOPE", str, "MAIL FROM"));
      }
      if (!this._envelope.rcptQueue.length) {
        return callback(this._formatError("Can't send mail - no recipients defined", "EENVELOPE", false, "API"));
      } else {
        this._recipientQueue = [];
        if (this._supportedExtensions.includes("PIPELINING")) {
          while (this._envelope.rcptQueue.length) {
            curRecipient = this._envelope.rcptQueue.shift();
            this._recipientQueue.push(curRecipient);
            this._responseActions.push((str2) => {
              this._actionRCPT(str2, callback);
            });
            this._sendCommand("RCPT TO:<" + curRecipient + ">" + this._getDsnRcptToArgs());
          }
        } else {
          curRecipient = this._envelope.rcptQueue.shift();
          this._recipientQueue.push(curRecipient);
          this._responseActions.push((str2) => {
            this._actionRCPT(str2, callback);
          });
          this._sendCommand("RCPT TO:<" + curRecipient + ">" + this._getDsnRcptToArgs());
        }
      }
    }
    /**
     * Handle response for a RCPT TO: command
     *
     * @param {String} str Message from the server
     */
    _actionRCPT(str, callback) {
      let message2, err2, curRecipient = this._recipientQueue.shift();
      if (Number(str.charAt(0)) !== 2) {
        if (this._usingSmtpUtf8 && /^553 /.test(str) && /[\x80-\uFFFF]/.test(curRecipient)) {
          message2 = "Internationalized mailbox name not allowed";
        } else {
          message2 = "Recipient command failed";
        }
        this._envelope.rejected.push(curRecipient);
        err2 = this._formatError(message2, "EENVELOPE", str, "RCPT TO");
        err2.recipient = curRecipient;
        this._envelope.rejectedErrors.push(err2);
      } else {
        this._envelope.accepted.push(curRecipient);
      }
      if (!this._envelope.rcptQueue.length && !this._recipientQueue.length) {
        if (this._envelope.rejected.length < this._envelope.to.length) {
          this._responseActions.push((str2) => {
            this._actionDATA(str2, callback);
          });
          this._sendCommand("DATA");
        } else {
          err2 = this._formatError("Can't send mail - all recipients were rejected", "EENVELOPE", str, "RCPT TO");
          err2.rejected = this._envelope.rejected;
          err2.rejectedErrors = this._envelope.rejectedErrors;
          return callback(err2);
        }
      } else if (this._envelope.rcptQueue.length) {
        curRecipient = this._envelope.rcptQueue.shift();
        this._recipientQueue.push(curRecipient);
        this._responseActions.push((str2) => {
          this._actionRCPT(str2, callback);
        });
        this._sendCommand("RCPT TO:<" + curRecipient + ">" + this._getDsnRcptToArgs());
      }
    }
    /**
     * Handle response for a DATA command
     *
     * @param {String} str Message from the server
     */
    _actionDATA(str, callback) {
      if (!/^[23]/.test(str)) {
        return callback(this._formatError("Data command failed", "EENVELOPE", str, "DATA"));
      }
      let response = {
        accepted: this._envelope.accepted,
        rejected: this._envelope.rejected
      };
      if (this._ehloLines && this._ehloLines.length) {
        response.ehlo = this._ehloLines;
      }
      if (this._envelope.rejectedErrors.length) {
        response.rejectedErrors = this._envelope.rejectedErrors;
      }
      callback(null, response);
    }
    /**
     * Handle response for a DATA stream when using SMTP
     * We expect a single response that defines if the sending succeeded or failed
     *
     * @param {String} str Message from the server
     */
    _actionSMTPStream(str, callback) {
      if (Number(str.charAt(0)) !== 2) {
        return callback(this._formatError("Message failed", "EMESSAGE", str, "DATA"));
      } else {
        return callback(null, str);
      }
    }
    /**
     * Handle response for a DATA stream
     * We expect a separate response for every recipient. All recipients can either
     * succeed or fail separately
     *
     * @param {String} recipient The recipient this response applies to
     * @param {Boolean} final Is this the final recipient?
     * @param {String} str Message from the server
     */
    _actionLMTPStream(recipient, final, str, callback) {
      let err2;
      if (Number(str.charAt(0)) !== 2) {
        err2 = this._formatError("Message failed for recipient " + recipient, "EMESSAGE", str, "DATA");
        err2.recipient = recipient;
        this._envelope.rejected.push(recipient);
        this._envelope.rejectedErrors.push(err2);
        for (let i = 0, len = this._envelope.accepted.length; i < len; i++) {
          if (this._envelope.accepted[i] === recipient) {
            this._envelope.accepted.splice(i, 1);
          }
        }
      }
      if (final) {
        return callback(null, str);
      }
    }
    _handleXOauth2Token(isRetry, callback) {
      this._auth.oauth2.getToken(isRetry, (err2, accessToken) => {
        if (err2) {
          this.logger.info(
            {
              tnx: "smtp",
              username: this._auth.user,
              action: "authfail",
              method: this._authMethod
            },
            "User %s failed to authenticate",
            JSON.stringify(this._auth.user)
          );
          return callback(this._formatError(err2, "EAUTH", false, "AUTH XOAUTH2"));
        }
        this._responseActions.push((str) => {
          this._actionAUTHComplete(str, isRetry, callback);
        });
        this._sendCommand(
          "AUTH XOAUTH2 " + this._auth.oauth2.buildXOAuth2Token(accessToken),
          //  Hidden for logs
          "AUTH XOAUTH2 " + this._auth.oauth2.buildXOAuth2Token("/* secret */")
        );
      });
    }
    /**
     *
     * @param {string} command
     * @private
     */
    _isDestroyedMessage(command) {
      if (this._destroyed) {
        return "Cannot " + command + " - smtp connection is already destroyed.";
      }
      if (this._socket) {
        if (this._socket.destroyed) {
          return "Cannot " + command + " - smtp connection socket is already destroyed.";
        }
        if (!this._socket.writable) {
          return "Cannot " + command + " - smtp connection socket is already half-closed.";
        }
      }
    }
    _getHostname() {
      let defaultHostname;
      try {
        defaultHostname = os.hostname() || "";
      } catch (_err) {
        defaultHostname = "localhost";
      }
      if (!defaultHostname || defaultHostname.indexOf(".") < 0) {
        defaultHostname = "[127.0.0.1]";
      }
      if (defaultHostname.match(/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/)) {
        defaultHostname = "[" + defaultHostname + "]";
      }
      return defaultHostname;
    }
  }
  smtpConnection = SMTPConnection;
  return smtpConnection;
}
var xoauth2;
var hasRequiredXoauth2;
function requireXoauth2() {
  if (hasRequiredXoauth2) return xoauth2;
  hasRequiredXoauth2 = 1;
  const Stream = require$$0$c.Stream;
  const nmfetch = requireFetch();
  const crypto2 = require$$0$5;
  const shared2 = requireShared();
  class XOAuth2 extends Stream {
    constructor(options, logger2) {
      super();
      this.options = options || {};
      if (options && options.serviceClient) {
        if (!options.privateKey || !options.user) {
          setImmediate(() => this.emit("error", new Error('Options "privateKey" and "user" are required for service account!')));
          return;
        }
        let serviceRequestTimeout = Math.min(Math.max(Number(this.options.serviceRequestTimeout) || 0, 0), 3600);
        this.options.serviceRequestTimeout = serviceRequestTimeout || 5 * 60;
      }
      this.logger = shared2.getLogger(
        {
          logger: logger2
        },
        {
          component: this.options.component || "OAuth2"
        }
      );
      this.provisionCallback = typeof this.options.provisionCallback === "function" ? this.options.provisionCallback : false;
      this.options.accessUrl = this.options.accessUrl || "https://accounts.google.com/o/oauth2/token";
      this.options.customHeaders = this.options.customHeaders || {};
      this.options.customParams = this.options.customParams || {};
      this.accessToken = this.options.accessToken || false;
      if (this.options.expires && Number(this.options.expires)) {
        this.expires = this.options.expires;
      } else {
        let timeout = Math.max(Number(this.options.timeout) || 0, 0);
        this.expires = timeout && Date.now() + timeout * 1e3 || 0;
      }
      this.renewing = false;
      this.renewalQueue = [];
    }
    /**
     * Returns or generates (if previous has expired) a XOAuth2 token
     *
     * @param {Boolean} renew If false then use cached access token (if available)
     * @param {Function} callback Callback function with error object and token string
     */
    getToken(renew, callback) {
      if (!renew && this.accessToken && (!this.expires || this.expires > Date.now())) {
        this.logger.debug(
          {
            tnx: "OAUTH2",
            user: this.options.user,
            action: "reuse"
          },
          "Reusing existing access token for %s",
          this.options.user
        );
        return callback(null, this.accessToken);
      }
      if (!this.provisionCallback && !this.options.refreshToken && !this.options.serviceClient) {
        if (this.accessToken) {
          this.logger.debug(
            {
              tnx: "OAUTH2",
              user: this.options.user,
              action: "reuse"
            },
            "Reusing existing access token (no refresh capability) for %s",
            this.options.user
          );
          return callback(null, this.accessToken);
        }
        this.logger.error(
          {
            tnx: "OAUTH2",
            user: this.options.user,
            action: "renew"
          },
          "Cannot renew access token for %s: No refresh mechanism available",
          this.options.user
        );
        return callback(new Error("Can't create new access token for user"));
      }
      if (this.renewing) {
        return this.renewalQueue.push({ renew, callback });
      }
      this.renewing = true;
      const generateCallback = (err2, accessToken) => {
        this.renewalQueue.forEach((item) => item.callback(err2, accessToken));
        this.renewalQueue = [];
        this.renewing = false;
        if (err2) {
          this.logger.error(
            {
              err: err2,
              tnx: "OAUTH2",
              user: this.options.user,
              action: "renew"
            },
            "Failed generating new Access Token for %s",
            this.options.user
          );
        } else {
          this.logger.info(
            {
              tnx: "OAUTH2",
              user: this.options.user,
              action: "renew"
            },
            "Generated new Access Token for %s",
            this.options.user
          );
        }
        callback(err2, accessToken);
      };
      if (this.provisionCallback) {
        this.provisionCallback(this.options.user, !!renew, (err2, accessToken, expires) => {
          if (!err2 && accessToken) {
            this.accessToken = accessToken;
            this.expires = expires || 0;
          }
          generateCallback(err2, accessToken);
        });
      } else {
        this.generateToken(generateCallback);
      }
    }
    /**
     * Updates token values
     *
     * @param {String} accessToken New access token
     * @param {Number} timeout Access token lifetime in seconds
     *
     * Emits 'token': { user: User email-address, accessToken: the new accessToken, timeout: TTL in seconds}
     */
    updateToken(accessToken, timeout) {
      this.accessToken = accessToken;
      timeout = Math.max(Number(timeout) || 0, 0);
      this.expires = timeout && Date.now() + timeout * 1e3 || 0;
      this.emit("token", {
        user: this.options.user,
        accessToken: accessToken || "",
        expires: this.expires
      });
    }
    /**
     * Generates a new XOAuth2 token with the credentials provided at initialization
     *
     * @param {Function} callback Callback function with error object and token string
     */
    generateToken(callback) {
      let urlOptions;
      let loggedUrlOptions;
      if (this.options.serviceClient) {
        let iat = Math.floor(Date.now() / 1e3);
        let tokenData = {
          iss: this.options.serviceClient,
          scope: this.options.scope || "https://mail.google.com/",
          sub: this.options.user,
          aud: this.options.accessUrl,
          iat,
          exp: iat + this.options.serviceRequestTimeout
        };
        let token2;
        try {
          token2 = this.jwtSignRS256(tokenData);
        } catch (_err) {
          return callback(new Error("Can't generate token. Check your auth options"));
        }
        urlOptions = {
          grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer",
          assertion: token2
        };
        loggedUrlOptions = {
          grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer",
          assertion: tokenData
        };
      } else {
        if (!this.options.refreshToken) {
          return callback(new Error("Can't create new access token for user"));
        }
        urlOptions = {
          client_id: this.options.clientId || "",
          client_secret: this.options.clientSecret || "",
          refresh_token: this.options.refreshToken,
          grant_type: "refresh_token"
        };
        loggedUrlOptions = {
          client_id: this.options.clientId || "",
          client_secret: (this.options.clientSecret || "").substr(0, 6) + "...",
          refresh_token: (this.options.refreshToken || "").substr(0, 6) + "...",
          grant_type: "refresh_token"
        };
      }
      Object.keys(this.options.customParams).forEach((key) => {
        urlOptions[key] = this.options.customParams[key];
        loggedUrlOptions[key] = this.options.customParams[key];
      });
      this.logger.debug(
        {
          tnx: "OAUTH2",
          user: this.options.user,
          action: "generate"
        },
        "Requesting token using: %s",
        JSON.stringify(loggedUrlOptions)
      );
      this.postRequest(this.options.accessUrl, urlOptions, this.options, (error2, body) => {
        let data;
        if (error2) {
          return callback(error2);
        }
        try {
          data = JSON.parse(body.toString());
        } catch (E) {
          return callback(E);
        }
        if (!data || typeof data !== "object") {
          this.logger.debug(
            {
              tnx: "OAUTH2",
              user: this.options.user,
              action: "post"
            },
            "Response: %s",
            (body || "").toString()
          );
          return callback(new Error("Invalid authentication response"));
        }
        let logData = {};
        Object.keys(data).forEach((key) => {
          if (key !== "access_token") {
            logData[key] = data[key];
          } else {
            logData[key] = (data[key] || "").toString().substr(0, 6) + "...";
          }
        });
        this.logger.debug(
          {
            tnx: "OAUTH2",
            user: this.options.user,
            action: "post"
          },
          "Response: %s",
          JSON.stringify(logData)
        );
        if (data.error) {
          let errorMessage = data.error;
          if (data.error_description) {
            errorMessage += ": " + data.error_description;
          }
          if (data.error_uri) {
            errorMessage += " (" + data.error_uri + ")";
          }
          return callback(new Error(errorMessage));
        }
        if (data.access_token) {
          this.updateToken(data.access_token, data.expires_in);
          return callback(null, this.accessToken);
        }
        return callback(new Error("No access token"));
      });
    }
    /**
     * Converts an access_token and user id into a base64 encoded XOAuth2 token
     *
     * @param {String} [accessToken] Access token string
     * @return {String} Base64 encoded token for IMAP or SMTP login
     */
    buildXOAuth2Token(accessToken) {
      let authData = ["user=" + (this.options.user || ""), "auth=Bearer " + (accessToken || this.accessToken), "", ""];
      return Buffer.from(authData.join(""), "utf-8").toString("base64");
    }
    /**
     * Custom POST request handler.
     * This is only needed to keep paths short in Windows  usually this module
     * is a dependency of a dependency and if it tries to require something
     * like the request module the paths get way too long to handle for Windows.
     * As we do only a simple POST request we do not actually require complicated
     * logic support (no redirects, no nothing) anyway.
     *
     * @param {String} url Url to POST to
     * @param {String|Buffer} payload Payload to POST
     * @param {Function} callback Callback function with (err, buff)
     */
    postRequest(url, payload, params, callback) {
      let returned = false;
      let chunks = [];
      let chunklen = 0;
      let req2 = nmfetch(url, {
        method: "post",
        headers: params.customHeaders,
        body: payload,
        allowErrorResponse: true
      });
      req2.on("readable", () => {
        let chunk;
        while ((chunk = req2.read()) !== null) {
          chunks.push(chunk);
          chunklen += chunk.length;
        }
      });
      req2.once("error", (err2) => {
        if (returned) {
          return;
        }
        returned = true;
        return callback(err2);
      });
      req2.once("end", () => {
        if (returned) {
          return;
        }
        returned = true;
        return callback(null, Buffer.concat(chunks, chunklen));
      });
    }
    /**
     * Encodes a buffer or a string into Base64url format
     *
     * @param {Buffer|String} data The data to convert
     * @return {String} The encoded string
     */
    toBase64URL(data) {
      if (typeof data === "string") {
        data = Buffer.from(data);
      }
      return data.toString("base64").replace(/[=]+/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    /**
     * Creates a JSON Web Token signed with RS256 (SHA256 + RSA)
     *
     * @param {Object} payload The payload to include in the generated token
     * @return {String} The generated and signed token
     */
    jwtSignRS256(payload) {
      payload = ['{"alg":"RS256","typ":"JWT"}', JSON.stringify(payload)].map((val) => this.toBase64URL(val)).join(".");
      let signature = crypto2.createSign("RSA-SHA256").update(payload).sign(this.options.privateKey);
      return payload + "." + this.toBase64URL(signature);
    }
  }
  xoauth2 = XOAuth2;
  return xoauth2;
}
var poolResource;
var hasRequiredPoolResource;
function requirePoolResource() {
  if (hasRequiredPoolResource) return poolResource;
  hasRequiredPoolResource = 1;
  const SMTPConnection = requireSmtpConnection();
  const assign = requireShared().assign;
  const XOAuth2 = requireXoauth2();
  const EventEmitter2 = require$$0$7;
  class PoolResource extends EventEmitter2 {
    constructor(pool) {
      super();
      this.pool = pool;
      this.options = pool.options;
      this.logger = this.pool.logger;
      if (this.options.auth) {
        switch ((this.options.auth.type || "").toString().toUpperCase()) {
          case "OAUTH2": {
            let oauth2 = new XOAuth2(this.options.auth, this.logger);
            oauth2.provisionCallback = this.pool.mailer && this.pool.mailer.get("oauth2_provision_cb") || oauth2.provisionCallback;
            this.auth = {
              type: "OAUTH2",
              user: this.options.auth.user,
              oauth2,
              method: "XOAUTH2"
            };
            oauth2.on("token", (token2) => this.pool.mailer.emit("token", token2));
            oauth2.on("error", (err2) => this.emit("error", err2));
            break;
          }
          default:
            if (!this.options.auth.user && !this.options.auth.pass) {
              break;
            }
            this.auth = {
              type: (this.options.auth.type || "").toString().toUpperCase() || "LOGIN",
              user: this.options.auth.user,
              credentials: {
                user: this.options.auth.user || "",
                pass: this.options.auth.pass,
                options: this.options.auth.options
              },
              method: (this.options.auth.method || "").trim().toUpperCase() || this.options.authMethod || false
            };
        }
      }
      this._connection = false;
      this._connected = false;
      this.messages = 0;
      this.available = true;
    }
    /**
     * Initiates a connection to the SMTP server
     *
     * @param {Function} callback Callback function to run once the connection is established or failed
     */
    connect(callback) {
      this.pool.getSocket(this.options, (err2, socketOptions) => {
        if (err2) {
          return callback(err2);
        }
        let returned = false;
        let options = this.options;
        if (socketOptions && socketOptions.connection) {
          this.logger.info(
            {
              tnx: "proxy",
              remoteAddress: socketOptions.connection.remoteAddress,
              remotePort: socketOptions.connection.remotePort,
              destHost: options.host || "",
              destPort: options.port || "",
              action: "connected"
            },
            "Using proxied socket from %s:%s to %s:%s",
            socketOptions.connection.remoteAddress,
            socketOptions.connection.remotePort,
            options.host || "",
            options.port || ""
          );
          options = assign(false, options);
          Object.keys(socketOptions).forEach((key) => {
            options[key] = socketOptions[key];
          });
        }
        this.connection = new SMTPConnection(options);
        this.connection.once("error", (err3) => {
          this.emit("error", err3);
          if (returned) {
            return;
          }
          returned = true;
          return callback(err3);
        });
        this.connection.once("end", () => {
          this.close();
          if (returned) {
            return;
          }
          returned = true;
          let timer = setTimeout(() => {
            if (returned) {
              return;
            }
            let err3 = new Error("Unexpected socket close");
            if (this.connection && this.connection._socket && this.connection._socket.upgrading) {
              err3.code = "ETLS";
            }
            callback(err3);
          }, 1e3);
          try {
            timer.unref();
          } catch (_E) {
          }
        });
        this.connection.connect(() => {
          if (returned) {
            return;
          }
          if (this.auth && (this.connection.allowsAuth || options.forceAuth)) {
            this.connection.login(this.auth, (err3) => {
              if (returned) {
                return;
              }
              returned = true;
              if (err3) {
                this.connection.close();
                this.emit("error", err3);
                return callback(err3);
              }
              this._connected = true;
              callback(null, true);
            });
          } else {
            returned = true;
            this._connected = true;
            return callback(null, true);
          }
        });
      });
    }
    /**
     * Sends an e-mail to be sent using the selected settings
     *
     * @param {Object} mail Mail object
     * @param {Function} callback Callback function
     */
    send(mail, callback) {
      if (!this._connected) {
        return this.connect((err2) => {
          if (err2) {
            return callback(err2);
          }
          return this.send(mail, callback);
        });
      }
      let envelope = mail.message.getEnvelope();
      let messageId = mail.message.messageId();
      let recipients = [].concat(envelope.to || []);
      if (recipients.length > 3) {
        recipients.push("...and " + recipients.splice(2).length + " more");
      }
      this.logger.info(
        {
          tnx: "send",
          messageId,
          cid: this.id
        },
        "Sending message %s using #%s to <%s>",
        messageId,
        this.id,
        recipients.join(", ")
      );
      if (mail.data.dsn) {
        envelope.dsn = mail.data.dsn;
      }
      if (mail.data.requireTLSExtensionEnabled) {
        envelope.requireTLSExtensionEnabled = mail.data.requireTLSExtensionEnabled;
      }
      this.connection.send(envelope, mail.message.createReadStream(), (err2, info2) => {
        this.messages++;
        if (err2) {
          this.connection.close();
          this.emit("error", err2);
          return callback(err2);
        }
        info2.envelope = {
          from: envelope.from,
          to: envelope.to
        };
        info2.messageId = messageId;
        setImmediate(() => {
          let err3;
          if (this.messages >= this.options.maxMessages) {
            err3 = new Error("Resource exhausted");
            err3.code = "EMAXLIMIT";
            this.connection.close();
            this.emit("error", err3);
          } else {
            this.pool._checkRateLimit(() => {
              this.available = true;
              this.emit("available");
            });
          }
        });
        callback(null, info2);
      });
    }
    /**
     * Closes the connection
     */
    close() {
      this._connected = false;
      if (this.auth && this.auth.oauth2) {
        this.auth.oauth2.removeAllListeners();
      }
      if (this.connection) {
        this.connection.close();
      }
      this.emit("close");
    }
  }
  poolResource = PoolResource;
  return poolResource;
}
const Aliyun = { "description": "Alibaba Cloud Mail", "domains": ["aliyun.com"], "host": "smtp.aliyun.com", "port": 465, "secure": true };
const AliyunQiye = { "description": "Alibaba Cloud Enterprise Mail", "host": "smtp.qiye.aliyun.com", "port": 465, "secure": true };
const AOL = { "description": "AOL Mail", "domains": ["aol.com"], "host": "smtp.aol.com", "port": 587 };
const Aruba = { "description": "Aruba PEC (Italian email provider)", "domains": ["aruba.it", "pec.aruba.it"], "aliases": ["Aruba PEC"], "host": "smtps.aruba.it", "port": 465, "secure": true, "authMethod": "LOGIN" };
const Bluewin = { "description": "Bluewin (Swiss email provider)", "host": "smtpauths.bluewin.ch", "domains": ["bluewin.ch"], "port": 465 };
const BOL = { "description": "BOL Mail (Brazilian provider)", "domains": ["bol.com.br"], "host": "smtp.bol.com.br", "port": 587, "requireTLS": true };
const DebugMail = { "description": "DebugMail (email testing service)", "host": "debugmail.io", "port": 25 };
const Disroot = { "description": "Disroot (privacy-focused provider)", "domains": ["disroot.org"], "host": "disroot.org", "port": 587, "secure": false, "authMethod": "LOGIN" };
const DynectEmail = { "description": "Dyn Email Delivery", "aliases": ["Dynect"], "host": "smtp.dynect.net", "port": 25 };
const ElasticEmail = { "description": "Elastic Email", "aliases": ["Elastic Email"], "host": "smtp.elasticemail.com", "port": 465, "secure": true };
const Ethereal = { "description": "Ethereal Email (email testing service)", "aliases": ["ethereal.email"], "host": "smtp.ethereal.email", "port": 587 };
const FastMail = { "description": "FastMail", "domains": ["fastmail.fm"], "host": "smtp.fastmail.com", "port": 465, "secure": true };
const GandiMail = { "description": "Gandi Mail", "aliases": ["Gandi", "Gandi Mail"], "host": "mail.gandi.net", "port": 587 };
const Gmail = { "description": "Gmail", "aliases": ["Google Mail"], "domains": ["gmail.com", "googlemail.com"], "host": "smtp.gmail.com", "port": 465, "secure": true };
const GMX = { "description": "GMX Mail", "domains": ["gmx.com", "gmx.net", "gmx.de"], "host": "mail.gmx.com", "port": 587 };
const Godaddy = { "description": "GoDaddy Email (US)", "host": "smtpout.secureserver.net", "port": 25 };
const GodaddyAsia = { "description": "GoDaddy Email (Asia)", "host": "smtp.asia.secureserver.net", "port": 25 };
const GodaddyEurope = { "description": "GoDaddy Email (Europe)", "host": "smtp.europe.secureserver.net", "port": 25 };
const Hotmail = { "description": "Outlook.com / Hotmail", "aliases": ["Outlook", "Outlook.com", "Hotmail.com"], "domains": ["hotmail.com", "outlook.com"], "host": "smtp-mail.outlook.com", "port": 587 };
const iCloud = { "description": "iCloud Mail", "aliases": ["Me", "Mac"], "domains": ["me.com", "mac.com"], "host": "smtp.mail.me.com", "port": 587 };
const Infomaniak = { "description": "Infomaniak Mail (Swiss hosting provider)", "host": "mail.infomaniak.com", "domains": ["ik.me", "ikmail.com", "etik.com"], "port": 587 };
const KolabNow = { "description": "KolabNow (secure email service)", "domains": ["kolabnow.com"], "aliases": ["Kolab"], "host": "smtp.kolabnow.com", "port": 465, "secure": true, "authMethod": "LOGIN" };
const Loopia = { "description": "Loopia (Swedish hosting provider)", "host": "mailcluster.loopia.se", "port": 465 };
const Loops = { "description": "Loops", "host": "smtp.loops.so", "port": 587 };
const Maildev = { "description": "MailDev (local email testing)", "port": 1025, "ignoreTLS": true };
const MailerSend = { "description": "MailerSend", "host": "smtp.mailersend.net", "port": 587 };
const Mailgun = { "description": "Mailgun", "host": "smtp.mailgun.org", "port": 465, "secure": true };
const Mailjet = { "description": "Mailjet", "host": "in.mailjet.com", "port": 587 };
const Mailosaur = { "description": "Mailosaur (email testing service)", "host": "mailosaur.io", "port": 25 };
const Mailtrap = { "description": "Mailtrap", "host": "live.smtp.mailtrap.io", "port": 587 };
const Mandrill = { "description": "Mandrill (by Mailchimp)", "host": "smtp.mandrillapp.com", "port": 587 };
const Naver = { "description": "Naver Mail (Korean email provider)", "host": "smtp.naver.com", "port": 587 };
const OhMySMTP = { "description": "OhMySMTP (email delivery service)", "host": "smtp.ohmysmtp.com", "port": 587, "secure": false };
const One = { "description": "One.com Email", "host": "send.one.com", "port": 465, "secure": true };
const OpenMailBox = { "description": "OpenMailBox", "aliases": ["OMB", "openmailbox.org"], "host": "smtp.openmailbox.org", "port": 465, "secure": true };
const Outlook365 = { "description": "Microsoft 365 / Office 365", "host": "smtp.office365.com", "port": 587, "secure": false };
const Postmark = { "description": "Postmark", "aliases": ["PostmarkApp"], "host": "smtp.postmarkapp.com", "port": 2525 };
const Proton = { "description": "Proton Mail", "aliases": ["ProtonMail", "Proton.me", "Protonmail.com", "Protonmail.ch"], "domains": ["proton.me", "protonmail.com", "pm.me", "protonmail.ch"], "host": "smtp.protonmail.ch", "port": 587, "requireTLS": true };
const QQ = { "description": "QQ Mail", "domains": ["qq.com"], "host": "smtp.qq.com", "port": 465, "secure": true };
const QQex = { "description": "QQ Enterprise Mail", "aliases": ["QQ Enterprise"], "domains": ["exmail.qq.com"], "host": "smtp.exmail.qq.com", "port": 465, "secure": true };
const Resend = { "description": "Resend", "host": "smtp.resend.com", "port": 465, "secure": true };
const Runbox = { "description": "Runbox (Norwegian email provider)", "domains": ["runbox.com"], "host": "smtp.runbox.com", "port": 465, "secure": true };
const SendCloud = { "description": "SendCloud (Chinese email delivery)", "host": "smtp.sendcloud.net", "port": 2525 };
const SendGrid = { "description": "SendGrid", "host": "smtp.sendgrid.net", "port": 587 };
const SendinBlue = { "description": "Brevo (formerly Sendinblue)", "aliases": ["Brevo"], "host": "smtp-relay.brevo.com", "port": 587 };
const SendPulse = { "description": "SendPulse", "host": "smtp-pulse.com", "port": 465, "secure": true };
const SES = { "description": "AWS SES US East (N. Virginia)", "host": "email-smtp.us-east-1.amazonaws.com", "port": 465, "secure": true };
const Seznam = { "description": "Seznam Email (Czech email provider)", "aliases": ["Seznam Email"], "domains": ["seznam.cz", "email.cz", "post.cz", "spoluzaci.cz"], "host": "smtp.seznam.cz", "port": 465, "secure": true };
const SMTP2GO = { "description": "SMTP2GO", "host": "mail.smtp2go.com", "port": 2525 };
const Sparkpost = { "description": "SparkPost", "aliases": ["SparkPost", "SparkPost Mail"], "domains": ["sparkpost.com"], "host": "smtp.sparkpostmail.com", "port": 587, "secure": false };
const Tipimail = { "description": "Tipimail (email delivery service)", "host": "smtp.tipimail.com", "port": 587 };
const Tutanota = { "description": "Tutanota (Tuta Mail)", "domains": ["tutanota.com", "tuta.com", "tutanota.de", "tuta.io"], "host": "smtp.tutanota.com", "port": 465, "secure": true };
const Yahoo = { "description": "Yahoo Mail", "domains": ["yahoo.com"], "host": "smtp.mail.yahoo.com", "port": 465, "secure": true };
const Yandex = { "description": "Yandex Mail", "domains": ["yandex.ru"], "host": "smtp.yandex.ru", "port": 465, "secure": true };
const Zimbra = { "description": "Zimbra Mail Server", "aliases": ["Zimbra Collaboration"], "host": "smtp.zimbra.com", "port": 587, "requireTLS": true };
const Zoho = { "description": "Zoho Mail", "host": "smtp.zoho.com", "port": 465, "secure": true, "authMethod": "LOGIN" };
const require$$0$2 = {
  "126": { "description": "126 Mail (NetEase)", "host": "smtp.126.com", "port": 465, "secure": true },
  "163": { "description": "163 Mail (NetEase)", "host": "smtp.163.com", "port": 465, "secure": true },
  "1und1": { "description": "1&1 Mail (German hosting provider)", "host": "smtp.1und1.de", "port": 465, "secure": true, "authMethod": "LOGIN" },
  Aliyun,
  AliyunQiye,
  AOL,
  Aruba,
  Bluewin,
  BOL,
  DebugMail,
  Disroot,
  DynectEmail,
  ElasticEmail,
  Ethereal,
  FastMail,
  "Feishu Mail": { "description": "Feishu Mail (Lark)", "aliases": ["Feishu", "FeishuMail"], "domains": ["www.feishu.cn"], "host": "smtp.feishu.cn", "port": 465, "secure": true },
  "Forward Email": { "description": "Forward Email (email forwarding service)", "aliases": ["FE", "ForwardEmail"], "domains": ["forwardemail.net"], "host": "smtp.forwardemail.net", "port": 465, "secure": true },
  GandiMail,
  Gmail,
  GMX,
  Godaddy,
  GodaddyAsia,
  GodaddyEurope,
  "hot.ee": { "description": "Hot.ee (Estonian email provider)", "host": "mail.hot.ee" },
  Hotmail,
  iCloud,
  Infomaniak,
  KolabNow,
  Loopia,
  Loops,
  "mail.ee": { "description": "Mail.ee (Estonian email provider)", "host": "smtp.mail.ee" },
  "Mail.ru": { "description": "Mail.ru", "host": "smtp.mail.ru", "port": 465, "secure": true },
  "Mailcatch.app": { "description": "Mailcatch (email testing service)", "host": "sandbox-smtp.mailcatch.app", "port": 2525 },
  Maildev,
  MailerSend,
  Mailgun,
  Mailjet,
  Mailosaur,
  Mailtrap,
  Mandrill,
  Naver,
  OhMySMTP,
  One,
  OpenMailBox,
  Outlook365,
  Postmark,
  Proton,
  "qiye.aliyun": { "description": "Alibaba Mail Enterprise Edition", "host": "smtp.mxhichina.com", "port": "465", "secure": true },
  QQ,
  QQex,
  Resend,
  Runbox,
  SendCloud,
  SendGrid,
  SendinBlue,
  SendPulse,
  SES,
  "SES-AP-NORTHEAST-1": { "description": "AWS SES Asia Pacific (Tokyo)", "host": "email-smtp.ap-northeast-1.amazonaws.com", "port": 465, "secure": true },
  "SES-AP-NORTHEAST-2": { "description": "AWS SES Asia Pacific (Seoul)", "host": "email-smtp.ap-northeast-2.amazonaws.com", "port": 465, "secure": true },
  "SES-AP-NORTHEAST-3": { "description": "AWS SES Asia Pacific (Osaka)", "host": "email-smtp.ap-northeast-3.amazonaws.com", "port": 465, "secure": true },
  "SES-AP-SOUTH-1": { "description": "AWS SES Asia Pacific (Mumbai)", "host": "email-smtp.ap-south-1.amazonaws.com", "port": 465, "secure": true },
  "SES-AP-SOUTHEAST-1": { "description": "AWS SES Asia Pacific (Singapore)", "host": "email-smtp.ap-southeast-1.amazonaws.com", "port": 465, "secure": true },
  "SES-AP-SOUTHEAST-2": { "description": "AWS SES Asia Pacific (Sydney)", "host": "email-smtp.ap-southeast-2.amazonaws.com", "port": 465, "secure": true },
  "SES-CA-CENTRAL-1": { "description": "AWS SES Canada (Central)", "host": "email-smtp.ca-central-1.amazonaws.com", "port": 465, "secure": true },
  "SES-EU-CENTRAL-1": { "description": "AWS SES Europe (Frankfurt)", "host": "email-smtp.eu-central-1.amazonaws.com", "port": 465, "secure": true },
  "SES-EU-NORTH-1": { "description": "AWS SES Europe (Stockholm)", "host": "email-smtp.eu-north-1.amazonaws.com", "port": 465, "secure": true },
  "SES-EU-WEST-1": { "description": "AWS SES Europe (Ireland)", "host": "email-smtp.eu-west-1.amazonaws.com", "port": 465, "secure": true },
  "SES-EU-WEST-2": { "description": "AWS SES Europe (London)", "host": "email-smtp.eu-west-2.amazonaws.com", "port": 465, "secure": true },
  "SES-EU-WEST-3": { "description": "AWS SES Europe (Paris)", "host": "email-smtp.eu-west-3.amazonaws.com", "port": 465, "secure": true },
  "SES-SA-EAST-1": { "description": "AWS SES South America (So Paulo)", "host": "email-smtp.sa-east-1.amazonaws.com", "port": 465, "secure": true },
  "SES-US-EAST-1": { "description": "AWS SES US East (N. Virginia)", "host": "email-smtp.us-east-1.amazonaws.com", "port": 465, "secure": true },
  "SES-US-EAST-2": { "description": "AWS SES US East (Ohio)", "host": "email-smtp.us-east-2.amazonaws.com", "port": 465, "secure": true },
  "SES-US-GOV-EAST-1": { "description": "AWS SES GovCloud (US-East)", "host": "email-smtp.us-gov-east-1.amazonaws.com", "port": 465, "secure": true },
  "SES-US-GOV-WEST-1": { "description": "AWS SES GovCloud (US-West)", "host": "email-smtp.us-gov-west-1.amazonaws.com", "port": 465, "secure": true },
  "SES-US-WEST-1": { "description": "AWS SES US West (N. California)", "host": "email-smtp.us-west-1.amazonaws.com", "port": 465, "secure": true },
  "SES-US-WEST-2": { "description": "AWS SES US West (Oregon)", "host": "email-smtp.us-west-2.amazonaws.com", "port": 465, "secure": true },
  Seznam,
  SMTP2GO,
  Sparkpost,
  Tipimail,
  Tutanota,
  Yahoo,
  Yandex,
  Zimbra,
  Zoho
};
var wellKnown;
var hasRequiredWellKnown;
function requireWellKnown() {
  if (hasRequiredWellKnown) return wellKnown;
  hasRequiredWellKnown = 1;
  const services = require$$0$2;
  const normalized = {};
  Object.keys(services).forEach((key) => {
    let service = services[key];
    normalized[normalizeKey2(key)] = normalizeService(service);
    [].concat(service.aliases || []).forEach((alias2) => {
      normalized[normalizeKey2(alias2)] = normalizeService(service);
    });
    [].concat(service.domains || []).forEach((domain) => {
      normalized[normalizeKey2(domain)] = normalizeService(service);
    });
  });
  function normalizeKey2(key) {
    return key.replace(/[^a-zA-Z0-9.-]/g, "").toLowerCase();
  }
  function normalizeService(service) {
    let filter = ["domains", "aliases"];
    let response = {};
    Object.keys(service).forEach((key) => {
      if (filter.indexOf(key) < 0) {
        response[key] = service[key];
      }
    });
    return response;
  }
  wellKnown = function(key) {
    key = normalizeKey2(key.split("@").pop());
    return normalized[key] || false;
  };
  return wellKnown;
}
var smtpPool;
var hasRequiredSmtpPool;
function requireSmtpPool() {
  if (hasRequiredSmtpPool) return smtpPool;
  hasRequiredSmtpPool = 1;
  const EventEmitter2 = require$$0$7;
  const PoolResource = requirePoolResource();
  const SMTPConnection = requireSmtpConnection();
  const wellKnown2 = requireWellKnown();
  const shared2 = requireShared();
  const packageData = require$$9;
  class SMTPPool extends EventEmitter2 {
    constructor(options) {
      super();
      options = options || {};
      if (typeof options === "string") {
        options = {
          url: options
        };
      }
      let urlData;
      let service = options.service;
      if (typeof options.getSocket === "function") {
        this.getSocket = options.getSocket;
      }
      if (options.url) {
        urlData = shared2.parseConnectionUrl(options.url);
        service = service || urlData.service;
      }
      this.options = shared2.assign(
        false,
        // create new object
        options,
        // regular options
        urlData,
        // url options
        service && wellKnown2(service)
        // wellknown options
      );
      this.options.maxConnections = this.options.maxConnections || 5;
      this.options.maxMessages = this.options.maxMessages || 100;
      this.logger = shared2.getLogger(this.options, {
        component: this.options.component || "smtp-pool"
      });
      let connection2 = new SMTPConnection(this.options);
      this.name = "SMTP (pool)";
      this.version = packageData.version + "[client:" + connection2.version + "]";
      this._rateLimit = {
        counter: 0,
        timeout: null,
        waiting: [],
        checkpoint: false,
        delta: Number(this.options.rateDelta) || 1e3,
        limit: Number(this.options.rateLimit) || 0
      };
      this._closed = false;
      this._queue = [];
      this._connections = [];
      this._connectionCounter = 0;
      this.idling = true;
      setImmediate(() => {
        if (this.idling) {
          this.emit("idle");
        }
      });
    }
    /**
     * Placeholder function for creating proxy sockets. This method immediatelly returns
     * without a socket
     *
     * @param {Object} options Connection options
     * @param {Function} callback Callback function to run with the socket keys
     */
    getSocket(options, callback) {
      return setImmediate(() => callback(null, false));
    }
    /**
     * Queues an e-mail to be sent using the selected settings
     *
     * @param {Object} mail Mail object
     * @param {Function} callback Callback function
     */
    send(mail, callback) {
      if (this._closed) {
        return false;
      }
      this._queue.push({
        mail,
        requeueAttempts: 0,
        callback
      });
      if (this.idling && this._queue.length >= this.options.maxConnections) {
        this.idling = false;
      }
      setImmediate(() => this._processMessages());
      return true;
    }
    /**
     * Closes all connections in the pool. If there is a message being sent, the connection
     * is closed later
     */
    close() {
      let connection2;
      let len = this._connections.length;
      this._closed = true;
      clearTimeout(this._rateLimit.timeout);
      if (!len && !this._queue.length) {
        return;
      }
      for (let i = len - 1; i >= 0; i--) {
        if (this._connections[i] && this._connections[i].available) {
          connection2 = this._connections[i];
          connection2.close();
          this.logger.info(
            {
              tnx: "connection",
              cid: connection2.id,
              action: "removed"
            },
            "Connection #%s removed",
            connection2.id
          );
        }
      }
      if (len && !this._connections.length) {
        this.logger.debug(
          {
            tnx: "connection"
          },
          "All connections removed"
        );
      }
      if (!this._queue.length) {
        return;
      }
      let invokeCallbacks = () => {
        if (!this._queue.length) {
          this.logger.debug(
            {
              tnx: "connection"
            },
            "Pending queue entries cleared"
          );
          return;
        }
        let entry = this._queue.shift();
        if (entry && typeof entry.callback === "function") {
          try {
            entry.callback(new Error("Connection pool was closed"));
          } catch (E) {
            this.logger.error(
              {
                err: E,
                tnx: "callback",
                cid: connection2.id
              },
              "Callback error for #%s: %s",
              connection2.id,
              E.message
            );
          }
        }
        setImmediate(invokeCallbacks);
      };
      setImmediate(invokeCallbacks);
    }
    /**
     * Check the queue and available connections. If there is a message to be sent and there is
     * an available connection, then use this connection to send the mail
     */
    _processMessages() {
      let connection2;
      let i, len;
      if (this._closed) {
        return;
      }
      if (!this._queue.length) {
        if (!this.idling) {
          this.idling = true;
          this.emit("idle");
        }
        return;
      }
      for (i = 0, len = this._connections.length; i < len; i++) {
        if (this._connections[i].available) {
          connection2 = this._connections[i];
          break;
        }
      }
      if (!connection2 && this._connections.length < this.options.maxConnections) {
        connection2 = this._createConnection();
      }
      if (!connection2) {
        this.idling = false;
        return;
      }
      if (!this.idling && this._queue.length < this.options.maxConnections) {
        this.idling = true;
        this.emit("idle");
      }
      let entry = connection2.queueEntry = this._queue.shift();
      entry.messageId = (connection2.queueEntry.mail.message.getHeader("message-id") || "").replace(/[<>\s]/g, "");
      connection2.available = false;
      this.logger.debug(
        {
          tnx: "pool",
          cid: connection2.id,
          messageId: entry.messageId,
          action: "assign"
        },
        "Assigned message <%s> to #%s (%s)",
        entry.messageId,
        connection2.id,
        connection2.messages + 1
      );
      if (this._rateLimit.limit) {
        this._rateLimit.counter++;
        if (!this._rateLimit.checkpoint) {
          this._rateLimit.checkpoint = Date.now();
        }
      }
      connection2.send(entry.mail, (err2, info2) => {
        if (entry === connection2.queueEntry) {
          try {
            entry.callback(err2, info2);
          } catch (E) {
            this.logger.error(
              {
                err: E,
                tnx: "callback",
                cid: connection2.id
              },
              "Callback error for #%s: %s",
              connection2.id,
              E.message
            );
          }
          connection2.queueEntry = false;
        }
      });
    }
    /**
     * Creates a new pool resource
     */
    _createConnection() {
      let connection2 = new PoolResource(this);
      connection2.id = ++this._connectionCounter;
      this.logger.info(
        {
          tnx: "pool",
          cid: connection2.id,
          action: "conection"
        },
        "Created new pool resource #%s",
        connection2.id
      );
      connection2.on("available", () => {
        this.logger.debug(
          {
            tnx: "connection",
            cid: connection2.id,
            action: "available"
          },
          "Connection #%s became available",
          connection2.id
        );
        if (this._closed) {
          this.close();
        } else {
          this._processMessages();
        }
      });
      connection2.once("error", (err2) => {
        if (err2.code !== "EMAXLIMIT") {
          this.logger.warn(
            {
              err: err2,
              tnx: "pool",
              cid: connection2.id
            },
            "Pool Error for #%s: %s",
            connection2.id,
            err2.message
          );
        } else {
          this.logger.debug(
            {
              tnx: "pool",
              cid: connection2.id,
              action: "maxlimit"
            },
            "Max messages limit exchausted for #%s",
            connection2.id
          );
        }
        if (connection2.queueEntry) {
          try {
            connection2.queueEntry.callback(err2);
          } catch (E) {
            this.logger.error(
              {
                err: E,
                tnx: "callback",
                cid: connection2.id
              },
              "Callback error for #%s: %s",
              connection2.id,
              E.message
            );
          }
          connection2.queueEntry = false;
        }
        this._removeConnection(connection2);
        this._continueProcessing();
      });
      connection2.once("close", () => {
        this.logger.info(
          {
            tnx: "connection",
            cid: connection2.id,
            action: "closed"
          },
          "Connection #%s was closed",
          connection2.id
        );
        this._removeConnection(connection2);
        if (connection2.queueEntry) {
          setTimeout(() => {
            if (connection2.queueEntry) {
              if (this._shouldRequeuOnConnectionClose(connection2.queueEntry)) {
                this._requeueEntryOnConnectionClose(connection2);
              } else {
                this._failDeliveryOnConnectionClose(connection2);
              }
            }
            this._continueProcessing();
          }, 50);
        } else {
          if (!this._closed && this.idling && !this._connections.length) {
            this.emit("clear");
          }
          this._continueProcessing();
        }
      });
      this._connections.push(connection2);
      return connection2;
    }
    _shouldRequeuOnConnectionClose(queueEntry) {
      if (this.options.maxRequeues === void 0 || this.options.maxRequeues < 0) {
        return true;
      }
      return queueEntry.requeueAttempts < this.options.maxRequeues;
    }
    _failDeliveryOnConnectionClose(connection2) {
      if (connection2.queueEntry && connection2.queueEntry.callback) {
        try {
          connection2.queueEntry.callback(new Error("Reached maximum number of retries after connection was closed"));
        } catch (E) {
          this.logger.error(
            {
              err: E,
              tnx: "callback",
              messageId: connection2.queueEntry.messageId,
              cid: connection2.id
            },
            "Callback error for #%s: %s",
            connection2.id,
            E.message
          );
        }
        connection2.queueEntry = false;
      }
    }
    _requeueEntryOnConnectionClose(connection2) {
      connection2.queueEntry.requeueAttempts = connection2.queueEntry.requeueAttempts + 1;
      this.logger.debug(
        {
          tnx: "pool",
          cid: connection2.id,
          messageId: connection2.queueEntry.messageId,
          action: "requeue"
        },
        "Re-queued message <%s> for #%s. Attempt: #%s",
        connection2.queueEntry.messageId,
        connection2.id,
        connection2.queueEntry.requeueAttempts
      );
      this._queue.unshift(connection2.queueEntry);
      connection2.queueEntry = false;
    }
    /**
     * Continue to process message if the pool hasn't closed
     */
    _continueProcessing() {
      if (this._closed) {
        this.close();
      } else {
        setTimeout(() => this._processMessages(), 100);
      }
    }
    /**
     * Remove resource from pool
     *
     * @param {Object} connection The PoolResource to remove
     */
    _removeConnection(connection2) {
      let index2 = this._connections.indexOf(connection2);
      if (index2 !== -1) {
        this._connections.splice(index2, 1);
      }
    }
    /**
     * Checks if connections have hit current rate limit and if so, queues the availability callback
     *
     * @param {Function} callback Callback function to run once rate limiter has been cleared
     */
    _checkRateLimit(callback) {
      if (!this._rateLimit.limit) {
        return callback();
      }
      let now2 = Date.now();
      if (this._rateLimit.counter < this._rateLimit.limit) {
        return callback();
      }
      this._rateLimit.waiting.push(callback);
      if (this._rateLimit.checkpoint <= now2 - this._rateLimit.delta) {
        return this._clearRateLimit();
      } else if (!this._rateLimit.timeout) {
        this._rateLimit.timeout = setTimeout(() => this._clearRateLimit(), this._rateLimit.delta - (now2 - this._rateLimit.checkpoint));
        this._rateLimit.checkpoint = now2;
      }
    }
    /**
     * Clears current rate limit limitation and runs paused callback
     */
    _clearRateLimit() {
      clearTimeout(this._rateLimit.timeout);
      this._rateLimit.timeout = null;
      this._rateLimit.counter = 0;
      this._rateLimit.checkpoint = false;
      while (this._rateLimit.waiting.length) {
        let cb = this._rateLimit.waiting.shift();
        setImmediate(cb);
      }
    }
    /**
     * Returns true if there are free slots in the queue
     */
    isIdle() {
      return this.idling;
    }
    /**
     * Verifies SMTP configuration
     *
     * @param {Function} callback Callback function
     */
    verify(callback) {
      let promise;
      if (!callback) {
        promise = new Promise((resolve2, reject) => {
          callback = shared2.callbackPromise(resolve2, reject);
        });
      }
      let auth2 = new PoolResource(this).auth;
      this.getSocket(this.options, (err2, socketOptions) => {
        if (err2) {
          return callback(err2);
        }
        let options = this.options;
        if (socketOptions && socketOptions.connection) {
          this.logger.info(
            {
              tnx: "proxy",
              remoteAddress: socketOptions.connection.remoteAddress,
              remotePort: socketOptions.connection.remotePort,
              destHost: options.host || "",
              destPort: options.port || "",
              action: "connected"
            },
            "Using proxied socket from %s:%s to %s:%s",
            socketOptions.connection.remoteAddress,
            socketOptions.connection.remotePort,
            options.host || "",
            options.port || ""
          );
          options = shared2.assign(false, options);
          Object.keys(socketOptions).forEach((key) => {
            options[key] = socketOptions[key];
          });
        }
        let connection2 = new SMTPConnection(options);
        let returned = false;
        connection2.once("error", (err3) => {
          if (returned) {
            return;
          }
          returned = true;
          connection2.close();
          return callback(err3);
        });
        connection2.once("end", () => {
          if (returned) {
            return;
          }
          returned = true;
          return callback(new Error("Connection closed"));
        });
        let finalize = () => {
          if (returned) {
            return;
          }
          returned = true;
          connection2.quit();
          return callback(null, true);
        };
        connection2.connect(() => {
          if (returned) {
            return;
          }
          if (auth2 && (connection2.allowsAuth || options.forceAuth)) {
            connection2.login(auth2, (err3) => {
              if (returned) {
                return;
              }
              if (err3) {
                returned = true;
                connection2.close();
                return callback(err3);
              }
              finalize();
            });
          } else if (!auth2 && connection2.allowsAuth && options.forceAuth) {
            let err3 = new Error("Authentication info was not provided");
            err3.code = "NoAuth";
            returned = true;
            connection2.close();
            return callback(err3);
          } else {
            finalize();
          }
        });
      });
      return promise;
    }
  }
  smtpPool = SMTPPool;
  return smtpPool;
}
var smtpTransport;
var hasRequiredSmtpTransport;
function requireSmtpTransport() {
  if (hasRequiredSmtpTransport) return smtpTransport;
  hasRequiredSmtpTransport = 1;
  const EventEmitter2 = require$$0$7;
  const SMTPConnection = requireSmtpConnection();
  const wellKnown2 = requireWellKnown();
  const shared2 = requireShared();
  const XOAuth2 = requireXoauth2();
  const packageData = require$$9;
  class SMTPTransport extends EventEmitter2 {
    constructor(options) {
      super();
      options = options || {};
      if (typeof options === "string") {
        options = {
          url: options
        };
      }
      let urlData;
      let service = options.service;
      if (typeof options.getSocket === "function") {
        this.getSocket = options.getSocket;
      }
      if (options.url) {
        urlData = shared2.parseConnectionUrl(options.url);
        service = service || urlData.service;
      }
      this.options = shared2.assign(
        false,
        // create new object
        options,
        // regular options
        urlData,
        // url options
        service && wellKnown2(service)
        // wellknown options
      );
      this.logger = shared2.getLogger(this.options, {
        component: this.options.component || "smtp-transport"
      });
      let connection2 = new SMTPConnection(this.options);
      this.name = "SMTP";
      this.version = packageData.version + "[client:" + connection2.version + "]";
      if (this.options.auth) {
        this.auth = this.getAuth({});
      }
    }
    /**
     * Placeholder function for creating proxy sockets. This method immediatelly returns
     * without a socket
     *
     * @param {Object} options Connection options
     * @param {Function} callback Callback function to run with the socket keys
     */
    getSocket(options, callback) {
      return setImmediate(() => callback(null, false));
    }
    getAuth(authOpts) {
      if (!authOpts) {
        return this.auth;
      }
      let hasAuth = false;
      let authData = {};
      if (this.options.auth && typeof this.options.auth === "object") {
        Object.keys(this.options.auth).forEach((key) => {
          hasAuth = true;
          authData[key] = this.options.auth[key];
        });
      }
      if (authOpts && typeof authOpts === "object") {
        Object.keys(authOpts).forEach((key) => {
          hasAuth = true;
          authData[key] = authOpts[key];
        });
      }
      if (!hasAuth) {
        return false;
      }
      switch ((authData.type || "").toString().toUpperCase()) {
        case "OAUTH2": {
          if (!authData.service && !authData.user) {
            return false;
          }
          let oauth2 = new XOAuth2(authData, this.logger);
          oauth2.provisionCallback = this.mailer && this.mailer.get("oauth2_provision_cb") || oauth2.provisionCallback;
          oauth2.on("token", (token2) => this.mailer.emit("token", token2));
          oauth2.on("error", (err2) => this.emit("error", err2));
          return {
            type: "OAUTH2",
            user: authData.user,
            oauth2,
            method: "XOAUTH2"
          };
        }
        default:
          return {
            type: (authData.type || "").toString().toUpperCase() || "LOGIN",
            user: authData.user,
            credentials: {
              user: authData.user || "",
              pass: authData.pass,
              options: authData.options
            },
            method: (authData.method || "").trim().toUpperCase() || this.options.authMethod || false
          };
      }
    }
    /**
     * Sends an e-mail using the selected settings
     *
     * @param {Object} mail Mail object
     * @param {Function} callback Callback function
     */
    send(mail, callback) {
      this.getSocket(this.options, (err2, socketOptions) => {
        if (err2) {
          return callback(err2);
        }
        let returned = false;
        let options = this.options;
        if (socketOptions && socketOptions.connection) {
          this.logger.info(
            {
              tnx: "proxy",
              remoteAddress: socketOptions.connection.remoteAddress,
              remotePort: socketOptions.connection.remotePort,
              destHost: options.host || "",
              destPort: options.port || "",
              action: "connected"
            },
            "Using proxied socket from %s:%s to %s:%s",
            socketOptions.connection.remoteAddress,
            socketOptions.connection.remotePort,
            options.host || "",
            options.port || ""
          );
          options = shared2.assign(false, options);
          Object.keys(socketOptions).forEach((key) => {
            options[key] = socketOptions[key];
          });
        }
        let connection2 = new SMTPConnection(options);
        connection2.once("error", (err3) => {
          if (returned) {
            return;
          }
          returned = true;
          connection2.close();
          return callback(err3);
        });
        connection2.once("end", () => {
          if (returned) {
            return;
          }
          let timer = setTimeout(() => {
            if (returned) {
              return;
            }
            returned = true;
            let err3 = new Error("Unexpected socket close");
            if (connection2 && connection2._socket && connection2._socket.upgrading) {
              err3.code = "ETLS";
            }
            callback(err3);
          }, 1e3);
          try {
            timer.unref();
          } catch (_E) {
          }
        });
        let sendMessage = () => {
          let envelope = mail.message.getEnvelope();
          let messageId = mail.message.messageId();
          let recipients = [].concat(envelope.to || []);
          if (recipients.length > 3) {
            recipients.push("...and " + recipients.splice(2).length + " more");
          }
          if (mail.data.dsn) {
            envelope.dsn = mail.data.dsn;
          }
          if (mail.data.requireTLSExtensionEnabled) {
            envelope.requireTLSExtensionEnabled = mail.data.requireTLSExtensionEnabled;
          }
          this.logger.info(
            {
              tnx: "send",
              messageId
            },
            "Sending message %s to <%s>",
            messageId,
            recipients.join(", ")
          );
          connection2.send(envelope, mail.message.createReadStream(), (err3, info2) => {
            returned = true;
            connection2.close();
            if (err3) {
              this.logger.error(
                {
                  err: err3,
                  tnx: "send"
                },
                "Send error for %s: %s",
                messageId,
                err3.message
              );
              return callback(err3);
            }
            info2.envelope = {
              from: envelope.from,
              to: envelope.to
            };
            info2.messageId = messageId;
            try {
              return callback(null, info2);
            } catch (E) {
              this.logger.error(
                {
                  err: E,
                  tnx: "callback"
                },
                "Callback error for %s: %s",
                messageId,
                E.message
              );
            }
          });
        };
        connection2.connect(() => {
          if (returned) {
            return;
          }
          let auth2 = this.getAuth(mail.data.auth);
          if (auth2 && (connection2.allowsAuth || options.forceAuth)) {
            connection2.login(auth2, (err3) => {
              if (auth2 && auth2 !== this.auth && auth2.oauth2) {
                auth2.oauth2.removeAllListeners();
              }
              if (returned) {
                return;
              }
              if (err3) {
                returned = true;
                connection2.close();
                return callback(err3);
              }
              sendMessage();
            });
          } else {
            sendMessage();
          }
        });
      });
    }
    /**
     * Verifies SMTP configuration
     *
     * @param {Function} callback Callback function
     */
    verify(callback) {
      let promise;
      if (!callback) {
        promise = new Promise((resolve2, reject) => {
          callback = shared2.callbackPromise(resolve2, reject);
        });
      }
      this.getSocket(this.options, (err2, socketOptions) => {
        if (err2) {
          return callback(err2);
        }
        let options = this.options;
        if (socketOptions && socketOptions.connection) {
          this.logger.info(
            {
              tnx: "proxy",
              remoteAddress: socketOptions.connection.remoteAddress,
              remotePort: socketOptions.connection.remotePort,
              destHost: options.host || "",
              destPort: options.port || "",
              action: "connected"
            },
            "Using proxied socket from %s:%s to %s:%s",
            socketOptions.connection.remoteAddress,
            socketOptions.connection.remotePort,
            options.host || "",
            options.port || ""
          );
          options = shared2.assign(false, options);
          Object.keys(socketOptions).forEach((key) => {
            options[key] = socketOptions[key];
          });
        }
        let connection2 = new SMTPConnection(options);
        let returned = false;
        connection2.once("error", (err3) => {
          if (returned) {
            return;
          }
          returned = true;
          connection2.close();
          return callback(err3);
        });
        connection2.once("end", () => {
          if (returned) {
            return;
          }
          returned = true;
          return callback(new Error("Connection closed"));
        });
        let finalize = () => {
          if (returned) {
            return;
          }
          returned = true;
          connection2.quit();
          return callback(null, true);
        };
        connection2.connect(() => {
          if (returned) {
            return;
          }
          let authData = this.getAuth({});
          if (authData && (connection2.allowsAuth || options.forceAuth)) {
            connection2.login(authData, (err3) => {
              if (returned) {
                return;
              }
              if (err3) {
                returned = true;
                connection2.close();
                return callback(err3);
              }
              finalize();
            });
          } else if (!authData && connection2.allowsAuth && options.forceAuth) {
            let err3 = new Error("Authentication info was not provided");
            err3.code = "NoAuth";
            returned = true;
            connection2.close();
            return callback(err3);
          } else {
            finalize();
          }
        });
      });
      return promise;
    }
    /**
     * Releases resources
     */
    close() {
      if (this.auth && this.auth.oauth2) {
        this.auth.oauth2.removeAllListeners();
      }
      this.emit("close");
    }
  }
  smtpTransport = SMTPTransport;
  return smtpTransport;
}
var sendmailTransport;
var hasRequiredSendmailTransport;
function requireSendmailTransport() {
  if (hasRequiredSendmailTransport) return sendmailTransport;
  hasRequiredSendmailTransport = 1;
  const spawn = require$$0$f.spawn;
  const packageData = require$$9;
  const shared2 = requireShared();
  class SendmailTransport {
    constructor(options) {
      options = options || {};
      this._spawn = spawn;
      this.options = options || {};
      this.name = "Sendmail";
      this.version = packageData.version;
      this.path = "sendmail";
      this.args = false;
      this.winbreak = false;
      this.logger = shared2.getLogger(this.options, {
        component: this.options.component || "sendmail"
      });
      if (options) {
        if (typeof options === "string") {
          this.path = options;
        } else if (typeof options === "object") {
          if (options.path) {
            this.path = options.path;
          }
          if (Array.isArray(options.args)) {
            this.args = options.args;
          }
          this.winbreak = ["win", "windows", "dos", "\r\n"].includes((options.newline || "").toString().toLowerCase());
        }
      }
    }
    /**
     * <p>Compiles a mailcomposer message and forwards it to handler that sends it.</p>
     *
     * @param {Object} emailMessage MailComposer object
     * @param {Function} callback Callback function to run when the sending is completed
     */
    send(mail, done) {
      mail.message.keepBcc = true;
      let envelope = mail.data.envelope || mail.message.getEnvelope();
      let messageId = mail.message.messageId();
      let args;
      let sendmail;
      let returned;
      const hasInvalidAddresses = [].concat(envelope.from || []).concat(envelope.to || []).some((addr) => /^-/.test(addr));
      if (hasInvalidAddresses) {
        return done(new Error("Can not send mail. Invalid envelope addresses."));
      }
      if (this.args) {
        args = ["-i"].concat(this.args).concat(envelope.to);
      } else {
        args = ["-i"].concat(envelope.from ? ["-f", envelope.from] : []).concat(envelope.to);
      }
      let callback = (err2) => {
        if (returned) {
          return;
        }
        returned = true;
        if (typeof done === "function") {
          if (err2) {
            return done(err2);
          } else {
            return done(null, {
              envelope: mail.data.envelope || mail.message.getEnvelope(),
              messageId,
              response: "Messages queued for delivery"
            });
          }
        }
      };
      try {
        sendmail = this._spawn(this.path, args);
      } catch (E) {
        this.logger.error(
          {
            err: E,
            tnx: "spawn",
            messageId
          },
          "Error occurred while spawning sendmail. %s",
          E.message
        );
        return callback(E);
      }
      if (sendmail) {
        sendmail.on("error", (err2) => {
          this.logger.error(
            {
              err: err2,
              tnx: "spawn",
              messageId
            },
            "Error occurred when sending message %s. %s",
            messageId,
            err2.message
          );
          callback(err2);
        });
        sendmail.once("exit", (code) => {
          if (!code) {
            return callback();
          }
          let err2;
          if (code === 127) {
            err2 = new Error("Sendmail command not found, process exited with code " + code);
          } else {
            err2 = new Error("Sendmail exited with code " + code);
          }
          this.logger.error(
            {
              err: err2,
              tnx: "stdin",
              messageId
            },
            "Error sending message %s to sendmail. %s",
            messageId,
            err2.message
          );
          callback(err2);
        });
        sendmail.once("close", callback);
        sendmail.stdin.on("error", (err2) => {
          this.logger.error(
            {
              err: err2,
              tnx: "stdin",
              messageId
            },
            "Error occurred when piping message %s to sendmail. %s",
            messageId,
            err2.message
          );
          callback(err2);
        });
        let recipients = [].concat(envelope.to || []);
        if (recipients.length > 3) {
          recipients.push("...and " + recipients.splice(2).length + " more");
        }
        this.logger.info(
          {
            tnx: "send",
            messageId
          },
          "Sending message %s to <%s>",
          messageId,
          recipients.join(", ")
        );
        let sourceStream = mail.message.createReadStream();
        sourceStream.once("error", (err2) => {
          this.logger.error(
            {
              err: err2,
              tnx: "stdin",
              messageId
            },
            "Error occurred when generating message %s. %s",
            messageId,
            err2.message
          );
          sendmail.kill("SIGINT");
          callback(err2);
        });
        sourceStream.pipe(sendmail.stdin);
      } else {
        return callback(new Error("sendmail was not found"));
      }
    }
  }
  sendmailTransport = SendmailTransport;
  return sendmailTransport;
}
var streamTransport;
var hasRequiredStreamTransport;
function requireStreamTransport() {
  if (hasRequiredStreamTransport) return streamTransport;
  hasRequiredStreamTransport = 1;
  const packageData = require$$9;
  const shared2 = requireShared();
  class StreamTransport {
    constructor(options) {
      options = options || {};
      this.options = options || {};
      this.name = "StreamTransport";
      this.version = packageData.version;
      this.logger = shared2.getLogger(this.options, {
        component: this.options.component || "stream-transport"
      });
      this.winbreak = ["win", "windows", "dos", "\r\n"].includes((options.newline || "").toString().toLowerCase());
    }
    /**
     * Compiles a mailcomposer message and forwards it to handler that sends it
     *
     * @param {Object} emailMessage MailComposer object
     * @param {Function} callback Callback function to run when the sending is completed
     */
    send(mail, done) {
      mail.message.keepBcc = true;
      let envelope = mail.data.envelope || mail.message.getEnvelope();
      let messageId = mail.message.messageId();
      let recipients = [].concat(envelope.to || []);
      if (recipients.length > 3) {
        recipients.push("...and " + recipients.splice(2).length + " more");
      }
      this.logger.info(
        {
          tnx: "send",
          messageId
        },
        "Sending message %s to <%s> using %s line breaks",
        messageId,
        recipients.join(", "),
        this.winbreak ? "<CR><LF>" : "<LF>"
      );
      setImmediate(() => {
        let stream2;
        try {
          stream2 = mail.message.createReadStream();
        } catch (E) {
          this.logger.error(
            {
              err: E,
              tnx: "send",
              messageId
            },
            "Creating send stream failed for %s. %s",
            messageId,
            E.message
          );
          return done(E);
        }
        if (!this.options.buffer) {
          stream2.once("error", (err2) => {
            this.logger.error(
              {
                err: err2,
                tnx: "send",
                messageId
              },
              "Failed creating message for %s. %s",
              messageId,
              err2.message
            );
          });
          return done(null, {
            envelope: mail.data.envelope || mail.message.getEnvelope(),
            messageId,
            message: stream2
          });
        }
        let chunks = [];
        let chunklen = 0;
        stream2.on("readable", () => {
          let chunk;
          while ((chunk = stream2.read()) !== null) {
            chunks.push(chunk);
            chunklen += chunk.length;
          }
        });
        stream2.once("error", (err2) => {
          this.logger.error(
            {
              err: err2,
              tnx: "send",
              messageId
            },
            "Failed creating message for %s. %s",
            messageId,
            err2.message
          );
          return done(err2);
        });
        stream2.on(
          "end",
          () => done(null, {
            envelope: mail.data.envelope || mail.message.getEnvelope(),
            messageId,
            message: Buffer.concat(chunks, chunklen)
          })
        );
      });
    }
  }
  streamTransport = StreamTransport;
  return streamTransport;
}
var jsonTransport;
var hasRequiredJsonTransport;
function requireJsonTransport() {
  if (hasRequiredJsonTransport) return jsonTransport;
  hasRequiredJsonTransport = 1;
  const packageData = require$$9;
  const shared2 = requireShared();
  class JSONTransport {
    constructor(options) {
      options = options || {};
      this.options = options || {};
      this.name = "JSONTransport";
      this.version = packageData.version;
      this.logger = shared2.getLogger(this.options, {
        component: this.options.component || "json-transport"
      });
    }
    /**
     * <p>Compiles a mailcomposer message and forwards it to handler that sends it.</p>
     *
     * @param {Object} emailMessage MailComposer object
     * @param {Function} callback Callback function to run when the sending is completed
     */
    send(mail, done) {
      mail.message.keepBcc = true;
      let envelope = mail.data.envelope || mail.message.getEnvelope();
      let messageId = mail.message.messageId();
      let recipients = [].concat(envelope.to || []);
      if (recipients.length > 3) {
        recipients.push("...and " + recipients.splice(2).length + " more");
      }
      this.logger.info(
        {
          tnx: "send",
          messageId
        },
        "Composing JSON structure of %s to <%s>",
        messageId,
        recipients.join(", ")
      );
      setImmediate(() => {
        mail.normalize((err2, data) => {
          if (err2) {
            this.logger.error(
              {
                err: err2,
                tnx: "send",
                messageId
              },
              "Failed building JSON structure for %s. %s",
              messageId,
              err2.message
            );
            return done(err2);
          }
          delete data.envelope;
          delete data.normalizedHeaders;
          return done(null, {
            envelope,
            messageId,
            message: this.options.skipEncoding ? data : JSON.stringify(data)
          });
        });
      });
    }
  }
  jsonTransport = JSONTransport;
  return jsonTransport;
}
var sesTransport;
var hasRequiredSesTransport;
function requireSesTransport() {
  if (hasRequiredSesTransport) return sesTransport;
  hasRequiredSesTransport = 1;
  const EventEmitter2 = require$$0$7;
  const packageData = require$$9;
  const shared2 = requireShared();
  const LeWindows = requireLeWindows();
  const MimeNode = requireMimeNode();
  class SESTransport extends EventEmitter2 {
    constructor(options) {
      super();
      options = options || {};
      this.options = options || {};
      this.ses = this.options.SES;
      this.name = "SESTransport";
      this.version = packageData.version;
      this.logger = shared2.getLogger(this.options, {
        component: this.options.component || "ses-transport"
      });
    }
    getRegion(cb) {
      if (this.ses.sesClient.config && typeof this.ses.sesClient.config.region === "function") {
        return this.ses.sesClient.config.region().then((region) => cb(null, region)).catch((err2) => cb(err2));
      }
      return cb(null, false);
    }
    /**
     * Compiles a mailcomposer message and forwards it to SES
     *
     * @param {Object} emailMessage MailComposer object
     * @param {Function} callback Callback function to run when the sending is completed
     */
    send(mail, callback) {
      let fromHeader = mail.message._headers.find((header) => /^from$/i.test(header.key));
      if (fromHeader) {
        let mimeNode2 = new MimeNode("text/plain");
        fromHeader = mimeNode2._convertAddresses(mimeNode2._parseAddresses(fromHeader.value));
      }
      let envelope = mail.data.envelope || mail.message.getEnvelope();
      let messageId = mail.message.messageId();
      let recipients = [].concat(envelope.to || []);
      if (recipients.length > 3) {
        recipients.push("...and " + recipients.splice(2).length + " more");
      }
      this.logger.info(
        {
          tnx: "send",
          messageId
        },
        "Sending message %s to <%s>",
        messageId,
        recipients.join(", ")
      );
      let getRawMessage = (next2) => {
        if (!mail.data._dkim) {
          mail.data._dkim = {};
        }
        if (mail.data._dkim.skipFields && typeof mail.data._dkim.skipFields === "string") {
          mail.data._dkim.skipFields += ":date:message-id";
        } else {
          mail.data._dkim.skipFields = "date:message-id";
        }
        let sourceStream = mail.message.createReadStream();
        let stream2 = sourceStream.pipe(new LeWindows());
        let chunks = [];
        let chunklen = 0;
        stream2.on("readable", () => {
          let chunk;
          while ((chunk = stream2.read()) !== null) {
            chunks.push(chunk);
            chunklen += chunk.length;
          }
        });
        sourceStream.once("error", (err2) => stream2.emit("error", err2));
        stream2.once("error", (err2) => {
          next2(err2);
        });
        stream2.once("end", () => next2(null, Buffer.concat(chunks, chunklen)));
      };
      setImmediate(
        () => getRawMessage((err2, raw) => {
          if (err2) {
            this.logger.error(
              {
                err: err2,
                tnx: "send",
                messageId
              },
              "Failed creating message for %s. %s",
              messageId,
              err2.message
            );
            return callback(err2);
          }
          let sesMessage = {
            Content: {
              Raw: {
                // required
                Data: raw
                // required
              }
            },
            FromEmailAddress: fromHeader ? fromHeader : envelope.from,
            Destination: {
              ToAddresses: envelope.to
            }
          };
          Object.keys(mail.data.ses || {}).forEach((key) => {
            sesMessage[key] = mail.data.ses[key];
          });
          this.getRegion((err3, region) => {
            if (err3 || !region) {
              region = "us-east-1";
            }
            const command = new this.ses.SendEmailCommand(sesMessage);
            const sendPromise = this.ses.sesClient.send(command);
            sendPromise.then((data) => {
              if (region === "us-east-1") {
                region = "email";
              }
              callback(null, {
                envelope: {
                  from: envelope.from,
                  to: envelope.to
                },
                messageId: "<" + data.MessageId + (!/@/.test(data.MessageId) ? "@" + region + ".amazonses.com" : "") + ">",
                response: data.MessageId,
                raw
              });
            }).catch((err4) => {
              this.logger.error(
                {
                  err: err4,
                  tnx: "send"
                },
                "Send error for %s: %s",
                messageId,
                err4.message
              );
              callback(err4);
            });
          });
        })
      );
    }
    /**
     * Verifies SES configuration
     *
     * @param {Function} callback Callback function
     */
    verify(callback) {
      let promise;
      if (!callback) {
        promise = new Promise((resolve2, reject) => {
          callback = shared2.callbackPromise(resolve2, reject);
        });
      }
      const cb = (err2) => {
        if (err2 && !["InvalidParameterValue", "MessageRejected"].includes(err2.code || err2.Code || err2.name)) {
          return callback(err2);
        }
        return callback(null, true);
      };
      const sesMessage = {
        Content: {
          Raw: {
            Data: Buffer.from("From: <invalid@invalid>\r\nTo: <invalid@invalid>\r\n Subject: Invalid\r\n\r\nInvalid")
          }
        },
        FromEmailAddress: "invalid@invalid",
        Destination: {
          ToAddresses: ["invalid@invalid"]
        }
      };
      this.getRegion((err2, region) => {
        const command = new this.ses.SendEmailCommand(sesMessage);
        const sendPromise = this.ses.sesClient.send(command);
        sendPromise.then((data) => cb(null)).catch((err3) => cb(err3));
      });
      return promise;
    }
  }
  sesTransport = SESTransport;
  return sesTransport;
}
var hasRequiredNodemailer;
function requireNodemailer() {
  if (hasRequiredNodemailer) return nodemailer;
  hasRequiredNodemailer = 1;
  const Mailer = requireMailer();
  const shared2 = requireShared();
  const SMTPPool = requireSmtpPool();
  const SMTPTransport = requireSmtpTransport();
  const SendmailTransport = requireSendmailTransport();
  const StreamTransport = requireStreamTransport();
  const JSONTransport = requireJsonTransport();
  const SESTransport = requireSesTransport();
  const nmfetch = requireFetch();
  const packageData = require$$9;
  const ETHEREAL_API = (process.env.ETHEREAL_API || "https://api.nodemailer.com").replace(/\/+$/, "");
  const ETHEREAL_WEB = (process.env.ETHEREAL_WEB || "https://ethereal.email").replace(/\/+$/, "");
  const ETHEREAL_API_KEY = (process.env.ETHEREAL_API_KEY || "").replace(/\s*/g, "") || null;
  const ETHEREAL_CACHE = ["true", "yes", "y", "1"].includes((process.env.ETHEREAL_CACHE || "yes").toString().trim().toLowerCase());
  let testAccount = false;
  nodemailer.createTransport = function(transporter, defaults2) {
    let urlConfig;
    let options;
    let mailer2;
    if (
      // provided transporter is a configuration object, not transporter plugin
      typeof transporter === "object" && typeof transporter.send !== "function" || // provided transporter looks like a connection url
      typeof transporter === "string" && /^(smtps?|direct):/i.test(transporter)
    ) {
      if (urlConfig = typeof transporter === "string" ? transporter : transporter.url) {
        options = shared2.parseConnectionUrl(urlConfig);
      } else {
        options = transporter;
      }
      if (options.pool) {
        transporter = new SMTPPool(options);
      } else if (options.sendmail) {
        transporter = new SendmailTransport(options);
      } else if (options.streamTransport) {
        transporter = new StreamTransport(options);
      } else if (options.jsonTransport) {
        transporter = new JSONTransport(options);
      } else if (options.SES) {
        if (options.SES.ses && options.SES.aws) {
          let error2 = new Error(
            "Using legacy SES configuration, expecting @aws-sdk/client-sesv2, see https://nodemailer.com/transports/ses/"
          );
          error2.code = "LegacyConfig";
          throw error2;
        }
        transporter = new SESTransport(options);
      } else {
        transporter = new SMTPTransport(options);
      }
    }
    mailer2 = new Mailer(transporter, options, defaults2);
    return mailer2;
  };
  nodemailer.createTestAccount = function(apiUrl, callback) {
    let promise;
    if (!callback && typeof apiUrl === "function") {
      callback = apiUrl;
      apiUrl = false;
    }
    if (!callback) {
      promise = new Promise((resolve2, reject) => {
        callback = shared2.callbackPromise(resolve2, reject);
      });
    }
    if (ETHEREAL_CACHE && testAccount) {
      setImmediate(() => callback(null, testAccount));
      return promise;
    }
    apiUrl = apiUrl || ETHEREAL_API;
    let chunks = [];
    let chunklen = 0;
    let requestHeaders = {};
    let requestBody = {
      requestor: packageData.name,
      version: packageData.version
    };
    if (ETHEREAL_API_KEY) {
      requestHeaders.Authorization = "Bearer " + ETHEREAL_API_KEY;
    }
    let req2 = nmfetch(apiUrl + "/user", {
      contentType: "application/json",
      method: "POST",
      headers: requestHeaders,
      body: Buffer.from(JSON.stringify(requestBody))
    });
    req2.on("readable", () => {
      let chunk;
      while ((chunk = req2.read()) !== null) {
        chunks.push(chunk);
        chunklen += chunk.length;
      }
    });
    req2.once("error", (err2) => callback(err2));
    req2.once("end", () => {
      let res2 = Buffer.concat(chunks, chunklen);
      let data;
      let err2;
      try {
        data = JSON.parse(res2.toString());
      } catch (E) {
        err2 = E;
      }
      if (err2) {
        return callback(err2);
      }
      if (data.status !== "success" || data.error) {
        return callback(new Error(data.error || "Request failed"));
      }
      delete data.status;
      testAccount = data;
      callback(null, testAccount);
    });
    return promise;
  };
  nodemailer.getTestMessageUrl = function(info2) {
    if (!info2 || !info2.response) {
      return false;
    }
    let infoProps = /* @__PURE__ */ new Map();
    info2.response.replace(/\[([^\]]+)\]$/, (m, props) => {
      props.replace(/\b([A-Z0-9]+)=([^\s]+)/g, (m2, key, value) => {
        infoProps.set(key, value);
      });
    });
    if (infoProps.has("STATUS") && infoProps.has("MSGID")) {
      return (testAccount.web || ETHEREAL_WEB) + "/message/" + infoProps.get("MSGID");
    }
    return false;
  };
  return nodemailer;
}
var nodemailerExports = requireNodemailer();
class SmtpAdapter extends MailAdapter {
  transporter;
  afterSendCallback;
  constructor(opts) {
    super();
    this.transporter = nodemailerExports.createTransport(opts.transport);
    this.afterSendCallback = opts.afterSendCallback;
  }
  async send(options) {
    const info2 = await this.transporter.sendMail(
      options
    );
    if (this.afterSendCallback) {
      await this.afterSendCallback(info2);
    }
  }
  /**
   * Verify SMTP connection
   */
  async verify() {
    return this.transporter.verify();
  }
}
const DEFAULT_SCHEMA = "pgboss";
const MIGRATE_RACE_MESSAGE = "division by zero";
const CREATE_RACE_MESSAGE = "already exists";
const SINGLE_QUOTE_REGEX = /'/g;
const FIFTEEN_MINUTES = 60 * 15;
const FORTEEN_DAYS = 60 * 60 * 24 * 14;
const SEVEN_DAYS = 60 * 60 * 24 * 7;
const JOB_STATES = Object.freeze({
  created: "created",
  retry: "retry",
  active: "active",
  completed: "completed",
  cancelled: "cancelled",
  failed: "failed"
});
const QUEUE_POLICIES = Object.freeze({
  standard: "standard",
  short: "short",
  singleton: "singleton",
  stately: "stately",
  exclusive: "exclusive"
});
const QUEUE_DEFAULTS = {
  expire_seconds: FIFTEEN_MINUTES,
  retention_seconds: FORTEEN_DAYS,
  deletion_seconds: SEVEN_DAYS,
  retry_limit: 2,
  retry_delay: 0,
  warning_queued: 0,
  retry_backoff: false,
  partition: false
};
const COMMON_JOB_TABLE = "job_common";
function create(schema2, version2, options) {
  const commands = [
    options?.createSchema ? createSchema(schema2) : "",
    createEnumJobState(schema2),
    createTableVersion(schema2),
    createTableQueue(schema2),
    createTableSchedule(schema2),
    createTableSubscription(schema2),
    createTableBam(schema2),
    jobTableFormatFunction(schema2),
    jobTableRunFunction(schema2),
    jobTableRunAsyncFunction(schema2),
    createTableJob(schema2),
    createPrimaryKeyJob(schema2),
    createTableJobCommon(schema2),
    createQueueFunction(schema2),
    deleteQueueFunction(schema2),
    insertVersion(schema2, version2)
  ];
  return locked(schema2, commands);
}
function createSchema(schema2) {
  return `CREATE SCHEMA IF NOT EXISTS ${schema2}`;
}
function createEnumJobState(schema2) {
  return `
    CREATE TYPE ${schema2}.job_state AS ENUM (
      '${JOB_STATES.created}',
      '${JOB_STATES.retry}',
      '${JOB_STATES.active}',
      '${JOB_STATES.completed}',
      '${JOB_STATES.cancelled}',
      '${JOB_STATES.failed}'
    )
  `;
}
function createTableVersion(schema2) {
  return `
    CREATE TABLE ${schema2}.version (
      version int primary key,
      cron_on timestamp with time zone,
      bam_on timestamp with time zone
    )
  `;
}
function createTableQueue(schema2) {
  return `
    CREATE TABLE ${schema2}.queue (
      name text NOT NULL,
      policy text NOT NULL,
      retry_limit int NOT NULL,
      retry_delay int NOT NULL,
      retry_backoff bool NOT NULL,
      retry_delay_max int,
      expire_seconds int NOT NULL,
      retention_seconds int NOT NULL,
      deletion_seconds int NOT NULL,
      dead_letter text REFERENCES ${schema2}.queue (name) CHECK (dead_letter IS DISTINCT FROM name),
      partition bool NOT NULL,
      table_name text NOT NULL,
      deferred_count int NOT NULL default 0,
      queued_count int NOT NULL default 0,
      warning_queued int NOT NULL default 0,
      active_count int NOT NULL default 0,
      total_count int NOT NULL default 0,
      singletons_active text[],
      monitor_on timestamp with time zone,
      maintain_on timestamp with time zone,
      created_on timestamp with time zone not null default now(),
      updated_on timestamp with time zone not null default now(),
      PRIMARY KEY (name)
    )
  `;
}
function createTableSchedule(schema2) {
  return `
    CREATE TABLE ${schema2}.schedule (
      name text REFERENCES ${schema2}.queue ON DELETE CASCADE,
      key text not null DEFAULT '',
      cron text not null,
      timezone text,
      data jsonb,
      options jsonb,
      created_on timestamp with time zone not null default now(),
      updated_on timestamp with time zone not null default now(),
      PRIMARY KEY (name, key)
    )
  `;
}
function createTableSubscription(schema2) {
  return `
    CREATE TABLE ${schema2}.subscription (
      event text not null,
      name text not null REFERENCES ${schema2}.queue ON DELETE CASCADE,
      created_on timestamp with time zone not null default now(),
      updated_on timestamp with time zone not null default now(),
      PRIMARY KEY(event, name)
    )
  `;
}
function createTableBam(schema2) {
  return `
    CREATE TABLE ${schema2}.bam (
      id uuid PRIMARY KEY default gen_random_uuid(),
      name text NOT NULL,
      version int NOT NULL,
      status text NOT NULL DEFAULT 'pending',
      queue text,
      table_name text NOT NULL,
      command text NOT NULL,
      error text,
      created_on timestamp with time zone NOT NULL DEFAULT now(),
      started_on timestamp with time zone,
      completed_on timestamp with time zone
    )
  `;
}
function jobTableFormatFunction(schema2) {
  return `
    CREATE FUNCTION ${schema2}.job_table_format(command text, table_name text)
    RETURNS text AS
    $$
      SELECT format(
        replace(
          replace(command, '.job', '.%1$I'),
          'job_i', '%1$s_i'
        ),
        table_name
      );
    $$
    LANGUAGE sql IMMUTABLE;
  `;
}
function jobTableRunFunction(schema2) {
  return `
    CREATE FUNCTION ${schema2}.job_table_run(command text, tbl_name text DEFAULT NULL, queue_name text DEFAULT NULL)
    RETURNS VOID AS
    $$
    DECLARE
      tbl RECORD;
    BEGIN
      IF queue_name IS NOT NULL THEN
        SELECT table_name INTO tbl_name FROM ${schema2}.queue WHERE name = queue_name;
      END IF;

      IF tbl_name IS NOT NULL THEN
        EXECUTE ${schema2}.job_table_format(command, tbl_name);
        RETURN;
      END IF;

      EXECUTE ${schema2}.job_table_format(command, '${COMMON_JOB_TABLE}');

      FOR tbl IN SELECT table_name FROM ${schema2}.queue WHERE partition = true
      LOOP
        EXECUTE ${schema2}.job_table_format(command, tbl.table_name);
      END LOOP;
    END;
    $$
    LANGUAGE plpgsql;
  `;
}
function jobTableRunAsyncFunction(schema2) {
  return `
    CREATE FUNCTION ${schema2}.job_table_run_async(command_name text, version int, command text, tbl_name text DEFAULT NULL, queue_name text DEFAULT NULL)
    RETURNS VOID AS
    $$
    BEGIN
      IF queue_name IS NOT NULL THEN
        SELECT table_name INTO tbl_name FROM ${schema2}.queue WHERE name = queue_name;
      END IF;

      IF tbl_name IS NOT NULL THEN
        INSERT INTO ${schema2}.bam (name, version, status, queue, table_name, command)
        VALUES (
          command_name,
          version,
          'pending',
          queue_name,
          tbl_name,
          ${schema2}.job_table_format(command, tbl_name)
        );
        RETURN;
      END IF;

      INSERT INTO ${schema2}.bam (name, version, status, queue, table_name, command)
      SELECT
        command_name,
        version,
        'pending',
        NULL,
        '${COMMON_JOB_TABLE}',
        ${schema2}.job_table_format(command, '${COMMON_JOB_TABLE}')
      UNION ALL
      SELECT
        command_name,
        version,
        'pending',
        queue.name,
        queue.table_name,
        ${schema2}.job_table_format(command, queue.table_name)
      FROM ${schema2}.queue
      WHERE partition = true;
    END;
    $$
    LANGUAGE plpgsql;
  `;
}
function createTableJob(schema2) {
  return `
    CREATE TABLE ${schema2}.job (
      id uuid not null default gen_random_uuid(),
      name text not null,
      priority integer not null default(0),
      data jsonb,
      state ${schema2}.job_state not null default '${JOB_STATES.created}',
      retry_limit integer not null default ${QUEUE_DEFAULTS.retry_limit},
      retry_count integer not null default 0,
      retry_delay integer not null default ${QUEUE_DEFAULTS.retry_delay},
      retry_backoff boolean not null default ${QUEUE_DEFAULTS.retry_backoff},
      retry_delay_max integer,
      expire_seconds int not null default ${QUEUE_DEFAULTS.expire_seconds},
      deletion_seconds int not null default ${QUEUE_DEFAULTS.deletion_seconds},
      singleton_key text,
      singleton_on timestamp without time zone,
      group_id text,
      group_tier text,
      start_after timestamp with time zone not null default now(),
      created_on timestamp with time zone not null default now(),
      started_on timestamp with time zone,
      completed_on timestamp with time zone,
      keep_until timestamp with time zone NOT NULL default now() + interval '${QUEUE_DEFAULTS.retention_seconds}',
      output jsonb,
      dead_letter text,
      policy text
    ) PARTITION BY LIST (name)
  `;
}
const JOB_COLUMNS_MIN = 'id, name, data, expire_seconds as "expireInSeconds", group_id as "groupId", group_tier as "groupTier"';
const JOB_COLUMNS_ALL = `${JOB_COLUMNS_MIN},
  policy,
  state,
  priority,
  retry_limit as "retryLimit",
  retry_count as "retryCount",
  retry_delay as "retryDelay",
  retry_backoff as "retryBackoff",
  retry_delay_max as "retryDelayMax",
  start_after as "startAfter",
  started_on as "startedOn",
  singleton_key as "singletonKey",
  singleton_on as "singletonOn",
  deletion_seconds as "deleteAfterSeconds",
  created_on as "createdOn",
  completed_on as "completedOn",
  keep_until as "keepUntil",
  dead_letter as "deadLetter",
  output
`;
function createTableJobCommon(schema2) {
  return `
    CREATE TABLE ${schema2}.${COMMON_JOB_TABLE} (LIKE ${schema2}.job INCLUDING GENERATED INCLUDING DEFAULTS);

    SELECT ${schema2}.job_table_run($cmd$${createPrimaryKeyJob(schema2)}$cmd$, '${COMMON_JOB_TABLE}');
    SELECT ${schema2}.job_table_run($cmd$${createQueueForeignKeyJob(schema2)}$cmd$, '${COMMON_JOB_TABLE}');
    SELECT ${schema2}.job_table_run($cmd$${createQueueForeignKeyJobDeadLetter(schema2)}$cmd$, '${COMMON_JOB_TABLE}');
    SELECT ${schema2}.job_table_run($cmd$${createIndexJobPolicyShort(schema2)}$cmd$, '${COMMON_JOB_TABLE}');
    SELECT ${schema2}.job_table_run($cmd$${createIndexJobPolicySingleton(schema2)}$cmd$, '${COMMON_JOB_TABLE}');
    SELECT ${schema2}.job_table_run($cmd$${createIndexJobPolicyStately(schema2)}$cmd$, '${COMMON_JOB_TABLE}');
    SELECT ${schema2}.job_table_run($cmd$${createIndexJobPolicyExclusive(schema2)}$cmd$, '${COMMON_JOB_TABLE}');
    SELECT ${schema2}.job_table_run($cmd$${createIndexJobThrottle(schema2)}$cmd$, '${COMMON_JOB_TABLE}');
    SELECT ${schema2}.job_table_run($cmd$${createIndexJobFetch(schema2)}$cmd$, '${COMMON_JOB_TABLE}');
    SELECT ${schema2}.job_table_run($cmd$${createIndexJobGroupConcurrency(schema2)}$cmd$, '${COMMON_JOB_TABLE}');

    ALTER TABLE ${schema2}.job ATTACH PARTITION ${schema2}.${COMMON_JOB_TABLE} DEFAULT;
  `;
}
function createQueueFunction(schema2) {
  return `
    CREATE FUNCTION ${schema2}.create_queue(queue_name text, options jsonb)
    RETURNS VOID AS
    $$
    DECLARE
      tablename varchar := CASE WHEN options->>'partition' = 'true'
                            THEN 'j' || encode(sha224(queue_name::bytea), 'hex')
                            ELSE '${COMMON_JOB_TABLE}'
                            END;
      queue_created_on timestamptz;
    BEGIN

      WITH q as (
        INSERT INTO ${schema2}.queue (
          name,
          policy,
          retry_limit,
          retry_delay,
          retry_backoff,
          retry_delay_max,
          expire_seconds,
          retention_seconds,
          deletion_seconds,
          warning_queued,
          dead_letter,
          partition,
          table_name
        )
        VALUES (
          queue_name,
          options->>'policy',
          COALESCE((options->>'retryLimit')::int, ${QUEUE_DEFAULTS.retry_limit}),
          COALESCE((options->>'retryDelay')::int, ${QUEUE_DEFAULTS.retry_delay}),
          COALESCE((options->>'retryBackoff')::bool, ${QUEUE_DEFAULTS.retry_backoff}),
          (options->>'retryDelayMax')::int,
          COALESCE((options->>'expireInSeconds')::int, ${QUEUE_DEFAULTS.expire_seconds}),
          COALESCE((options->>'retentionSeconds')::int, ${QUEUE_DEFAULTS.retention_seconds}),
          COALESCE((options->>'deleteAfterSeconds')::int, ${QUEUE_DEFAULTS.deletion_seconds}),
          COALESCE((options->>'warningQueueSize')::int, ${QUEUE_DEFAULTS.warning_queued}),
          options->>'deadLetter',
          COALESCE((options->>'partition')::bool, ${QUEUE_DEFAULTS.partition}),
          tablename
        )
        ON CONFLICT DO NOTHING
        RETURNING created_on
      )
      SELECT created_on into queue_created_on from q;

      IF queue_created_on IS NULL OR options->>'partition' IS DISTINCT FROM 'true' THEN
        RETURN;
      END IF;

      EXECUTE format('CREATE TABLE ${schema2}.%I (LIKE ${schema2}.job INCLUDING DEFAULTS)', tablename);

      EXECUTE ${schema2}.job_table_format($cmd$${createPrimaryKeyJob(schema2)}$cmd$, tablename);
      EXECUTE ${schema2}.job_table_format($cmd$${createQueueForeignKeyJob(schema2)}$cmd$, tablename);
      EXECUTE ${schema2}.job_table_format($cmd$${createQueueForeignKeyJobDeadLetter(schema2)}$cmd$, tablename);

      EXECUTE ${schema2}.job_table_format($cmd$${createIndexJobFetch(schema2)}$cmd$, tablename);
      EXECUTE ${schema2}.job_table_format($cmd$${createIndexJobThrottle(schema2)}$cmd$, tablename);
      EXECUTE ${schema2}.job_table_format($cmd$${createIndexJobGroupConcurrency(schema2)}$cmd$, tablename);

      IF options->>'policy' = 'short' THEN
        EXECUTE ${schema2}.job_table_format($cmd$${createIndexJobPolicyShort(schema2)}$cmd$, tablename);
      ELSIF options->>'policy' = 'singleton' THEN
        EXECUTE ${schema2}.job_table_format($cmd$${createIndexJobPolicySingleton(schema2)}$cmd$, tablename);
      ELSIF options->>'policy' = 'stately' THEN
        EXECUTE ${schema2}.job_table_format($cmd$${createIndexJobPolicyStately(schema2)}$cmd$, tablename);
      ELSIF options->>'policy' = 'exclusive' THEN
        EXECUTE ${schema2}.job_table_format($cmd$${createIndexJobPolicyExclusive(schema2)}$cmd$, tablename);
      END IF;

      EXECUTE format('ALTER TABLE ${schema2}.%I ADD CONSTRAINT cjc CHECK (name=%L)', tablename, queue_name);
      EXECUTE format('ALTER TABLE ${schema2}.job ATTACH PARTITION ${schema2}.%I FOR VALUES IN (%L)', tablename, queue_name);
    END;
    $$
    LANGUAGE plpgsql;
  `;
}
function deleteQueueFunction(schema2) {
  return `
    CREATE FUNCTION ${schema2}.delete_queue(queue_name text)
    RETURNS VOID AS
    $$
    DECLARE
      v_table varchar;
      v_partition bool;
    BEGIN
      SELECT table_name, partition
      FROM ${schema2}.queue
      WHERE name = queue_name
      INTO v_table, v_partition;

      IF v_partition THEN
        EXECUTE format('DROP TABLE IF EXISTS ${schema2}.%I', v_table);
      ELSE
        EXECUTE format('DELETE FROM ${schema2}.%I WHERE name = %L', v_table, queue_name);
      END IF;

      DELETE FROM ${schema2}.queue WHERE name = queue_name;
    END;
    $$
    LANGUAGE plpgsql;
  `;
}
function createQueue(schema2, name2, options) {
  const sql2 = `SELECT ${schema2}.create_queue('${name2}', '${JSON.stringify(options)}'::jsonb)`;
  return locked(schema2, sql2, "create-queue");
}
function deleteQueue(schema2, name2) {
  const sql2 = `SELECT ${schema2}.delete_queue('${name2}')`;
  return locked(schema2, sql2, "delete-queue");
}
function createPrimaryKeyJob(schema2) {
  return `ALTER TABLE ${schema2}.job ADD PRIMARY KEY (name, id)`;
}
function createQueueForeignKeyJob(schema2) {
  return `ALTER TABLE ${schema2}.job ADD CONSTRAINT q_fkey FOREIGN KEY (name) REFERENCES ${schema2}.queue (name) ON DELETE RESTRICT DEFERRABLE INITIALLY DEFERRED`;
}
function createQueueForeignKeyJobDeadLetter(schema2) {
  return `ALTER TABLE ${schema2}.job ADD CONSTRAINT dlq_fkey FOREIGN KEY (dead_letter) REFERENCES ${schema2}.queue (name) ON DELETE RESTRICT DEFERRABLE INITIALLY DEFERRED`;
}
function createIndexJobPolicyShort(schema2) {
  return `CREATE UNIQUE INDEX job_i1 ON ${schema2}.job (name, COALESCE(singleton_key, '')) WHERE state = '${JOB_STATES.created}' AND policy = '${QUEUE_POLICIES.short}'`;
}
function createIndexJobPolicySingleton(schema2) {
  return `CREATE UNIQUE INDEX job_i2 ON ${schema2}.job (name, COALESCE(singleton_key, '')) WHERE state = '${JOB_STATES.active}' AND policy = '${QUEUE_POLICIES.singleton}'`;
}
function createIndexJobPolicyStately(schema2) {
  return `CREATE UNIQUE INDEX job_i3 ON ${schema2}.job (name, state, COALESCE(singleton_key, '')) WHERE state <= '${JOB_STATES.active}' AND policy = '${QUEUE_POLICIES.stately}'`;
}
function createIndexJobThrottle(schema2) {
  return `CREATE UNIQUE INDEX job_i4 ON ${schema2}.job (name, singleton_on, COALESCE(singleton_key, '')) WHERE state <> '${JOB_STATES.cancelled}' AND singleton_on IS NOT NULL`;
}
function createIndexJobFetch(schema2) {
  return `CREATE INDEX job_i5 ON ${schema2}.job (name, start_after) INCLUDE (priority, created_on, id) WHERE state < '${JOB_STATES.active}'`;
}
function createIndexJobPolicyExclusive(schema2) {
  return `CREATE UNIQUE INDEX job_i6 ON ${schema2}.job (name, COALESCE(singleton_key, '')) WHERE state <= '${JOB_STATES.active}' AND policy = '${QUEUE_POLICIES.exclusive}'`;
}
function createIndexJobGroupConcurrency(schema2) {
  return `CREATE INDEX job_i7 ON ${schema2}.job (name, group_id) WHERE state = '${JOB_STATES.active}' AND group_id IS NOT NULL`;
}
function trySetQueueMonitorTime(schema2, queues, seconds) {
  return trySetQueueTimestamp(schema2, queues, "monitor_on", seconds);
}
function trySetQueueDeletionTime(schema2, queues, seconds) {
  return trySetQueueTimestamp(schema2, queues, "maintain_on", seconds);
}
function trySetCronTime(schema2, seconds) {
  return trySetTimestamp(schema2, "cron_on", seconds);
}
function trySetBamTime(schema2, seconds) {
  return trySetTimestamp(schema2, "bam_on", seconds);
}
function trySetTimestamp(schema2, column, seconds) {
  return `
    UPDATE ${schema2}.version
    SET ${column} = now()
    WHERE EXTRACT( EPOCH FROM (now() - COALESCE(${column}, now() - interval '1 week') ) ) > ${seconds}
    RETURNING true
  `;
}
function trySetQueueTimestamp(schema2, queues, column, seconds) {
  return {
    text: `
    UPDATE ${schema2}.queue
    SET ${column} = now()
    WHERE name = ANY($1::text[])
      AND EXTRACT( EPOCH FROM (now() - COALESCE(${column}, now() - interval '1 week') ) ) > ${seconds}
    RETURNING name
  `,
    values: [queues]
  };
}
function updateQueue(schema2, { deadLetter } = {}) {
  return `
    WITH options as (SELECT $2::jsonb as data)
    UPDATE ${schema2}.queue SET
      retry_limit = COALESCE((o.data->>'retryLimit')::int, retry_limit),
      retry_delay = COALESCE((o.data->>'retryDelay')::int, retry_delay),
      retry_backoff = COALESCE((o.data->>'retryBackoff')::bool, retry_backoff),
      retry_delay_max = CASE WHEN o.data ? 'retryDelayMax'
        THEN (o.data->>'retryDelayMax')::int
        ELSE retry_delay_max END,
      expire_seconds = COALESCE((o.data->>'expireInSeconds')::int, expire_seconds),
      retention_seconds = COALESCE((o.data->>'retentionSeconds')::int, retention_seconds),
      deletion_seconds = COALESCE((o.data->>'deleteAfterSeconds')::int, deletion_seconds),
      warning_queued = COALESCE((o.data->>'warningQueueSize')::int, warning_queued),
      ${deadLetter === void 0 ? "" : `dead_letter = CASE WHEN '${deadLetter}' IS DISTINCT FROM dead_letter THEN '${deadLetter}' ELSE dead_letter END,`}
      updated_on = now()
    FROM options o
    WHERE name = $1
  `;
}
function getQueues(schema2, names) {
  const hasNames = names && names.length > 0;
  return {
    text: `
    SELECT
      q.name,
      q.policy,
      q.retry_limit as "retryLimit",
      q.retry_delay as "retryDelay",
      q.retry_backoff as "retryBackoff",
      q.retry_delay_max as "retryDelayMax",
      q.expire_seconds as "expireInSeconds",
      q.retention_seconds as "retentionSeconds",
      q.deletion_seconds as "deleteAfterSeconds",
      q.partition,
      q.dead_letter as "deadLetter",
      q.deferred_count as "deferredCount",
      q.warning_queued as "warningQueueSize",
      q.queued_count as "queuedCount",
      q.active_count as "activeCount",
      q.total_count as "totalCount",
      q.singletons_active as "singletonsActive",
      q.table_name as "table",
      q.created_on as "createdOn",
      q.updated_on as "updatedOn"
    FROM ${schema2}.queue q
    ${hasNames ? "WHERE q.name = ANY($1::text[])" : ""}
   `,
    values: hasNames ? [names] : []
  };
}
function deleteJobsById(schema2, table) {
  return `
    WITH results as (
      DELETE FROM ${schema2}.${table}
      WHERE name = $1
        AND id IN (SELECT UNNEST($2::uuid[]))        
      RETURNING 1
    )
    SELECT COUNT(*) from results
  `;
}
function deleteQueuedJobs(schema2, table) {
  return `DELETE from ${schema2}.${table} WHERE name = $1 and state < '${JOB_STATES.active}'`;
}
function deleteStoredJobs(schema2, table) {
  return `DELETE from ${schema2}.${table} WHERE name = $1 and state > '${JOB_STATES.active}'`;
}
function truncateTable(schema2, table) {
  return `TRUNCATE ${schema2}.${table}`;
}
function deleteAllJobs(schema2, table) {
  return `DELETE from ${schema2}.${table} WHERE name = $1`;
}
function getSchedules(schema2) {
  return `SELECT * FROM ${schema2}.schedule`;
}
function getSchedulesByQueue(schema2) {
  return `SELECT * FROM ${schema2}.schedule WHERE name = $1 AND COALESCE(key, '') = $2`;
}
function schedule(schema2) {
  return `
    INSERT INTO ${schema2}.schedule (name, key, cron, timezone, data, options)
    VALUES ($1, $2, $3, $4, $5, $6)
    ON CONFLICT (name, key) DO UPDATE SET
      cron = EXCLUDED.cron,
      timezone = EXCLUDED.timezone,
      data = EXCLUDED.data,
      options = EXCLUDED.options,
      updated_on = now()
  `;
}
function unschedule(schema2) {
  return `
    DELETE FROM ${schema2}.schedule
    WHERE name = $1
      AND COALESCE(key, '') = $2
  `;
}
function subscribe(schema2) {
  return `
    INSERT INTO ${schema2}.subscription (event, name)
    VALUES ($1, $2)
    ON CONFLICT (event, name) DO UPDATE SET
      event = EXCLUDED.event,
      name = EXCLUDED.name,
      updated_on = now()
  `;
}
function unsubscribe(schema2) {
  return `
    DELETE FROM ${schema2}.subscription
    WHERE event = $1 and name = $2
  `;
}
function getQueuesForEvent(schema2) {
  return `
    SELECT name FROM ${schema2}.subscription
    WHERE event = $1
  `;
}
function getTime() {
  return "SELECT round(date_part('epoch', now()) * 1000) as time";
}
function getVersion(schema2) {
  return `SELECT version from ${schema2}.version`;
}
function setVersion(schema2, version2) {
  return `UPDATE ${schema2}.version SET version = '${version2}'`;
}
function versionTableExists(schema2) {
  return `SELECT to_regclass('${schema2}.version') as name`;
}
function insertVersion(schema2, version2) {
  return `INSERT INTO ${schema2}.version(version) VALUES ('${version2}')`;
}
function buildFetchParams(options) {
  const { ignoreSingletons, ignoreGroups, groupConcurrency } = options;
  const hasIgnoreSingletons = ignoreSingletons != null && ignoreSingletons.length > 0;
  const hasIgnoreGroups = ignoreGroups != null && ignoreGroups.length > 0;
  const hasGroupConcurrency = groupConcurrency != null;
  const groupConcurrencyConfig = hasGroupConcurrency ? typeof groupConcurrency === "number" ? { default: groupConcurrency } : groupConcurrency : null;
  const hasTiers = groupConcurrencyConfig?.tiers && Object.keys(groupConcurrencyConfig.tiers).length > 0;
  const values = [];
  let paramIndex = 0;
  let ignoreSingletonsParam = "";
  let ignoreGroupsParam = "";
  let defaultGroupLimitParam = "";
  let tiersParam = "";
  if (hasIgnoreSingletons) {
    paramIndex++;
    ignoreSingletonsParam = `$${paramIndex}::text[]`;
    values.push(ignoreSingletons);
  }
  if (hasIgnoreGroups) {
    paramIndex++;
    ignoreGroupsParam = `$${paramIndex}::text[]`;
    values.push(ignoreGroups);
  }
  if (hasGroupConcurrency && groupConcurrencyConfig) {
    paramIndex++;
    defaultGroupLimitParam = `$${paramIndex}::int`;
    values.push(groupConcurrencyConfig.default);
    if (hasTiers) {
      paramIndex++;
      tiersParam = `$${paramIndex}::jsonb`;
      values.push(JSON.stringify(groupConcurrencyConfig.tiers));
    }
  }
  return { values, ignoreSingletonsParam, ignoreGroupsParam, defaultGroupLimitParam, tiersParam };
}
function fetchNextJob(options) {
  const { schema: schema2, table, name: name2, policy, limit, includeMetadata, priority = true, orderByCreatedOn = true, ignoreStartAfter = false, groupConcurrency } = options;
  const singletonFetch = limit > 1 && (policy === QUEUE_POLICIES.singleton || policy === QUEUE_POLICIES.stately);
  const hasIgnoreSingletons = options.ignoreSingletons != null && options.ignoreSingletons.length > 0;
  const hasIgnoreGroups = options.ignoreGroups != null && options.ignoreGroups.length > 0;
  const hasGroupConcurrency = groupConcurrency != null;
  const hasTiers = hasGroupConcurrency && typeof groupConcurrency === "object" && groupConcurrency.tiers && Object.keys(groupConcurrency.tiers).length > 0;
  const params = buildFetchParams(options);
  const whereConditions = [
    `name = '${name2}'`,
    `state < '${JOB_STATES.active}'`,
    !ignoreStartAfter ? "start_after < now()" : "",
    hasIgnoreSingletons ? `singleton_key <> ALL(${params.ignoreSingletonsParam})` : "",
    hasIgnoreGroups ? `(group_id IS NULL OR group_id <> ALL(${params.ignoreGroupsParam}))` : ""
  ].filter(Boolean).join(" AND ");
  const selectCols = [
    "id",
    singletonFetch ? "singleton_key" : "",
    hasGroupConcurrency ? "group_id, group_tier" : ""
  ].filter(Boolean).join(", ");
  const activeGroupCountsCte = hasGroupConcurrency ? `active_group_counts AS (
        SELECT group_id, COUNT(*)::int as active_cnt
        FROM ${schema2}.${table}
        WHERE name = '${name2}' AND state = '${JOB_STATES.active}' AND group_id IS NOT NULL
        GROUP BY group_id
      ), ` : "";
  const nextCte = `
      next AS (
        SELECT ${selectCols}
        FROM ${schema2}.${table}
        WHERE ${whereConditions}
        ORDER BY ${priority ? "priority desc, " : ""}${orderByCreatedOn ? "created_on, " : ""}id
        LIMIT ${limit}
        FOR UPDATE SKIP LOCKED
      )`;
  const singletonCte = singletonFetch ? `, singleton_ranking AS (
        SELECT id, ${hasGroupConcurrency ? "group_id, group_tier, " : ""}
          row_number() OVER (PARTITION BY singleton_key) as singleton_rn
        FROM next
      )` : "";
  const groupConcurrencyCtes = hasGroupConcurrency ? `,
      group_ranking AS (
        SELECT t.id
          , t.group_id
          , t.group_tier
          ${singletonFetch ? ", singleton_rn" : ""}
          , ROW_NUMBER() OVER (PARTITION BY t.group_id ORDER BY t.id) as group_rn
          , COALESCE(agc.active_cnt, 0) as active_cnt
        FROM ${singletonFetch ? "singleton_ranking" : "next"} t
        LEFT JOIN active_group_counts agc ON t.group_id = agc.group_id
        ${singletonFetch ? "WHERE singleton_rn = 1" : ""}
      ),
      group_filtered AS (
        SELECT id FROM group_ranking
        WHERE group_id IS NULL
          OR (active_cnt + group_rn) <= ${hasTiers ? `COALESCE((${params.tiersParam} ->> group_tier)::int, ${params.defaultGroupLimitParam})` : params.defaultGroupLimitParam}
      )` : "";
  const finalCte = hasGroupConcurrency ? "group_filtered" : singletonFetch ? "singleton_ranking" : "next";
  return {
    text: `
      WITH
      ${activeGroupCountsCte}
      ${nextCte}
      ${singletonCte}
      ${groupConcurrencyCtes}
      UPDATE ${schema2}.${table} j SET
        state = '${JOB_STATES.active}',
        started_on = now(),
        retry_count = CASE WHEN started_on IS NOT NULL THEN retry_count + 1 ELSE retry_count END
      FROM ${finalCte}
      WHERE name = '${name2}' AND j.id = ${finalCte}.id
      ${singletonFetch && !hasGroupConcurrency ? "AND singleton_rn = 1" : ""}
      RETURNING j.${includeMetadata ? JOB_COLUMNS_ALL : JOB_COLUMNS_MIN}
    `,
    values: params.values
  };
}
function completeJobs(schema2, table, includeQueued) {
  const stateFilter = includeQueued ? `state < '${JOB_STATES.completed}'` : `state = '${JOB_STATES.active}'`;
  return `
    WITH results AS (
      UPDATE ${schema2}.${table}
      SET completed_on = now(),
        state = '${JOB_STATES.completed}',
        output = $3::jsonb
      WHERE name = $1
        AND id IN (SELECT UNNEST($2::uuid[]))
        AND ${stateFilter}
      RETURNING *
    )
    SELECT COUNT(*) FROM results
  `;
}
function cancelJobs(schema2, table) {
  return `
    WITH results as (
      UPDATE ${schema2}.${table}
      SET completed_on = now(),
        state = '${JOB_STATES.cancelled}'
      WHERE name = $1
        AND id IN (SELECT UNNEST($2::uuid[]))
        AND state < '${JOB_STATES.completed}'
      RETURNING 1
    )
    SELECT COUNT(*) from results
  `;
}
function resumeJobs(schema2, table) {
  return `
    WITH results as (
      UPDATE ${schema2}.${table}
      SET completed_on = NULL,
        state = '${JOB_STATES.created}'
      WHERE name = $1
        AND id IN (SELECT UNNEST($2::uuid[]))
        AND state = '${JOB_STATES.cancelled}'
      RETURNING 1
    )
    SELECT COUNT(*) from results
  `;
}
function restoreJobs(schema2, table) {
  return `
    UPDATE ${schema2}.${table}
    SET state = '${JOB_STATES.created}'
    WHERE name = $1
      AND id IN (SELECT UNNEST($2::uuid[]))
  `;
}
function insertJobs(schema2, { table, name: name2, returnId = true }) {
  const sql2 = `
    INSERT INTO ${schema2}.${table} (
      id,
      name,
      data,
      priority,
      start_after,
      singleton_key,
      singleton_on,
      group_id,
      group_tier,
      expire_seconds,
      deletion_seconds,
      keep_until,
      retry_limit,
      retry_delay,
      retry_backoff,
      retry_delay_max,
      policy,
      dead_letter
    )
    SELECT
      COALESCE(id, gen_random_uuid()) as id,
      '${name2}' as name,
      data,
      COALESCE(priority, 0) as priority,
      j.start_after,
      "singletonKey",
      CASE
        WHEN "singletonSeconds" IS NOT NULL THEN 'epoch'::timestamp + '1s'::interval * ("singletonSeconds" * floor(( date_part('epoch', now()) + COALESCE("singletonOffset",0)) / "singletonSeconds" ))
        ELSE NULL
        END as singleton_on,
      "groupId" as group_id,
      "groupTier" as group_tier,
      COALESCE("expireInSeconds", q.expire_seconds) as expire_seconds,
      COALESCE("deleteAfterSeconds", q.deletion_seconds) as deletion_seconds,
      j.start_after + (COALESCE("retentionSeconds", q.retention_seconds) * interval '1s') as keep_until,
      COALESCE("retryLimit", q.retry_limit) as retry_limit,
      COALESCE("retryDelay", q.retry_delay) as retry_delay,
      COALESCE("retryBackoff", q.retry_backoff, false) as retry_backoff,
      COALESCE("retryDelayMax", q.retry_delay_max) as retry_delay_max,
      q.policy,
      COALESCE("deadLetter", q.dead_letter) as dead_letter
    FROM (
      SELECT *,
        CASE
          WHEN right("startAfter", 1) = 'Z' THEN CAST("startAfter" as timestamp with time zone)
          ELSE now() + CAST(COALESCE("startAfter",'0') as interval)
          END as start_after
      FROM json_to_recordset($1::json) as x (
        id uuid,
        priority integer,
        data jsonb,
        "startAfter" text,
        "retryLimit" integer,
        "retryDelay" integer,
        "retryDelayMax" integer,
        "retryBackoff" boolean,
        "singletonKey" text,
        "singletonSeconds" integer,
        "singletonOffset" integer,
        "groupId" text,
        "groupTier" text,
        "expireInSeconds" integer,
        "deleteAfterSeconds" integer,
        "retentionSeconds" integer,
        "deadLetter" text
      )
    ) j
    JOIN ${schema2}.queue q ON q.name = '${name2}'
    ON CONFLICT DO NOTHING
    ${returnId ? "RETURNING id" : ""}
  `;
  return sql2;
}
function failJobsById(schema2, table) {
  const where = `name = $1 AND id IN (SELECT UNNEST($2::uuid[])) AND state < '${JOB_STATES.completed}'`;
  const output = "$3::jsonb";
  return failJobs(schema2, table, where, output);
}
function failJobsByTimeout(schema2, table, queues) {
  const where = `state = '${JOB_STATES.active}'
            AND (started_on + expire_seconds * interval '1s') < now()
            AND name = ANY(${serializeArrayParam(queues)})`;
  const output = `'{ "value": { "message": "job timed out" } }'::jsonb`;
  return locked(schema2, failJobs(schema2, table, where, output), table + "failJobsByTimeout");
}
function failJobs(schema2, table, where, output) {
  return `
    WITH deleted_jobs AS (
      DELETE FROM ${schema2}.${table}
      WHERE ${where}
      RETURNING *
    ),
    retried_jobs AS (
      INSERT INTO ${schema2}.${table} (
        id,
        name,
        priority,
        data,
        state,
        retry_limit,
        retry_count,
        retry_delay,
        retry_backoff,
        retry_delay_max,
        start_after,
        started_on,
        singleton_key,
        singleton_on,
        group_id,
        group_tier,
        expire_seconds,
        deletion_seconds,
        created_on,
        completed_on,
        keep_until,
        policy,
        output,
        dead_letter
      )
      SELECT
        id,
        name,
        priority,
        data,
        CASE
          WHEN retry_count < retry_limit THEN '${JOB_STATES.retry}'::${schema2}.job_state
          ELSE '${JOB_STATES.failed}'::${schema2}.job_state
          END as state,
        retry_limit,
        retry_count,
        retry_delay,
        retry_backoff,
        retry_delay_max,
        CASE WHEN retry_count = retry_limit THEN start_after
             WHEN NOT retry_backoff THEN now() + retry_delay * interval '1'
             ELSE now() + LEAST(
               retry_delay_max,
               retry_delay * (
                2 ^ LEAST(16, retry_count + 1) / 2 +
                2 ^ LEAST(16, retry_count + 1) / 2 * random()
               )
             ) * interval '1s'
        END as start_after,
        started_on,
        singleton_key,
        singleton_on,
        group_id,
        group_tier,
        expire_seconds,
        deletion_seconds,
        created_on,
        CASE WHEN retry_count < retry_limit THEN NULL ELSE now() END as completed_on,
        keep_until,
        policy,
        ${output},
        dead_letter
      FROM deleted_jobs
      ON CONFLICT DO NOTHING
      RETURNING *
    ),
    failed_jobs as (
      INSERT INTO ${schema2}.${table} (
        id,
        name,
        priority,
        data,
        state,
        retry_limit,
        retry_count,
        retry_delay,
        retry_backoff,
        retry_delay_max,
        start_after,
        started_on,
        singleton_key,
        singleton_on,
        group_id,
        group_tier,
        expire_seconds,
        deletion_seconds,
        created_on,
        completed_on,
        keep_until,
        policy,
        output,
        dead_letter
      )
      SELECT
        id,
        name,
        priority,
        data,
        '${JOB_STATES.failed}'::${schema2}.job_state as state,
        retry_limit,
        retry_count,
        retry_delay,
        retry_backoff,
        retry_delay_max,
        start_after,
        started_on,
        singleton_key,
        singleton_on,
        group_id,
        group_tier,
        expire_seconds,
        deletion_seconds,
        created_on,
        now() as completed_on,
        keep_until,
        policy,
        ${output},
        dead_letter
      FROM deleted_jobs
      WHERE id NOT IN (SELECT id from retried_jobs)
      RETURNING *
    ),
    results as (
      SELECT * FROM retried_jobs
      UNION ALL
      SELECT * FROM failed_jobs
    ),
    dlq_jobs as (
      INSERT INTO ${schema2}.job (name, data, output, retry_limit, retry_backoff, retry_delay, keep_until, deletion_seconds)
      SELECT
        r.dead_letter,
        data,
        output,
        q.retry_limit,
        q.retry_backoff,
        q.retry_delay,
        now() + q.retention_seconds * interval '1s',
        q.deletion_seconds
      FROM results r
        JOIN ${schema2}.queue q ON q.name = r.dead_letter
      WHERE state = '${JOB_STATES.failed}'
    )
    SELECT COUNT(*) FROM results
  `;
}
function deletion(schema2, table, queues) {
  const sql2 = `
    DELETE FROM ${schema2}.${table}
    WHERE name = ANY(${serializeArrayParam(queues)})
      AND
      (
        (deletion_seconds > 0 AND completed_on + deletion_seconds * interval '1s' < now())
        OR
        (state < '${JOB_STATES.active}' AND keep_until < now())
      )
  `;
  return locked(schema2, sql2, table + "deletion");
}
function retryJobs(schema2, table) {
  return `
    WITH results as (
      UPDATE ${schema2}.job
      SET state = '${JOB_STATES.retry}',
        retry_limit = retry_limit + 1
      WHERE name = $1
        AND id IN (SELECT UNNEST($2::uuid[]))
        AND state = '${JOB_STATES.failed}'
      RETURNING 1
    )
    SELECT COUNT(*) from results
  `;
}
function getQueueStats(schema2, table, queues) {
  return {
    text: `
    SELECT
        name,
        (count(*) FILTER (WHERE start_after > now()))::int as "deferredCount",
        (count(*) FILTER (WHERE state < '${JOB_STATES.active}'))::int as "queuedCount",
        (count(*) FILTER (WHERE state = '${JOB_STATES.active}'))::int as "activeCount",
        count(*)::int as "totalCount",
        array_agg(singleton_key) FILTER (WHERE policy IN ('${QUEUE_POLICIES.singleton}','${QUEUE_POLICIES.stately}') AND state = '${JOB_STATES.active}') as "singletonsActive"
      FROM ${schema2}.${table}
      WHERE name = ANY($1::text[])
      GROUP BY 1
  `,
    values: [queues]
  };
}
function cacheQueueStats(schema2, table, queues) {
  const statsQuery = getQueueStats(schema2, table, queues);
  const statsText = statsQuery.text.replace("$1::text[]", serializeArrayParam(queues));
  const sql2 = `
    WITH stats AS (${statsText})
    UPDATE ${schema2}.queue SET
      deferred_count = COALESCE(stats."deferredCount", 0),
      queued_count = COALESCE(stats."queuedCount", 0),
      active_count = COALESCE(stats."activeCount", 0),
      total_count = COALESCE(stats."totalCount", 0),
      singletons_active = stats."singletonsActive"
    FROM (
      SELECT q.name
      FROM unnest(${serializeArrayParam(queues)}) AS q(name)
    ) q
    LEFT JOIN stats ON stats.name = q.name
    WHERE queue.name = q.name
    RETURNING
      queue.name,
      queue.queued_count as "queuedCount",
      queue.warning_queued as "warningQueueSize"
  `;
  return locked(schema2, sql2, "queue-stats");
}
function serializeArrayParam(values) {
  const escaped = values.map((v) => `'${v.replace(SINGLE_QUOTE_REGEX, "''")}'`);
  return `ARRAY[${escaped.join(",")}]::text[]`;
}
function locked(schema2, query2, key) {
  const sql2 = Array.isArray(query2) ? query2.join(";\n") : query2;
  return `
    BEGIN;
    SET LOCAL lock_timeout = 30000;
    SET LOCAL idle_in_transaction_session_timeout = 30000;
    ${advisoryLock(schema2, key)};
    ${sql2};
    COMMIT;
  `;
}
function advisoryLock(schema2, key) {
  return `SELECT pg_advisory_xact_lock(
      ('x' || encode(sha224((current_database() || '.pgboss.${schema2}${key || ""}')::bytea), 'hex'))::bit(64)::bigint
  )`;
}
function assertMigration(schema2, version2) {
  return `SELECT version::int/(version::int-${version2}) from ${schema2}.version`;
}
function findJobs(schema2, table, options) {
  const { queued, byKey, byData, byId } = options;
  let paramIndex = 1;
  const whereConditions = [];
  if (byId) {
    ++paramIndex;
    whereConditions.push(`AND id = $${paramIndex}`);
  }
  if (byKey) {
    ++paramIndex;
    whereConditions.push(`AND singleton_key = $${paramIndex}`);
  }
  if (byData) {
    ++paramIndex;
    whereConditions.push(`AND data @> $${paramIndex}`);
  }
  if (queued) {
    whereConditions.push(`AND state < '${JOB_STATES.active}'`);
  }
  return `
    SELECT ${JOB_COLUMNS_ALL}
    FROM ${schema2}.${table}
    WHERE name = $1
      ${whereConditions.join("\n      ")}
    `;
}
function getJobById(schema2, table) {
  return `
    SELECT ${JOB_COLUMNS_ALL}
    FROM ${schema2}.${table}
    WHERE name = $1
      AND id = $2
    `;
}
function getNextBamCommand(schema2) {
  return `
    UPDATE ${schema2}.bam
    SET status = 'in_progress', started_on = now()
    WHERE id = (
      SELECT id FROM ${schema2}.bam
      WHERE status IN ('pending', 'failed')
        AND NOT EXISTS (SELECT 1 FROM ${schema2}.bam WHERE status = 'in_progress')
      ORDER BY created_on
      LIMIT 1
    )
    RETURNING id, name, version, status, queue, table_name as "table", command, error,
              created_on as "createdOn", started_on as "startedOn", completed_on as "completedOn"
  `;
}
function setBamCompleted(schema2, id) {
  return `
    UPDATE ${schema2}.bam
    SET status = 'completed', completed_on = now()
    WHERE id = '${id}'
  `;
}
function setBamFailed(schema2, id, error2) {
  const escapedError = error2.replace(/'/g, "''");
  return `
    UPDATE ${schema2}.bam
    SET status = 'failed', error = '${escapedError}', completed_on = now()
    WHERE id = '${id}'
  `;
}
function getBamStatus(schema2) {
  return `
    SELECT status, count(*)::int as count, max(created_on) as "lastCreatedOn"
    FROM ${schema2}.bam
    GROUP BY status
  `;
}
function getBamEntries(schema2) {
  return `
    SELECT id, name, version, status, queue, table_name as "table", command, error,
           created_on as "createdOn", started_on as "startedOn", completed_on as "completedOn"
    FROM ${schema2}.bam
    ORDER BY version, created_on
  `;
}
const POLICY = {
  MAX_EXPIRATION_HOURS: 24,
  MIN_POLLING_INTERVAL_MS: 500
};
function assertObjectName(value, name2 = "Name") {
  assert(/^[\w.-]+$/.test(value), `${name2} can only contain alphanumeric characters, underscores, hyphens, or periods`);
}
function validateQueueArgs(config2 = {}) {
  assert(!("deadLetter" in config2) || config2.deadLetter === null || typeof config2.deadLetter === "string", "deadLetter must be a string");
  if (config2.deadLetter) {
    assertObjectName(config2.deadLetter, "deadLetter");
  }
  validateRetryConfig(config2);
  validateExpirationConfig(config2);
  validateRetentionConfig(config2);
  validateDeletionConfig(config2);
}
function checkSendArgs(args) {
  let name2, data, options;
  if (typeof args[0] === "string") {
    name2 = args[0];
    data = args[1];
    assert(typeof data !== "function", "send() cannot accept a function as the payload.  Did you intend to use work()?");
    options = args[2];
  } else if (typeof args[0] === "object") {
    assert(args.length === 1, "send object API only accepts 1 argument");
    const job = args[0];
    assert(job, "boss requires all jobs to have a name");
    name2 = job.name;
    data = job.data;
    options = job.options;
  }
  options = options || {};
  assert(name2, "boss requires all jobs to have a queue name");
  assert(typeof options === "object", "options should be an object");
  options = { ...options };
  assert(!("priority" in options) || Number.isInteger(options.priority), "priority must be an integer");
  options.priority = options.priority || 0;
  options.startAfter = options.startAfter instanceof Date && typeof options.startAfter.toISOString === "function" ? options.startAfter.toISOString() : +options.startAfter > 0 ? "" + options.startAfter : typeof options.startAfter === "string" ? options.startAfter : void 0;
  validateRetryConfig(options);
  validateExpirationConfig(options);
  validateRetentionConfig(options);
  validateDeletionConfig(options);
  validateGroupConfig(options);
  return { name: name2, data, options };
}
function validateGroupConfig(config2) {
  if (!("group" in config2) || config2.group === void 0 || config2.group === null) {
    return;
  }
  assert(typeof config2.group === "object", "group must be an object");
  assert(typeof config2.group.id === "string" && config2.group.id.length > 0, "group.id must be a non-empty string");
  assert(!("tier" in config2.group) || typeof config2.group.tier === "string" && config2.group.tier.length > 0, "group.tier must be a non-empty string if provided");
}
function validateGroupConcurrencyValue(value, optionName) {
  if (typeof value === "number") {
    assert(Number.isInteger(value) && value >= 1, `${optionName} must be an integer >= 1`);
    return;
  }
  assert(typeof value === "object", `${optionName} must be a number or an object with { default, tiers? }`);
  assert(Number.isInteger(value.default) && value.default >= 1, `${optionName}.default must be an integer >= 1`);
  if ("tiers" in value && value.tiers) {
    assert(typeof value.tiers === "object", `${optionName}.tiers must be an object`);
    for (const [tier, limit] of Object.entries(value.tiers)) {
      assert(typeof tier === "string" && tier.length > 0, `${optionName} tier keys must be non-empty strings`);
      assert(Number.isInteger(limit) && limit >= 1, `${optionName}.tiers["${tier}"] must be an integer >= 1`);
    }
  }
}
function validateGroupConcurrencyConfig(config2) {
  const hasGlobal = config2.groupConcurrency != null;
  const hasLocal = config2.localGroupConcurrency != null;
  assert(!(hasGlobal && hasLocal), "cannot specify both groupConcurrency and localGroupConcurrency - choose one");
  if (hasGlobal)
    validateGroupConcurrencyValue(config2.groupConcurrency, "groupConcurrency");
  if (hasLocal) {
    validateGroupConcurrencyValue(config2.localGroupConcurrency, "localGroupConcurrency");
    validateLocalGroupConcurrencyLimit(config2.localGroupConcurrency, config2.localConcurrency);
  }
}
function validateLocalGroupConcurrencyLimit(localGroupConcurrency, localConcurrency) {
  const effectiveLocalConcurrency = localConcurrency ?? 1;
  if (typeof localGroupConcurrency === "number") {
    assert(localGroupConcurrency <= effectiveLocalConcurrency, `localGroupConcurrency (${localGroupConcurrency}) cannot exceed localConcurrency (${effectiveLocalConcurrency})`);
  } else if (typeof localGroupConcurrency === "object") {
    assert(localGroupConcurrency.default <= effectiveLocalConcurrency, `localGroupConcurrency.default (${localGroupConcurrency.default}) cannot exceed localConcurrency (${effectiveLocalConcurrency})`);
    if (localGroupConcurrency.tiers) {
      for (const [tier, limit] of Object.entries(localGroupConcurrency.tiers)) {
        assert(limit <= effectiveLocalConcurrency, `localGroupConcurrency.tiers["${tier}"] (${limit}) cannot exceed localConcurrency (${effectiveLocalConcurrency})`);
      }
    }
  }
}
function checkWorkArgs(name2, args) {
  let options, callback;
  assert(name2, "queue name is required");
  if (args.length === 1) {
    callback = args[0];
    options = {};
  } else if (args.length > 1) {
    options = args[0] || {};
    callback = args[1];
  }
  assert(typeof callback === "function", "expected callback to be a function");
  assert(typeof options === "object", "expected config to be an object");
  options = { ...options };
  applyPollingInterval(options);
  assert(!("batchSize" in options) || Number.isInteger(options.batchSize) && options.batchSize >= 1, "batchSize must be an integer > 0");
  assert(!("includeMetadata" in options) || typeof options.includeMetadata === "boolean", "includeMetadata must be a boolean");
  assert(!("priority" in options) || typeof options.priority === "boolean", "priority must be a boolean");
  assert(!("localConcurrency" in options) || Number.isInteger(options.localConcurrency) && options.localConcurrency >= 1, "localConcurrency must be an integer >= 1");
  validateGroupConcurrencyConfig(options);
  return { options, callback };
}
function checkFetchArgs(name2, options) {
  assert(name2, "missing queue name");
  assert(!("batchSize" in options) || Number.isInteger(options.batchSize) && options.batchSize >= 1, "batchSize must be an integer > 0");
  assert(!("includeMetadata" in options) || typeof options.includeMetadata === "boolean", "includeMetadata must be a boolean");
  assert(!("priority" in options) || typeof options.priority === "boolean", "priority must be a boolean");
  assert(!("ignoreStartAfter" in options) || typeof options.ignoreStartAfter === "boolean", "ignoreStartAfter must be a boolean");
}
function getConfig(value) {
  assert(value && (typeof value === "object" || typeof value === "string"), "configuration assert: string or config object is required to connect to postgres");
  const config2 = typeof value === "string" ? { connectionString: value } : { ...value };
  config2.schedule = "schedule" in config2 ? config2.schedule : true;
  config2.supervise = "supervise" in config2 ? config2.supervise : true;
  config2.migrate = "migrate" in config2 ? config2.migrate : true;
  config2.createSchema = "createSchema" in config2 ? config2.createSchema : true;
  applySchemaConfig(config2);
  applyOpsConfig(config2);
  applyScheduleConfig(config2);
  applyBamConfig(config2);
  validateWarningConfig(config2);
  return config2;
}
function applySchemaConfig(config2) {
  if (config2.schema) {
    assertPostgresObjectName(config2.schema);
  }
  config2.schema = config2.schema || DEFAULT_SCHEMA;
}
function validateWarningConfig(config2) {
  assert(!("warningQueueSize" in config2) || config2.warningQueueSize >= 1, "configuration assert: warningQueueSize must be at least 1");
  assert(!("warningSlowQuerySeconds" in config2) || config2.warningSlowQuerySeconds >= 1, "configuration assert: warningSlowQuerySeconds must be at least 1");
}
function assertPostgresObjectName(name2) {
  assert(typeof name2 === "string", "Name must be a string");
  assert(name2.length <= 50, "Name cannot exceed 50 characters");
  assert(!/\W/.test(name2), "Name can only contain alphanumeric characters or underscores");
  assert(!/^\d/.test(name2), "Name cannot start with a number");
}
function assertQueueName(name2) {
  assert(name2, "Name is required");
  assert(typeof name2 === "string", "Name must be a string");
  assertObjectName(name2);
}
function assertKey(key) {
  if (!key)
    return;
  assert(typeof key === "string", "Key must be a string");
  assertObjectName(key, "Key");
}
function validateRetentionConfig(config2) {
  assert(!("retentionSeconds" in config2) || config2.retentionSeconds >= 1, "configuration assert: retentionSeconds must be at least every second");
}
function validateExpirationConfig(config2) {
  assert(!("expireInSeconds" in config2) || config2.expireInSeconds >= 1, "configuration assert: expireInSeconds must be at least every second");
  assert(!config2.expireInSeconds || config2.expireInSeconds / 60 / 60 < POLICY.MAX_EXPIRATION_HOURS, `configuration assert: expiration cannot exceed ${POLICY.MAX_EXPIRATION_HOURS} hours`);
}
function validateRetryConfig(config2) {
  assert(!("retryDelay" in config2) || Number.isInteger(config2.retryDelay) && config2.retryDelay >= 0, "retryDelay must be an integer >= 0");
  assert(!("retryLimit" in config2) || Number.isInteger(config2.retryLimit) && config2.retryLimit >= 0, "retryLimit must be an integer >= 0");
  assert(!("retryBackoff" in config2) || (config2.retryBackoff === true || config2.retryBackoff === false), "retryBackoff must be either true or false");
  assert(!("retryDelayMax" in config2) || config2.retryDelayMax === null || config2.retryBackoff === true, "retryDelayMax can only be set if retryBackoff is true");
  assert(!("retryDelayMax" in config2) || config2.retryDelayMax === null || Number.isInteger(config2.retryDelayMax) && config2.retryDelayMax >= 0, "retryDelayMax must be an integer >= 0");
}
function applyPollingInterval(config2) {
  assert(!("pollingIntervalSeconds" in config2) || config2.pollingIntervalSeconds >= POLICY.MIN_POLLING_INTERVAL_MS / 1e3, `configuration assert: pollingIntervalSeconds must be at least every ${POLICY.MIN_POLLING_INTERVAL_MS}ms`);
  config2.pollingInterval = "pollingIntervalSeconds" in config2 ? config2.pollingIntervalSeconds * 1e3 : 2e3;
}
function applyOpsConfig(config2) {
  assert(!("superviseIntervalSeconds" in config2) || config2.superviseIntervalSeconds >= 1, "configuration assert: superviseIntervalSeconds must be at least every second");
  config2.superviseIntervalSeconds = config2.superviseIntervalSeconds || 60;
  assert(config2.superviseIntervalSeconds / 60 / 60 <= POLICY.MAX_EXPIRATION_HOURS, `configuration assert: superviseIntervalSeconds cannot exceed ${POLICY.MAX_EXPIRATION_HOURS} hours`);
  assert(!("maintenanceIntervalSeconds" in config2) || config2.maintenanceIntervalSeconds >= 1, "configuration assert: maintenanceIntervalSeconds must be at least every second");
  config2.maintenanceIntervalSeconds = config2.maintenanceIntervalSeconds || POLICY.MAX_EXPIRATION_HOURS * 60 * 60;
  assert(config2.maintenanceIntervalSeconds / 60 / 60 <= POLICY.MAX_EXPIRATION_HOURS, `configuration assert: maintenanceIntervalSeconds cannot exceed ${POLICY.MAX_EXPIRATION_HOURS} hours`);
  assert(!("monitorIntervalSeconds" in config2) || config2.monitorIntervalSeconds >= 1, "configuration assert: monitorIntervalSeconds must be at least every second");
  config2.monitorIntervalSeconds = config2.monitorIntervalSeconds || 60;
  assert(config2.monitorIntervalSeconds / 60 / 60 <= POLICY.MAX_EXPIRATION_HOURS, `configuration assert: monitorIntervalSeconds cannot exceed ${POLICY.MAX_EXPIRATION_HOURS} hours`);
  assert(!("queueCacheIntervalSeconds" in config2) || config2.queueCacheIntervalSeconds >= 1, "configuration assert: queueCacheIntervalSeconds must be at least every second");
  config2.queueCacheIntervalSeconds = config2.queueCacheIntervalSeconds || 60;
  assert(config2.queueCacheIntervalSeconds / 60 / 60 <= POLICY.MAX_EXPIRATION_HOURS, `configuration assert: queueCacheIntervalSeconds cannot exceed ${POLICY.MAX_EXPIRATION_HOURS} hours`);
}
function validateDeletionConfig(config2) {
  assert(!("deleteAfterSeconds" in config2) || config2.deleteAfterSeconds >= 0, "configuration assert: deleteAfterSeconds must be at least 0 (0 disables deletion)");
}
function applyScheduleConfig(config2) {
  assert(!("clockMonitorIntervalSeconds" in config2) || config2.clockMonitorIntervalSeconds >= 1 && config2.clockMonitorIntervalSeconds <= 600, "configuration assert: clockMonitorIntervalSeconds must be between 1 second and 10 minutes");
  config2.clockMonitorIntervalSeconds = config2.clockMonitorIntervalSeconds || 600;
  assert(!("cronMonitorIntervalSeconds" in config2) || config2.cronMonitorIntervalSeconds >= 1 && config2.cronMonitorIntervalSeconds <= 45, "configuration assert: cronMonitorIntervalSeconds must be between 1 and 45 seconds");
  config2.cronMonitorIntervalSeconds = config2.cronMonitorIntervalSeconds || 30;
  assert(!("cronWorkerIntervalSeconds" in config2) || config2.cronWorkerIntervalSeconds >= 1 && config2.cronWorkerIntervalSeconds <= 45, "configuration assert: cronWorkerIntervalSeconds must be between 1 and 45 seconds");
  config2.cronWorkerIntervalSeconds = config2.cronWorkerIntervalSeconds || 5;
}
function applyBamConfig(config2) {
  const minInterval = config2.__test__bypass_bam_interval_check ? 1 : 10;
  assert(!("bamIntervalSeconds" in config2) || config2.bamIntervalSeconds >= minInterval, `configuration assert: bamIntervalSeconds must be at least ${minInterval} seconds`);
  config2.bamIntervalSeconds = config2.bamIntervalSeconds || 60;
}
function flatten(schema2, commands, version2) {
  commands.unshift(assertMigration(schema2, version2));
  commands.push(setVersion(schema2, version2));
  return locked(schema2, commands);
}
function rollback(schema2, version2, migrations) {
  migrations = migrations || getAll(schema2);
  const result2 = migrations.find((i) => i.version === version2);
  assert(result2, `Version ${version2} not found.`);
  return flatten(schema2, result2.uninstall || [], result2.previous);
}
function next(schema2, version2, migrations) {
  migrations = migrations || getAll(schema2);
  const result2 = migrations.find((i) => i.previous === version2);
  assert(result2, `Version ${version2} not found.`);
  return flatten(schema2, result2.install, result2.version);
}
function migrate(schema2, version2, migrations) {
  migrations = migrations || getAll(schema2);
  const result2 = migrations.filter((i) => i.previous >= version2).sort((a, b) => a.version - b.version).reduce((acc, migration) => {
    acc.install = acc.install.concat(migration.install);
    if (migration.async) {
      const bamCommands = migration.async.map((cmd) => cmd.replace(/\$VERSION\$/g, String(migration.version)));
      acc.install = acc.install.concat(bamCommands);
    }
    acc.version = migration.version;
    return acc;
  }, { install: [], version: version2 });
  assert(result2.install.length > 0, `Version ${version2} not found.`);
  return flatten(schema2, result2.install, result2.version);
}
function getAll(schema2) {
  return [
    {
      release: "11.1.0",
      version: 26,
      previous: 25,
      install: [
        `
        CREATE OR REPLACE FUNCTION ${schema2}.create_queue(queue_name text, options jsonb)
        RETURNS VOID AS
        $$
        DECLARE
          tablename varchar := CASE WHEN options->>'partition' = 'true'
                                THEN 'j' || encode(sha224(queue_name::bytea), 'hex')
                                ELSE 'job_common'
                                END;
          queue_created_on timestamptz;
        BEGIN

          WITH q as (
            INSERT INTO ${schema2}.queue (
              name,
              policy,
              retry_limit,
              retry_delay,
              retry_backoff,
              retry_delay_max,
              expire_seconds,
              retention_seconds,
              deletion_seconds,
              warning_queued,
              dead_letter,
              partition,
              table_name
            )
            VALUES (
              queue_name,
              options->>'policy',
              COALESCE((options->>'retryLimit')::int, 2),
              COALESCE((options->>'retryDelay')::int, 0),
              COALESCE((options->>'retryBackoff')::bool, false),
              (options->>'retryDelayMax')::int,
              COALESCE((options->>'expireInSeconds')::int, 900),
              COALESCE((options->>'retentionSeconds')::int, 1209600),
              COALESCE((options->>'deleteAfterSeconds')::int, 604800),
              COALESCE((options->>'warningQueueSize')::int, 0),
              options->>'deadLetter',
              COALESCE((options->>'partition')::bool, false),
              tablename
            )
            ON CONFLICT DO NOTHING
            RETURNING created_on
          )
          SELECT created_on into queue_created_on from q;

          IF queue_created_on IS NULL OR options->>'partition' IS DISTINCT FROM 'true' THEN
            RETURN;
          END IF;

          EXECUTE format('CREATE TABLE ${schema2}.%I (LIKE ${schema2}.job INCLUDING DEFAULTS)', tablename);

          EXECUTE format('ALTER TABLE ${schema2}.%1$I ADD PRIMARY KEY (name, id)', tablename);
          EXECUTE format('ALTER TABLE ${schema2}.%1$I ADD CONSTRAINT q_fkey FOREIGN KEY (name) REFERENCES ${schema2}.queue (name) ON DELETE RESTRICT DEFERRABLE INITIALLY DEFERRED', tablename);
          EXECUTE format('ALTER TABLE ${schema2}.%1$I ADD CONSTRAINT dlq_fkey FOREIGN KEY (dead_letter) REFERENCES ${schema2}.queue (name) ON DELETE RESTRICT DEFERRABLE INITIALLY DEFERRED', tablename);

          EXECUTE format('CREATE INDEX %1$s_i5 ON ${schema2}.%1$I (name, start_after) INCLUDE (priority, created_on, id) WHERE state < ''active''', tablename);
          EXECUTE format('CREATE UNIQUE INDEX %1$s_i4 ON ${schema2}.%1$I (name, singleton_on, COALESCE(singleton_key, '''')) WHERE state <> ''cancelled'' AND singleton_on IS NOT NULL', tablename);

          IF options->>'policy' = 'short' THEN
            EXECUTE format('CREATE UNIQUE INDEX %1$s_i1 ON ${schema2}.%1$I (name, COALESCE(singleton_key, '''')) WHERE state = ''created'' AND policy = ''short''', tablename);
          ELSIF options->>'policy' = 'singleton' THEN
            EXECUTE format('CREATE UNIQUE INDEX %1$s_i2 ON ${schema2}.%1$I (name, COALESCE(singleton_key, '''')) WHERE state = ''active'' AND policy = ''singleton''', tablename);
          ELSIF options->>'policy' = 'stately' THEN
            EXECUTE format('CREATE UNIQUE INDEX %1$s_i3 ON ${schema2}.%1$I (name, state, COALESCE(singleton_key, '''')) WHERE state <= ''active'' AND policy = ''stately''', tablename);
          ELSIF options->>'policy' = 'exclusive' THEN
            EXECUTE format('CREATE UNIQUE INDEX %1$s_i6 ON ${schema2}.%1$I (name, COALESCE(singleton_key, '''')) WHERE state <= ''active'' AND policy = ''exclusive''', tablename);
          END IF;

          EXECUTE format('ALTER TABLE ${schema2}.%I ADD CONSTRAINT cjc CHECK (name=%L)', tablename, queue_name);
          EXECUTE format('ALTER TABLE ${schema2}.job ATTACH PARTITION ${schema2}.%I FOR VALUES IN (%L)', tablename, queue_name);
        END;
        $$
        LANGUAGE plpgsql;
        `,
        `CREATE UNIQUE INDEX job_i6 ON ${schema2}.job_common (name, COALESCE(singleton_key, '')) WHERE state <= 'active' AND policy = 'exclusive'`
      ],
      uninstall: [
        `DROP INDEX ${schema2}.job_i6`
      ]
    },
    {
      release: "12.6.0",
      version: 27,
      previous: 26,
      install: [
        `ALTER TABLE ${schema2}.version ADD COLUMN IF NOT EXISTS bam_on timestamp with time zone`,
        `
        CREATE TABLE IF NOT EXISTS ${schema2}.bam (
          id uuid PRIMARY KEY default gen_random_uuid(),
          name text NOT NULL,
          version int NOT NULL,
          status text NOT NULL DEFAULT 'pending',
          queue text,
          table_name text NOT NULL,
          command text NOT NULL,
          error text,
          created_on timestamp with time zone NOT NULL DEFAULT now(),
          started_on timestamp with time zone,
          completed_on timestamp with time zone
        )
        `,
        `CREATE FUNCTION ${schema2}.job_table_format(command text, table_name text)
          RETURNS text AS
          $$
            SELECT format(
              replace(
                replace(command, '.job', '.%1$I'),
                'job_i', '%1$s_i'
              ),
              table_name
            );
          $$
          LANGUAGE sql IMMUTABLE;
        `,
        `
        CREATE OR REPLACE FUNCTION ${schema2}.job_table_run_async(command_name text, version int, command text, tbl_name text DEFAULT NULL, queue_name text DEFAULT NULL)
        RETURNS VOID AS
        $$
        BEGIN
          IF queue_name IS NOT NULL THEN
            SELECT table_name INTO tbl_name FROM ${schema2}.queue WHERE name = queue_name;
          END IF;

          IF tbl_name IS NOT NULL THEN
            INSERT INTO ${schema2}.bam (name, version, status, queue, table_name, command)
            VALUES (
              command_name,
              version,
              'pending',
              queue_name,
              tbl_name,
              ${schema2}.job_table_format(command, tbl_name)
            );
            RETURN;
          END IF;

          INSERT INTO ${schema2}.bam (name, version, status, queue, table_name, command)
          SELECT
            command_name,
            version,
            'pending',
            NULL,
            'job_common',
            ${schema2}.job_table_format(command, 'job_common')
          UNION ALL
          SELECT
            command_name,
            version,
            'pending',
            queue.name,
            queue.table_name,
            ${schema2}.job_table_format(command, queue.table_name)
          FROM ${schema2}.queue
          WHERE partition = true;
        END;
        $$
        LANGUAGE plpgsql;
        `,
        `
        CREATE OR REPLACE FUNCTION ${schema2}.job_table_run(command text, tbl_name text DEFAULT NULL, queue_name text DEFAULT NULL)
        RETURNS VOID AS
        $$
        DECLARE
          tbl RECORD;
        BEGIN
          IF queue_name IS NOT NULL THEN
            SELECT table_name INTO tbl_name FROM ${schema2}.queue WHERE name = queue_name;
          END IF;

          IF tbl_name IS NOT NULL THEN
            EXECUTE ${schema2}.job_table_format(command, tbl_name);
            RETURN;
          END IF;

          EXECUTE ${schema2}.job_table_format(command, 'job_common');

          FOR tbl IN SELECT table_name FROM ${schema2}.queue WHERE partition = true
          LOOP
            EXECUTE ${schema2}.job_table_format(command, tbl.table_name);
          END LOOP;
        END;
        $$
        LANGUAGE plpgsql;
        `,
        `ALTER TABLE ${schema2}.job ADD COLUMN IF NOT EXISTS group_id text`,
        `ALTER TABLE ${schema2}.job ADD COLUMN IF NOT EXISTS group_tier text`,
        `
        CREATE OR REPLACE FUNCTION ${schema2}.create_queue(queue_name text, options jsonb)
        RETURNS VOID AS
        $$
        DECLARE
          tablename varchar := CASE WHEN options->>'partition' = 'true'
                                THEN 'j' || encode(sha224(queue_name::bytea), 'hex')
                                ELSE 'job_common'
                                END;
          queue_created_on timestamptz;
        BEGIN

          WITH q as (
            INSERT INTO ${schema2}.queue (
              name,
              policy,
              retry_limit,
              retry_delay,
              retry_backoff,
              retry_delay_max,
              expire_seconds,
              retention_seconds,
              deletion_seconds,
              warning_queued,
              dead_letter,
              partition,
              table_name
            )
            VALUES (
              queue_name,
              options->>'policy',
              COALESCE((options->>'retryLimit')::int, 2),
              COALESCE((options->>'retryDelay')::int, 0),
              COALESCE((options->>'retryBackoff')::bool, false),
              (options->>'retryDelayMax')::int,
              COALESCE((options->>'expireInSeconds')::int, 900),
              COALESCE((options->>'retentionSeconds')::int, 1209600),
              COALESCE((options->>'deleteAfterSeconds')::int, 604800),
              COALESCE((options->>'warningQueueSize')::int, 0),
              options->>'deadLetter',
              COALESCE((options->>'partition')::bool, false),
              tablename
            )
            ON CONFLICT DO NOTHING
            RETURNING created_on
          )
          SELECT created_on into queue_created_on from q;

          IF queue_created_on IS NULL OR options->>'partition' IS DISTINCT FROM 'true' THEN
            RETURN;
          END IF;

          EXECUTE format('CREATE TABLE ${schema2}.%I (LIKE ${schema2}.job INCLUDING DEFAULTS)', tablename);

          EXECUTE ${schema2}.job_table_format($cmd$ALTER TABLE ${schema2}.job ADD PRIMARY KEY (name, id)$cmd$, tablename);
          EXECUTE ${schema2}.job_table_format($cmd$ALTER TABLE ${schema2}.job ADD CONSTRAINT q_fkey FOREIGN KEY (name) REFERENCES ${schema2}.queue (name) ON DELETE RESTRICT DEFERRABLE INITIALLY DEFERRED$cmd$, tablename);
          EXECUTE ${schema2}.job_table_format($cmd$ALTER TABLE ${schema2}.job ADD CONSTRAINT dlq_fkey FOREIGN KEY (dead_letter) REFERENCES ${schema2}.queue (name) ON DELETE RESTRICT DEFERRABLE INITIALLY DEFERRED$cmd$, tablename);

          EXECUTE ${schema2}.job_table_format($cmd$CREATE INDEX job_i5 ON ${schema2}.job (name, start_after) INCLUDE (priority, created_on, id) WHERE state < 'active'$cmd$, tablename);
          EXECUTE ${schema2}.job_table_format($cmd$CREATE UNIQUE INDEX job_i4 ON ${schema2}.job (name, singleton_on, COALESCE(singleton_key, '')) WHERE state <> 'cancelled' AND singleton_on IS NOT NULL$cmd$, tablename);
          EXECUTE ${schema2}.job_table_format($cmd$CREATE INDEX job_i7 ON ${schema2}.job (name, group_id) WHERE state = 'active' AND group_id IS NOT NULL$cmd$, tablename);

          IF options->>'policy' = 'short' THEN
            EXECUTE ${schema2}.job_table_format($cmd$CREATE UNIQUE INDEX job_i1 ON ${schema2}.job (name, COALESCE(singleton_key, '')) WHERE state = 'created' AND policy = 'short'$cmd$, tablename);
          ELSIF options->>'policy' = 'singleton' THEN
            EXECUTE ${schema2}.job_table_format($cmd$CREATE UNIQUE INDEX job_i2 ON ${schema2}.job (name, COALESCE(singleton_key, '')) WHERE state = 'active' AND policy = 'singleton'$cmd$, tablename);
          ELSIF options->>'policy' = 'stately' THEN
            EXECUTE ${schema2}.job_table_format($cmd$CREATE UNIQUE INDEX job_i3 ON ${schema2}.job (name, state, COALESCE(singleton_key, '')) WHERE state <= 'active' AND policy = 'stately'$cmd$, tablename);
          ELSIF options->>'policy' = 'exclusive' THEN
            EXECUTE ${schema2}.job_table_format($cmd$CREATE UNIQUE INDEX job_i6 ON ${schema2}.job (name, COALESCE(singleton_key, '')) WHERE state <= 'active' AND policy = 'exclusive'$cmd$, tablename);
          END IF;

          EXECUTE format('ALTER TABLE ${schema2}.%I ADD CONSTRAINT cjc CHECK (name=%L)', tablename, queue_name);
          EXECUTE format('ALTER TABLE ${schema2}.job ATTACH PARTITION ${schema2}.%I FOR VALUES IN (%L)', tablename, queue_name);
        END;
        $$
        LANGUAGE plpgsql;
        `,
        `ALTER INDEX IF EXISTS ${schema2}.job_i1 RENAME TO job_common_i1`,
        `ALTER INDEX IF EXISTS ${schema2}.job_i2 RENAME TO job_common_i2`,
        `ALTER INDEX IF EXISTS ${schema2}.job_i3 RENAME TO job_common_i3`,
        `ALTER INDEX IF EXISTS ${schema2}.job_i4 RENAME TO job_common_i4`,
        `ALTER INDEX IF EXISTS ${schema2}.job_i5 RENAME TO job_common_i5`,
        `ALTER INDEX IF EXISTS ${schema2}.job_i6 RENAME TO job_common_i6`,
        `ALTER INDEX IF EXISTS ${schema2}.job_i7 RENAME TO job_common_i7`
      ],
      async: [
        `SELECT ${schema2}.job_table_run_async(
          'group_concurency_index',
          $VERSION$,
          $$
          CREATE INDEX CONCURRENTLY job_i7 ON ${schema2}.job (name, group_id) WHERE state = 'active' AND group_id IS NOT NULL
          $$
        )`
      ],
      uninstall: [
        `ALTER INDEX ${schema2}.job_common_i6 RENAME TO job_i6`,
        `ALTER INDEX ${schema2}.job_common_i5 RENAME TO job_i5`,
        `ALTER INDEX ${schema2}.job_common_i4 RENAME TO job_i4`,
        `ALTER INDEX ${schema2}.job_common_i3 RENAME TO job_i3`,
        `ALTER INDEX ${schema2}.job_common_i2 RENAME TO job_i2`,
        `ALTER INDEX ${schema2}.job_common_i1 RENAME TO job_i1`,
        `SELECT ${schema2}.job_table_run('DROP INDEX ${schema2}.job_i7')`,
        `
        CREATE OR REPLACE FUNCTION ${schema2}.create_queue(queue_name text, options jsonb)
        RETURNS VOID AS
        $$
        DECLARE
          tablename varchar := CASE WHEN options->>'partition' = 'true'
                                THEN 'j' || encode(sha224(queue_name::bytea), 'hex')
                                ELSE 'job_common'
                                END;
          queue_created_on timestamptz;
        BEGIN

          WITH q as (
            INSERT INTO ${schema2}.queue (
              name,
              policy,
              retry_limit,
              retry_delay,
              retry_backoff,
              retry_delay_max,
              expire_seconds,
              retention_seconds,
              deletion_seconds,
              warning_queued,
              dead_letter,
              partition,
              table_name
            )
            VALUES (
              queue_name,
              options->>'policy',
              COALESCE((options->>'retryLimit')::int, 2),
              COALESCE((options->>'retryDelay')::int, 0),
              COALESCE((options->>'retryBackoff')::bool, false),
              (options->>'retryDelayMax')::int,
              COALESCE((options->>'expireInSeconds')::int, 900),
              COALESCE((options->>'retentionSeconds')::int, 1209600),
              COALESCE((options->>'deleteAfterSeconds')::int, 604800),
              COALESCE((options->>'warningQueueSize')::int, 0),
              options->>'deadLetter',
              COALESCE((options->>'partition')::bool, false),
              tablename
            )
            ON CONFLICT DO NOTHING
            RETURNING created_on
          )
          SELECT created_on into queue_created_on from q;

          IF queue_created_on IS NULL OR options->>'partition' IS DISTINCT FROM 'true' THEN
            RETURN;
          END IF;

          EXECUTE format('CREATE TABLE ${schema2}.%I (LIKE ${schema2}.job INCLUDING DEFAULTS)', tablename);

          EXECUTE format('ALTER TABLE ${schema2}.%1$I ADD PRIMARY KEY (name, id)', tablename);
          EXECUTE format('ALTER TABLE ${schema2}.%1$I ADD CONSTRAINT q_fkey FOREIGN KEY (name) REFERENCES ${schema2}.queue (name) ON DELETE RESTRICT DEFERRABLE INITIALLY DEFERRED', tablename);
          EXECUTE format('ALTER TABLE ${schema2}.%1$I ADD CONSTRAINT dlq_fkey FOREIGN KEY (dead_letter) REFERENCES ${schema2}.queue (name) ON DELETE RESTRICT DEFERRABLE INITIALLY DEFERRED', tablename);

          EXECUTE format('CREATE INDEX %1$s_i5 ON ${schema2}.%1$I (name, start_after) INCLUDE (priority, created_on, id) WHERE state < ''active''', tablename);
          EXECUTE format('CREATE UNIQUE INDEX %1$s_i4 ON ${schema2}.%1$I (name, singleton_on, COALESCE(singleton_key, '''')) WHERE state <> ''cancelled'' AND singleton_on IS NOT NULL', tablename);

          IF options->>'policy' = 'short' THEN
            EXECUTE format('CREATE UNIQUE INDEX %1$s_i1 ON ${schema2}.%1$I (name, COALESCE(singleton_key, '''')) WHERE state = ''created'' AND policy = ''short''', tablename);
          ELSIF options->>'policy' = 'singleton' THEN
            EXECUTE format('CREATE UNIQUE INDEX %1$s_i2 ON ${schema2}.%1$I (name, COALESCE(singleton_key, '''')) WHERE state = ''active'' AND policy = ''singleton''', tablename);
          ELSIF options->>'policy' = 'stately' THEN
            EXECUTE format('CREATE UNIQUE INDEX %1$s_i3 ON ${schema2}.%1$I (name, state, COALESCE(singleton_key, '''')) WHERE state <= ''active'' AND policy = ''stately''', tablename);
          ELSIF options->>'policy' = 'exclusive' THEN
            EXECUTE format('CREATE UNIQUE INDEX %1$s_i6 ON ${schema2}.%1$I (name, COALESCE(singleton_key, '''')) WHERE state <= ''active'' AND policy = ''exclusive''', tablename);
          END IF;

          EXECUTE format('ALTER TABLE ${schema2}.%I ADD CONSTRAINT cjc CHECK (name=%L)', tablename, queue_name);
          EXECUTE format('ALTER TABLE ${schema2}.job ATTACH PARTITION ${schema2}.%I FOR VALUES IN (%L)', tablename, queue_name);
        END;
        $$
        LANGUAGE plpgsql;
        `,
        `DROP FUNCTION ${schema2}.job_table_run(text, text, text)`,
        `DROP FUNCTION ${schema2}.job_table_run_async(text, int, text, text, text)`,
        `DROP FUNCTION ${schema2}.job_table_format(text, text)`,
        `DROP TABLE ${schema2}.bam`,
        `ALTER TABLE ${schema2}.version DROP COLUMN bam_on`,
        `ALTER TABLE ${schema2}.job DROP COLUMN group_tier`,
        `ALTER TABLE ${schema2}.job DROP COLUMN group_id`
      ]
    }
  ];
}
const pgboss = { "schema": 27 };
const packageJson = {
  pgboss
};
const schemaVersion = packageJson.pgboss.schema;
class Contractor {
  static constructionPlans(schema2 = DEFAULT_SCHEMA, options = { createSchema: true }) {
    return create(schema2, schemaVersion, options);
  }
  static migrationPlans(schema2 = DEFAULT_SCHEMA, version2 = schemaVersion - 1) {
    return migrate(schema2, version2);
  }
  static rollbackPlans(schema2 = DEFAULT_SCHEMA, version2 = schemaVersion) {
    return rollback(schema2, version2);
  }
  config;
  db;
  migrations;
  constructor(db, config2) {
    this.config = config2;
    this.db = db;
    this.migrations = this.config.migrations || getAll(this.config.schema);
  }
  async schemaVersion() {
    const result2 = await this.db.executeSql(getVersion(this.config.schema));
    return result2.rows.length ? parseInt(result2.rows[0].version) : null;
  }
  async isInstalled() {
    const result2 = await this.db.executeSql(versionTableExists(this.config.schema));
    return !!result2.rows[0].name;
  }
  async start() {
    const installed = await this.isInstalled();
    if (installed) {
      const version2 = await this.schemaVersion();
      if (version2 !== null && schemaVersion > version2) {
        await this.migrate(version2);
      }
    } else {
      await this.create();
    }
  }
  async check() {
    const installed = await this.isInstalled();
    if (!installed) {
      throw new Error("pg-boss is not installed");
    }
    const version2 = await this.schemaVersion();
    if (schemaVersion !== version2) {
      throw new Error("pg-boss database requires migrations");
    }
  }
  async create() {
    try {
      const commands = create(this.config.schema, schemaVersion, this.config);
      await this.db.executeSql(commands);
    } catch (err2) {
      assert(err2.message.includes(CREATE_RACE_MESSAGE), err2);
    }
  }
  async migrate(version2) {
    try {
      const commands = migrate(this.config.schema, version2, this.migrations);
      await this.db.executeSql(commands);
    } catch (err2) {
      assert(err2.message.includes(MIGRATE_RACE_MESSAGE), err2);
    }
  }
  async next(version2) {
    const commands = next(this.config.schema, version2, this.migrations);
    await this.db.executeSql(commands);
  }
  async rollback(version2) {
    const commands = rollback(this.config.schema, version2, this.migrations);
    await this.db.executeSql(commands);
  }
}
const isNonErrorSymbol = /* @__PURE__ */ Symbol("isNonError");
function defineProperty(object, key, value) {
  Object.defineProperty(object, key, {
    value,
    writable: false,
    enumerable: false,
    configurable: false
  });
}
function stringify(value) {
  if (value === void 0) {
    return "undefined";
  }
  if (value === null) {
    return "null";
  }
  if (typeof value === "string") {
    return value;
  }
  if (typeof value === "number" || typeof value === "boolean") {
    return String(value);
  }
  if (typeof value === "bigint") {
    return `${value}n`;
  }
  if (typeof value === "symbol") {
    return value.toString();
  }
  if (typeof value === "function") {
    return `[Function${value.name ? ` ${value.name}` : " (anonymous)"}]`;
  }
  if (value instanceof Error) {
    try {
      return String(value);
    } catch {
      return "<Unserializable error>";
    }
  }
  try {
    return JSON.stringify(value);
  } catch {
    try {
      return String(value);
    } catch {
      return "<Unserializable value>";
    }
  }
}
class NonError extends Error {
  constructor(value, { superclass: Superclass = Error } = {}) {
    if (NonError.isNonError(value)) {
      return value;
    }
    if (value instanceof Error) {
      throw new TypeError("Do not pass Error instances to NonError. Throw the error directly instead.");
    }
    super(`Non-error value: ${stringify(value)}`);
    if (Superclass !== Error) {
      Object.setPrototypeOf(this, Superclass.prototype);
    }
    defineProperty(this, "name", "NonError");
    defineProperty(this, isNonErrorSymbol, true);
    defineProperty(this, "isNonError", true);
    defineProperty(this, "value", value);
  }
  static isNonError(value) {
    return value?.[isNonErrorSymbol] === true;
  }
  static #handleCallback(callback, arguments_) {
    try {
      const result2 = callback(...arguments_);
      if (result2 && typeof result2.then === "function") {
        return (async () => {
          try {
            return await result2;
          } catch (error2) {
            if (error2 instanceof Error) {
              throw error2;
            }
            throw new NonError(error2);
          }
        })();
      }
      return result2;
    } catch (error2) {
      if (error2 instanceof Error) {
        throw error2;
      }
      throw new NonError(error2);
    }
  }
  static try(callback) {
    return NonError.#handleCallback(callback, []);
  }
  static wrap(callback) {
    return (...arguments_) => NonError.#handleCallback(callback, arguments_);
  }
  // This makes instanceof work even when using the `superclass` option
  static [Symbol.hasInstance](instance) {
    return NonError.isNonError(instance);
  }
}
const errorProperties = [
  {
    property: "name",
    enumerable: false
  },
  {
    property: "message",
    enumerable: false
  },
  {
    property: "stack",
    enumerable: false
  },
  {
    property: "code",
    enumerable: true
  },
  {
    property: "cause",
    enumerable: false
  },
  {
    property: "errors",
    enumerable: false
  }
];
const toJsonWasCalled = /* @__PURE__ */ new WeakSet();
const toJSON = (from) => {
  toJsonWasCalled.add(from);
  const json2 = from.toJSON();
  toJsonWasCalled.delete(from);
  return json2;
};
const destroyCircular = ({
  from,
  seen,
  to,
  forceEnumerable,
  maxDepth,
  depth,
  useToJSON,
  serialize: serialize2
}) => {
  if (!to) {
    if (Array.isArray(from)) {
      to = [];
    } else {
      to = {};
    }
  }
  seen.add(from);
  if (depth >= maxDepth) {
    seen.delete(from);
    return to;
  }
  if (useToJSON && typeof from.toJSON === "function" && !toJsonWasCalled.has(from)) {
    seen.delete(from);
    return toJSON(from);
  }
  const continueDestroyCircular = (value) => destroyCircular({
    from: value,
    seen,
    forceEnumerable,
    maxDepth,
    depth: depth + 1,
    useToJSON,
    serialize: serialize2
  });
  for (const key of Object.keys(from)) {
    const value = from[key];
    if (value && value instanceof Uint8Array && value.constructor.name === "Buffer") {
      to[key] = "[object Buffer]";
      continue;
    }
    if (value !== null && typeof value === "object" && typeof value.pipe === "function") {
      to[key] = "[object Stream]";
      continue;
    }
    if (typeof value === "function") {
      continue;
    }
    if (typeof value === "bigint") {
      to[key] = `${value}n`;
      continue;
    }
    if (!value || typeof value !== "object") {
      try {
        to[key] = value;
      } catch {
      }
      continue;
    }
    if (!seen.has(value)) {
      to[key] = continueDestroyCircular(value);
      continue;
    }
    to[key] = "[Circular]";
  }
  {
    for (const { property, enumerable } of errorProperties) {
      const value = from[property];
      if (value === void 0 || value === null) {
        continue;
      }
      const descriptor = Object.getOwnPropertyDescriptor(to, property);
      if (descriptor?.configurable === false) {
        continue;
      }
      let processedValue = value;
      if (typeof value === "object") {
        processedValue = seen.has(value) ? "[Circular]" : continueDestroyCircular(value);
      }
      Object.defineProperty(to, property, {
        value: processedValue,
        enumerable: forceEnumerable,
        configurable: true,
        writable: true
      });
    }
  }
  seen.delete(from);
  return to;
};
function serializeError(value, options = {}) {
  const {
    maxDepth = Number.POSITIVE_INFINITY,
    useToJSON = true
  } = options;
  if (typeof value === "object" && value !== null) {
    return destroyCircular({
      from: value,
      seen: /* @__PURE__ */ new Set(),
      forceEnumerable: true,
      maxDepth,
      depth: 0,
      useToJSON,
      serialize: true
    });
  }
  if (typeof value === "function") {
    value = "<Function>";
  }
  return destroyCircular({
    from: new NonError(value),
    seen: /* @__PURE__ */ new Set(),
    forceEnumerable: true,
    maxDepth,
    depth: 0,
    useToJSON,
    serialize: true
  });
}
var dist$1 = {};
var CronExpressionParser = {};
var CronFieldCollection = {};
var fields = {};
var types$2 = {};
var hasRequiredTypes;
function requireTypes() {
  if (hasRequiredTypes) return types$2;
  hasRequiredTypes = 1;
  Object.defineProperty(types$2, "__esModule", { value: true });
  return types$2;
}
var CronDayOfMonth = {};
var CronField = {};
var hasRequiredCronField;
function requireCronField() {
  if (hasRequiredCronField) return CronField;
  hasRequiredCronField = 1;
  Object.defineProperty(CronField, "__esModule", { value: true });
  CronField.CronField = void 0;
  let CronField$1 = class CronField2 {
    #hasLastChar = false;
    #hasQuestionMarkChar = false;
    #wildcard = false;
    #values = [];
    options = { rawValue: "" };
    /**
     * Returns the minimum value allowed for this field.
     */
    /* istanbul ignore next */
    static get min() {
      throw new Error("min must be overridden");
    }
    /**
     * Returns the maximum value allowed for this field.
     */
    /* istanbul ignore next */
    static get max() {
      throw new Error("max must be overridden");
    }
    /**
     * Returns the allowed characters for this field.
     */
    /* istanbul ignore next */
    static get chars() {
      return Object.freeze([]);
    }
    /**
     * Returns the regular expression used to validate this field.
     */
    static get validChars() {
      return /^[?,*\dH/-]+$|^.*H\(\d+-\d+\)\/\d+.*$|^.*H\(\d+-\d+\).*$|^.*H\/\d+.*$/;
    }
    /**
     * Returns the constraints for this field.
     */
    static get constraints() {
      return { min: this.min, max: this.max, chars: this.chars, validChars: this.validChars };
    }
    /**
     * CronField constructor. Initializes the field with the provided values.
     * @param {number[] | string[]} values - Values for this field
     * @param {CronFieldOptions} [options] - Options provided by the parser
     * @throws {TypeError} if the constructor is called directly
     * @throws {Error} if validation fails
     */
    constructor(values, options = { rawValue: "" }) {
      if (!Array.isArray(values)) {
        throw new Error(`${this.constructor.name} Validation error, values is not an array`);
      }
      if (!(values.length > 0)) {
        throw new Error(`${this.constructor.name} Validation error, values contains no values`);
      }
      this.options = {
        ...options,
        rawValue: options.rawValue ?? ""
      };
      this.#values = values.sort(CronField2.sorter);
      this.#wildcard = this.options.wildcard !== void 0 ? this.options.wildcard : this.#isWildcardValue();
      this.#hasLastChar = this.options.rawValue.includes("L") || values.includes("L");
      this.#hasQuestionMarkChar = this.options.rawValue.includes("?") || values.includes("?");
    }
    /**
     * Returns the minimum value allowed for this field.
     * @returns {number}
     */
    get min() {
      return this.constructor.min;
    }
    /**
     * Returns the maximum value allowed for this field.
     * @returns {number}
     */
    get max() {
      return this.constructor.max;
    }
    /**
     * Returns an array of allowed special characters for this field.
     * @returns {string[]}
     */
    get chars() {
      return this.constructor.chars;
    }
    /**
     * Indicates whether this field has a "last" character.
     * @returns {boolean}
     */
    get hasLastChar() {
      return this.#hasLastChar;
    }
    /**
     * Indicates whether this field has a "question mark" character.
     * @returns {boolean}
     */
    get hasQuestionMarkChar() {
      return this.#hasQuestionMarkChar;
    }
    /**
     * Indicates whether this field is a wildcard.
     * @returns {boolean}
     */
    get isWildcard() {
      return this.#wildcard;
    }
    /**
     * Returns an array of allowed values for this field.
     * @returns {CronFieldType}
     */
    get values() {
      return this.#values;
    }
    /**
     * Helper function to sort values in ascending order.
     * @param {number | string} a - First value to compare
     * @param {number | string} b - Second value to compare
     * @returns {number} - A negative, zero, or positive value, depending on the sort order
     */
    static sorter(a, b) {
      const aIsNumber = typeof a === "number";
      const bIsNumber = typeof b === "number";
      if (aIsNumber && bIsNumber)
        return a - b;
      if (!aIsNumber && !bIsNumber)
        return a.localeCompare(b);
      return aIsNumber ? (
        /* istanbul ignore next - A will always be a number until L-2 is supported */
        -1
      ) : 1;
    }
    /**
     * Find the next (or previous when `reverse` is true) numeric value in a sorted list.
     * Returns null if there's no value strictly after/before the current one.
     *
     * @param values - Sorted numeric values
     * @param currentValue - Current value to compare against
     * @param reverse - When true, search in reverse for previous smaller value
     */
    static findNearestValueInList(values, currentValue, reverse = false) {
      if (reverse) {
        for (let i = values.length - 1; i >= 0; i--) {
          if (values[i] < currentValue)
            return values[i];
        }
        return null;
      }
      for (let i = 0; i < values.length; i++) {
        if (values[i] > currentValue)
          return values[i];
      }
      return null;
    }
    /**
     * Instance helper that operates on this field's numeric `values`.
     *
     * @param currentValue - Current value to compare against
     * @param reverse - When true, search in reverse for previous smaller value
     */
    findNearestValue(currentValue, reverse = false) {
      return this.constructor.findNearestValueInList(this.values, currentValue, reverse);
    }
    /**
     * Serializes the field to an object.
     * @returns {SerializedCronField}
     */
    serialize() {
      return {
        wildcard: this.#wildcard,
        values: this.#values
      };
    }
    /**
     * Validates the field values against the allowed range and special characters.
     * @throws {Error} if validation fails
     */
    validate() {
      let badValue;
      const charsString = this.chars.length > 0 ? ` or chars ${this.chars.join("")}` : "";
      const charTest = (value) => (char2) => new RegExp(`^\\d{0,2}${char2}$`).test(value);
      const rangeTest = (value) => {
        badValue = value;
        return typeof value === "number" ? value >= this.min && value <= this.max : this.chars.some(charTest(value));
      };
      const isValidRange = this.#values.every(rangeTest);
      if (!isValidRange) {
        throw new Error(`${this.constructor.name} Validation error, got value ${badValue} expected range ${this.min}-${this.max}${charsString}`);
      }
      const duplicate = this.#values.find((value, index2) => this.#values.indexOf(value) !== index2);
      if (duplicate) {
        throw new Error(`${this.constructor.name} Validation error, duplicate values found: ${duplicate}`);
      }
    }
    /**
     * Determines if the field is a wildcard based on the values.
     * When options.rawValue is not empty, it checks if the raw value is a wildcard, otherwise it checks if all values in the range are included.
     * @returns {boolean}
     */
    #isWildcardValue() {
      if (this.options.rawValue.length > 0) {
        return ["*", "?"].includes(this.options.rawValue);
      }
      return Array.from({ length: this.max - this.min + 1 }, (_, i) => i + this.min).every((value) => this.#values.includes(value));
    }
  };
  CronField.CronField = CronField$1;
  return CronField;
}
var hasRequiredCronDayOfMonth;
function requireCronDayOfMonth() {
  if (hasRequiredCronDayOfMonth) return CronDayOfMonth;
  hasRequiredCronDayOfMonth = 1;
  Object.defineProperty(CronDayOfMonth, "__esModule", { value: true });
  CronDayOfMonth.CronDayOfMonth = void 0;
  const CronField_1 = requireCronField();
  const MIN_DAY = 1;
  const MAX_DAY = 31;
  const DAY_CHARS = Object.freeze(["L"]);
  let CronDayOfMonth$1 = class CronDayOfMonth extends CronField_1.CronField {
    static get min() {
      return MIN_DAY;
    }
    static get max() {
      return MAX_DAY;
    }
    static get chars() {
      return DAY_CHARS;
    }
    static get validChars() {
      return /^[?,*\dLH/-]+$|^.*H\(\d+-\d+\)\/\d+.*$|^.*H\(\d+-\d+\).*$|^.*H\/\d+.*$/;
    }
    /**
     * CronDayOfMonth constructor. Initializes the "day of the month" field with the provided values.
     * @param {DayOfMonthRange[]} values - Values for the "day of the month" field
     * @param {CronFieldOptions} [options] - Options provided by the parser
     * @throws {Error} if validation fails
     */
    constructor(values, options) {
      super(values, options);
      this.validate();
    }
    /**
     * Returns an array of allowed values for the "day of the month" field.
     * @returns {DayOfMonthRange[]}
     */
    get values() {
      return super.values;
    }
  };
  CronDayOfMonth.CronDayOfMonth = CronDayOfMonth$1;
  return CronDayOfMonth;
}
var CronDayOfWeek = {};
var hasRequiredCronDayOfWeek;
function requireCronDayOfWeek() {
  if (hasRequiredCronDayOfWeek) return CronDayOfWeek;
  hasRequiredCronDayOfWeek = 1;
  Object.defineProperty(CronDayOfWeek, "__esModule", { value: true });
  CronDayOfWeek.CronDayOfWeek = void 0;
  const CronField_1 = requireCronField();
  const MIN_DAY = 0;
  const MAX_DAY = 7;
  const DAY_CHARS = Object.freeze(["L"]);
  let CronDayOfWeek$1 = class CronDayOfWeek extends CronField_1.CronField {
    static get min() {
      return MIN_DAY;
    }
    static get max() {
      return MAX_DAY;
    }
    static get chars() {
      return DAY_CHARS;
    }
    static get validChars() {
      return /^[?,*\dLH#/-]+$|^.*H\(\d+-\d+\)\/\d+.*$|^.*H\(\d+-\d+\).*$|^.*H\/\d+.*$/;
    }
    /**
     * CronDayOfTheWeek constructor. Initializes the "day of the week" field with the provided values.
     * @param {DayOfWeekRange[]} values - Values for the "day of the week" field
     * @param {CronFieldOptions} [options] - Options provided by the parser
     */
    constructor(values, options) {
      super(values, options);
      this.validate();
    }
    /**
     * Returns an array of allowed values for the "day of the week" field.
     * @returns {DayOfWeekRange[]}
     */
    get values() {
      return super.values;
    }
    /**
     * Returns the nth day of the week if specified in the cron expression.
     * This is used for the '#' character in the cron expression.
     * @returns {number} The nth day of the week (1-5) or 0 if not specified.
     */
    get nthDay() {
      return this.options.nthDayOfWeek ?? 0;
    }
  };
  CronDayOfWeek.CronDayOfWeek = CronDayOfWeek$1;
  return CronDayOfWeek;
}
var CronHour = {};
var hasRequiredCronHour;
function requireCronHour() {
  if (hasRequiredCronHour) return CronHour;
  hasRequiredCronHour = 1;
  Object.defineProperty(CronHour, "__esModule", { value: true });
  CronHour.CronHour = void 0;
  const CronField_1 = requireCronField();
  const MIN_HOUR = 0;
  const MAX_HOUR = 23;
  const HOUR_CHARS = Object.freeze([]);
  let CronHour$1 = class CronHour extends CronField_1.CronField {
    static get min() {
      return MIN_HOUR;
    }
    static get max() {
      return MAX_HOUR;
    }
    static get chars() {
      return HOUR_CHARS;
    }
    /**
     * CronHour constructor. Initializes the "hour" field with the provided values.
     * @param {HourRange[]} values - Values for the "hour" field
     * @param {CronFieldOptions} [options] - Options provided by the parser
     */
    constructor(values, options) {
      super(values, options);
      this.validate();
    }
    /**
     * Returns an array of allowed values for the "hour" field.
     * @returns {HourRange[]}
     */
    get values() {
      return super.values;
    }
  };
  CronHour.CronHour = CronHour$1;
  return CronHour;
}
var CronMinute = {};
var hasRequiredCronMinute;
function requireCronMinute() {
  if (hasRequiredCronMinute) return CronMinute;
  hasRequiredCronMinute = 1;
  Object.defineProperty(CronMinute, "__esModule", { value: true });
  CronMinute.CronMinute = void 0;
  const CronField_1 = requireCronField();
  const MIN_MINUTE = 0;
  const MAX_MINUTE = 59;
  const MINUTE_CHARS = Object.freeze([]);
  let CronMinute$1 = class CronMinute extends CronField_1.CronField {
    static get min() {
      return MIN_MINUTE;
    }
    static get max() {
      return MAX_MINUTE;
    }
    static get chars() {
      return MINUTE_CHARS;
    }
    /**
     * CronSecond constructor. Initializes the "second" field with the provided values.
     * @param {SixtyRange[]} values - Values for the "second" field
     * @param {CronFieldOptions} [options] - Options provided by the parser
     */
    constructor(values, options) {
      super(values, options);
      this.validate();
    }
    /**
     * Returns an array of allowed values for the "second" field.
     * @returns {SixtyRange[]}
     */
    get values() {
      return super.values;
    }
  };
  CronMinute.CronMinute = CronMinute$1;
  return CronMinute;
}
var CronMonth = {};
var CronDate = {};
class LuxonError extends Error {
}
class InvalidDateTimeError extends LuxonError {
  constructor(reason) {
    super(`Invalid DateTime: ${reason.toMessage()}`);
  }
}
class InvalidIntervalError extends LuxonError {
  constructor(reason) {
    super(`Invalid Interval: ${reason.toMessage()}`);
  }
}
class InvalidDurationError extends LuxonError {
  constructor(reason) {
    super(`Invalid Duration: ${reason.toMessage()}`);
  }
}
class ConflictingSpecificationError extends LuxonError {
}
class InvalidUnitError extends LuxonError {
  constructor(unit) {
    super(`Invalid unit ${unit}`);
  }
}
class InvalidArgumentError extends LuxonError {
}
class ZoneIsAbstractError extends LuxonError {
  constructor() {
    super("Zone is an abstract class");
  }
}
const n = "numeric", s = "short", l = "long";
const DATE_SHORT = {
  year: n,
  month: n,
  day: n
};
const DATE_MED = {
  year: n,
  month: s,
  day: n
};
const DATE_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s
};
const DATE_FULL = {
  year: n,
  month: l,
  day: n
};
const DATE_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l
};
const TIME_SIMPLE = {
  hour: n,
  minute: n
};
const TIME_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n
};
const TIME_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s
};
const TIME_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l
};
const TIME_24_SIMPLE = {
  hour: n,
  minute: n,
  hourCycle: "h23"
};
const TIME_24_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23"
};
const TIME_24_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: s
};
const TIME_24_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: l
};
const DATETIME_SHORT = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n
};
const DATETIME_SHORT_WITH_SECONDS = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n,
  second: n
};
const DATETIME_MED = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n
};
const DATETIME_MED_WITH_SECONDS = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n,
  second: n
};
const DATETIME_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s,
  hour: n,
  minute: n
};
const DATETIME_FULL = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  timeZoneName: s
};
const DATETIME_FULL_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s
};
const DATETIME_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  timeZoneName: l
};
const DATETIME_HUGE_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l
};
class Zone {
  /**
   * The type of zone
   * @abstract
   * @type {string}
   */
  get type() {
    throw new ZoneIsAbstractError();
  }
  /**
   * The name of this zone.
   * @abstract
   * @type {string}
   */
  get name() {
    throw new ZoneIsAbstractError();
  }
  /**
   * The IANA name of this zone.
   * Defaults to `name` if not overwritten by a subclass.
   * @abstract
   * @type {string}
   */
  get ianaName() {
    return this.name;
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year.
   * @abstract
   * @type {boolean}
   */
  get isUniversal() {
    throw new ZoneIsAbstractError();
  }
  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(ts, opts) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Returns the offset's value as a string
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(ts, format2) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(ts) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return whether this Zone is equal to another zone
   * @abstract
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(otherZone) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return whether this Zone is valid.
   * @abstract
   * @type {boolean}
   */
  get isValid() {
    throw new ZoneIsAbstractError();
  }
}
let singleton$1 = null;
class SystemZone extends Zone {
  /**
   * Get a singleton instance of the local zone
   * @return {SystemZone}
   */
  static get instance() {
    if (singleton$1 === null) {
      singleton$1 = new SystemZone();
    }
    return singleton$1;
  }
  /** @override **/
  get type() {
    return "system";
  }
  /** @override **/
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
  /** @override **/
  get isUniversal() {
    return false;
  }
  /** @override **/
  offsetName(ts, { format: format2, locale }) {
    return parseZoneInfo(ts, format2, locale);
  }
  /** @override **/
  formatOffset(ts, format2) {
    return formatOffset(this.offset(ts), format2);
  }
  /** @override **/
  offset(ts) {
    return -new Date(ts).getTimezoneOffset();
  }
  /** @override **/
  equals(otherZone) {
    return otherZone.type === "system";
  }
  /** @override **/
  get isValid() {
    return true;
  }
}
const dtfCache = /* @__PURE__ */ new Map();
function makeDTF(zoneName) {
  let dtf = dtfCache.get(zoneName);
  if (dtf === void 0) {
    dtf = new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone: zoneName,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      era: "short"
    });
    dtfCache.set(zoneName, dtf);
  }
  return dtf;
}
const typeToPos = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6
};
function hackyOffset(dtf, date2) {
  const formatted = dtf.format(date2).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted), [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
}
function partsOffset(dtf, date2) {
  const formatted = dtf.formatToParts(date2);
  const filled = [];
  for (let i = 0; i < formatted.length; i++) {
    const { type: type2, value } = formatted[i];
    const pos = typeToPos[type2];
    if (type2 === "era") {
      filled[pos] = value;
    } else if (!isUndefined(pos)) {
      filled[pos] = parseInt(value, 10);
    }
  }
  return filled;
}
const ianaZoneCache = /* @__PURE__ */ new Map();
class IANAZone extends Zone {
  /**
   * @param {string} name - Zone name
   * @return {IANAZone}
   */
  static create(name2) {
    let zone = ianaZoneCache.get(name2);
    if (zone === void 0) {
      ianaZoneCache.set(name2, zone = new IANAZone(name2));
    }
    return zone;
  }
  /**
   * Reset local caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCache() {
    ianaZoneCache.clear();
    dtfCache.clear();
  }
  /**
   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
   * @param {string} s - The string to check validity on
   * @example IANAZone.isValidSpecifier("America/New_York") //=> true
   * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
   * @deprecated For backward compatibility, this forwards to isValidZone, better use `isValidZone()` directly instead.
   * @return {boolean}
   */
  static isValidSpecifier(s2) {
    return this.isValidZone(s2);
  }
  /**
   * Returns whether the provided string identifies a real zone
   * @param {string} zone - The string to check
   * @example IANAZone.isValidZone("America/New_York") //=> true
   * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
   * @example IANAZone.isValidZone("Sport~~blorp") //=> false
   * @return {boolean}
   */
  static isValidZone(zone) {
    if (!zone) {
      return false;
    }
    try {
      new Intl.DateTimeFormat("en-US", { timeZone: zone }).format();
      return true;
    } catch (e2) {
      return false;
    }
  }
  constructor(name2) {
    super();
    this.zoneName = name2;
    this.valid = IANAZone.isValidZone(name2);
  }
  /**
   * The type of zone. `iana` for all instances of `IANAZone`.
   * @override
   * @type {string}
   */
  get type() {
    return "iana";
  }
  /**
   * The name of this zone (i.e. the IANA zone name).
   * @override
   * @type {string}
   */
  get name() {
    return this.zoneName;
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year:
   * Always returns false for all IANA zones.
   * @override
   * @type {boolean}
   */
  get isUniversal() {
    return false;
  }
  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @override
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(ts, { format: format2, locale }) {
    return parseZoneInfo(ts, format2, locale, this.name);
  }
  /**
   * Returns the offset's value as a string
   * @override
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(ts, format2) {
    return formatOffset(this.offset(ts), format2);
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @override
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(ts) {
    if (!this.valid) return NaN;
    const date2 = new Date(ts);
    if (isNaN(date2)) return NaN;
    const dtf = makeDTF(this.name);
    let [year2, month, day2, adOrBc, hour2, minute2, second] = dtf.formatToParts ? partsOffset(dtf, date2) : hackyOffset(dtf, date2);
    if (adOrBc === "BC") {
      year2 = -Math.abs(year2) + 1;
    }
    const adjustedHour = hour2 === 24 ? 0 : hour2;
    const asUTC = objToLocalTS({
      year: year2,
      month,
      day: day2,
      hour: adjustedHour,
      minute: minute2,
      second,
      millisecond: 0
    });
    let asTS = +date2;
    const over = asTS % 1e3;
    asTS -= over >= 0 ? over : 1e3 + over;
    return (asUTC - asTS) / (60 * 1e3);
  }
  /**
   * Return whether this Zone is equal to another zone
   * @override
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(otherZone) {
    return otherZone.type === "iana" && otherZone.name === this.name;
  }
  /**
   * Return whether this Zone is valid.
   * @override
   * @type {boolean}
   */
  get isValid() {
    return this.valid;
  }
}
let intlLFCache = {};
function getCachedLF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlLFCache[key];
  if (!dtf) {
    dtf = new Intl.ListFormat(locString, opts);
    intlLFCache[key] = dtf;
  }
  return dtf;
}
const intlDTCache = /* @__PURE__ */ new Map();
function getCachedDTF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlDTCache.get(key);
  if (dtf === void 0) {
    dtf = new Intl.DateTimeFormat(locString, opts);
    intlDTCache.set(key, dtf);
  }
  return dtf;
}
const intlNumCache = /* @__PURE__ */ new Map();
function getCachedINF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let inf = intlNumCache.get(key);
  if (inf === void 0) {
    inf = new Intl.NumberFormat(locString, opts);
    intlNumCache.set(key, inf);
  }
  return inf;
}
const intlRelCache = /* @__PURE__ */ new Map();
function getCachedRTF(locString, opts = {}) {
  const { base, ...cacheKeyOpts } = opts;
  const key = JSON.stringify([locString, cacheKeyOpts]);
  let inf = intlRelCache.get(key);
  if (inf === void 0) {
    inf = new Intl.RelativeTimeFormat(locString, opts);
    intlRelCache.set(key, inf);
  }
  return inf;
}
let sysLocaleCache = null;
function systemLocale() {
  if (sysLocaleCache) {
    return sysLocaleCache;
  } else {
    sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
    return sysLocaleCache;
  }
}
const intlResolvedOptionsCache = /* @__PURE__ */ new Map();
function getCachedIntResolvedOptions(locString) {
  let opts = intlResolvedOptionsCache.get(locString);
  if (opts === void 0) {
    opts = new Intl.DateTimeFormat(locString).resolvedOptions();
    intlResolvedOptionsCache.set(locString, opts);
  }
  return opts;
}
const weekInfoCache = /* @__PURE__ */ new Map();
function getCachedWeekInfo(locString) {
  let data = weekInfoCache.get(locString);
  if (!data) {
    const locale = new Intl.Locale(locString);
    data = "getWeekInfo" in locale ? locale.getWeekInfo() : locale.weekInfo;
    if (!("minimalDays" in data)) {
      data = { ...fallbackWeekSettings, ...data };
    }
    weekInfoCache.set(locString, data);
  }
  return data;
}
function parseLocaleString(localeStr) {
  const xIndex = localeStr.indexOf("-x-");
  if (xIndex !== -1) {
    localeStr = localeStr.substring(0, xIndex);
  }
  const uIndex = localeStr.indexOf("-u-");
  if (uIndex === -1) {
    return [localeStr];
  } else {
    let options;
    let selectedStr;
    try {
      options = getCachedDTF(localeStr).resolvedOptions();
      selectedStr = localeStr;
    } catch (e2) {
      const smaller = localeStr.substring(0, uIndex);
      options = getCachedDTF(smaller).resolvedOptions();
      selectedStr = smaller;
    }
    const { numberingSystem, calendar } = options;
    return [selectedStr, numberingSystem, calendar];
  }
}
function intlConfigString(localeStr, numberingSystem, outputCalendar) {
  if (outputCalendar || numberingSystem) {
    if (!localeStr.includes("-u-")) {
      localeStr += "-u";
    }
    if (outputCalendar) {
      localeStr += `-ca-${outputCalendar}`;
    }
    if (numberingSystem) {
      localeStr += `-nu-${numberingSystem}`;
    }
    return localeStr;
  } else {
    return localeStr;
  }
}
function mapMonths(f) {
  const ms2 = [];
  for (let i = 1; i <= 12; i++) {
    const dt = DateTime.utc(2009, i, 1);
    ms2.push(f(dt));
  }
  return ms2;
}
function mapWeekdays(f) {
  const ms2 = [];
  for (let i = 1; i <= 7; i++) {
    const dt = DateTime.utc(2016, 11, 13 + i);
    ms2.push(f(dt));
  }
  return ms2;
}
function listStuff(loc, length, englishFn, intlFn) {
  const mode = loc.listingMode();
  if (mode === "error") {
    return null;
  } else if (mode === "en") {
    return englishFn(length);
  } else {
    return intlFn(length);
  }
}
function supportsFastNumbers(loc) {
  if (loc.numberingSystem && loc.numberingSystem !== "latn") {
    return false;
  } else {
    return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || getCachedIntResolvedOptions(loc.locale).numberingSystem === "latn";
  }
}
class PolyNumberFormatter {
  constructor(intl, forceSimple, opts) {
    this.padTo = opts.padTo || 0;
    this.floor = opts.floor || false;
    const { padTo, floor: floor2, ...otherOpts } = opts;
    if (!forceSimple || Object.keys(otherOpts).length > 0) {
      const intlOpts = { useGrouping: false, ...opts };
      if (opts.padTo > 0) intlOpts.minimumIntegerDigits = opts.padTo;
      this.inf = getCachedINF(intl, intlOpts);
    }
  }
  format(i) {
    if (this.inf) {
      const fixed = this.floor ? Math.floor(i) : i;
      return this.inf.format(fixed);
    } else {
      const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);
      return padStart(fixed, this.padTo);
    }
  }
}
class PolyDateFormatter {
  constructor(dt, intl, opts) {
    this.opts = opts;
    this.originalZone = void 0;
    let z2 = void 0;
    if (this.opts.timeZone) {
      this.dt = dt;
    } else if (dt.zone.type === "fixed") {
      const gmtOffset = -1 * (dt.offset / 60);
      const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
      if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
        z2 = offsetZ;
        this.dt = dt;
      } else {
        z2 = "UTC";
        this.dt = dt.offset === 0 ? dt : dt.setZone("UTC").plus({ minutes: dt.offset });
        this.originalZone = dt.zone;
      }
    } else if (dt.zone.type === "system") {
      this.dt = dt;
    } else if (dt.zone.type === "iana") {
      this.dt = dt;
      z2 = dt.zone.name;
    } else {
      z2 = "UTC";
      this.dt = dt.setZone("UTC").plus({ minutes: dt.offset });
      this.originalZone = dt.zone;
    }
    const intlOpts = { ...this.opts };
    intlOpts.timeZone = intlOpts.timeZone || z2;
    this.dtf = getCachedDTF(intl, intlOpts);
  }
  format() {
    if (this.originalZone) {
      return this.formatToParts().map(({ value }) => value).join("");
    }
    return this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    const parts = this.dtf.formatToParts(this.dt.toJSDate());
    if (this.originalZone) {
      return parts.map((part) => {
        if (part.type === "timeZoneName") {
          const offsetName = this.originalZone.offsetName(this.dt.ts, {
            locale: this.dt.locale,
            format: this.opts.timeZoneName
          });
          return {
            ...part,
            value: offsetName
          };
        } else {
          return part;
        }
      });
    }
    return parts;
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
}
class PolyRelFormatter {
  constructor(intl, isEnglish, opts) {
    this.opts = { style: "long", ...opts };
    if (!isEnglish && hasRelative()) {
      this.rtf = getCachedRTF(intl, opts);
    }
  }
  format(count2, unit) {
    if (this.rtf) {
      return this.rtf.format(count2, unit);
    } else {
      return formatRelativeTime(unit, count2, this.opts.numeric, this.opts.style !== "long");
    }
  }
  formatToParts(count2, unit) {
    if (this.rtf) {
      return this.rtf.formatToParts(count2, unit);
    } else {
      return [];
    }
  }
}
const fallbackWeekSettings = {
  firstDay: 1,
  minimalDays: 4,
  weekend: [6, 7]
};
class Locale {
  static fromOpts(opts) {
    return Locale.create(
      opts.locale,
      opts.numberingSystem,
      opts.outputCalendar,
      opts.weekSettings,
      opts.defaultToEN
    );
  }
  static create(locale, numberingSystem, outputCalendar, weekSettings, defaultToEN = false) {
    const specifiedLocale = locale || Settings.defaultLocale;
    const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
    const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
    const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
    const weekSettingsR = validateWeekSettings(weekSettings) || Settings.defaultWeekSettings;
    return new Locale(localeR, numberingSystemR, outputCalendarR, weekSettingsR, specifiedLocale);
  }
  static resetCache() {
    sysLocaleCache = null;
    intlDTCache.clear();
    intlNumCache.clear();
    intlRelCache.clear();
    intlResolvedOptionsCache.clear();
    weekInfoCache.clear();
  }
  static fromObject({ locale, numberingSystem, outputCalendar, weekSettings } = {}) {
    return Locale.create(locale, numberingSystem, outputCalendar, weekSettings);
  }
  constructor(locale, numbering, outputCalendar, weekSettings, specifiedLocale) {
    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);
    this.locale = parsedLocale;
    this.numberingSystem = numbering || parsedNumberingSystem || null;
    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
    this.weekSettings = weekSettings;
    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
    this.weekdaysCache = { format: {}, standalone: {} };
    this.monthsCache = { format: {}, standalone: {} };
    this.meridiemCache = null;
    this.eraCache = {};
    this.specifiedLocale = specifiedLocale;
    this.fastNumbersCached = null;
  }
  get fastNumbers() {
    if (this.fastNumbersCached == null) {
      this.fastNumbersCached = supportsFastNumbers(this);
    }
    return this.fastNumbersCached;
  }
  listingMode() {
    const isActuallyEn = this.isEnglish();
    const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return isActuallyEn && hasNoWeirdness ? "en" : "intl";
  }
  clone(alts) {
    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
      return this;
    } else {
      return Locale.create(
        alts.locale || this.specifiedLocale,
        alts.numberingSystem || this.numberingSystem,
        alts.outputCalendar || this.outputCalendar,
        validateWeekSettings(alts.weekSettings) || this.weekSettings,
        alts.defaultToEN || false
      );
    }
  }
  redefaultToEN(alts = {}) {
    return this.clone({ ...alts, defaultToEN: true });
  }
  redefaultToSystem(alts = {}) {
    return this.clone({ ...alts, defaultToEN: false });
  }
  months(length, format2 = false) {
    return listStuff(this, length, months, () => {
      const monthSpecialCase = this.intl === "ja" || this.intl.startsWith("ja-");
      format2 &= !monthSpecialCase;
      const intl = format2 ? { month: length, day: "numeric" } : { month: length }, formatStr = format2 ? "format" : "standalone";
      if (!this.monthsCache[formatStr][length]) {
        const mapper = !monthSpecialCase ? (dt) => this.extract(dt, intl, "month") : (dt) => this.dtFormatter(dt, intl).format();
        this.monthsCache[formatStr][length] = mapMonths(mapper);
      }
      return this.monthsCache[formatStr][length];
    });
  }
  weekdays(length, format2 = false) {
    return listStuff(this, length, weekdays, () => {
      const intl = format2 ? { weekday: length, year: "numeric", month: "long", day: "numeric" } : { weekday: length }, formatStr = format2 ? "format" : "standalone";
      if (!this.weekdaysCache[formatStr][length]) {
        this.weekdaysCache[formatStr][length] = mapWeekdays(
          (dt) => this.extract(dt, intl, "weekday")
        );
      }
      return this.weekdaysCache[formatStr][length];
    });
  }
  meridiems() {
    return listStuff(
      this,
      void 0,
      () => meridiems,
      () => {
        if (!this.meridiemCache) {
          const intl = { hour: "numeric", hourCycle: "h12" };
          this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(
            (dt) => this.extract(dt, intl, "dayperiod")
          );
        }
        return this.meridiemCache;
      }
    );
  }
  eras(length) {
    return listStuff(this, length, eras, () => {
      const intl = { era: length };
      if (!this.eraCache[length]) {
        this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map(
          (dt) => this.extract(dt, intl, "era")
        );
      }
      return this.eraCache[length];
    });
  }
  extract(dt, intlOpts, field) {
    const df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find((m) => m.type.toLowerCase() === field);
    return matching ? matching.value : null;
  }
  numberFormatter(opts = {}) {
    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
  }
  dtFormatter(dt, intlOpts = {}) {
    return new PolyDateFormatter(dt, this.intl, intlOpts);
  }
  relFormatter(opts = {}) {
    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
  }
  listFormatter(opts = {}) {
    return getCachedLF(this.intl, opts);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || getCachedIntResolvedOptions(this.intl).locale.startsWith("en-us");
  }
  getWeekSettings() {
    if (this.weekSettings) {
      return this.weekSettings;
    } else if (!hasLocaleWeekInfo()) {
      return fallbackWeekSettings;
    } else {
      return getCachedWeekInfo(this.locale);
    }
  }
  getStartOfWeek() {
    return this.getWeekSettings().firstDay;
  }
  getMinDaysInFirstWeek() {
    return this.getWeekSettings().minimalDays;
  }
  getWeekendDays() {
    return this.getWeekSettings().weekend;
  }
  equals(other) {
    return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
  }
  toString() {
    return `Locale(${this.locale}, ${this.numberingSystem}, ${this.outputCalendar})`;
  }
}
let singleton = null;
class FixedOffsetZone extends Zone {
  /**
   * Get a singleton instance of UTC
   * @return {FixedOffsetZone}
   */
  static get utcInstance() {
    if (singleton === null) {
      singleton = new FixedOffsetZone(0);
    }
    return singleton;
  }
  /**
   * Get an instance with a specified offset
   * @param {number} offset - The offset in minutes
   * @return {FixedOffsetZone}
   */
  static instance(offset2) {
    return offset2 === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset2);
  }
  /**
   * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
   * @param {string} s - The offset string to parse
   * @example FixedOffsetZone.parseSpecifier("UTC+6")
   * @example FixedOffsetZone.parseSpecifier("UTC+06")
   * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
   * @return {FixedOffsetZone}
   */
  static parseSpecifier(s2) {
    if (s2) {
      const r2 = s2.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (r2) {
        return new FixedOffsetZone(signedOffset(r2[1], r2[2]));
      }
    }
    return null;
  }
  constructor(offset2) {
    super();
    this.fixed = offset2;
  }
  /**
   * The type of zone. `fixed` for all instances of `FixedOffsetZone`.
   * @override
   * @type {string}
   */
  get type() {
    return "fixed";
  }
  /**
   * The name of this zone.
   * All fixed zones' names always start with "UTC" (plus optional offset)
   * @override
   * @type {string}
   */
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
  }
  /**
   * The IANA name of this zone, i.e. `Etc/UTC` or `Etc/GMT+/-nn`
   *
   * @override
   * @type {string}
   */
  get ianaName() {
    if (this.fixed === 0) {
      return "Etc/UTC";
    } else {
      return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
    }
  }
  /**
   * Returns the offset's common name at the specified timestamp.
   *
   * For fixed offset zones this equals to the zone name.
   * @override
   */
  offsetName() {
    return this.name;
  }
  /**
   * Returns the offset's value as a string
   * @override
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(ts, format2) {
    return formatOffset(this.fixed, format2);
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year:
   * Always returns true for all fixed offset zones.
   * @override
   * @type {boolean}
   */
  get isUniversal() {
    return true;
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   *
   * For fixed offset zones, this is constant and does not depend on a timestamp.
   * @override
   * @return {number}
   */
  offset() {
    return this.fixed;
  }
  /**
   * Return whether this Zone is equal to another zone (i.e. also fixed and same offset)
   * @override
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(otherZone) {
    return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
  }
  /**
   * Return whether this Zone is valid:
   * All fixed offset zones are valid.
   * @override
   * @type {boolean}
   */
  get isValid() {
    return true;
  }
}
class InvalidZone extends Zone {
  constructor(zoneName) {
    super();
    this.zoneName = zoneName;
  }
  /** @override **/
  get type() {
    return "invalid";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return false;
  }
  /** @override **/
  offsetName() {
    return null;
  }
  /** @override **/
  formatOffset() {
    return "";
  }
  /** @override **/
  offset() {
    return NaN;
  }
  /** @override **/
  equals() {
    return false;
  }
  /** @override **/
  get isValid() {
    return false;
  }
}
function normalizeZone(input, defaultZone2) {
  if (isUndefined(input) || input === null) {
    return defaultZone2;
  } else if (input instanceof Zone) {
    return input;
  } else if (isString(input)) {
    const lowered = input.toLowerCase();
    if (lowered === "default") return defaultZone2;
    else if (lowered === "local" || lowered === "system") return SystemZone.instance;
    else if (lowered === "utc" || lowered === "gmt") return FixedOffsetZone.utcInstance;
    else return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input);
  } else if (isNumber(input)) {
    return FixedOffsetZone.instance(input);
  } else if (typeof input === "object" && "offset" in input && typeof input.offset === "function") {
    return input;
  } else {
    return new InvalidZone(input);
  }
}
const numberingSystems = {
  arab: "[-]",
  arabext: "[-]",
  bali: "[-]",
  beng: "[-]",
  deva: "[-]",
  fullwide: "[-]",
  gujr: "[-]",
  hanidec: "[|||||||||]",
  khmr: "[-]",
  knda: "[-]",
  laoo: "[-]",
  limb: "[-]",
  mlym: "[-]",
  mong: "[-]",
  mymr: "[-]",
  orya: "[-]",
  tamldec: "[-]",
  telu: "[-]",
  thai: "[-]",
  tibt: "[-]",
  latn: "\\d"
};
const numberingSystemsUTF16 = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
};
const hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
function parseDigits(str) {
  let value = parseInt(str, 10);
  if (isNaN(value)) {
    value = "";
    for (let i = 0; i < str.length; i++) {
      const code = str.charCodeAt(i);
      if (str[i].search(numberingSystems.hanidec) !== -1) {
        value += hanidecChars.indexOf(str[i]);
      } else {
        for (const key in numberingSystemsUTF16) {
          const [min2, max2] = numberingSystemsUTF16[key];
          if (code >= min2 && code <= max2) {
            value += code - min2;
          }
        }
      }
    }
    return parseInt(value, 10);
  } else {
    return value;
  }
}
const digitRegexCache = /* @__PURE__ */ new Map();
function resetDigitRegexCache() {
  digitRegexCache.clear();
}
function digitRegex({ numberingSystem }, append = "") {
  const ns = numberingSystem || "latn";
  let appendCache = digitRegexCache.get(ns);
  if (appendCache === void 0) {
    appendCache = /* @__PURE__ */ new Map();
    digitRegexCache.set(ns, appendCache);
  }
  let regex = appendCache.get(append);
  if (regex === void 0) {
    regex = new RegExp(`${numberingSystems[ns]}${append}`);
    appendCache.set(append, regex);
  }
  return regex;
}
let now = () => Date.now(), defaultZone = "system", defaultLocale = null, defaultNumberingSystem = null, defaultOutputCalendar = null, twoDigitCutoffYear = 60, throwOnInvalid, defaultWeekSettings = null;
class Settings {
  /**
   * Get the callback for returning the current timestamp.
   * @type {function}
   */
  static get now() {
    return now;
  }
  /**
   * Set the callback for returning the current timestamp.
   * The function should return a number, which will be interpreted as an Epoch millisecond count
   * @type {function}
   * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
   * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
   */
  static set now(n2) {
    now = n2;
  }
  /**
   * Set the default time zone to create DateTimes in. Does not affect existing instances.
   * Use the value "system" to reset this value to the system's time zone.
   * @type {string}
   */
  static set defaultZone(zone) {
    defaultZone = zone;
  }
  /**
   * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
   * The default value is the system's time zone (the one set on the machine that runs this code).
   * @type {Zone}
   */
  static get defaultZone() {
    return normalizeZone(defaultZone, SystemZone.instance);
  }
  /**
   * Get the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultLocale() {
    return defaultLocale;
  }
  /**
   * Set the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultLocale(locale) {
    defaultLocale = locale;
  }
  /**
   * Get the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultNumberingSystem() {
    return defaultNumberingSystem;
  }
  /**
   * Set the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultNumberingSystem(numberingSystem) {
    defaultNumberingSystem = numberingSystem;
  }
  /**
   * Get the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultOutputCalendar() {
    return defaultOutputCalendar;
  }
  /**
   * Set the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultOutputCalendar(outputCalendar) {
    defaultOutputCalendar = outputCalendar;
  }
  /**
   * @typedef {Object} WeekSettings
   * @property {number} firstDay
   * @property {number} minimalDays
   * @property {number[]} weekend
   */
  /**
   * @return {WeekSettings|null}
   */
  static get defaultWeekSettings() {
    return defaultWeekSettings;
  }
  /**
   * Allows overriding the default locale week settings, i.e. the start of the week, the weekend and
   * how many days are required in the first week of a year.
   * Does not affect existing instances.
   *
   * @param {WeekSettings|null} weekSettings
   */
  static set defaultWeekSettings(weekSettings) {
    defaultWeekSettings = validateWeekSettings(weekSettings);
  }
  /**
   * Get the cutoff year for whether a 2-digit year string is interpreted in the current or previous century. Numbers higher than the cutoff will be considered to mean 19xx and numbers lower or equal to the cutoff will be considered 20xx.
   * @type {number}
   */
  static get twoDigitCutoffYear() {
    return twoDigitCutoffYear;
  }
  /**
   * Set the cutoff year for whether a 2-digit year string is interpreted in the current or previous century. Numbers higher than the cutoff will be considered to mean 19xx and numbers lower or equal to the cutoff will be considered 20xx.
   * @type {number}
   * @example Settings.twoDigitCutoffYear = 0 // all 'yy' are interpreted as 20th century
   * @example Settings.twoDigitCutoffYear = 99 // all 'yy' are interpreted as 21st century
   * @example Settings.twoDigitCutoffYear = 50 // '49' -> 2049; '50' -> 1950
   * @example Settings.twoDigitCutoffYear = 1950 // interpreted as 50
   * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpreted as 50
   */
  static set twoDigitCutoffYear(cutoffYear) {
    twoDigitCutoffYear = cutoffYear % 100;
  }
  /**
   * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static get throwOnInvalid() {
    return throwOnInvalid;
  }
  /**
   * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static set throwOnInvalid(t2) {
    throwOnInvalid = t2;
  }
  /**
   * Reset Luxon's global caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCaches() {
    Locale.resetCache();
    IANAZone.resetCache();
    DateTime.resetCache();
    resetDigitRegexCache();
  }
}
class Invalid {
  constructor(reason, explanation) {
    this.reason = reason;
    this.explanation = explanation;
  }
  toMessage() {
    if (this.explanation) {
      return `${this.reason}: ${this.explanation}`;
    } else {
      return this.reason;
    }
  }
}
const nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function unitOutOfRange(unit, value) {
  return new Invalid(
    "unit out of range",
    `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`
  );
}
function dayOfWeek(year2, month, day2) {
  const d = new Date(Date.UTC(year2, month - 1, day2));
  if (year2 < 100 && year2 >= 0) {
    d.setUTCFullYear(d.getUTCFullYear() - 1900);
  }
  const js = d.getUTCDay();
  return js === 0 ? 7 : js;
}
function computeOrdinal(year2, month, day2) {
  return day2 + (isLeapYear(year2) ? leapLadder : nonLeapLadder)[month - 1];
}
function uncomputeOrdinal(year2, ordinal2) {
  const table = isLeapYear(year2) ? leapLadder : nonLeapLadder, month0 = table.findIndex((i) => i < ordinal2), day2 = ordinal2 - table[month0];
  return { month: month0 + 1, day: day2 };
}
function isoWeekdayToLocal(isoWeekday, startOfWeek) {
  return (isoWeekday - startOfWeek + 7) % 7 + 1;
}
function gregorianToWeek(gregObj, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const { year: year2, month, day: day2 } = gregObj, ordinal2 = computeOrdinal(year2, month, day2), weekday = isoWeekdayToLocal(dayOfWeek(year2, month, day2), startOfWeek);
  let weekNumber = Math.floor((ordinal2 - weekday + 14 - minDaysInFirstWeek) / 7), weekYear;
  if (weekNumber < 1) {
    weekYear = year2 - 1;
    weekNumber = weeksInWeekYear(weekYear, minDaysInFirstWeek, startOfWeek);
  } else if (weekNumber > weeksInWeekYear(year2, minDaysInFirstWeek, startOfWeek)) {
    weekYear = year2 + 1;
    weekNumber = 1;
  } else {
    weekYear = year2;
  }
  return { weekYear, weekNumber, weekday, ...timeObject(gregObj) };
}
function weekToGregorian(weekData, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const { weekYear, weekNumber, weekday } = weekData, weekdayOfJan4 = isoWeekdayToLocal(dayOfWeek(weekYear, 1, minDaysInFirstWeek), startOfWeek), yearInDays = daysInYear(weekYear);
  let ordinal2 = weekNumber * 7 + weekday - weekdayOfJan4 - 7 + minDaysInFirstWeek, year2;
  if (ordinal2 < 1) {
    year2 = weekYear - 1;
    ordinal2 += daysInYear(year2);
  } else if (ordinal2 > yearInDays) {
    year2 = weekYear + 1;
    ordinal2 -= daysInYear(weekYear);
  } else {
    year2 = weekYear;
  }
  const { month, day: day2 } = uncomputeOrdinal(year2, ordinal2);
  return { year: year2, month, day: day2, ...timeObject(weekData) };
}
function gregorianToOrdinal(gregData) {
  const { year: year2, month, day: day2 } = gregData;
  const ordinal2 = computeOrdinal(year2, month, day2);
  return { year: year2, ordinal: ordinal2, ...timeObject(gregData) };
}
function ordinalToGregorian(ordinalData) {
  const { year: year2, ordinal: ordinal2 } = ordinalData;
  const { month, day: day2 } = uncomputeOrdinal(year2, ordinal2);
  return { year: year2, month, day: day2, ...timeObject(ordinalData) };
}
function usesLocalWeekValues(obj, loc) {
  const hasLocaleWeekData = !isUndefined(obj.localWeekday) || !isUndefined(obj.localWeekNumber) || !isUndefined(obj.localWeekYear);
  if (hasLocaleWeekData) {
    const hasIsoWeekData = !isUndefined(obj.weekday) || !isUndefined(obj.weekNumber) || !isUndefined(obj.weekYear);
    if (hasIsoWeekData) {
      throw new ConflictingSpecificationError(
        "Cannot mix locale-based week fields with ISO-based week fields"
      );
    }
    if (!isUndefined(obj.localWeekday)) obj.weekday = obj.localWeekday;
    if (!isUndefined(obj.localWeekNumber)) obj.weekNumber = obj.localWeekNumber;
    if (!isUndefined(obj.localWeekYear)) obj.weekYear = obj.localWeekYear;
    delete obj.localWeekday;
    delete obj.localWeekNumber;
    delete obj.localWeekYear;
    return {
      minDaysInFirstWeek: loc.getMinDaysInFirstWeek(),
      startOfWeek: loc.getStartOfWeek()
    };
  } else {
    return { minDaysInFirstWeek: 4, startOfWeek: 1 };
  }
}
function hasInvalidWeekData(obj, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const validYear = isInteger(obj.weekYear), validWeek = integerBetween(
    obj.weekNumber,
    1,
    weeksInWeekYear(obj.weekYear, minDaysInFirstWeek, startOfWeek)
  ), validWeekday = integerBetween(obj.weekday, 1, 7);
  if (!validYear) {
    return unitOutOfRange("weekYear", obj.weekYear);
  } else if (!validWeek) {
    return unitOutOfRange("week", obj.weekNumber);
  } else if (!validWeekday) {
    return unitOutOfRange("weekday", obj.weekday);
  } else return false;
}
function hasInvalidOrdinalData(obj) {
  const validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validOrdinal) {
    return unitOutOfRange("ordinal", obj.ordinal);
  } else return false;
}
function hasInvalidGregorianData(obj) {
  const validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validMonth) {
    return unitOutOfRange("month", obj.month);
  } else if (!validDay) {
    return unitOutOfRange("day", obj.day);
  } else return false;
}
function hasInvalidTimeData(obj) {
  const { hour: hour2, minute: minute2, second, millisecond } = obj;
  const validHour = integerBetween(hour2, 0, 23) || hour2 === 24 && minute2 === 0 && second === 0 && millisecond === 0, validMinute = integerBetween(minute2, 0, 59), validSecond = integerBetween(second, 0, 59), validMillisecond = integerBetween(millisecond, 0, 999);
  if (!validHour) {
    return unitOutOfRange("hour", hour2);
  } else if (!validMinute) {
    return unitOutOfRange("minute", minute2);
  } else if (!validSecond) {
    return unitOutOfRange("second", second);
  } else if (!validMillisecond) {
    return unitOutOfRange("millisecond", millisecond);
  } else return false;
}
function isUndefined(o2) {
  return typeof o2 === "undefined";
}
function isNumber(o2) {
  return typeof o2 === "number";
}
function isInteger(o2) {
  return typeof o2 === "number" && o2 % 1 === 0;
}
function isString(o2) {
  return typeof o2 === "string";
}
function isDate(o2) {
  return Object.prototype.toString.call(o2) === "[object Date]";
}
function hasRelative() {
  try {
    return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
  } catch (e2) {
    return false;
  }
}
function hasLocaleWeekInfo() {
  try {
    return typeof Intl !== "undefined" && !!Intl.Locale && ("weekInfo" in Intl.Locale.prototype || "getWeekInfo" in Intl.Locale.prototype);
  } catch (e2) {
    return false;
  }
}
function maybeArray(thing) {
  return Array.isArray(thing) ? thing : [thing];
}
function bestBy(arr, by, compare) {
  if (arr.length === 0) {
    return void 0;
  }
  return arr.reduce((best, next2) => {
    const pair = [by(next2), next2];
    if (!best) {
      return pair;
    } else if (compare(best[0], pair[0]) === best[0]) {
      return best;
    } else {
      return pair;
    }
  }, null)[1];
}
function pick(obj, keys) {
  return keys.reduce((a, k) => {
    a[k] = obj[k];
    return a;
  }, {});
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function validateWeekSettings(settings) {
  if (settings == null) {
    return null;
  } else if (typeof settings !== "object") {
    throw new InvalidArgumentError("Week settings must be an object");
  } else {
    if (!integerBetween(settings.firstDay, 1, 7) || !integerBetween(settings.minimalDays, 1, 7) || !Array.isArray(settings.weekend) || settings.weekend.some((v) => !integerBetween(v, 1, 7))) {
      throw new InvalidArgumentError("Invalid week settings");
    }
    return {
      firstDay: settings.firstDay,
      minimalDays: settings.minimalDays,
      weekend: Array.from(settings.weekend)
    };
  }
}
function integerBetween(thing, bottom, top) {
  return isInteger(thing) && thing >= bottom && thing <= top;
}
function floorMod(x, n2) {
  return x - n2 * Math.floor(x / n2);
}
function padStart(input, n2 = 2) {
  const isNeg = input < 0;
  let padded;
  if (isNeg) {
    padded = "-" + ("" + -input).padStart(n2, "0");
  } else {
    padded = ("" + input).padStart(n2, "0");
  }
  return padded;
}
function parseInteger(string) {
  if (isUndefined(string) || string === null || string === "") {
    return void 0;
  } else {
    return parseInt(string, 10);
  }
}
function parseFloating(string) {
  if (isUndefined(string) || string === null || string === "") {
    return void 0;
  } else {
    return parseFloat(string);
  }
}
function parseMillis(fraction) {
  if (isUndefined(fraction) || fraction === null || fraction === "") {
    return void 0;
  } else {
    const f = parseFloat("0." + fraction) * 1e3;
    return Math.floor(f);
  }
}
function roundTo(number, digits, rounding = "round") {
  const factor = 10 ** digits;
  switch (rounding) {
    case "expand":
      return number > 0 ? Math.ceil(number * factor) / factor : Math.floor(number * factor) / factor;
    case "trunc":
      return Math.trunc(number * factor) / factor;
    case "round":
      return Math.round(number * factor) / factor;
    case "floor":
      return Math.floor(number * factor) / factor;
    case "ceil":
      return Math.ceil(number * factor) / factor;
    default:
      throw new RangeError(`Value rounding ${rounding} is out of range`);
  }
}
function isLeapYear(year2) {
  return year2 % 4 === 0 && (year2 % 100 !== 0 || year2 % 400 === 0);
}
function daysInYear(year2) {
  return isLeapYear(year2) ? 366 : 365;
}
function daysInMonth(year2, month) {
  const modMonth = floorMod(month - 1, 12) + 1, modYear = year2 + (month - modMonth) / 12;
  if (modMonth === 2) {
    return isLeapYear(modYear) ? 29 : 28;
  } else {
    return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
  }
}
function objToLocalTS(obj) {
  let d = Date.UTC(
    obj.year,
    obj.month - 1,
    obj.day,
    obj.hour,
    obj.minute,
    obj.second,
    obj.millisecond
  );
  if (obj.year < 100 && obj.year >= 0) {
    d = new Date(d);
    d.setUTCFullYear(obj.year, obj.month - 1, obj.day);
  }
  return +d;
}
function firstWeekOffset(year2, minDaysInFirstWeek, startOfWeek) {
  const fwdlw = isoWeekdayToLocal(dayOfWeek(year2, 1, minDaysInFirstWeek), startOfWeek);
  return -fwdlw + minDaysInFirstWeek - 1;
}
function weeksInWeekYear(weekYear, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const weekOffset = firstWeekOffset(weekYear, minDaysInFirstWeek, startOfWeek);
  const weekOffsetNext = firstWeekOffset(weekYear + 1, minDaysInFirstWeek, startOfWeek);
  return (daysInYear(weekYear) - weekOffset + weekOffsetNext) / 7;
}
function untruncateYear(year2) {
  if (year2 > 99) {
    return year2;
  } else return year2 > Settings.twoDigitCutoffYear ? 1900 + year2 : 2e3 + year2;
}
function parseZoneInfo(ts, offsetFormat, locale, timeZone = null) {
  const date2 = new Date(ts), intlOpts = {
    hourCycle: "h23",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit"
  };
  if (timeZone) {
    intlOpts.timeZone = timeZone;
  }
  const modified = { timeZoneName: offsetFormat, ...intlOpts };
  const parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date2).find((m) => m.type.toLowerCase() === "timezonename");
  return parsed ? parsed.value : null;
}
function signedOffset(offHourStr, offMinuteStr) {
  let offHour = parseInt(offHourStr, 10);
  if (Number.isNaN(offHour)) {
    offHour = 0;
  }
  const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
  return offHour * 60 + offMinSigned;
}
function asNumber(value) {
  const numericValue = Number(value);
  if (typeof value === "boolean" || value === "" || !Number.isFinite(numericValue))
    throw new InvalidArgumentError(`Invalid unit value ${value}`);
  return numericValue;
}
function normalizeObject(obj, normalizer) {
  const normalized = {};
  for (const u in obj) {
    if (hasOwnProperty(obj, u)) {
      const v = obj[u];
      if (v === void 0 || v === null) continue;
      normalized[normalizer(u)] = asNumber(v);
    }
  }
  return normalized;
}
function formatOffset(offset2, format2) {
  const hours = Math.trunc(Math.abs(offset2 / 60)), minutes = Math.trunc(Math.abs(offset2 % 60)), sign2 = offset2 >= 0 ? "+" : "-";
  switch (format2) {
    case "short":
      return `${sign2}${padStart(hours, 2)}:${padStart(minutes, 2)}`;
    case "narrow":
      return `${sign2}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
    case "techie":
      return `${sign2}${padStart(hours, 2)}${padStart(minutes, 2)}`;
    default:
      throw new RangeError(`Value format ${format2} is out of range for property format`);
  }
}
function timeObject(obj) {
  return pick(obj, ["hour", "minute", "second", "millisecond"]);
}
const monthsLong = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];
const monthsShort = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
const monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function months(length) {
  switch (length) {
    case "narrow":
      return [...monthsNarrow];
    case "short":
      return [...monthsShort];
    case "long":
      return [...monthsLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
const weekdaysLong = [
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Sunday"
];
const weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
const weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
function weekdays(length) {
  switch (length) {
    case "narrow":
      return [...weekdaysNarrow];
    case "short":
      return [...weekdaysShort];
    case "long":
      return [...weekdaysLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
const meridiems = ["AM", "PM"];
const erasLong = ["Before Christ", "Anno Domini"];
const erasShort = ["BC", "AD"];
const erasNarrow = ["B", "A"];
function eras(length) {
  switch (length) {
    case "narrow":
      return [...erasNarrow];
    case "short":
      return [...erasShort];
    case "long":
      return [...erasLong];
    default:
      return null;
  }
}
function meridiemForDateTime(dt) {
  return meridiems[dt.hour < 12 ? 0 : 1];
}
function weekdayForDateTime(dt, length) {
  return weekdays(length)[dt.weekday - 1];
}
function monthForDateTime(dt, length) {
  return months(length)[dt.month - 1];
}
function eraForDateTime(dt, length) {
  return eras(length)[dt.year < 0 ? 0 : 1];
}
function formatRelativeTime(unit, count2, numeric2 = "always", narrow = false) {
  const units = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  };
  const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
  if (numeric2 === "auto" && lastable) {
    const isDay = unit === "days";
    switch (count2) {
      case 1:
        return isDay ? "tomorrow" : `next ${units[unit][0]}`;
      case -1:
        return isDay ? "yesterday" : `last ${units[unit][0]}`;
      case 0:
        return isDay ? "today" : `this ${units[unit][0]}`;
    }
  }
  const isInPast = Object.is(count2, -0) || count2 < 0, fmtValue = Math.abs(count2), singular2 = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular2 ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular2 ? units[unit][0] : unit;
  return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
}
function stringifyTokens(splits, tokenToString) {
  let s2 = "";
  for (const token2 of splits) {
    if (token2.literal) {
      s2 += token2.val;
    } else {
      s2 += tokenToString(token2.val);
    }
  }
  return s2;
}
const macroTokenToFormatOpts = {
  D: DATE_SHORT,
  DD: DATE_MED,
  DDD: DATE_FULL,
  DDDD: DATE_HUGE,
  t: TIME_SIMPLE,
  tt: TIME_WITH_SECONDS,
  ttt: TIME_WITH_SHORT_OFFSET,
  tttt: TIME_WITH_LONG_OFFSET,
  T: TIME_24_SIMPLE,
  TT: TIME_24_WITH_SECONDS,
  TTT: TIME_24_WITH_SHORT_OFFSET,
  TTTT: TIME_24_WITH_LONG_OFFSET,
  f: DATETIME_SHORT,
  ff: DATETIME_MED,
  fff: DATETIME_FULL,
  ffff: DATETIME_HUGE,
  F: DATETIME_SHORT_WITH_SECONDS,
  FF: DATETIME_MED_WITH_SECONDS,
  FFF: DATETIME_FULL_WITH_SECONDS,
  FFFF: DATETIME_HUGE_WITH_SECONDS
};
class Formatter {
  static create(locale, opts = {}) {
    return new Formatter(locale, opts);
  }
  static parseFormat(fmt2) {
    let current = null, currentFull = "", bracketed = false;
    const splits = [];
    for (let i = 0; i < fmt2.length; i++) {
      const c2 = fmt2.charAt(i);
      if (c2 === "'") {
        if (currentFull.length > 0 || bracketed) {
          splits.push({
            literal: bracketed || /^\s+$/.test(currentFull),
            val: currentFull === "" ? "'" : currentFull
          });
        }
        current = null;
        currentFull = "";
        bracketed = !bracketed;
      } else if (bracketed) {
        currentFull += c2;
      } else if (c2 === current) {
        currentFull += c2;
      } else {
        if (currentFull.length > 0) {
          splits.push({ literal: /^\s+$/.test(currentFull), val: currentFull });
        }
        currentFull = c2;
        current = c2;
      }
    }
    if (currentFull.length > 0) {
      splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
    }
    return splits;
  }
  static macroTokenToFormatOpts(token2) {
    return macroTokenToFormatOpts[token2];
  }
  constructor(locale, formatOpts) {
    this.opts = formatOpts;
    this.loc = locale;
    this.systemLoc = null;
  }
  formatWithSystemDefault(dt, opts) {
    if (this.systemLoc === null) {
      this.systemLoc = this.loc.redefaultToSystem();
    }
    const df = this.systemLoc.dtFormatter(dt, { ...this.opts, ...opts });
    return df.format();
  }
  dtFormatter(dt, opts = {}) {
    return this.loc.dtFormatter(dt, { ...this.opts, ...opts });
  }
  formatDateTime(dt, opts) {
    return this.dtFormatter(dt, opts).format();
  }
  formatDateTimeParts(dt, opts) {
    return this.dtFormatter(dt, opts).formatToParts();
  }
  formatInterval(interval, opts) {
    const df = this.dtFormatter(interval.start, opts);
    return df.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());
  }
  resolvedOptions(dt, opts) {
    return this.dtFormatter(dt, opts).resolvedOptions();
  }
  num(n2, p = 0, signDisplay = void 0) {
    if (this.opts.forceSimple) {
      return padStart(n2, p);
    }
    const opts = { ...this.opts };
    if (p > 0) {
      opts.padTo = p;
    }
    if (signDisplay) {
      opts.signDisplay = signDisplay;
    }
    return this.loc.numberFormatter(opts).format(n2);
  }
  formatDateTimeFromString(dt, fmt2) {
    const knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string = (opts, extract2) => this.loc.extract(dt, opts, extract2), formatOffset2 = (opts) => {
      if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
        return "Z";
      }
      return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
    }, meridiem = () => knownEnglish ? meridiemForDateTime(dt) : string({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), month = (length, standalone) => knownEnglish ? monthForDateTime(dt, length) : string(standalone ? { month: length } : { month: length, day: "numeric" }, "month"), weekday = (length, standalone) => knownEnglish ? weekdayForDateTime(dt, length) : string(
      standalone ? { weekday: length } : { weekday: length, month: "long", day: "numeric" },
      "weekday"
    ), maybeMacro = (token2) => {
      const formatOpts = Formatter.macroTokenToFormatOpts(token2);
      if (formatOpts) {
        return this.formatWithSystemDefault(dt, formatOpts);
      } else {
        return token2;
      }
    }, era = (length) => knownEnglish ? eraForDateTime(dt, length) : string({ era: length }, "era"), tokenToString = (token2) => {
      switch (token2) {
        // ms
        case "S":
          return this.num(dt.millisecond);
        case "u":
        // falls through
        case "SSS":
          return this.num(dt.millisecond, 3);
        // seconds
        case "s":
          return this.num(dt.second);
        case "ss":
          return this.num(dt.second, 2);
        // fractional seconds
        case "uu":
          return this.num(Math.floor(dt.millisecond / 10), 2);
        case "uuu":
          return this.num(Math.floor(dt.millisecond / 100));
        // minutes
        case "m":
          return this.num(dt.minute);
        case "mm":
          return this.num(dt.minute, 2);
        // hours
        case "h":
          return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
        case "hh":
          return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
        case "H":
          return this.num(dt.hour);
        case "HH":
          return this.num(dt.hour, 2);
        // offset
        case "Z":
          return formatOffset2({ format: "narrow", allowZ: this.opts.allowZ });
        case "ZZ":
          return formatOffset2({ format: "short", allowZ: this.opts.allowZ });
        case "ZZZ":
          return formatOffset2({ format: "techie", allowZ: this.opts.allowZ });
        case "ZZZZ":
          return dt.zone.offsetName(dt.ts, { format: "short", locale: this.loc.locale });
        case "ZZZZZ":
          return dt.zone.offsetName(dt.ts, { format: "long", locale: this.loc.locale });
        // zone
        case "z":
          return dt.zoneName;
        // meridiems
        case "a":
          return meridiem();
        // dates
        case "d":
          return useDateTimeFormatter ? string({ day: "numeric" }, "day") : this.num(dt.day);
        case "dd":
          return useDateTimeFormatter ? string({ day: "2-digit" }, "day") : this.num(dt.day, 2);
        // weekdays - standalone
        case "c":
          return this.num(dt.weekday);
        case "ccc":
          return weekday("short", true);
        case "cccc":
          return weekday("long", true);
        case "ccccc":
          return weekday("narrow", true);
        // weekdays - format
        case "E":
          return this.num(dt.weekday);
        case "EEE":
          return weekday("short", false);
        case "EEEE":
          return weekday("long", false);
        case "EEEEE":
          return weekday("narrow", false);
        // months - standalone
        case "L":
          return useDateTimeFormatter ? string({ month: "numeric", day: "numeric" }, "month") : this.num(dt.month);
        case "LL":
          return useDateTimeFormatter ? string({ month: "2-digit", day: "numeric" }, "month") : this.num(dt.month, 2);
        case "LLL":
          return month("short", true);
        case "LLLL":
          return month("long", true);
        case "LLLLL":
          return month("narrow", true);
        // months - format
        case "M":
          return useDateTimeFormatter ? string({ month: "numeric" }, "month") : this.num(dt.month);
        case "MM":
          return useDateTimeFormatter ? string({ month: "2-digit" }, "month") : this.num(dt.month, 2);
        case "MMM":
          return month("short", false);
        case "MMMM":
          return month("long", false);
        case "MMMMM":
          return month("narrow", false);
        // years
        case "y":
          return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year);
        case "yy":
          return useDateTimeFormatter ? string({ year: "2-digit" }, "year") : this.num(dt.year.toString().slice(-2), 2);
        case "yyyy":
          return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 4);
        case "yyyyyy":
          return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 6);
        // eras
        case "G":
          return era("short");
        case "GG":
          return era("long");
        case "GGGGG":
          return era("narrow");
        case "kk":
          return this.num(dt.weekYear.toString().slice(-2), 2);
        case "kkkk":
          return this.num(dt.weekYear, 4);
        case "W":
          return this.num(dt.weekNumber);
        case "WW":
          return this.num(dt.weekNumber, 2);
        case "n":
          return this.num(dt.localWeekNumber);
        case "nn":
          return this.num(dt.localWeekNumber, 2);
        case "ii":
          return this.num(dt.localWeekYear.toString().slice(-2), 2);
        case "iiii":
          return this.num(dt.localWeekYear, 4);
        case "o":
          return this.num(dt.ordinal);
        case "ooo":
          return this.num(dt.ordinal, 3);
        case "q":
          return this.num(dt.quarter);
        case "qq":
          return this.num(dt.quarter, 2);
        case "X":
          return this.num(Math.floor(dt.ts / 1e3));
        case "x":
          return this.num(dt.ts);
        default:
          return maybeMacro(token2);
      }
    };
    return stringifyTokens(Formatter.parseFormat(fmt2), tokenToString);
  }
  formatDurationFromString(dur, fmt2) {
    const invertLargest = this.opts.signMode === "negativeLargestOnly" ? -1 : 1;
    const tokenToField = (token2) => {
      switch (token2[0]) {
        case "S":
          return "milliseconds";
        case "s":
          return "seconds";
        case "m":
          return "minutes";
        case "h":
          return "hours";
        case "d":
          return "days";
        case "w":
          return "weeks";
        case "M":
          return "months";
        case "y":
          return "years";
        default:
          return null;
      }
    }, tokenToString = (lildur, info2) => (token2) => {
      const mapped = tokenToField(token2);
      if (mapped) {
        const inversionFactor = info2.isNegativeDuration && mapped !== info2.largestUnit ? invertLargest : 1;
        let signDisplay;
        if (this.opts.signMode === "negativeLargestOnly" && mapped !== info2.largestUnit) {
          signDisplay = "never";
        } else if (this.opts.signMode === "all") {
          signDisplay = "always";
        } else {
          signDisplay = "auto";
        }
        return this.num(lildur.get(mapped) * inversionFactor, token2.length, signDisplay);
      } else {
        return token2;
      }
    }, tokens = Formatter.parseFormat(fmt2), realTokens = tokens.reduce(
      (found, { literal: literal2, val }) => literal2 ? found : found.concat(val),
      []
    ), collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t2) => t2)), durationInfo = {
      isNegativeDuration: collapsed < 0,
      // this relies on "collapsed" being based on "shiftTo", which builds up the object
      // in order
      largestUnit: Object.keys(collapsed.values)[0]
    };
    return stringifyTokens(tokens, tokenToString(collapsed, durationInfo));
  }
}
const ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
function combineRegexes(...regexes) {
  const full = regexes.reduce((f, r2) => f + r2.source, "");
  return RegExp(`^${full}$`);
}
function combineExtractors(...extractors) {
  return (m) => extractors.reduce(
    ([mergedVals, mergedZone, cursor], ex) => {
      const [val, zone, next2] = ex(m, cursor);
      return [{ ...mergedVals, ...val }, zone || mergedZone, next2];
    },
    [{}, null, 1]
  ).slice(0, 2);
}
function parse$2(s2, ...patterns) {
  if (s2 == null) {
    return [null, null];
  }
  for (const [regex, extractor] of patterns) {
    const m = regex.exec(s2);
    if (m) {
      return extractor(m);
    }
  }
  return [null, null];
}
function simpleParse(...keys) {
  return (match2, cursor) => {
    const ret = {};
    let i;
    for (i = 0; i < keys.length; i++) {
      ret[keys[i]] = parseInteger(match2[cursor + i]);
    }
    return [ret, null, cursor + i];
  };
}
const offsetRegex = /(?:([Zz])|([+-]\d\d)(?::?(\d\d))?)/;
const isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
const isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
const isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
const isoTimeExtensionRegex = RegExp(`(?:[Tt]${isoTimeRegex.source})?`);
const isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
const isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
const isoOrdinalRegex = /(\d{4})-?(\d{3})/;
const extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
const extractISOOrdinalData = simpleParse("year", "ordinal");
const sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
const sqlTimeRegex = RegExp(
  `${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`
);
const sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
function int(match2, pos, fallback) {
  const m = match2[pos];
  return isUndefined(m) ? fallback : parseInteger(m);
}
function extractISOYmd(match2, cursor) {
  const item = {
    year: int(match2, cursor),
    month: int(match2, cursor + 1, 1),
    day: int(match2, cursor + 2, 1)
  };
  return [item, null, cursor + 3];
}
function extractISOTime(match2, cursor) {
  const item = {
    hours: int(match2, cursor, 0),
    minutes: int(match2, cursor + 1, 0),
    seconds: int(match2, cursor + 2, 0),
    milliseconds: parseMillis(match2[cursor + 3])
  };
  return [item, null, cursor + 4];
}
function extractISOOffset(match2, cursor) {
  const local = !match2[cursor] && !match2[cursor + 1], fullOffset = signedOffset(match2[cursor + 1], match2[cursor + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset);
  return [{}, zone, cursor + 3];
}
function extractIANAZone(match2, cursor) {
  const zone = match2[cursor] ? IANAZone.create(match2[cursor]) : null;
  return [{}, zone, cursor + 1];
}
const isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);
const isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function extractISODuration(match2) {
  const [s2, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match2;
  const hasNegativePrefix = s2[0] === "-";
  const negativeSeconds = secondStr && secondStr[0] === "-";
  const maybeNegate = (num, force = false) => num !== void 0 && (force || num && hasNegativePrefix) ? -num : num;
  return [
    {
      years: maybeNegate(parseFloating(yearStr)),
      months: maybeNegate(parseFloating(monthStr)),
      weeks: maybeNegate(parseFloating(weekStr)),
      days: maybeNegate(parseFloating(dayStr)),
      hours: maybeNegate(parseFloating(hourStr)),
      minutes: maybeNegate(parseFloating(minuteStr)),
      seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
      milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
    }
  ];
}
const obsOffsets = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  const result2 = {
    year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
    month: monthsShort.indexOf(monthStr) + 1,
    day: parseInteger(dayStr),
    hour: parseInteger(hourStr),
    minute: parseInteger(minuteStr)
  };
  if (secondStr) result2.second = parseInteger(secondStr);
  if (weekdayStr) {
    result2.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
  }
  return result2;
}
const rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function extractRFC2822(match2) {
  const [
    ,
    weekdayStr,
    dayStr,
    monthStr,
    yearStr,
    hourStr,
    minuteStr,
    secondStr,
    obsOffset,
    milOffset,
    offHourStr,
    offMinuteStr
  ] = match2, result2 = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  let offset2;
  if (obsOffset) {
    offset2 = obsOffsets[obsOffset];
  } else if (milOffset) {
    offset2 = 0;
  } else {
    offset2 = signedOffset(offHourStr, offMinuteStr);
  }
  return [result2, new FixedOffsetZone(offset2)];
}
function preprocessRFC2822(s2) {
  return s2.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
}
const rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/, rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/, ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function extractRFC1123Or850(match2) {
  const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match2, result2 = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result2, FixedOffsetZone.utcInstance];
}
function extractASCII(match2) {
  const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match2, result2 = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result2, FixedOffsetZone.utcInstance];
}
const isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
const isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
const isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
const isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
const extractISOYmdTimeAndOffset = combineExtractors(
  extractISOYmd,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
const extractISOWeekTimeAndOffset = combineExtractors(
  extractISOWeekData,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
const extractISOOrdinalDateAndTime = combineExtractors(
  extractISOOrdinalData,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
const extractISOTimeAndOffset = combineExtractors(
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
function parseISODate$1(s2) {
  return parse$2(
    s2,
    [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
    [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset],
    [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime],
    [isoTimeCombinedRegex, extractISOTimeAndOffset]
  );
}
function parseRFC2822Date(s2) {
  return parse$2(preprocessRFC2822(s2), [rfc2822, extractRFC2822]);
}
function parseHTTPDate(s2) {
  return parse$2(
    s2,
    [rfc1123, extractRFC1123Or850],
    [rfc850, extractRFC1123Or850],
    [ascii, extractASCII]
  );
}
function parseISODuration(s2) {
  return parse$2(s2, [isoDuration, extractISODuration]);
}
const extractISOTimeOnly = combineExtractors(extractISOTime);
function parseISOTimeOnly(s2) {
  return parse$2(s2, [isoTimeOnly, extractISOTimeOnly]);
}
const sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
const sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
const extractISOTimeOffsetAndIANAZone = combineExtractors(
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
function parseSQL(s2) {
  return parse$2(
    s2,
    [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
    [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]
  );
}
const INVALID$2 = "Invalid Duration";
const lowOrderMatrix = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1e3
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1e3
  },
  hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
  minutes: { seconds: 60, milliseconds: 60 * 1e3 },
  seconds: { milliseconds: 1e3 }
}, casualMatrix = {
  years: {
    quarters: 4,
    months: 12,
    weeks: 52,
    days: 365,
    hours: 365 * 24,
    minutes: 365 * 24 * 60,
    seconds: 365 * 24 * 60 * 60,
    milliseconds: 365 * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: 13,
    days: 91,
    hours: 91 * 24,
    minutes: 91 * 24 * 60,
    seconds: 91 * 24 * 60 * 60,
    milliseconds: 91 * 24 * 60 * 60 * 1e3
  },
  months: {
    weeks: 4,
    days: 30,
    hours: 30 * 24,
    minutes: 30 * 24 * 60,
    seconds: 30 * 24 * 60 * 60,
    milliseconds: 30 * 24 * 60 * 60 * 1e3
  },
  ...lowOrderMatrix
}, daysInYearAccurate = 146097 / 400, daysInMonthAccurate = 146097 / 4800, accurateMatrix = {
  years: {
    quarters: 4,
    months: 12,
    weeks: daysInYearAccurate / 7,
    days: daysInYearAccurate,
    hours: daysInYearAccurate * 24,
    minutes: daysInYearAccurate * 24 * 60,
    seconds: daysInYearAccurate * 24 * 60 * 60,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: daysInYearAccurate / 28,
    days: daysInYearAccurate / 4,
    hours: daysInYearAccurate * 24 / 4,
    minutes: daysInYearAccurate * 24 * 60 / 4,
    seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3 / 4
  },
  months: {
    weeks: daysInMonthAccurate / 7,
    days: daysInMonthAccurate,
    hours: daysInMonthAccurate * 24,
    minutes: daysInMonthAccurate * 24 * 60,
    seconds: daysInMonthAccurate * 24 * 60 * 60,
    milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1e3
  },
  ...lowOrderMatrix
};
const orderedUnits$1 = [
  "years",
  "quarters",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds"
];
const reverseUnits = orderedUnits$1.slice(0).reverse();
function clone$1(dur, alts, clear = false) {
  const conf = {
    values: clear ? alts.values : { ...dur.values, ...alts.values || {} },
    loc: dur.loc.clone(alts.loc),
    conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
    matrix: alts.matrix || dur.matrix
  };
  return new Duration(conf);
}
function durationToMillis(matrix, vals) {
  let sum2 = vals.milliseconds ?? 0;
  for (const unit of reverseUnits.slice(1)) {
    if (vals[unit]) {
      sum2 += vals[unit] * matrix[unit]["milliseconds"];
    }
  }
  return sum2;
}
function normalizeValues(matrix, vals) {
  const factor = durationToMillis(matrix, vals) < 0 ? -1 : 1;
  orderedUnits$1.reduceRight((previous, current) => {
    if (!isUndefined(vals[current])) {
      if (previous) {
        const previousVal = vals[previous] * factor;
        const conv = matrix[current][previous];
        const rollUp = Math.floor(previousVal / conv);
        vals[current] += rollUp * factor;
        vals[previous] -= rollUp * conv * factor;
      }
      return current;
    } else {
      return previous;
    }
  }, null);
  orderedUnits$1.reduce((previous, current) => {
    if (!isUndefined(vals[current])) {
      if (previous) {
        const fraction = vals[previous] % 1;
        vals[previous] -= fraction;
        vals[current] += fraction * matrix[previous][current];
      }
      return current;
    } else {
      return previous;
    }
  }, null);
}
function removeZeroes(vals) {
  const newVals = {};
  for (const [key, value] of Object.entries(vals)) {
    if (value !== 0) {
      newVals[key] = value;
    }
  }
  return newVals;
}
class Duration {
  /**
   * @private
   */
  constructor(config2) {
    const accurate = config2.conversionAccuracy === "longterm" || false;
    let matrix = accurate ? accurateMatrix : casualMatrix;
    if (config2.matrix) {
      matrix = config2.matrix;
    }
    this.values = config2.values;
    this.loc = config2.loc || Locale.create();
    this.conversionAccuracy = accurate ? "longterm" : "casual";
    this.invalid = config2.invalid || null;
    this.matrix = matrix;
    this.isLuxonDuration = true;
  }
  /**
   * Create Duration from a number of milliseconds.
   * @param {number} count of milliseconds
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  static fromMillis(count2, opts) {
    return Duration.fromObject({ milliseconds: count2 }, opts);
  }
  /**
   * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
   * If this object is empty then a zero milliseconds duration is returned.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.years
   * @param {number} obj.quarters
   * @param {number} obj.months
   * @param {number} obj.weeks
   * @param {number} obj.days
   * @param {number} obj.hours
   * @param {number} obj.minutes
   * @param {number} obj.seconds
   * @param {number} obj.milliseconds
   * @param {Object} [opts=[]] - options for creating this Duration
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the custom conversion system to use
   * @return {Duration}
   */
  static fromObject(obj, opts = {}) {
    if (obj == null || typeof obj !== "object") {
      throw new InvalidArgumentError(
        `Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`
      );
    }
    return new Duration({
      values: normalizeObject(obj, Duration.normalizeUnit),
      loc: Locale.fromObject(opts),
      conversionAccuracy: opts.conversionAccuracy,
      matrix: opts.matrix
    });
  }
  /**
   * Create a Duration from DurationLike.
   *
   * @param {Object | number | Duration} durationLike
   * One of:
   * - object with keys like 'years' and 'hours'.
   * - number representing milliseconds
   * - Duration instance
   * @return {Duration}
   */
  static fromDurationLike(durationLike) {
    if (isNumber(durationLike)) {
      return Duration.fromMillis(durationLike);
    } else if (Duration.isDuration(durationLike)) {
      return durationLike;
    } else if (typeof durationLike === "object") {
      return Duration.fromObject(durationLike);
    } else {
      throw new InvalidArgumentError(
        `Unknown duration argument ${durationLike} of type ${typeof durationLike}`
      );
    }
  }
  /**
   * Create a Duration from an ISO 8601 duration string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the preset conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
   * @return {Duration}
   */
  static fromISO(text2, opts) {
    const [parsed] = parseISODuration(text2);
    if (parsed) {
      return Duration.fromObject(parsed, opts);
    } else {
      return Duration.invalid("unparsable", `the input "${text2}" can't be parsed as ISO 8601`);
    }
  }
  /**
   * Create a Duration from an ISO 8601 time string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
   * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @return {Duration}
   */
  static fromISOTime(text2, opts) {
    const [parsed] = parseISOTimeOnly(text2);
    if (parsed) {
      return Duration.fromObject(parsed, opts);
    } else {
      return Duration.invalid("unparsable", `the input "${text2}" can't be parsed as ISO 8601`);
    }
  }
  /**
   * Create an invalid Duration.
   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Duration}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDurationError(invalid);
    } else {
      return new Duration({ invalid });
    }
  }
  /**
   * @private
   */
  static normalizeUnit(unit) {
    const normalized = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[unit ? unit.toLowerCase() : unit];
    if (!normalized) throw new InvalidUnitError(unit);
    return normalized;
  }
  /**
   * Check if an object is a Duration. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDuration(o2) {
    return o2 && o2.isLuxonDuration || false;
  }
  /**
   * Get  the locale of a Duration, such 'en-GB'
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
   * * `S` for milliseconds
   * * `s` for seconds
   * * `m` for minutes
   * * `h` for hours
   * * `d` for days
   * * `w` for weeks
   * * `M` for months
   * * `y` for years
   * Notes:
   * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
   * * Tokens can be escaped by wrapping with single quotes.
   * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
   * @param {string} fmt - the format string
   * @param {Object} opts - options
   * @param {boolean} [opts.floor=true] - floor numerical values
   * @param {'negative'|'all'|'negativeLargestOnly'} [opts.signMode=negative] - How to handle signs
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
   * @example Duration.fromObject({ days: 6, seconds: 2 }).toFormat("d s", { signMode: "all" }) //=> "+6 +2"
   * @example Duration.fromObject({ days: -6, seconds: -2 }).toFormat("d s", { signMode: "all" }) //=> "-6 -2"
   * @example Duration.fromObject({ days: -6, seconds: -2 }).toFormat("d s", { signMode: "negativeLargestOnly" }) //=> "-6 2"
   * @return {string}
   */
  toFormat(fmt2, opts = {}) {
    const fmtOpts = {
      ...opts,
      floor: opts.round !== false && opts.floor !== false
    };
    return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt2) : INVALID$2;
  }
  /**
   * Returns a string representation of a Duration with all units included.
   * To modify its behavior, use `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#options
   * @param {Object} opts - Formatting options. Accepts the same keys as the options parameter of the native `Intl.NumberFormat` constructor, as well as `listStyle`.
   * @param {string} [opts.listStyle='narrow'] - How to format the merged list. Corresponds to the `style` property of the options parameter of the native `Intl.ListFormat` constructor.
   * @param {boolean} [opts.showZeros=true] - Show all units previously used by the duration even if they are zero
   * @example
   * ```js
   * var dur = Duration.fromObject({ months: 1, weeks: 0, hours: 5, minutes: 6 })
   * dur.toHuman() //=> '1 month, 0 weeks, 5 hours, 6 minutes'
   * dur.toHuman({ listStyle: "long" }) //=> '1 month, 0 weeks, 5 hours, and 6 minutes'
   * dur.toHuman({ unitDisplay: "short" }) //=> '1 mth, 0 wks, 5 hr, 6 min'
   * dur.toHuman({ showZeros: false }) //=> '1 month, 5 hours, 6 minutes'
   * ```
   */
  toHuman(opts = {}) {
    if (!this.isValid) return INVALID$2;
    const showZeros = opts.showZeros !== false;
    const l2 = orderedUnits$1.map((unit) => {
      const val = this.values[unit];
      if (isUndefined(val) || val === 0 && !showZeros) {
        return null;
      }
      return this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...opts, unit: unit.slice(0, -1) }).format(val);
    }).filter((n2) => n2);
    return this.loc.listFormatter({ type: "conjunction", style: opts.listStyle || "narrow", ...opts }).format(l2);
  }
  /**
   * Returns a JavaScript object with this Duration's values.
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
   * @return {Object}
   */
  toObject() {
    if (!this.isValid) return {};
    return { ...this.values };
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
   * @return {string}
   */
  toISO() {
    if (!this.isValid) return null;
    let s2 = "P";
    if (this.years !== 0) s2 += this.years + "Y";
    if (this.months !== 0 || this.quarters !== 0) s2 += this.months + this.quarters * 3 + "M";
    if (this.weeks !== 0) s2 += this.weeks + "W";
    if (this.days !== 0) s2 += this.days + "D";
    if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
      s2 += "T";
    if (this.hours !== 0) s2 += this.hours + "H";
    if (this.minutes !== 0) s2 += this.minutes + "M";
    if (this.seconds !== 0 || this.milliseconds !== 0)
      s2 += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S";
    if (s2 === "P") s2 += "T0S";
    return s2;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
   * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
   * @return {string}
   */
  toISOTime(opts = {}) {
    if (!this.isValid) return null;
    const millis = this.toMillis();
    if (millis < 0 || millis >= 864e5) return null;
    opts = {
      suppressMilliseconds: false,
      suppressSeconds: false,
      includePrefix: false,
      format: "extended",
      ...opts,
      includeOffset: false
    };
    const dateTime = DateTime.fromMillis(millis, { zone: "UTC" });
    return dateTime.toISOTime(opts);
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
   * @return {string}
   */
  toString() {
    return this.toISO();
  }
  /**
   * Returns a string representation of this Duration appropriate for the REPL.
   * @return {string}
   */
  [/* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom")]() {
    if (this.isValid) {
      return `Duration { values: ${JSON.stringify(this.values)} }`;
    } else {
      return `Duration { Invalid, reason: ${this.invalidReason} }`;
    }
  }
  /**
   * Returns an milliseconds value of this Duration.
   * @return {number}
   */
  toMillis() {
    if (!this.isValid) return NaN;
    return durationToMillis(this.matrix, this.values);
  }
  /**
   * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  plus(duration) {
    if (!this.isValid) return this;
    const dur = Duration.fromDurationLike(duration), result2 = {};
    for (const k of orderedUnits$1) {
      if (hasOwnProperty(dur.values, k) || hasOwnProperty(this.values, k)) {
        result2[k] = dur.get(k) + this.get(k);
      }
    }
    return clone$1(this, { values: result2 }, true);
  }
  /**
   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  minus(duration) {
    if (!this.isValid) return this;
    const dur = Duration.fromDurationLike(duration);
    return this.plus(dur.negate());
  }
  /**
   * Scale this Duration by the specified amount. Return a newly-constructed Duration.
   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
   * @return {Duration}
   */
  mapUnits(fn2) {
    if (!this.isValid) return this;
    const result2 = {};
    for (const k of Object.keys(this.values)) {
      result2[k] = asNumber(fn2(this.values[k], k));
    }
    return clone$1(this, { values: result2 }, true);
  }
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
   * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
   * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
   * @return {number}
   */
  get(unit) {
    return this[Duration.normalizeUnit(unit)];
  }
  /**
   * "Set" the values of specified units. Return a newly-constructed Duration.
   * @param {Object} values - a mapping of units to numbers
   * @example dur.set({ years: 2017 })
   * @example dur.set({ hours: 8, minutes: 30 })
   * @return {Duration}
   */
  set(values) {
    if (!this.isValid) return this;
    const mixed = { ...this.values, ...normalizeObject(values, Duration.normalizeUnit) };
    return clone$1(this, { values: mixed });
  }
  /**
   * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
   * @example dur.reconfigure({ locale: 'en-GB' })
   * @return {Duration}
   */
  reconfigure({ locale, numberingSystem, conversionAccuracy, matrix } = {}) {
    const loc = this.loc.clone({ locale, numberingSystem });
    const opts = { loc, matrix, conversionAccuracy };
    return clone$1(this, opts);
  }
  /**
   * Return the length of the duration in the specified unit.
   * @param {string} unit - a unit such as 'minutes' or 'days'
   * @example Duration.fromObject({years: 1}).as('days') //=> 365
   * @example Duration.fromObject({years: 1}).as('months') //=> 12
   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
   * @return {number}
   */
  as(unit) {
    return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
  }
  /**
   * Reduce this Duration to its canonical representation in its current units.
   * Assuming the overall value of the Duration is positive, this means:
   * - excessive values for lower-order units are converted to higher-order units (if possible, see first and second example)
   * - negative lower-order units are converted to higher order units (there must be such a higher order unit, otherwise
   *   the overall value would be negative, see third example)
   * - fractional values for higher-order units are converted to lower-order units (if possible, see fourth example)
   *
   * If the overall value is negative, the result of this method is equivalent to `this.negate().normalize().negate()`.
   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
   * @example Duration.fromObject({ days: 5000 }).normalize().toObject() //=> { days: 5000 }
   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
   * @example Duration.fromObject({ years: 2.5, days: 0, hours: 0 }).normalize().toObject() //=> { years: 2, days: 182, hours: 12 }
   * @return {Duration}
   */
  normalize() {
    if (!this.isValid) return this;
    const vals = this.toObject();
    normalizeValues(this.matrix, vals);
    return clone$1(this, { values: vals }, true);
  }
  /**
   * Rescale units to its largest representation
   * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
   * @return {Duration}
   */
  rescale() {
    if (!this.isValid) return this;
    const vals = removeZeroes(this.normalize().shiftToAll().toObject());
    return clone$1(this, { values: vals }, true);
  }
  /**
   * Convert this Duration into its representation in a different set of units.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
   * @return {Duration}
   */
  shiftTo(...units) {
    if (!this.isValid) return this;
    if (units.length === 0) {
      return this;
    }
    units = units.map((u) => Duration.normalizeUnit(u));
    const built = {}, accumulated = {}, vals = this.toObject();
    let lastUnit;
    for (const k of orderedUnits$1) {
      if (units.indexOf(k) >= 0) {
        lastUnit = k;
        let own = 0;
        for (const ak in accumulated) {
          own += this.matrix[ak][k] * accumulated[ak];
          accumulated[ak] = 0;
        }
        if (isNumber(vals[k])) {
          own += vals[k];
        }
        const i = Math.trunc(own);
        built[k] = i;
        accumulated[k] = (own * 1e3 - i * 1e3) / 1e3;
      } else if (isNumber(vals[k])) {
        accumulated[k] = vals[k];
      }
    }
    for (const key in accumulated) {
      if (accumulated[key] !== 0) {
        built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
      }
    }
    normalizeValues(this.matrix, built);
    return clone$1(this, { values: built }, true);
  }
  /**
   * Shift this Duration to all available units.
   * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
   * @return {Duration}
   */
  shiftToAll() {
    if (!this.isValid) return this;
    return this.shiftTo(
      "years",
      "months",
      "weeks",
      "days",
      "hours",
      "minutes",
      "seconds",
      "milliseconds"
    );
  }
  /**
   * Return the negative of this Duration.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
   * @return {Duration}
   */
  negate() {
    if (!this.isValid) return this;
    const negated = {};
    for (const k of Object.keys(this.values)) {
      negated[k] = this.values[k] === 0 ? 0 : -this.values[k];
    }
    return clone$1(this, { values: negated }, true);
  }
  /**
   * Removes all units with values equal to 0 from this Duration.
   * @example Duration.fromObject({ years: 2, days: 0, hours: 0, minutes: 0 }).removeZeros().toObject() //=> { years: 2 }
   * @return {Duration}
   */
  removeZeros() {
    if (!this.isValid) return this;
    const vals = removeZeroes(this.values);
    return clone$1(this, { values: vals }, true);
  }
  /**
   * Get the years.
   * @type {number}
   */
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  /**
   * Get the quarters.
   * @type {number}
   */
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  /**
   * Get the months.
   * @type {number}
   */
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  /**
   * Get the weeks
   * @type {number}
   */
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  /**
   * Get the days.
   * @type {number}
   */
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  /**
   * Get the hours.
   * @type {number}
   */
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  /**
   * Get the minutes.
   * @type {number}
   */
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  /**
   * Get the seconds.
   * @return {number}
   */
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  /**
   * Get the milliseconds.
   * @return {number}
   */
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  /**
   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
   * on invalid DateTimes or Intervals.
   * @return {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this Duration became invalid, or null if the Duration is valid
   * @return {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Equality check
   * Two Durations are equal iff they have the same units and the same values for each unit.
   * @param {Duration} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    if (!this.loc.equals(other.loc)) {
      return false;
    }
    function eq2(v1, v2) {
      if (v1 === void 0 || v1 === 0) return v2 === void 0 || v2 === 0;
      return v1 === v2;
    }
    for (const u of orderedUnits$1) {
      if (!eq2(this.values[u], other.values[u])) {
        return false;
      }
    }
    return true;
  }
}
const INVALID$1 = "Invalid Interval";
function validateStartEnd(start, end) {
  if (!start || !start.isValid) {
    return Interval.invalid("missing or invalid start");
  } else if (!end || !end.isValid) {
    return Interval.invalid("missing or invalid end");
  } else if (end < start) {
    return Interval.invalid(
      "end before start",
      `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`
    );
  } else {
    return null;
  }
}
class Interval {
  /**
   * @private
   */
  constructor(config2) {
    this.s = config2.start;
    this.e = config2.end;
    this.invalid = config2.invalid || null;
    this.isLuxonInterval = true;
  }
  /**
   * Create an invalid Interval.
   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Interval}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidIntervalError(invalid);
    } else {
      return new Interval({ invalid });
    }
  }
  /**
   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
   * @param {DateTime|Date|Object} start
   * @param {DateTime|Date|Object} end
   * @return {Interval}
   */
  static fromDateTimes(start, end) {
    const builtStart = friendlyDateTime(start), builtEnd = friendlyDateTime(end);
    const validateError = validateStartEnd(builtStart, builtEnd);
    if (validateError == null) {
      return new Interval({
        start: builtStart,
        end: builtEnd
      });
    } else {
      return validateError;
    }
  }
  /**
   * Create an Interval from a start DateTime and a Duration to extend to.
   * @param {DateTime|Date|Object} start
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static after(start, duration) {
    const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(start);
    return Interval.fromDateTimes(dt, dt.plus(dur));
  }
  /**
   * Create an Interval from an end DateTime and a Duration to extend backwards to.
   * @param {DateTime|Date|Object} end
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static before(end, duration) {
    const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(end);
    return Interval.fromDateTimes(dt.minus(dur), dt);
  }
  /**
   * Create an Interval from an ISO 8601 string.
   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
   * @param {string} text - the ISO string to parse
   * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {Interval}
   */
  static fromISO(text2, opts) {
    const [s2, e2] = (text2 || "").split("/", 2);
    if (s2 && e2) {
      let start, startIsValid;
      try {
        start = DateTime.fromISO(s2, opts);
        startIsValid = start.isValid;
      } catch (e3) {
        startIsValid = false;
      }
      let end, endIsValid;
      try {
        end = DateTime.fromISO(e2, opts);
        endIsValid = end.isValid;
      } catch (e3) {
        endIsValid = false;
      }
      if (startIsValid && endIsValid) {
        return Interval.fromDateTimes(start, end);
      }
      if (startIsValid) {
        const dur = Duration.fromISO(e2, opts);
        if (dur.isValid) {
          return Interval.after(start, dur);
        }
      } else if (endIsValid) {
        const dur = Duration.fromISO(s2, opts);
        if (dur.isValid) {
          return Interval.before(end, dur);
        }
      }
    }
    return Interval.invalid("unparsable", `the input "${text2}" can't be parsed as ISO 8601`);
  }
  /**
   * Check if an object is an Interval. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isInterval(o2) {
    return o2 && o2.isLuxonInterval || false;
  }
  /**
   * Returns the start of the Interval
   * @type {DateTime}
   */
  get start() {
    return this.isValid ? this.s : null;
  }
  /**
   * Returns the end of the Interval. This is the first instant which is not part of the interval
   * (Interval is half-open).
   * @type {DateTime}
   */
  get end() {
    return this.isValid ? this.e : null;
  }
  /**
   * Returns the last DateTime included in the interval (since end is not part of the interval)
   * @type {DateTime}
   */
  get lastDateTime() {
    return this.isValid ? this.e ? this.e.minus(1) : null : null;
  }
  /**
   * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
   * @type {boolean}
   */
  get isValid() {
    return this.invalidReason === null;
  }
  /**
   * Returns an error code if this Interval is invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Returns the length of the Interval in the specified unit.
   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
   * @return {number}
   */
  length(unit = "milliseconds") {
    return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
  }
  /**
   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
   * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
   * @param {string} [unit='milliseconds'] - the unit of time to count.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; this operation will always use the locale of the start DateTime
   * @return {number}
   */
  count(unit = "milliseconds", opts) {
    if (!this.isValid) return NaN;
    const start = this.start.startOf(unit, opts);
    let end;
    if (opts?.useLocaleWeeks) {
      end = this.end.reconfigure({ locale: start.locale });
    } else {
      end = this.end;
    }
    end = end.startOf(unit, opts);
    return Math.floor(end.diff(start, unit).get(unit)) + (end.valueOf() !== this.end.valueOf());
  }
  /**
   * Returns whether this Interval's start and end are both in the same unit of time
   * @param {string} unit - the unit of time to check sameness on
   * @return {boolean}
   */
  hasSame(unit) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
  }
  /**
   * Return whether this Interval has the same start and end DateTimes.
   * @return {boolean}
   */
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  /**
   * Return whether this Interval's start is after the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isAfter(dateTime) {
    if (!this.isValid) return false;
    return this.s > dateTime;
  }
  /**
   * Return whether this Interval's end is before the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isBefore(dateTime) {
    if (!this.isValid) return false;
    return this.e <= dateTime;
  }
  /**
   * Return whether this Interval contains the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  contains(dateTime) {
    if (!this.isValid) return false;
    return this.s <= dateTime && this.e > dateTime;
  }
  /**
   * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
   * @param {Object} values - the values to set
   * @param {DateTime} values.start - the starting DateTime
   * @param {DateTime} values.end - the ending DateTime
   * @return {Interval}
   */
  set({ start, end } = {}) {
    if (!this.isValid) return this;
    return Interval.fromDateTimes(start || this.s, end || this.e);
  }
  /**
   * Split this Interval at each of the specified DateTimes
   * @param {...DateTime} dateTimes - the unit of time to count.
   * @return {Array}
   */
  splitAt(...dateTimes) {
    if (!this.isValid) return [];
    const sorted = dateTimes.map(friendlyDateTime).filter((d) => this.contains(d)).sort((a, b) => a.toMillis() - b.toMillis()), results = [];
    let { s: s2 } = this, i = 0;
    while (s2 < this.e) {
      const added = sorted[i] || this.e, next2 = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s2, next2));
      s2 = next2;
      i += 1;
    }
    return results;
  }
  /**
   * Split this Interval into smaller Intervals, each of the specified length.
   * Left over time is grouped into a smaller interval
   * @param {Duration|Object|number} duration - The length of each resulting interval.
   * @return {Array}
   */
  splitBy(duration) {
    const dur = Duration.fromDurationLike(duration);
    if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
      return [];
    }
    let { s: s2 } = this, idx = 1, next2;
    const results = [];
    while (s2 < this.e) {
      const added = this.start.plus(dur.mapUnits((x) => x * idx));
      next2 = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s2, next2));
      s2 = next2;
      idx += 1;
    }
    return results;
  }
  /**
   * Split this Interval into the specified number of smaller intervals.
   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
   * @return {Array}
   */
  divideEqually(numberOfParts) {
    if (!this.isValid) return [];
    return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
  }
  /**
   * Return whether this Interval overlaps with the specified Interval
   * @param {Interval} other
   * @return {boolean}
   */
  overlaps(other) {
    return this.e > other.s && this.s < other.e;
  }
  /**
   * Return whether this Interval's end is adjacent to the specified Interval's start.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsStart(other) {
    if (!this.isValid) return false;
    return +this.e === +other.s;
  }
  /**
   * Return whether this Interval's start is adjacent to the specified Interval's end.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsEnd(other) {
    if (!this.isValid) return false;
    return +other.e === +this.s;
  }
  /**
   * Returns true if this Interval fully contains the specified Interval, specifically if the intersect (of this Interval and the other Interval) is equal to the other Interval; false otherwise.
   * @param {Interval} other
   * @return {boolean}
   */
  engulfs(other) {
    if (!this.isValid) return false;
    return this.s <= other.s && this.e >= other.e;
  }
  /**
   * Return whether this Interval has the same start and end as the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    return this.s.equals(other.s) && this.e.equals(other.e);
  }
  /**
   * Return an Interval representing the intersection of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
   * Returns null if the intersection is empty, meaning, the intervals don't intersect.
   * @param {Interval} other
   * @return {Interval}
   */
  intersection(other) {
    if (!this.isValid) return this;
    const s2 = this.s > other.s ? this.s : other.s, e2 = this.e < other.e ? this.e : other.e;
    if (s2 >= e2) {
      return null;
    } else {
      return Interval.fromDateTimes(s2, e2);
    }
  }
  /**
   * Return an Interval representing the union of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
   * @param {Interval} other
   * @return {Interval}
   */
  union(other) {
    if (!this.isValid) return this;
    const s2 = this.s < other.s ? this.s : other.s, e2 = this.e > other.e ? this.e : other.e;
    return Interval.fromDateTimes(s2, e2);
  }
  /**
   * Merge an array of Intervals into an equivalent minimal set of Intervals.
   * Combines overlapping and adjacent Intervals.
   * The resulting array will contain the Intervals in ascending order, that is, starting with the earliest Interval
   * and ending with the latest.
   *
   * @param {Array} intervals
   * @return {Array}
   */
  static merge(intervals) {
    const [found, final] = intervals.sort((a, b) => a.s - b.s).reduce(
      ([sofar, current], item) => {
        if (!current) {
          return [sofar, item];
        } else if (current.overlaps(item) || current.abutsStart(item)) {
          return [sofar, current.union(item)];
        } else {
          return [sofar.concat([current]), item];
        }
      },
      [[], null]
    );
    if (final) {
      found.push(final);
    }
    return found;
  }
  /**
   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static xor(intervals) {
    let start = null, currentCount = 0;
    const results = [], ends = intervals.map((i) => [
      { time: i.s, type: "s" },
      { time: i.e, type: "e" }
    ]), flattened = Array.prototype.concat(...ends), arr = flattened.sort((a, b) => a.time - b.time);
    for (const i of arr) {
      currentCount += i.type === "s" ? 1 : -1;
      if (currentCount === 1) {
        start = i.time;
      } else {
        if (start && +start !== +i.time) {
          results.push(Interval.fromDateTimes(start, i.time));
        }
        start = null;
      }
    }
    return Interval.merge(results);
  }
  /**
   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
   * @param {...Interval} intervals
   * @return {Array}
   */
  difference(...intervals) {
    return Interval.xor([this].concat(intervals)).map((i) => this.intersection(i)).filter((i) => i && !i.isEmpty());
  }
  /**
   * Returns a string representation of this Interval appropriate for debugging.
   * @return {string}
   */
  toString() {
    if (!this.isValid) return INVALID$1;
    return `[${this.s.toISO()}  ${this.e.toISO()})`;
  }
  /**
   * Returns a string representation of this Interval appropriate for the REPL.
   * @return {string}
   */
  [/* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom")]() {
    if (this.isValid) {
      return `Interval { start: ${this.s.toISO()}, end: ${this.e.toISO()} }`;
    } else {
      return `Interval { Invalid, reason: ${this.invalidReason} }`;
    }
  }
  /**
   * Returns a localized string representing this Interval. Accepts the same options as the
   * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
   * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
   * is browser-specific, but in general it will return an appropriate representation of the
   * Interval in the assigned locale. Defaults to the system's locale if no locale has been
   * specified.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
   * Intl.DateTimeFormat constructor options.
   * @param {Object} opts - Options to override the configuration of the start DateTime.
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022  11/8/2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7  8, 2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 78 novembre 2022
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00  8:00 PM
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00  8:00 p
   * @return {string}
   */
  toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
    return this.isValid ? Formatter.create(this.s.loc.clone(opts), formatOpts).formatInterval(this) : INVALID$1;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Interval.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISO(opts) {
    if (!this.isValid) return INVALID$1;
    return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
  }
  /**
   * Returns an ISO 8601-compliant string representation of date of this Interval.
   * The time components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {string}
   */
  toISODate() {
    if (!this.isValid) return INVALID$1;
    return `${this.s.toISODate()}/${this.e.toISODate()}`;
  }
  /**
   * Returns an ISO 8601-compliant string representation of time of this Interval.
   * The date components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISOTime(opts) {
    if (!this.isValid) return INVALID$1;
    return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
  }
  /**
   * Returns a string representation of this Interval formatted according to the specified format
   * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
   * formatting tool.
   * @param {string} dateFormat - The format string. This string formats the start and end time.
   * See {@link DateTime#toFormat} for details.
   * @param {Object} opts - Options.
   * @param {string} [opts.separator =  '  '] - A separator to place between the start and end
   * representations.
   * @return {string}
   */
  toFormat(dateFormat, { separator = "  " } = {}) {
    if (!this.isValid) return INVALID$1;
    return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
  }
  /**
   * Return a Duration representing the time spanned by this interval.
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
   * @return {Duration}
   */
  toDuration(unit, opts) {
    if (!this.isValid) {
      return Duration.invalid(this.invalidReason);
    }
    return this.e.diff(this.s, unit, opts);
  }
  /**
   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
   * @param {function} mapFn
   * @return {Interval}
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
   */
  mapEndpoints(mapFn) {
    return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
  }
}
class Info {
  /**
   * Return whether the specified zone contains a DST.
   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
   * @return {boolean}
   */
  static hasDST(zone = Settings.defaultZone) {
    const proto2 = DateTime.now().setZone(zone).set({ month: 12 });
    return !zone.isUniversal && proto2.offset !== proto2.set({ month: 6 }).offset;
  }
  /**
   * Return whether the specified zone is a valid IANA specifier.
   * @param {string} zone - Zone to check
   * @return {boolean}
   */
  static isValidIANAZone(zone) {
    return IANAZone.isValidZone(zone);
  }
  /**
   * Converts the input into a {@link Zone} instance.
   *
   * * If `input` is already a Zone instance, it is returned unchanged.
   * * If `input` is a string containing a valid time zone name, a Zone instance
   *   with that name is returned.
   * * If `input` is a string that doesn't refer to a known time zone, a Zone
   *   instance with {@link Zone#isValid} == false is returned.
   * * If `input is a number, a Zone instance with the specified fixed offset
   *   in minutes is returned.
   * * If `input` is `null` or `undefined`, the default zone is returned.
   * @param {string|Zone|number} [input] - the value to be converted
   * @return {Zone}
   */
  static normalizeZone(input) {
    return normalizeZone(input, Settings.defaultZone);
  }
  /**
   * Get the weekday on which the week starts according to the given locale.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number} the start of the week, 1 for Monday through 7 for Sunday
   */
  static getStartOfWeek({ locale = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale)).getStartOfWeek();
  }
  /**
   * Get the minimum number of days necessary in a week before it is considered part of the next year according
   * to the given locale.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number}
   */
  static getMinimumDaysInFirstWeek({ locale = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale)).getMinDaysInFirstWeek();
  }
  /**
   * Get the weekdays, which are considered the weekend according to the given locale
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number[]} an array of weekdays, 1 for Monday through 7 for Sunday
   */
  static getWeekendWeekdays({ locale = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale)).getWeekendDays().slice();
  }
  /**
   * Return an array of standalone month names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @example Info.months()[0] //=> 'January'
   * @example Info.months('short')[0] //=> 'Jan'
   * @example Info.months('numeric')[0] //=> '1'
   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
   * @example Info.months('numeric', { locale: 'ar' })[0] //=> ''
   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabi I'
   * @return {Array}
   */
  static months(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length);
  }
  /**
   * Return an array of format month names.
   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
   * changes the string.
   * See {@link Info#months}
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @return {Array}
   */
  static monthsFormat(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length, true);
  }
  /**
   * Return an array of standalone week names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @example Info.weekdays()[0] //=> 'Monday'
   * @example Info.weekdays('short')[0] //=> 'Mon'
   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> ''
   * @return {Array}
   */
  static weekdays(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length);
  }
  /**
   * Return an array of format week names.
   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
   * changes the string.
   * See {@link Info#weekdays}
   * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale=null] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @return {Array}
   */
  static weekdaysFormat(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length, true);
  }
  /**
   * Return an array of meridiems.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.meridiems() //=> [ 'AM', 'PM' ]
   * @example Info.meridiems({ locale: 'my' }) //=> [ '', '' ]
   * @return {Array}
   */
  static meridiems({ locale = null } = {}) {
    return Locale.create(locale).meridiems();
  }
  /**
   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
   * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.eras() //=> [ 'BC', 'AD' ]
   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jsus-Christ', 'aprs Jsus-Christ' ]
   * @return {Array}
   */
  static eras(length = "short", { locale = null } = {}) {
    return Locale.create(locale, null, "gregory").eras(length);
  }
  /**
   * Return the set of available features in this environment.
   * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
   * Keys:
   * * `relative`: whether this environment supports relative time formatting
   * * `localeWeek`: whether this environment supports different weekdays for the start of the week based on the locale
   * @example Info.features() //=> { relative: false, localeWeek: true }
   * @return {Object}
   */
  static features() {
    return { relative: hasRelative(), localeWeek: hasLocaleWeekInfo() };
  }
}
function dayDiff(earlier, later) {
  const utcDayStart = (dt) => dt.toUTC(0, { keepLocalTime: true }).startOf("day").valueOf(), ms2 = utcDayStart(later) - utcDayStart(earlier);
  return Math.floor(Duration.fromMillis(ms2).as("days"));
}
function highOrderDiffs(cursor, later, units) {
  const differs = [
    ["years", (a, b) => b.year - a.year],
    ["quarters", (a, b) => b.quarter - a.quarter + (b.year - a.year) * 4],
    ["months", (a, b) => b.month - a.month + (b.year - a.year) * 12],
    [
      "weeks",
      (a, b) => {
        const days = dayDiff(a, b);
        return (days - days % 7) / 7;
      }
    ],
    ["days", dayDiff]
  ];
  const results = {};
  const earlier = cursor;
  let lowestOrder, highWater;
  for (const [unit, differ] of differs) {
    if (units.indexOf(unit) >= 0) {
      lowestOrder = unit;
      results[unit] = differ(cursor, later);
      highWater = earlier.plus(results);
      if (highWater > later) {
        results[unit]--;
        cursor = earlier.plus(results);
        if (cursor > later) {
          highWater = cursor;
          results[unit]--;
          cursor = earlier.plus(results);
        }
      } else {
        cursor = highWater;
      }
    }
  }
  return [cursor, results, highWater, lowestOrder];
}
function diff(earlier, later, units, opts) {
  let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);
  const remainingMillis = later - cursor;
  const lowerOrderUnits = units.filter(
    (u) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0
  );
  if (lowerOrderUnits.length === 0) {
    if (highWater < later) {
      highWater = cursor.plus({ [lowestOrder]: 1 });
    }
    if (highWater !== cursor) {
      results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
    }
  }
  const duration = Duration.fromObject(results, opts);
  if (lowerOrderUnits.length > 0) {
    return Duration.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration);
  } else {
    return duration;
  }
}
const MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
function intUnit(regex, post = (i) => i) {
  return { regex, deser: ([s2]) => post(parseDigits(s2)) };
}
const NBSP = String.fromCharCode(160);
const spaceOrNBSP = `[ ${NBSP}]`;
const spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
function fixListRegex(s2) {
  return s2.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
}
function stripInsensitivities(s2) {
  return s2.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
}
function oneOf(strings, startIndex) {
  if (strings === null) {
    return null;
  } else {
    return {
      regex: RegExp(strings.map(fixListRegex).join("|")),
      deser: ([s2]) => strings.findIndex((i) => stripInsensitivities(s2) === stripInsensitivities(i)) + startIndex
    };
  }
}
function offset(regex, groups) {
  return { regex, deser: ([, h, m]) => signedOffset(h, m), groups };
}
function simple(regex) {
  return { regex, deser: ([s2]) => s2 };
}
function escapeToken(value) {
  return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function unitForToken(token2, loc) {
  const one = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal2 = (t2) => ({ regex: RegExp(escapeToken(t2.val)), deser: ([s2]) => s2, literal: true }), unitate = (t2) => {
    if (token2.literal) {
      return literal2(t2);
    }
    switch (t2.val) {
      // era
      case "G":
        return oneOf(loc.eras("short"), 0);
      case "GG":
        return oneOf(loc.eras("long"), 0);
      // years
      case "y":
        return intUnit(oneToSix);
      case "yy":
        return intUnit(twoToFour, untruncateYear);
      case "yyyy":
        return intUnit(four);
      case "yyyyy":
        return intUnit(fourToSix);
      case "yyyyyy":
        return intUnit(six);
      // months
      case "M":
        return intUnit(oneOrTwo);
      case "MM":
        return intUnit(two);
      case "MMM":
        return oneOf(loc.months("short", true), 1);
      case "MMMM":
        return oneOf(loc.months("long", true), 1);
      case "L":
        return intUnit(oneOrTwo);
      case "LL":
        return intUnit(two);
      case "LLL":
        return oneOf(loc.months("short", false), 1);
      case "LLLL":
        return oneOf(loc.months("long", false), 1);
      // dates
      case "d":
        return intUnit(oneOrTwo);
      case "dd":
        return intUnit(two);
      // ordinals
      case "o":
        return intUnit(oneToThree);
      case "ooo":
        return intUnit(three);
      // time
      case "HH":
        return intUnit(two);
      case "H":
        return intUnit(oneOrTwo);
      case "hh":
        return intUnit(two);
      case "h":
        return intUnit(oneOrTwo);
      case "mm":
        return intUnit(two);
      case "m":
        return intUnit(oneOrTwo);
      case "q":
        return intUnit(oneOrTwo);
      case "qq":
        return intUnit(two);
      case "s":
        return intUnit(oneOrTwo);
      case "ss":
        return intUnit(two);
      case "S":
        return intUnit(oneToThree);
      case "SSS":
        return intUnit(three);
      case "u":
        return simple(oneToNine);
      case "uu":
        return simple(oneOrTwo);
      case "uuu":
        return intUnit(one);
      // meridiem
      case "a":
        return oneOf(loc.meridiems(), 0);
      // weekYear (k)
      case "kkkk":
        return intUnit(four);
      case "kk":
        return intUnit(twoToFour, untruncateYear);
      // weekNumber (W)
      case "W":
        return intUnit(oneOrTwo);
      case "WW":
        return intUnit(two);
      // weekdays
      case "E":
      case "c":
        return intUnit(one);
      case "EEE":
        return oneOf(loc.weekdays("short", false), 1);
      case "EEEE":
        return oneOf(loc.weekdays("long", false), 1);
      case "ccc":
        return oneOf(loc.weekdays("short", true), 1);
      case "cccc":
        return oneOf(loc.weekdays("long", true), 1);
      // offset/zone
      case "Z":
      case "ZZ":
        return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
      case "ZZZ":
        return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
      // we don't support ZZZZ (PST) or ZZZZZ (Pacific Standard Time) in parsing
      // because we don't have any way to figure out what they are
      case "z":
        return simple(/[a-z_+-/]{1,256}?/i);
      // this special-case "token" represents a place where a macro-token expanded into a white-space literal
      // in this case we accept any non-newline white-space
      case " ":
        return simple(/[^\S\n\r]/);
      default:
        return literal2(t2);
    }
  };
  const unit = unitate(token2) || {
    invalidReason: MISSING_FTP
  };
  unit.token = token2;
  return unit;
}
const partTypeStyleToTokenVal = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour12: {
    numeric: "h",
    "2-digit": "hh"
  },
  hour24: {
    numeric: "H",
    "2-digit": "HH"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  },
  timeZoneName: {
    long: "ZZZZZ",
    short: "ZZZ"
  }
};
function tokenForPart(part, formatOpts, resolvedOpts) {
  const { type: type2, value } = part;
  if (type2 === "literal") {
    const isSpace = /^\s+$/.test(value);
    return {
      literal: !isSpace,
      val: isSpace ? " " : value
    };
  }
  const style = formatOpts[type2];
  let actualType = type2;
  if (type2 === "hour") {
    if (formatOpts.hour12 != null) {
      actualType = formatOpts.hour12 ? "hour12" : "hour24";
    } else if (formatOpts.hourCycle != null) {
      if (formatOpts.hourCycle === "h11" || formatOpts.hourCycle === "h12") {
        actualType = "hour12";
      } else {
        actualType = "hour24";
      }
    } else {
      actualType = resolvedOpts.hour12 ? "hour12" : "hour24";
    }
  }
  let val = partTypeStyleToTokenVal[actualType];
  if (typeof val === "object") {
    val = val[style];
  }
  if (val) {
    return {
      literal: false,
      val
    };
  }
  return void 0;
}
function buildRegex(units) {
  const re = units.map((u) => u.regex).reduce((f, r2) => `${f}(${r2.source})`, "");
  return [`^${re}$`, units];
}
function match(input, regex, handlers) {
  const matches = input.match(regex);
  if (matches) {
    const all2 = {};
    let matchIndex = 1;
    for (const i in handlers) {
      if (hasOwnProperty(handlers, i)) {
        const h = handlers[i], groups = h.groups ? h.groups + 1 : 1;
        if (!h.literal && h.token) {
          all2[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));
        }
        matchIndex += groups;
      }
    }
    return [matches, all2];
  } else {
    return [matches, {}];
  }
}
function dateTimeFromMatches(matches) {
  const toField = (token2) => {
    switch (token2) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let zone = null;
  let specificOffset;
  if (!isUndefined(matches.z)) {
    zone = IANAZone.create(matches.z);
  }
  if (!isUndefined(matches.Z)) {
    if (!zone) {
      zone = new FixedOffsetZone(matches.Z);
    }
    specificOffset = matches.Z;
  }
  if (!isUndefined(matches.q)) {
    matches.M = (matches.q - 1) * 3 + 1;
  }
  if (!isUndefined(matches.h)) {
    if (matches.h < 12 && matches.a === 1) {
      matches.h += 12;
    } else if (matches.h === 12 && matches.a === 0) {
      matches.h = 0;
    }
  }
  if (matches.G === 0 && matches.y) {
    matches.y = -matches.y;
  }
  if (!isUndefined(matches.u)) {
    matches.S = parseMillis(matches.u);
  }
  const vals = Object.keys(matches).reduce((r2, k) => {
    const f = toField(k);
    if (f) {
      r2[f] = matches[k];
    }
    return r2;
  }, {});
  return [vals, zone, specificOffset];
}
let dummyDateTimeCache = null;
function getDummyDateTime() {
  if (!dummyDateTimeCache) {
    dummyDateTimeCache = DateTime.fromMillis(1555555555555);
  }
  return dummyDateTimeCache;
}
function maybeExpandMacroToken(token2, locale) {
  if (token2.literal) {
    return token2;
  }
  const formatOpts = Formatter.macroTokenToFormatOpts(token2.val);
  const tokens = formatOptsToTokens(formatOpts, locale);
  if (tokens == null || tokens.includes(void 0)) {
    return token2;
  }
  return tokens;
}
function expandMacroTokens(tokens, locale) {
  return Array.prototype.concat(...tokens.map((t2) => maybeExpandMacroToken(t2, locale)));
}
class TokenParser {
  constructor(locale, format2) {
    this.locale = locale;
    this.format = format2;
    this.tokens = expandMacroTokens(Formatter.parseFormat(format2), locale);
    this.units = this.tokens.map((t2) => unitForToken(t2, locale));
    this.disqualifyingUnit = this.units.find((t2) => t2.invalidReason);
    if (!this.disqualifyingUnit) {
      const [regexString, handlers] = buildRegex(this.units);
      this.regex = RegExp(regexString, "i");
      this.handlers = handlers;
    }
  }
  explainFromTokens(input) {
    if (!this.isValid) {
      return { input, tokens: this.tokens, invalidReason: this.invalidReason };
    } else {
      const [rawMatches, matches] = match(input, this.regex, this.handlers), [result2, zone, specificOffset] = matches ? dateTimeFromMatches(matches) : [null, null, void 0];
      if (hasOwnProperty(matches, "a") && hasOwnProperty(matches, "H")) {
        throw new ConflictingSpecificationError(
          "Can't include meridiem when specifying 24-hour format"
        );
      }
      return {
        input,
        tokens: this.tokens,
        regex: this.regex,
        rawMatches,
        matches,
        result: result2,
        zone,
        specificOffset
      };
    }
  }
  get isValid() {
    return !this.disqualifyingUnit;
  }
  get invalidReason() {
    return this.disqualifyingUnit ? this.disqualifyingUnit.invalidReason : null;
  }
}
function explainFromTokens(locale, input, format2) {
  const parser2 = new TokenParser(locale, format2);
  return parser2.explainFromTokens(input);
}
function parseFromTokens(locale, input, format2) {
  const { result: result2, zone, specificOffset, invalidReason } = explainFromTokens(locale, input, format2);
  return [result2, zone, specificOffset, invalidReason];
}
function formatOptsToTokens(formatOpts, locale) {
  if (!formatOpts) {
    return null;
  }
  const formatter = Formatter.create(locale, formatOpts);
  const df = formatter.dtFormatter(getDummyDateTime());
  const parts = df.formatToParts();
  const resolvedOpts = df.resolvedOptions();
  return parts.map((p) => tokenForPart(p, formatOpts, resolvedOpts));
}
const INVALID = "Invalid DateTime";
const MAX_DATE = 864e13;
function unsupportedZone(zone) {
  return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
}
function possiblyCachedWeekData(dt) {
  if (dt.weekData === null) {
    dt.weekData = gregorianToWeek(dt.c);
  }
  return dt.weekData;
}
function possiblyCachedLocalWeekData(dt) {
  if (dt.localWeekData === null) {
    dt.localWeekData = gregorianToWeek(
      dt.c,
      dt.loc.getMinDaysInFirstWeek(),
      dt.loc.getStartOfWeek()
    );
  }
  return dt.localWeekData;
}
function clone(inst, alts) {
  const current = {
    ts: inst.ts,
    zone: inst.zone,
    c: inst.c,
    o: inst.o,
    loc: inst.loc,
    invalid: inst.invalid
  };
  return new DateTime({ ...current, ...alts, old: current });
}
function fixOffset(localTS, o2, tz) {
  let utcGuess = localTS - o2 * 60 * 1e3;
  const o22 = tz.offset(utcGuess);
  if (o2 === o22) {
    return [utcGuess, o2];
  }
  utcGuess -= (o22 - o2) * 60 * 1e3;
  const o3 = tz.offset(utcGuess);
  if (o22 === o3) {
    return [utcGuess, o22];
  }
  return [localTS - Math.min(o22, o3) * 60 * 1e3, Math.max(o22, o3)];
}
function tsToObj(ts, offset2) {
  ts += offset2 * 60 * 1e3;
  const d = new Date(ts);
  return {
    year: d.getUTCFullYear(),
    month: d.getUTCMonth() + 1,
    day: d.getUTCDate(),
    hour: d.getUTCHours(),
    minute: d.getUTCMinutes(),
    second: d.getUTCSeconds(),
    millisecond: d.getUTCMilliseconds()
  };
}
function objToTS(obj, offset2, zone) {
  return fixOffset(objToLocalTS(obj), offset2, zone);
}
function adjustTime(inst, dur) {
  const oPre = inst.o, year2 = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c2 = {
    ...inst.c,
    year: year2,
    month,
    day: Math.min(inst.c.day, daysInMonth(year2, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
  }, millisToAdd = Duration.fromObject({
    years: dur.years - Math.trunc(dur.years),
    quarters: dur.quarters - Math.trunc(dur.quarters),
    months: dur.months - Math.trunc(dur.months),
    weeks: dur.weeks - Math.trunc(dur.weeks),
    days: dur.days - Math.trunc(dur.days),
    hours: dur.hours,
    minutes: dur.minutes,
    seconds: dur.seconds,
    milliseconds: dur.milliseconds
  }).as("milliseconds"), localTS = objToLocalTS(c2);
  let [ts, o2] = fixOffset(localTS, oPre, inst.zone);
  if (millisToAdd !== 0) {
    ts += millisToAdd;
    o2 = inst.zone.offset(ts);
  }
  return { ts, o: o2 };
}
function parseDataToDateTime(parsed, parsedZone, opts, format2, text2, specificOffset) {
  const { setZone, zone } = opts;
  if (parsed && Object.keys(parsed).length !== 0 || parsedZone) {
    const interpretationZone = parsedZone || zone, inst = DateTime.fromObject(parsed, {
      ...opts,
      zone: interpretationZone,
      specificOffset
    });
    return setZone ? inst : inst.setZone(zone);
  } else {
    return DateTime.invalid(
      new Invalid("unparsable", `the input "${text2}" can't be parsed as ${format2}`)
    );
  }
}
function toTechFormat(dt, format2, allowZ = true) {
  return dt.isValid ? Formatter.create(Locale.create("en-US"), {
    allowZ,
    forceSimple: true
  }).formatDateTimeFromString(dt, format2) : null;
}
function toISODate(o2, extended, precision) {
  const longFormat = o2.c.year > 9999 || o2.c.year < 0;
  let c2 = "";
  if (longFormat && o2.c.year >= 0) c2 += "+";
  c2 += padStart(o2.c.year, longFormat ? 6 : 4);
  if (precision === "year") return c2;
  if (extended) {
    c2 += "-";
    c2 += padStart(o2.c.month);
    if (precision === "month") return c2;
    c2 += "-";
  } else {
    c2 += padStart(o2.c.month);
    if (precision === "month") return c2;
  }
  c2 += padStart(o2.c.day);
  return c2;
}
function toISOTime(o2, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone, precision) {
  let showSeconds = !suppressSeconds || o2.c.millisecond !== 0 || o2.c.second !== 0, c2 = "";
  switch (precision) {
    case "day":
    case "month":
    case "year":
      break;
    default:
      c2 += padStart(o2.c.hour);
      if (precision === "hour") break;
      if (extended) {
        c2 += ":";
        c2 += padStart(o2.c.minute);
        if (precision === "minute") break;
        if (showSeconds) {
          c2 += ":";
          c2 += padStart(o2.c.second);
        }
      } else {
        c2 += padStart(o2.c.minute);
        if (precision === "minute") break;
        if (showSeconds) {
          c2 += padStart(o2.c.second);
        }
      }
      if (precision === "second") break;
      if (showSeconds && (!suppressMilliseconds || o2.c.millisecond !== 0)) {
        c2 += ".";
        c2 += padStart(o2.c.millisecond, 3);
      }
  }
  if (includeOffset) {
    if (o2.isOffsetFixed && o2.offset === 0 && !extendedZone) {
      c2 += "Z";
    } else if (o2.o < 0) {
      c2 += "-";
      c2 += padStart(Math.trunc(-o2.o / 60));
      c2 += ":";
      c2 += padStart(Math.trunc(-o2.o % 60));
    } else {
      c2 += "+";
      c2 += padStart(Math.trunc(o2.o / 60));
      c2 += ":";
      c2 += padStart(Math.trunc(o2.o % 60));
    }
  }
  if (extendedZone) {
    c2 += "[" + o2.zone.ianaName + "]";
  }
  return c2;
}
const defaultUnitValues = {
  month: 1,
  day: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, defaultWeekUnitValues = {
  weekNumber: 1,
  weekday: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, defaultOrdinalUnitValues = {
  ordinal: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
const orderedUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"], orderedWeekUnits = [
  "weekYear",
  "weekNumber",
  "weekday",
  "hour",
  "minute",
  "second",
  "millisecond"
], orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function normalizeUnit(unit) {
  const normalized = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[unit.toLowerCase()];
  if (!normalized) throw new InvalidUnitError(unit);
  return normalized;
}
function normalizeUnitWithLocalWeeks(unit) {
  switch (unit.toLowerCase()) {
    case "localweekday":
    case "localweekdays":
      return "localWeekday";
    case "localweeknumber":
    case "localweeknumbers":
      return "localWeekNumber";
    case "localweekyear":
    case "localweekyears":
      return "localWeekYear";
    default:
      return normalizeUnit(unit);
  }
}
function guessOffsetForZone(zone) {
  if (zoneOffsetTs === void 0) {
    zoneOffsetTs = Settings.now();
  }
  if (zone.type !== "iana") {
    return zone.offset(zoneOffsetTs);
  }
  const zoneName = zone.name;
  let offsetGuess = zoneOffsetGuessCache.get(zoneName);
  if (offsetGuess === void 0) {
    offsetGuess = zone.offset(zoneOffsetTs);
    zoneOffsetGuessCache.set(zoneName, offsetGuess);
  }
  return offsetGuess;
}
function quickDT(obj, opts) {
  const zone = normalizeZone(opts.zone, Settings.defaultZone);
  if (!zone.isValid) {
    return DateTime.invalid(unsupportedZone(zone));
  }
  const loc = Locale.fromObject(opts);
  let ts, o2;
  if (!isUndefined(obj.year)) {
    for (const u of orderedUnits) {
      if (isUndefined(obj[u])) {
        obj[u] = defaultUnitValues[u];
      }
    }
    const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
    if (invalid) {
      return DateTime.invalid(invalid);
    }
    const offsetProvis = guessOffsetForZone(zone);
    [ts, o2] = objToTS(obj, offsetProvis, zone);
  } else {
    ts = Settings.now();
  }
  return new DateTime({ ts, zone, loc, o: o2 });
}
function diffRelative(start, end, opts) {
  const round2 = isUndefined(opts.round) ? true : opts.round, rounding = isUndefined(opts.rounding) ? "trunc" : opts.rounding, format2 = (c2, unit) => {
    c2 = roundTo(c2, round2 || opts.calendary ? 0 : 2, opts.calendary ? "round" : rounding);
    const formatter = end.loc.clone(opts).relFormatter(opts);
    return formatter.format(c2, unit);
  }, differ = (unit) => {
    if (opts.calendary) {
      if (!end.hasSame(start, unit)) {
        return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);
      } else return 0;
    } else {
      return end.diff(start, unit).get(unit);
    }
  };
  if (opts.unit) {
    return format2(differ(opts.unit), opts.unit);
  }
  for (const unit of opts.units) {
    const count2 = differ(unit);
    if (Math.abs(count2) >= 1) {
      return format2(count2, unit);
    }
  }
  return format2(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
}
function lastOpts(argList) {
  let opts = {}, args;
  if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
    opts = argList[argList.length - 1];
    args = Array.from(argList).slice(0, argList.length - 1);
  } else {
    args = Array.from(argList);
  }
  return [opts, args];
}
let zoneOffsetTs;
const zoneOffsetGuessCache = /* @__PURE__ */ new Map();
class DateTime {
  /**
   * @access private
   */
  constructor(config2) {
    const zone = config2.zone || Settings.defaultZone;
    let invalid = config2.invalid || (Number.isNaN(config2.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
    this.ts = isUndefined(config2.ts) ? Settings.now() : config2.ts;
    let c2 = null, o2 = null;
    if (!invalid) {
      const unchanged = config2.old && config2.old.ts === this.ts && config2.old.zone.equals(zone);
      if (unchanged) {
        [c2, o2] = [config2.old.c, config2.old.o];
      } else {
        const ot = isNumber(config2.o) && !config2.old ? config2.o : zone.offset(this.ts);
        c2 = tsToObj(this.ts, ot);
        invalid = Number.isNaN(c2.year) ? new Invalid("invalid input") : null;
        c2 = invalid ? null : c2;
        o2 = invalid ? null : ot;
      }
    }
    this._zone = zone;
    this.loc = config2.loc || Locale.create();
    this.invalid = invalid;
    this.weekData = null;
    this.localWeekData = null;
    this.c = c2;
    this.o = o2;
    this.isLuxonDateTime = true;
  }
  // CONSTRUCT
  /**
   * Create a DateTime for the current instant, in the system's time zone.
   *
   * Use Settings to override these default values if needed.
   * @example DateTime.now().toISO() //~> now in the ISO format
   * @return {DateTime}
   */
  static now() {
    return new DateTime({});
  }
  /**
   * Create a local DateTime
   * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month, 1-indexed
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @example DateTime.local()                                  //~> now
   * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
   * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
   * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
   * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
   * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
   * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
   * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
   * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
   * @return {DateTime}
   */
  static local() {
    const [opts, args] = lastOpts(arguments), [year2, month, day2, hour2, minute2, second, millisecond] = args;
    return quickDT({ year: year2, month, day: day2, hour: hour2, minute: minute2, second, millisecond }, opts);
  }
  /**
   * Create a DateTime in UTC
   * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @param {Object} options - configuration options for the DateTime
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @param {string} [options.weekSettings] - the week settings to set on the resulting DateTime instance
   * @example DateTime.utc()                                              //~> now
   * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
   * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
   * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
   * @return {DateTime}
   */
  static utc() {
    const [opts, args] = lastOpts(arguments), [year2, month, day2, hour2, minute2, second, millisecond] = args;
    opts.zone = FixedOffsetZone.utcInstance;
    return quickDT({ year: year2, month, day: day2, hour: hour2, minute: minute2, second, millisecond }, opts);
  }
  /**
   * Create a DateTime from a JavaScript Date object. Uses the default zone.
   * @param {Date} date - a JavaScript Date object
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @return {DateTime}
   */
  static fromJSDate(date2, options = {}) {
    const ts = isDate(date2) ? date2.valueOf() : NaN;
    if (Number.isNaN(ts)) {
      return DateTime.invalid("invalid input");
    }
    const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }
    return new DateTime({
      ts,
      zone: zoneToUse,
      loc: Locale.fromObject(options)
    });
  }
  /**
   * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} milliseconds - a number of milliseconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} options.weekSettings - the week settings to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromMillis(milliseconds, options = {}) {
    if (!isNumber(milliseconds)) {
      throw new InvalidArgumentError(
        `fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`
      );
    } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
      return DateTime.invalid("Timestamp out of range");
    } else {
      return new DateTime({
        ts: milliseconds,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }
  /**
   * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} seconds - a number of seconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} options.weekSettings - the week settings to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromSeconds(seconds, options = {}) {
    if (!isNumber(seconds)) {
      throw new InvalidArgumentError("fromSeconds requires a numerical input");
    } else {
      return new DateTime({
        ts: seconds * 1e3,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }
  /**
   * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.year - a year, such as 1987
   * @param {number} obj.month - a month, 1-12
   * @param {number} obj.day - a day of the month, 1-31, depending on the month
   * @param {number} obj.ordinal - day of the year, 1-365 or 366
   * @param {number} obj.weekYear - an ISO week year
   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
   * @param {number} obj.localWeekYear - a week year, according to the locale
   * @param {number} obj.localWeekNumber - a week number, between 1 and 52 or 53, depending on the year, according to the locale
   * @param {number} obj.localWeekday - a weekday, 1-7, where 1 is the first and 7 is the last day of the week, according to the locale
   * @param {number} obj.hour - hour of the day, 0-23
   * @param {number} obj.minute - minute of the hour, 0-59
   * @param {number} obj.second - second of the minute, 0-59
   * @param {number} obj.millisecond - millisecond of the second, 0-999
   * @param {Object} opts - options for creating this DateTime
   * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
   * @param {string} [opts.locale='system\'s locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
   * @example DateTime.fromObject({ localWeekYear: 2022, localWeekNumber: 1, localWeekday: 1 }, { locale: "en-US" }).toISODate() //=> '2021-12-26'
   * @return {DateTime}
   */
  static fromObject(obj, opts = {}) {
    obj = obj || {};
    const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }
    const loc = Locale.fromObject(opts);
    const normalized = normalizeObject(obj, normalizeUnitWithLocalWeeks);
    const { minDaysInFirstWeek, startOfWeek } = usesLocalWeekValues(normalized, loc);
    const tsNow = Settings.now(), offsetProvis = !isUndefined(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
    let units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
    if (useWeekData) {
      units = orderedWeekUnits;
      defaultValues = defaultWeekUnitValues;
      objNow = gregorianToWeek(objNow, minDaysInFirstWeek, startOfWeek);
    } else if (containsOrdinal) {
      units = orderedOrdinalUnits;
      defaultValues = defaultOrdinalUnitValues;
      objNow = gregorianToOrdinal(objNow);
    } else {
      units = orderedUnits;
      defaultValues = defaultUnitValues;
    }
    let foundFirst = false;
    for (const u of units) {
      const v = normalized[u];
      if (!isUndefined(v)) {
        foundFirst = true;
      } else if (foundFirst) {
        normalized[u] = defaultValues[u];
      } else {
        normalized[u] = objNow[u];
      }
    }
    const higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized, minDaysInFirstWeek, startOfWeek) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
    if (invalid) {
      return DateTime.invalid(invalid);
    }
    const gregorian = useWeekData ? weekToGregorian(normalized, minDaysInFirstWeek, startOfWeek) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse), inst = new DateTime({
      ts: tsFinal,
      zone: zoneToUse,
      o: offsetFinal,
      loc
    });
    if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
      return DateTime.invalid(
        "mismatched weekday",
        `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`
      );
    }
    if (!inst.isValid) {
      return DateTime.invalid(inst.invalid);
    }
    return inst;
  }
  /**
   * Create a DateTime from an ISO 8601 string
   * @param {string} text - the ISO string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @param {string} [opts.weekSettings] - the week settings to set on the resulting DateTime instance
   * @example DateTime.fromISO('2016-05-25T09:08:34.123')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
   * @example DateTime.fromISO('2016-W05-4')
   * @return {DateTime}
   */
  static fromISO(text2, opts = {}) {
    const [vals, parsedZone] = parseISODate$1(text2);
    return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text2);
  }
  /**
   * Create a DateTime from an RFC 2822 string
   * @param {string} text - the RFC 2822 string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
   * @return {DateTime}
   */
  static fromRFC2822(text2, opts = {}) {
    const [vals, parsedZone] = parseRFC2822Date(text2);
    return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text2);
  }
  /**
   * Create a DateTime from an HTTP header date
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @param {string} text - the HTTP header date
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
   * @return {DateTime}
   */
  static fromHTTP(text2, opts = {}) {
    const [vals, parsedZone] = parseHTTPDate(text2);
    return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
  }
  /**
   * Create a DateTime from an input string and format string.
   * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromFormat(text2, fmt2, opts = {}) {
    if (isUndefined(text2) || isUndefined(fmt2)) {
      throw new InvalidArgumentError("fromFormat requires an input string and a format");
    }
    const { locale = null, numberingSystem = null } = opts, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    }), [vals, parsedZone, specificOffset, invalid] = parseFromTokens(localeToUse, text2, fmt2);
    if (invalid) {
      return DateTime.invalid(invalid);
    } else {
      return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt2}`, text2, specificOffset);
    }
  }
  /**
   * @deprecated use fromFormat instead
   */
  static fromString(text2, fmt2, opts = {}) {
    return DateTime.fromFormat(text2, fmt2, opts);
  }
  /**
   * Create a DateTime from a SQL date, time, or datetime
   * Defaults to en-US if no locale has been specified, regardless of the system's locale
   * @param {string} text - the string to parse
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @example DateTime.fromSQL('2017-05-15')
   * @example DateTime.fromSQL('2017-05-15 09:12:34')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
   * @example DateTime.fromSQL('09:12:34.342')
   * @return {DateTime}
   */
  static fromSQL(text2, opts = {}) {
    const [vals, parsedZone] = parseSQL(text2);
    return parseDataToDateTime(vals, parsedZone, opts, "SQL", text2);
  }
  /**
   * Create an invalid DateTime.
   * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent.
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {DateTime}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDateTimeError(invalid);
    } else {
      return new DateTime({ invalid });
    }
  }
  /**
   * Check if an object is an instance of DateTime. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDateTime(o2) {
    return o2 && o2.isLuxonDateTime || false;
  }
  /**
   * Produce the format string for a set of options
   * @param formatOpts
   * @param localeOpts
   * @returns {string}
   */
  static parseFormatForOpts(formatOpts, localeOpts = {}) {
    const tokenList = formatOptsToTokens(formatOpts, Locale.fromObject(localeOpts));
    return !tokenList ? null : tokenList.map((t2) => t2 ? t2.val : null).join("");
  }
  /**
   * Produce the the fully expanded format token for the locale
   * Does NOT quote characters, so quoted tokens will not round trip correctly
   * @param fmt
   * @param localeOpts
   * @returns {string}
   */
  static expandFormat(fmt2, localeOpts = {}) {
    const expanded = expandMacroTokens(Formatter.parseFormat(fmt2), Locale.fromObject(localeOpts));
    return expanded.map((t2) => t2.val).join("");
  }
  static resetCache() {
    zoneOffsetTs = void 0;
    zoneOffsetGuessCache.clear();
  }
  // INFO
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
   * @return {number}
   */
  get(unit) {
    return this[unit];
  }
  /**
   * Returns whether the DateTime is valid. Invalid DateTimes occur when:
   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
   * * The DateTime was created by an operation on another invalid date
   * @type {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
   *
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
   *
   * @type {string}
   */
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }
  /**
   * Get the time zone associated with this DateTime.
   * @type {Zone}
   */
  get zone() {
    return this._zone;
  }
  /**
   * Get the name of the time zone.
   * @type {string}
   */
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }
  /**
   * Get the year
   * @example DateTime.local(2017, 5, 25).year //=> 2017
   * @type {number}
   */
  get year() {
    return this.isValid ? this.c.year : NaN;
  }
  /**
   * Get the quarter
   * @example DateTime.local(2017, 5, 25).quarter //=> 2
   * @type {number}
   */
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }
  /**
   * Get the month (1-12).
   * @example DateTime.local(2017, 5, 25).month //=> 5
   * @type {number}
   */
  get month() {
    return this.isValid ? this.c.month : NaN;
  }
  /**
   * Get the day of the month (1-30ish).
   * @example DateTime.local(2017, 5, 25).day //=> 25
   * @type {number}
   */
  get day() {
    return this.isValid ? this.c.day : NaN;
  }
  /**
   * Get the hour of the day (0-23).
   * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
   * @type {number}
   */
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }
  /**
   * Get the minute of the hour (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
   * @type {number}
   */
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }
  /**
   * Get the second of the minute (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
   * @type {number}
   */
  get second() {
    return this.isValid ? this.c.second : NaN;
  }
  /**
   * Get the millisecond of the second (0-999).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
   * @type {number}
   */
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }
  /**
   * Get the week year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
   * @type {number}
   */
  get weekYear() {
    return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
  }
  /**
   * Get the week number of the week year (1-52ish).
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
   * @type {number}
   */
  get weekNumber() {
    return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
  }
  /**
   * Get the day of the week.
   * 1 is Monday and 7 is Sunday
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 11, 31).weekday //=> 4
   * @type {number}
   */
  get weekday() {
    return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
  }
  /**
   * Returns true if this date is on a weekend according to the locale, false otherwise
   * @returns {boolean}
   */
  get isWeekend() {
    return this.isValid && this.loc.getWeekendDays().includes(this.weekday);
  }
  /**
   * Get the day of the week according to the locale.
   * 1 is the first day of the week and 7 is the last day of the week.
   * If the locale assigns Sunday as the first day of the week, then a date which is a Sunday will return 1,
   * @returns {number}
   */
  get localWeekday() {
    return this.isValid ? possiblyCachedLocalWeekData(this).weekday : NaN;
  }
  /**
   * Get the week number of the week year according to the locale. Different locales assign week numbers differently,
   * because the week can start on different days of the week (see localWeekday) and because a different number of days
   * is required for a week to count as the first week of a year.
   * @returns {number}
   */
  get localWeekNumber() {
    return this.isValid ? possiblyCachedLocalWeekData(this).weekNumber : NaN;
  }
  /**
   * Get the week year according to the locale. Different locales assign week numbers (and therefor week years)
   * differently, see localWeekNumber.
   * @returns {number}
   */
  get localWeekYear() {
    return this.isValid ? possiblyCachedLocalWeekData(this).weekYear : NaN;
  }
  /**
   * Get the ordinal (meaning the day of the year)
   * @example DateTime.local(2017, 5, 25).ordinal //=> 145
   * @type {number|DateTime}
   */
  get ordinal() {
    return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
  }
  /**
   * Get the human readable short month name, such as 'Oct'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
   * @type {string}
   */
  get monthShort() {
    return this.isValid ? Info.months("short", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable long month name, such as 'October'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthLong //=> October
   * @type {string}
   */
  get monthLong() {
    return this.isValid ? Info.months("long", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable short weekday, such as 'Mon'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
   * @type {string}
   */
  get weekdayShort() {
    return this.isValid ? Info.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the human readable long weekday, such as 'Monday'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
   * @type {string}
   */
  get weekdayLong() {
    return this.isValid ? Info.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the UTC offset of this DateTime in minutes
   * @example DateTime.now().offset //=> -240
   * @example DateTime.utc().offset //=> 0
   * @type {number}
   */
  get offset() {
    return this.isValid ? +this.o : NaN;
  }
  /**
   * Get the short human name for the zone's current offset, for example "EST" or "EDT".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameShort() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "short",
        locale: this.locale
      });
    } else {
      return null;
    }
  }
  /**
   * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameLong() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "long",
        locale: this.locale
      });
    } else {
      return null;
    }
  }
  /**
   * Get whether this zone's offset ever changes, as in a DST.
   * @type {boolean}
   */
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }
  /**
   * Get whether the DateTime is in a DST.
   * @type {boolean}
   */
  get isInDST() {
    if (this.isOffsetFixed) {
      return false;
    } else {
      return this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
    }
  }
  /**
   * Get those DateTimes which have the same local time as this DateTime, but a different offset from UTC
   * in this DateTime's zone. During DST changes local time can be ambiguous, for example
   * `2023-10-29T02:30:00` in `Europe/Berlin` can have offset `+01:00` or `+02:00`.
   * This method will return both possible DateTimes if this DateTime's local time is ambiguous.
   * @returns {DateTime[]}
   */
  getPossibleOffsets() {
    if (!this.isValid || this.isOffsetFixed) {
      return [this];
    }
    const dayMs = 864e5;
    const minuteMs = 6e4;
    const localTS = objToLocalTS(this.c);
    const oEarlier = this.zone.offset(localTS - dayMs);
    const oLater = this.zone.offset(localTS + dayMs);
    const o1 = this.zone.offset(localTS - oEarlier * minuteMs);
    const o2 = this.zone.offset(localTS - oLater * minuteMs);
    if (o1 === o2) {
      return [this];
    }
    const ts1 = localTS - o1 * minuteMs;
    const ts2 = localTS - o2 * minuteMs;
    const c1 = tsToObj(ts1, o1);
    const c2 = tsToObj(ts2, o2);
    if (c1.hour === c2.hour && c1.minute === c2.minute && c1.second === c2.second && c1.millisecond === c2.millisecond) {
      return [clone(this, { ts: ts1 }), clone(this, { ts: ts2 })];
    }
    return [this];
  }
  /**
   * Returns true if this DateTime is in a leap year, false otherwise
   * @example DateTime.local(2016).isInLeapYear //=> true
   * @example DateTime.local(2013).isInLeapYear //=> false
   * @type {boolean}
   */
  get isInLeapYear() {
    return isLeapYear(this.year);
  }
  /**
   * Returns the number of days in this DateTime's month
   * @example DateTime.local(2016, 2).daysInMonth //=> 29
   * @example DateTime.local(2016, 3).daysInMonth //=> 31
   * @type {number}
   */
  get daysInMonth() {
    return daysInMonth(this.year, this.month);
  }
  /**
   * Returns the number of days in this DateTime's year
   * @example DateTime.local(2016).daysInYear //=> 366
   * @example DateTime.local(2013).daysInYear //=> 365
   * @type {number}
   */
  get daysInYear() {
    return this.isValid ? daysInYear(this.year) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2004).weeksInWeekYear //=> 53
   * @example DateTime.local(2013).weeksInWeekYear //=> 52
   * @type {number}
   */
  get weeksInWeekYear() {
    return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's local week year
   * @example DateTime.local(2020, 6, {locale: 'en-US'}).weeksInLocalWeekYear //=> 52
   * @example DateTime.local(2020, 6, {locale: 'de-DE'}).weeksInLocalWeekYear //=> 53
   * @type {number}
   */
  get weeksInLocalWeekYear() {
    return this.isValid ? weeksInWeekYear(
      this.localWeekYear,
      this.loc.getMinDaysInFirstWeek(),
      this.loc.getStartOfWeek()
    ) : NaN;
  }
  /**
   * Returns the resolved Intl options for this DateTime.
   * This is useful in understanding the behavior of formatting methods
   * @param {Object} opts - the same options as toLocaleString
   * @return {Object}
   */
  resolvedLocaleOptions(opts = {}) {
    const { locale, numberingSystem, calendar } = Formatter.create(
      this.loc.clone(opts),
      opts
    ).resolvedOptions(this);
    return { locale, numberingSystem, outputCalendar: calendar };
  }
  // TRANSFORM
  /**
   * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
   *
   * Equivalent to {@link DateTime#setZone}('utc')
   * @param {number} [offset=0] - optionally, an offset from UTC in minutes
   * @param {Object} [opts={}] - options to pass to `setZone()`
   * @return {DateTime}
   */
  toUTC(offset2 = 0, opts = {}) {
    return this.setZone(FixedOffsetZone.instance(offset2), opts);
  }
  /**
   * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
   *
   * Equivalent to `setZone('local')`
   * @return {DateTime}
   */
  toLocal() {
    return this.setZone(Settings.defaultZone);
  }
  /**
   * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
   *
   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
   * @param {Object} opts - options
   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
   * @return {DateTime}
   */
  setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {
    zone = normalizeZone(zone, Settings.defaultZone);
    if (zone.equals(this.zone)) {
      return this;
    } else if (!zone.isValid) {
      return DateTime.invalid(unsupportedZone(zone));
    } else {
      let newTS = this.ts;
      if (keepLocalTime || keepCalendarTime) {
        const offsetGuess = zone.offset(this.ts);
        const asObj = this.toObject();
        [newTS] = objToTS(asObj, offsetGuess, zone);
      }
      return clone(this, { ts: newTS, zone });
    }
  }
  /**
   * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
   * @param {Object} properties - the properties to set
   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
   * @return {DateTime}
   */
  reconfigure({ locale, numberingSystem, outputCalendar } = {}) {
    const loc = this.loc.clone({ locale, numberingSystem, outputCalendar });
    return clone(this, { loc });
  }
  /**
   * "Set" the locale. Returns a newly-constructed DateTime.
   * Just a convenient alias for reconfigure({ locale })
   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
   * @return {DateTime}
   */
  setLocale(locale) {
    return this.reconfigure({ locale });
  }
  /**
   * "Set" the values of specified units. Returns a newly-constructed DateTime.
   * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
   *
   * This method also supports setting locale-based week units, i.e. `localWeekday`, `localWeekNumber` and `localWeekYear`.
   * They cannot be mixed with ISO-week units like `weekday`.
   * @param {Object} values - a mapping of units to numbers
   * @example dt.set({ year: 2017 })
   * @example dt.set({ hour: 8, minute: 30 })
   * @example dt.set({ weekday: 5 })
   * @example dt.set({ year: 2005, ordinal: 234 })
   * @return {DateTime}
   */
  set(values) {
    if (!this.isValid) return this;
    const normalized = normalizeObject(values, normalizeUnitWithLocalWeeks);
    const { minDaysInFirstWeek, startOfWeek } = usesLocalWeekValues(normalized, this.loc);
    const settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    let mixed;
    if (settingWeekStuff) {
      mixed = weekToGregorian(
        { ...gregorianToWeek(this.c, minDaysInFirstWeek, startOfWeek), ...normalized },
        minDaysInFirstWeek,
        startOfWeek
      );
    } else if (!isUndefined(normalized.ordinal)) {
      mixed = ordinalToGregorian({ ...gregorianToOrdinal(this.c), ...normalized });
    } else {
      mixed = { ...this.toObject(), ...normalized };
      if (isUndefined(normalized.day)) {
        mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
      }
    }
    const [ts, o2] = objToTS(mixed, this.o, this.zone);
    return clone(this, { ts, o: o2 });
  }
  /**
   * Add a period of time to this DateTime and return the resulting DateTime
   *
   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @example DateTime.now().plus(123) //~> in 123 milliseconds
   * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
   * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
   * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
   * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
   * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
   * @return {DateTime}
   */
  plus(duration) {
    if (!this.isValid) return this;
    const dur = Duration.fromDurationLike(duration);
    return clone(this, adjustTime(this, dur));
  }
  /**
   * Subtract a period of time to this DateTime and return the resulting DateTime
   * See {@link DateTime#plus}
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   @return {DateTime}
   */
  minus(duration) {
    if (!this.isValid) return this;
    const dur = Duration.fromDurationLike(duration).negate();
    return clone(this, adjustTime(this, dur));
  }
  /**
   * "Set" this DateTime to the beginning of a unit of time.
   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
   * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
   * @return {DateTime}
   */
  startOf(unit, { useLocaleWeeks = false } = {}) {
    if (!this.isValid) return this;
    const o2 = {}, normalizedUnit = Duration.normalizeUnit(unit);
    switch (normalizedUnit) {
      case "years":
        o2.month = 1;
      // falls through
      case "quarters":
      case "months":
        o2.day = 1;
      // falls through
      case "weeks":
      case "days":
        o2.hour = 0;
      // falls through
      case "hours":
        o2.minute = 0;
      // falls through
      case "minutes":
        o2.second = 0;
      // falls through
      case "seconds":
        o2.millisecond = 0;
        break;
    }
    if (normalizedUnit === "weeks") {
      if (useLocaleWeeks) {
        const startOfWeek = this.loc.getStartOfWeek();
        const { weekday } = this;
        if (weekday < startOfWeek) {
          o2.weekNumber = this.weekNumber - 1;
        }
        o2.weekday = startOfWeek;
      } else {
        o2.weekday = 1;
      }
    }
    if (normalizedUnit === "quarters") {
      const q2 = Math.ceil(this.month / 3);
      o2.month = (q2 - 1) * 3 + 1;
    }
    return this.set(o2);
  }
  /**
   * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
   * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
   * @return {DateTime}
   */
  endOf(unit, opts) {
    return this.isValid ? this.plus({ [unit]: 1 }).startOf(unit, opts).minus(1) : this;
  }
  // OUTPUT
  /**
   * Returns a string representation of this DateTime formatted according to the specified format string.
   * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
   * Defaults to en-US if no locale has been specified, regardless of the system's locale.
   * @param {string} fmt - the format string
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
   * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
   * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
   * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
   * @return {string}
   */
  toFormat(fmt2, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt2) : INVALID;
  }
  /**
   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
   * of the DateTime in the assigned locale.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toLocaleString(); //=> 4/20/2017
   * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 aot 2022'
   * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
   * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
   * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
   * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
   * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
   * @return {string}
   */
  toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID;
  }
  /**
   * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
   * @example DateTime.now().toLocaleParts(); //=> [
   *                                   //=>   { type: 'day', value: '25' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'month', value: '05' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'year', value: '1982' }
   *                                   //=> ]
   */
  toLocaleParts(opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @param {string} [opts.precision='milliseconds'] - truncate output to desired presicion: 'years', 'months', 'days', 'hours', 'minutes', 'seconds' or 'milliseconds'. When precision and suppressSeconds or suppressMilliseconds are used together, precision sets the maximum unit shown in the output, however seconds or milliseconds will still be suppressed if they are 0.
   * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
   * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
   * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
   * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
   * @example DateTime.now().toISO({ precision: 'day' }) //=> '2017-04-22Z'
   * @example DateTime.now().toISO({ precision: 'minute' }) //=> '2017-04-22T20:47Z'
   * @return {string|null}
   */
  toISO({
    format: format2 = "extended",
    suppressSeconds = false,
    suppressMilliseconds = false,
    includeOffset = true,
    extendedZone = false,
    precision = "milliseconds"
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    precision = normalizeUnit(precision);
    const ext = format2 === "extended";
    let c2 = toISODate(this, ext, precision);
    if (orderedUnits.indexOf(precision) >= 3) c2 += "T";
    c2 += toISOTime(
      this,
      ext,
      suppressSeconds,
      suppressMilliseconds,
      includeOffset,
      extendedZone,
      precision
    );
    return c2;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's date component
   * @param {Object} opts - options
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @param {string} [opts.precision='day'] - truncate output to desired precision: 'years', 'months', or 'days'.
   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
   * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
   * @example DateTime.utc(1982, 5, 25).toISODate({ precision: 'month' }) //=> '1982-05'
   * @return {string|null}
   */
  toISODate({ format: format2 = "extended", precision = "day" } = {}) {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, format2 === "extended", normalizeUnit(precision));
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's week date
   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
   * @return {string}
   */
  toISOWeekDate() {
    return toTechFormat(this, "kkkk-'W'WW-c");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's time component
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @param {string} [opts.precision='milliseconds'] - truncate output to desired presicion: 'hours', 'minutes', 'seconds' or 'milliseconds'. When precision and suppressSeconds or suppressMilliseconds are used together, precision sets the maximum unit shown in the output, however seconds or milliseconds will still be suppressed if they are 0.
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34, second: 56 }).toISOTime({ precision: 'minute' }) //=> '07:34Z'
   * @return {string}
   */
  toISOTime({
    suppressMilliseconds = false,
    suppressSeconds = false,
    includeOffset = true,
    includePrefix = false,
    extendedZone = false,
    format: format2 = "extended",
    precision = "milliseconds"
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    precision = normalizeUnit(precision);
    let c2 = includePrefix && orderedUnits.indexOf(precision) >= 3 ? "T" : "";
    return c2 + toISOTime(
      this,
      format2 === "extended",
      suppressSeconds,
      suppressMilliseconds,
      includeOffset,
      extendedZone,
      precision
    );
  }
  /**
   * Returns an RFC 2822-compatible string representation of this DateTime
   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
   * @return {string}
   */
  toRFC2822() {
    return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
   * Specifically, the string conforms to RFC 1123.
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
   * @return {string}
   */
  toHTTP() {
    return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Date
   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
   * @return {string|null}
   */
  toSQLDate() {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, true);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Time
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc().toSQL() //=> '05:15:16.345'
   * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
   * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
   * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
   * @return {string}
   */
  toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {
    let fmt2 = "HH:mm:ss.SSS";
    if (includeZone || includeOffset) {
      if (includeOffsetSpace) {
        fmt2 += " ";
      }
      if (includeZone) {
        fmt2 += "z";
      } else if (includeOffset) {
        fmt2 += "ZZ";
      }
    }
    return toTechFormat(this, fmt2, true);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
   * @return {string}
   */
  toSQL(opts = {}) {
    if (!this.isValid) {
      return null;
    }
    return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
  }
  /**
   * Returns a string representation of this DateTime appropriate for debugging
   * @return {string}
   */
  toString() {
    return this.isValid ? this.toISO() : INVALID;
  }
  /**
   * Returns a string representation of this DateTime appropriate for the REPL.
   * @return {string}
   */
  [/* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom")]() {
    if (this.isValid) {
      return `DateTime { ts: ${this.toISO()}, zone: ${this.zone.name}, locale: ${this.locale} }`;
    } else {
      return `DateTime { Invalid, reason: ${this.invalidReason} }`;
    }
  }
  /**
   * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Returns the epoch milliseconds of this DateTime.
   * @return {number}
   */
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  /**
   * Returns the epoch seconds (including milliseconds in the fractional part) of this DateTime.
   * @return {number}
   */
  toSeconds() {
    return this.isValid ? this.ts / 1e3 : NaN;
  }
  /**
   * Returns the epoch seconds (as a whole number) of this DateTime.
   * @return {number}
   */
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
  }
  /**
   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns a BSON serializable equivalent to this DateTime.
   * @return {Date}
   */
  toBSON() {
    return this.toJSDate();
  }
  /**
   * Returns a JavaScript object with this DateTime's year, month, day, and so on.
   * @param opts - options for generating the object
   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
   * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
   * @return {Object}
   */
  toObject(opts = {}) {
    if (!this.isValid) return {};
    const base = { ...this.c };
    if (opts.includeConfig) {
      base.outputCalendar = this.outputCalendar;
      base.numberingSystem = this.loc.numberingSystem;
      base.locale = this.loc.locale;
    }
    return base;
  }
  /**
   * Returns a JavaScript Date equivalent to this DateTime.
   * @return {Date}
   */
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }
  // COMPARE
  /**
   * Return the difference between two DateTimes as a Duration.
   * @param {DateTime} otherDateTime - the DateTime to compare this one to
   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example
   * var i1 = DateTime.fromISO('1982-05-25T09:45'),
   *     i2 = DateTime.fromISO('1983-10-14T10:30');
   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
   * @return {Duration}
   */
  diff(otherDateTime, unit = "milliseconds", opts = {}) {
    if (!this.isValid || !otherDateTime.isValid) {
      return Duration.invalid("created by diffing an invalid DateTime");
    }
    const durOpts = { locale: this.locale, numberingSystem: this.numberingSystem, ...opts };
    const units = maybeArray(unit).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = diff(earlier, later, units, durOpts);
    return otherIsLater ? diffed.negate() : diffed;
  }
  /**
   * Return the difference between this DateTime and right now.
   * See {@link DateTime#diff}
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  diffNow(unit = "milliseconds", opts = {}) {
    return this.diff(DateTime.now(), unit, opts);
  }
  /**
   * Return an Interval spanning between this DateTime and another DateTime
   * @param {DateTime} otherDateTime - the other end point of the Interval
   * @return {Interval|DateTime}
   */
  until(otherDateTime) {
    return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
  }
  /**
   * Return whether this DateTime is in the same unit of time as another DateTime.
   * Higher-order units must also be identical for this function to return `true`.
   * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
   * @param {DateTime} otherDateTime - the other DateTime
   * @param {string} unit - the unit of time to check sameness on
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; only the locale of this DateTime is used
   * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
   * @return {boolean}
   */
  hasSame(otherDateTime, unit, opts) {
    if (!this.isValid) return false;
    const inputMs = otherDateTime.valueOf();
    const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });
    return adjustedToZone.startOf(unit, opts) <= inputMs && inputMs <= adjustedToZone.endOf(unit, opts);
  }
  /**
   * Equality check
   * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
   * To compare just the millisecond values, use `+dt1 === +dt2`.
   * @param {DateTime} other - the other DateTime
   * @return {boolean}
   */
  equals(other) {
    return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
  }
  /**
   * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
   * platform supports Intl.RelativeTimeFormat. Rounds towards zero by default.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
   * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
   * @param {boolean} [options.round=true] - whether to round the numbers in the output.
   * @param {string} [options.rounding="trunc"] - rounding method to use when rounding the numbers in the output. Can be "trunc" (toward zero), "expand" (away from zero), "round", "floor", or "ceil".
   * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
   * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 da"
   * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
   * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
   * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
   * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
   */
  toRelative(options = {}) {
    if (!this.isValid) return null;
    const base = options.base || DateTime.fromObject({}, { zone: this.zone }), padding = options.padding ? this < base ? -options.padding : options.padding : 0;
    let units = ["years", "months", "days", "hours", "minutes", "seconds"];
    let unit = options.unit;
    if (Array.isArray(options.unit)) {
      units = options.unit;
      unit = void 0;
    }
    return diffRelative(base, this.plus(padding), {
      ...options,
      numeric: "always",
      units,
      unit
    });
  }
  /**
   * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
   * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
   * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""maana"
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
   * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
   */
  toRelativeCalendar(options = {}) {
    if (!this.isValid) return null;
    return diffRelative(options.base || DateTime.fromObject({}, { zone: this.zone }), this, {
      ...options,
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: true
    });
  }
  /**
   * Return the min of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
   * @return {DateTime} the min DateTime, or undefined if called with no argument
   */
  static min(...dateTimes) {
    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("min requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i) => i.valueOf(), Math.min);
  }
  /**
   * Return the max of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
   * @return {DateTime} the max DateTime, or undefined if called with no argument
   */
  static max(...dateTimes) {
    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("max requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i) => i.valueOf(), Math.max);
  }
  // MISC
  /**
   * Explain how a string would be parsed by fromFormat()
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see description)
   * @param {Object} options - options taken by fromFormat()
   * @return {Object}
   */
  static fromFormatExplain(text2, fmt2, options = {}) {
    const { locale = null, numberingSystem = null } = options, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    });
    return explainFromTokens(localeToUse, text2, fmt2);
  }
  /**
   * @deprecated use fromFormatExplain instead
   */
  static fromStringExplain(text2, fmt2, options = {}) {
    return DateTime.fromFormatExplain(text2, fmt2, options);
  }
  /**
   * Build a parser for `fmt` using the given locale. This parser can be passed
   * to {@link DateTime.fromFormatParser} to a parse a date in this format. This
   * can be used to optimize cases where many dates need to be parsed in a
   * specific format.
   *
   * @param {String} fmt - the format the string is expected to be in (see
   * description)
   * @param {Object} options - options used to set locale and numberingSystem
   * for parser
   * @returns {TokenParser} - opaque object to be used
   */
  static buildFormatParser(fmt2, options = {}) {
    const { locale = null, numberingSystem = null } = options, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    });
    return new TokenParser(localeToUse, fmt2);
  }
  /**
   * Create a DateTime from an input string and format parser.
   *
   * The format parser must have been created with the same locale as this call.
   *
   * @param {String} text - the string to parse
   * @param {TokenParser} formatParser - parser from {@link DateTime.buildFormatParser}
   * @param {Object} opts - options taken by fromFormat()
   * @returns {DateTime}
   */
  static fromFormatParser(text2, formatParser, opts = {}) {
    if (isUndefined(text2) || isUndefined(formatParser)) {
      throw new InvalidArgumentError(
        "fromFormatParser requires an input string and a format parser"
      );
    }
    const { locale = null, numberingSystem = null } = opts, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    });
    if (!localeToUse.equals(formatParser.locale)) {
      throw new InvalidArgumentError(
        `fromFormatParser called with a locale of ${localeToUse}, but the format parser was created for ${formatParser.locale}`
      );
    }
    const { result: result2, zone, specificOffset, invalidReason } = formatParser.explainFromTokens(text2);
    if (invalidReason) {
      return DateTime.invalid(invalidReason);
    } else {
      return parseDataToDateTime(
        result2,
        zone,
        opts,
        `format ${formatParser.format}`,
        text2,
        specificOffset
      );
    }
  }
  // FORMAT PRESETS
  /**
   * {@link DateTime#toLocaleString} format like 10/14/1983
   * @type {Object}
   */
  static get DATE_SHORT() {
    return DATE_SHORT;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED() {
    return DATE_MED;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED_WITH_WEEKDAY() {
    return DATE_MED_WITH_WEEKDAY;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983'
   * @type {Object}
   */
  static get DATE_FULL() {
    return DATE_FULL;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
   * @type {Object}
   */
  static get DATE_HUGE() {
    return DATE_HUGE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_SIMPLE() {
    return TIME_SIMPLE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SECONDS() {
    return TIME_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SHORT_OFFSET() {
    return TIME_WITH_SHORT_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_LONG_OFFSET() {
    return TIME_WITH_LONG_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_SIMPLE() {
    return TIME_24_SIMPLE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SECONDS() {
    return TIME_24_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SHORT_OFFSET() {
    return TIME_24_WITH_SHORT_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_LONG_OFFSET() {
    return TIME_24_WITH_LONG_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT() {
    return DATETIME_SHORT;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT_WITH_SECONDS() {
    return DATETIME_SHORT_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED() {
    return DATETIME_MED;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_SECONDS() {
    return DATETIME_MED_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_WEEKDAY() {
    return DATETIME_MED_WITH_WEEKDAY;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL() {
    return DATETIME_FULL;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL_WITH_SECONDS() {
    return DATETIME_FULL_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE() {
    return DATETIME_HUGE;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE_WITH_SECONDS() {
    return DATETIME_HUGE_WITH_SECONDS;
  }
}
function friendlyDateTime(dateTimeish) {
  if (DateTime.isDateTime(dateTimeish)) {
    return dateTimeish;
  } else if (dateTimeish && dateTimeish.valueOf && isNumber(dateTimeish.valueOf())) {
    return DateTime.fromJSDate(dateTimeish);
  } else if (dateTimeish && typeof dateTimeish === "object") {
    return DateTime.fromObject(dateTimeish);
  } else {
    throw new InvalidArgumentError(
      `Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`
    );
  }
}
const VERSION = "3.7.2";
const luxon = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DateTime,
  Duration,
  FixedOffsetZone,
  IANAZone,
  Info,
  Interval,
  InvalidZone,
  Settings,
  SystemZone,
  VERSION,
  Zone
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(luxon);
var hasRequiredCronDate;
function requireCronDate() {
  if (hasRequiredCronDate) return CronDate;
  hasRequiredCronDate = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.CronDate = exports$1.DAYS_IN_MONTH = exports$1.DateMathOp = exports$1.TimeUnit = void 0;
    const luxon_1 = require$$0$1;
    var TimeUnit;
    (function(TimeUnit2) {
      TimeUnit2["Second"] = "Second";
      TimeUnit2["Minute"] = "Minute";
      TimeUnit2["Hour"] = "Hour";
      TimeUnit2["Day"] = "Day";
      TimeUnit2["Month"] = "Month";
      TimeUnit2["Year"] = "Year";
    })(TimeUnit || (exports$1.TimeUnit = TimeUnit = {}));
    var DateMathOp;
    (function(DateMathOp2) {
      DateMathOp2["Add"] = "Add";
      DateMathOp2["Subtract"] = "Subtract";
    })(DateMathOp || (exports$1.DateMathOp = DateMathOp = {}));
    exports$1.DAYS_IN_MONTH = Object.freeze([31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]);
    class CronDate2 {
      #date;
      #dstStart = null;
      #dstEnd = null;
      /**
       * Maps the verb to the appropriate method
       */
      #verbMap = {
        add: {
          [TimeUnit.Year]: this.addYear.bind(this),
          [TimeUnit.Month]: this.addMonth.bind(this),
          [TimeUnit.Day]: this.addDay.bind(this),
          [TimeUnit.Hour]: this.addHour.bind(this),
          [TimeUnit.Minute]: this.addMinute.bind(this),
          [TimeUnit.Second]: this.addSecond.bind(this)
        },
        subtract: {
          [TimeUnit.Year]: this.subtractYear.bind(this),
          [TimeUnit.Month]: this.subtractMonth.bind(this),
          [TimeUnit.Day]: this.subtractDay.bind(this),
          [TimeUnit.Hour]: this.subtractHour.bind(this),
          [TimeUnit.Minute]: this.subtractMinute.bind(this),
          [TimeUnit.Second]: this.subtractSecond.bind(this)
        }
      };
      /**
       * Constructs a new CronDate instance.
       * @param {CronDate | Date | number | string} [timestamp] - The timestamp to initialize the CronDate with.
       * @param {string} [tz] - The timezone to use for the CronDate.
       */
      constructor(timestamp2, tz) {
        const dateOpts = { zone: tz };
        if (!timestamp2) {
          this.#date = luxon_1.DateTime.local();
        } else if (timestamp2 instanceof CronDate2) {
          this.#date = timestamp2.#date;
          this.#dstStart = timestamp2.#dstStart;
          this.#dstEnd = timestamp2.#dstEnd;
        } else if (timestamp2 instanceof Date) {
          this.#date = luxon_1.DateTime.fromJSDate(timestamp2, dateOpts);
        } else if (typeof timestamp2 === "number") {
          this.#date = luxon_1.DateTime.fromMillis(timestamp2, dateOpts);
        } else {
          this.#date = luxon_1.DateTime.fromISO(timestamp2, dateOpts);
          this.#date.isValid || (this.#date = luxon_1.DateTime.fromRFC2822(timestamp2, dateOpts));
          this.#date.isValid || (this.#date = luxon_1.DateTime.fromSQL(timestamp2, dateOpts));
          this.#date.isValid || (this.#date = luxon_1.DateTime.fromFormat(timestamp2, "EEE, d MMM yyyy HH:mm:ss", dateOpts));
        }
        if (!this.#date.isValid) {
          throw new Error(`CronDate: unhandled timestamp: ${timestamp2}`);
        }
        if (tz && tz !== this.#date.zoneName) {
          this.#date = this.#date.setZone(tz);
        }
      }
      /**
       * Determines if the given year is a leap year.
       * @param {number} year - The year to check
       * @returns {boolean} - True if the year is a leap year, false otherwise
       * @private
       */
      static #isLeapYear(year2) {
        return year2 % 4 === 0 && year2 % 100 !== 0 || year2 % 400 === 0;
      }
      /**
       * Returns daylight savings start time.
       * @returns {number | null}
       */
      get dstStart() {
        return this.#dstStart;
      }
      /**
       * Sets daylight savings start time.
       * @param {number | null} value
       */
      set dstStart(value) {
        this.#dstStart = value;
      }
      /**
       * Returns daylight savings end time.
       * @returns {number | null}
       */
      get dstEnd() {
        return this.#dstEnd;
      }
      /**
       * Sets daylight savings end time.
       * @param {number | null} value
       */
      set dstEnd(value) {
        this.#dstEnd = value;
      }
      /**
       * Adds one year to the current CronDate.
       */
      addYear() {
        this.#date = this.#date.plus({ years: 1 });
      }
      /**
       * Adds one month to the current CronDate.
       */
      addMonth() {
        this.#date = this.#date.plus({ months: 1 }).startOf("month");
      }
      /**
       * Adds one day to the current CronDate.
       */
      addDay() {
        this.#date = this.#date.plus({ days: 1 }).startOf("day");
      }
      /**
       * Adds one hour to the current CronDate.
       */
      addHour() {
        this.#date = this.#date.plus({ hours: 1 }).startOf("hour");
      }
      /**
       * Adds one minute to the current CronDate.
       */
      addMinute() {
        this.#date = this.#date.plus({ minutes: 1 }).startOf("minute");
      }
      /**
       * Adds one second to the current CronDate.
       */
      addSecond() {
        this.#date = this.#date.plus({ seconds: 1 });
      }
      /**
       * Subtracts one year from the current CronDate.
       */
      subtractYear() {
        this.#date = this.#date.minus({ years: 1 });
      }
      /**
       * Subtracts one month from the current CronDate.
       * If the month is 1, it will subtract one year instead.
       */
      subtractMonth() {
        this.#date = this.#date.minus({ months: 1 }).endOf("month").startOf("second");
      }
      /**
       * Subtracts one day from the current CronDate.
       * If the day is 1, it will subtract one month instead.
       */
      subtractDay() {
        this.#date = this.#date.minus({ days: 1 }).endOf("day").startOf("second");
      }
      /**
       * Subtracts one hour from the current CronDate.
       * If the hour is 0, it will subtract one day instead.
       */
      subtractHour() {
        this.#date = this.#date.minus({ hours: 1 }).endOf("hour").startOf("second");
      }
      /**
       * Subtracts one minute from the current CronDate.
       * If the minute is 0, it will subtract one hour instead.
       */
      subtractMinute() {
        this.#date = this.#date.minus({ minutes: 1 }).endOf("minute").startOf("second");
      }
      /**
       * Subtracts one second from the current CronDate.
       * If the second is 0, it will subtract one minute instead.
       */
      subtractSecond() {
        this.#date = this.#date.minus({ seconds: 1 });
      }
      /**
       * Adds a unit of time to the current CronDate.
       * @param {TimeUnit} unit
       */
      addUnit(unit) {
        this.#verbMap.add[unit]();
      }
      /**
       * Subtracts a unit of time from the current CronDate.
       * @param {TimeUnit} unit
       */
      subtractUnit(unit) {
        this.#verbMap.subtract[unit]();
      }
      /**
       * Handles a math operation.
       * @param {DateMathOp} verb - {'add' | 'subtract'}
       * @param {TimeUnit} unit - {'year' | 'month' | 'day' | 'hour' | 'minute' | 'second'}
       */
      invokeDateOperation(verb, unit) {
        if (verb === DateMathOp.Add) {
          this.addUnit(unit);
          return;
        }
        if (verb === DateMathOp.Subtract) {
          this.subtractUnit(unit);
          return;
        }
        throw new Error(`Invalid verb: ${verb}`);
      }
      /**
       * Returns the day.
       * @returns {number}
       */
      getDate() {
        return this.#date.day;
      }
      /**
       * Returns the year.
       * @returns {number}
       */
      getFullYear() {
        return this.#date.year;
      }
      /**
       * Returns the day of the week.
       * @returns {number}
       */
      getDay() {
        const weekday = this.#date.weekday;
        return weekday === 7 ? 0 : weekday;
      }
      /**
       * Returns the month.
       * @returns {number}
       */
      getMonth() {
        return this.#date.month - 1;
      }
      /**
       * Returns the hour.
       * @returns {number}
       */
      getHours() {
        return this.#date.hour;
      }
      /**
       * Returns the minutes.
       * @returns {number}
       */
      getMinutes() {
        return this.#date.minute;
      }
      /**
       * Returns the seconds.
       * @returns {number}
       */
      getSeconds() {
        return this.#date.second;
      }
      /**
       * Returns the milliseconds.
       * @returns {number}
       */
      getMilliseconds() {
        return this.#date.millisecond;
      }
      /**
       * Returns the timezone offset from UTC in minutes (e.g. UTC+2 => 120).
       * Useful for detecting DST transition days.
       *
       * @returns {number} UTC offset in minutes
       */
      getUTCOffset() {
        return this.#date.offset;
      }
      /**
       * Sets the time to the start of the day (00:00:00.000) in the current timezone.
       */
      setStartOfDay() {
        this.#date = this.#date.startOf("day");
      }
      /**
       * Sets the time to the end of the day (23:59:59.999) in the current timezone.
       */
      setEndOfDay() {
        this.#date = this.#date.endOf("day");
      }
      /**
       * Returns the time.
       * @returns {number}
       */
      getTime() {
        return this.#date.valueOf();
      }
      /**
       * Returns the UTC day.
       * @returns {number}
       */
      getUTCDate() {
        return this.#getUTC().day;
      }
      /**
       * Returns the UTC year.
       * @returns {number}
       */
      getUTCFullYear() {
        return this.#getUTC().year;
      }
      /**
       * Returns the UTC day of the week.
       * @returns {number}
       */
      getUTCDay() {
        const weekday = this.#getUTC().weekday;
        return weekday === 7 ? 0 : weekday;
      }
      /**
       * Returns the UTC month.
       * @returns {number}
       */
      getUTCMonth() {
        return this.#getUTC().month - 1;
      }
      /**
       * Returns the UTC hour.
       * @returns {number}
       */
      getUTCHours() {
        return this.#getUTC().hour;
      }
      /**
       * Returns the UTC minutes.
       * @returns {number}
       */
      getUTCMinutes() {
        return this.#getUTC().minute;
      }
      /**
       * Returns the UTC seconds.
       * @returns {number}
       */
      getUTCSeconds() {
        return this.#getUTC().second;
      }
      /**
       * Returns the UTC milliseconds.
       * @returns {string | null}
       */
      toISOString() {
        return this.#date.toUTC().toISO();
      }
      /**
       * Returns the date as a JSON string.
       * @returns {string | null}
       */
      toJSON() {
        return this.#date.toJSON();
      }
      /**
       * Sets the day.
       * @param d
       */
      setDate(d) {
        this.#date = this.#date.set({ day: d });
      }
      /**
       * Sets the year.
       * @param y
       */
      setFullYear(y) {
        this.#date = this.#date.set({ year: y });
      }
      /**
       * Sets the day of the week.
       * @param d
       */
      setDay(d) {
        this.#date = this.#date.set({ weekday: d });
      }
      /**
       * Sets the month.
       * @param m
       */
      setMonth(m) {
        this.#date = this.#date.set({ month: m + 1 });
      }
      /**
       * Sets the hour.
       * @param h
       */
      setHours(h) {
        this.#date = this.#date.set({ hour: h });
      }
      /**
       * Sets the minutes.
       * @param m
       */
      setMinutes(m) {
        this.#date = this.#date.set({ minute: m });
      }
      /**
       * Sets the seconds.
       * @param s
       */
      setSeconds(s2) {
        this.#date = this.#date.set({ second: s2 });
      }
      /**
       * Sets the milliseconds.
       * @param s
       */
      setMilliseconds(s2) {
        this.#date = this.#date.set({ millisecond: s2 });
      }
      /**
       * Returns the date as a string.
       * @returns {string}
       */
      toString() {
        return this.toDate().toString();
      }
      /**
       * Returns the date as a Date object.
       * @returns {Date}
       */
      toDate() {
        return this.#date.toJSDate();
      }
      /**
       * Returns true if the day is the last day of the month.
       * @returns {boolean}
       */
      isLastDayOfMonth() {
        const { day: day2, month } = this.#date;
        if (month === 2) {
          const isLeap = CronDate2.#isLeapYear(this.#date.year);
          return day2 === exports$1.DAYS_IN_MONTH[month - 1] - (isLeap ? 0 : 1);
        }
        return day2 === exports$1.DAYS_IN_MONTH[month - 1];
      }
      /**
       * Returns true if the day is the last weekday of the month.
       * @returns {boolean}
       */
      isLastWeekdayOfMonth() {
        const { day: day2, month } = this.#date;
        let lastDay;
        if (month === 2) {
          lastDay = exports$1.DAYS_IN_MONTH[month - 1] - (CronDate2.#isLeapYear(this.#date.year) ? 0 : 1);
        } else {
          lastDay = exports$1.DAYS_IN_MONTH[month - 1];
        }
        return day2 > lastDay - 7;
      }
      /**
       * Primarily for internal use.
       * @param {DateMathOp} op - The operation to perform.
       * @param {TimeUnit} unit - The unit of time to use.
       * @param {number} [hoursLength] - The length of the hours. Required when unit is not month or day.
       */
      applyDateOperation(op, unit, hoursLength) {
        if (unit === TimeUnit.Month || unit === TimeUnit.Day) {
          this.invokeDateOperation(op, unit);
          return;
        }
        const previousHour = this.getHours();
        this.invokeDateOperation(op, unit);
        const currentHour = this.getHours();
        const diff2 = currentHour - previousHour;
        if (diff2 === 2) {
          if (hoursLength !== 24) {
            this.dstStart = currentHour;
          }
        } else if (diff2 === 0 && this.getMinutes() === 0 && this.getSeconds() === 0) {
          if (hoursLength !== 24) {
            this.dstEnd = currentHour;
          }
        }
      }
      /**
       * Returns the UTC date.
       * @private
       * @returns {DateTime}
       */
      #getUTC() {
        return this.#date.toUTC();
      }
    }
    exports$1.CronDate = CronDate2;
    exports$1.default = CronDate2;
  })(CronDate);
  return CronDate;
}
var hasRequiredCronMonth;
function requireCronMonth() {
  if (hasRequiredCronMonth) return CronMonth;
  hasRequiredCronMonth = 1;
  Object.defineProperty(CronMonth, "__esModule", { value: true });
  CronMonth.CronMonth = void 0;
  const CronDate_1 = requireCronDate();
  const CronField_1 = requireCronField();
  const MIN_MONTH = 1;
  const MAX_MONTH = 12;
  const MONTH_CHARS = Object.freeze([]);
  let CronMonth$1 = class CronMonth extends CronField_1.CronField {
    static get min() {
      return MIN_MONTH;
    }
    static get max() {
      return MAX_MONTH;
    }
    static get chars() {
      return MONTH_CHARS;
    }
    static get daysInMonth() {
      return CronDate_1.DAYS_IN_MONTH;
    }
    /**
     * CronDayOfMonth constructor. Initializes the "day of the month" field with the provided values.
     * @param {MonthRange[]} values - Values for the "day of the month" field
     * @param {CronFieldOptions} [options] - Options provided by the parser
     */
    constructor(values, options) {
      super(values, options);
      this.validate();
    }
    /**
     * Returns an array of allowed values for the "day of the month" field.
     * @returns {MonthRange[]}
     */
    get values() {
      return super.values;
    }
  };
  CronMonth.CronMonth = CronMonth$1;
  return CronMonth;
}
var CronSecond = {};
var hasRequiredCronSecond;
function requireCronSecond() {
  if (hasRequiredCronSecond) return CronSecond;
  hasRequiredCronSecond = 1;
  Object.defineProperty(CronSecond, "__esModule", { value: true });
  CronSecond.CronSecond = void 0;
  const CronField_1 = requireCronField();
  const MIN_SECOND = 0;
  const MAX_SECOND = 59;
  const SECOND_CHARS = Object.freeze([]);
  let CronSecond$1 = class CronSecond extends CronField_1.CronField {
    static get min() {
      return MIN_SECOND;
    }
    static get max() {
      return MAX_SECOND;
    }
    static get chars() {
      return SECOND_CHARS;
    }
    /**
     * CronSecond constructor. Initializes the "second" field with the provided values.
     * @param {SixtyRange[]} values - Values for the "second" field
     * @param {CronFieldOptions} [options] - Options provided by the parser
     */
    constructor(values, options) {
      super(values, options);
      this.validate();
    }
    /**
     * Returns an array of allowed values for the "second" field.
     * @returns {SixtyRange[]}
     */
    get values() {
      return super.values;
    }
  };
  CronSecond.CronSecond = CronSecond$1;
  return CronSecond;
}
var hasRequiredFields;
function requireFields() {
  if (hasRequiredFields) return fields;
  hasRequiredFields = 1;
  (function(exports$1) {
    var __createBinding = fields && fields.__createBinding || (Object.create ? (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc2 = Object.getOwnPropertyDescriptor(m, k);
      if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc2);
    }) : (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m[k];
    }));
    var __exportStar = fields && fields.__exportStar || function(m, exports$12) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$12, p)) __createBinding(exports$12, m, p);
    };
    Object.defineProperty(exports$1, "__esModule", { value: true });
    __exportStar(requireTypes(), exports$1);
    __exportStar(requireCronDayOfMonth(), exports$1);
    __exportStar(requireCronDayOfWeek(), exports$1);
    __exportStar(requireCronField(), exports$1);
    __exportStar(requireCronHour(), exports$1);
    __exportStar(requireCronMinute(), exports$1);
    __exportStar(requireCronMonth(), exports$1);
    __exportStar(requireCronSecond(), exports$1);
  })(fields);
  return fields;
}
var hasRequiredCronFieldCollection;
function requireCronFieldCollection() {
  if (hasRequiredCronFieldCollection) return CronFieldCollection;
  hasRequiredCronFieldCollection = 1;
  Object.defineProperty(CronFieldCollection, "__esModule", { value: true });
  CronFieldCollection.CronFieldCollection = void 0;
  const fields_1 = requireFields();
  let CronFieldCollection$1 = class CronFieldCollection2 {
    #second;
    #minute;
    #hour;
    #dayOfMonth;
    #month;
    #dayOfWeek;
    /**
     * Creates a new CronFieldCollection instance by partially overriding fields from an existing one.
     * @param {CronFieldCollection} base - The base CronFieldCollection to copy fields from
     * @param {CronFieldOverride} fields - The fields to override, can be CronField instances or raw values
     * @returns {CronFieldCollection} A new CronFieldCollection instance
     * @example
     * const base = new CronFieldCollection({
     *   second: new CronSecond([0]),
     *   minute: new CronMinute([0]),
     *   hour: new CronHour([12]),
     *   dayOfMonth: new CronDayOfMonth([1]),
     *   month: new CronMonth([1]),
     *   dayOfWeek: new CronDayOfWeek([1])
     * });
     *
     * // Using CronField instances
     * const modified1 = CronFieldCollection.from(base, {
     *   hour: new CronHour([15]),
     *   minute: new CronMinute([30])
     * });
     *
     * // Using raw values
     * const modified2 = CronFieldCollection.from(base, {
     *   hour: [15],        // Will create new CronHour
     *   minute: [30]       // Will create new CronMinute
     * });
     */
    static from(base, fields2) {
      return new CronFieldCollection2({
        second: this.resolveField(fields_1.CronSecond, base.second, fields2.second),
        minute: this.resolveField(fields_1.CronMinute, base.minute, fields2.minute),
        hour: this.resolveField(fields_1.CronHour, base.hour, fields2.hour),
        dayOfMonth: this.resolveField(fields_1.CronDayOfMonth, base.dayOfMonth, fields2.dayOfMonth),
        month: this.resolveField(fields_1.CronMonth, base.month, fields2.month),
        dayOfWeek: this.resolveField(fields_1.CronDayOfWeek, base.dayOfWeek, fields2.dayOfWeek)
      });
    }
    /**
     * Resolves a field value, either using the provided CronField instance or creating a new one from raw values.
     * @param constructor - The constructor for creating new field instances
     * @param baseField - The base field to use if no override is provided
     * @param fieldValue - The override value, either a CronField instance or raw values
     * @returns The resolved CronField instance
     * @private
     */
    static resolveField(constructor, baseField, fieldValue) {
      if (!fieldValue) {
        return baseField;
      }
      if (fieldValue instanceof fields_1.CronField) {
        return fieldValue;
      }
      return new constructor(fieldValue);
    }
    /**
     * CronFieldCollection constructor. Initializes the cron fields with the provided values.
     * @param {CronFields} param0 - The cron fields values
     * @throws {Error} if validation fails
     * @example
     * const cronFields = new CronFieldCollection({
     *   second: new CronSecond([0]),
     *   minute: new CronMinute([0, 30]),
     *   hour: new CronHour([9]),
     *   dayOfMonth: new CronDayOfMonth([15]),
     *   month: new CronMonth([1]),
     *   dayOfWeek: new CronDayOfTheWeek([1, 2, 3, 4, 5]),
     * })
     *
     * console.log(cronFields.second.values); // [0]
     * console.log(cronFields.minute.values); // [0, 30]
     * console.log(cronFields.hour.values); // [9]
     * console.log(cronFields.dayOfMonth.values); // [15]
     * console.log(cronFields.month.values); // [1]
     * console.log(cronFields.dayOfWeek.values); // [1, 2, 3, 4, 5]
     */
    constructor({ second, minute: minute2, hour: hour2, dayOfMonth, month, dayOfWeek: dayOfWeek2 }) {
      if (!second) {
        throw new Error("Validation error, Field second is missing");
      }
      if (!minute2) {
        throw new Error("Validation error, Field minute is missing");
      }
      if (!hour2) {
        throw new Error("Validation error, Field hour is missing");
      }
      if (!dayOfMonth) {
        throw new Error("Validation error, Field dayOfMonth is missing");
      }
      if (!month) {
        throw new Error("Validation error, Field month is missing");
      }
      if (!dayOfWeek2) {
        throw new Error("Validation error, Field dayOfWeek is missing");
      }
      if (month.values.length === 1 && !dayOfMonth.hasLastChar) {
        if (!(parseInt(dayOfMonth.values[0], 10) <= fields_1.CronMonth.daysInMonth[month.values[0] - 1])) {
          throw new Error("Invalid explicit day of month definition");
        }
      }
      this.#second = second;
      this.#minute = minute2;
      this.#hour = hour2;
      this.#month = month;
      this.#dayOfWeek = dayOfWeek2;
      this.#dayOfMonth = dayOfMonth;
    }
    /**
     * Returns the second field.
     * @returns {CronSecond}
     */
    get second() {
      return this.#second;
    }
    /**
     * Returns the minute field.
     * @returns {CronMinute}
     */
    get minute() {
      return this.#minute;
    }
    /**
     * Returns the hour field.
     * @returns {CronHour}
     */
    get hour() {
      return this.#hour;
    }
    /**
     * Returns the day of the month field.
     * @returns {CronDayOfMonth}
     */
    get dayOfMonth() {
      return this.#dayOfMonth;
    }
    /**
     * Returns the month field.
     * @returns {CronMonth}
     */
    get month() {
      return this.#month;
    }
    /**
     * Returns the day of the week field.
     * @returns {CronDayOfWeek}
     */
    get dayOfWeek() {
      return this.#dayOfWeek;
    }
    /**
     * Returns a string representation of the cron fields.
     * @param {(number | CronChars)[]} input - The cron fields values
     * @static
     * @returns {FieldRange[]} - The compacted cron fields
     */
    static compactField(input) {
      if (input.length === 0) {
        return [];
      }
      const output = [];
      let current = void 0;
      input.forEach((item, i, arr) => {
        if (current === void 0) {
          current = { start: item, count: 1 };
          return;
        }
        const prevItem = arr[i - 1] || current.start;
        const nextItem = arr[i + 1];
        if (item === "L" || item === "W") {
          output.push(current);
          output.push({ start: item, count: 1 });
          current = void 0;
          return;
        }
        if (current.step === void 0 && nextItem !== void 0) {
          const step = item - prevItem;
          const nextStep = nextItem - item;
          if (step <= nextStep) {
            current = { ...current, count: 2, end: item, step };
            return;
          }
          current.step = 1;
        }
        if (item - (current.end ?? 0) === current.step) {
          current.count++;
          current.end = item;
        } else {
          if (current.count === 1) {
            output.push({ start: current.start, count: 1 });
          } else if (current.count === 2) {
            output.push({ start: current.start, count: 1 });
            output.push({
              start: current.end ?? /* istanbul ignore next - see above */
              prevItem,
              count: 1
            });
          } else {
            output.push(current);
          }
          current = { start: item, count: 1 };
        }
      });
      if (current) {
        output.push(current);
      }
      return output;
    }
    /**
     * Handles a single range.
     * @param {CronField} field - The cron field to stringify
     * @param {FieldRange} range {start: number, end: number, step: number, count: number} The range to handle.
     * @param {number} max The maximum value for the field.
     * @returns {string | null} The stringified range or null if it cannot be stringified.
     * @private
     */
    static #handleSingleRange(field, range2, max2) {
      const step = range2.step;
      if (!step) {
        return null;
      }
      if (step === 1 && range2.start === field.min && range2.end && range2.end >= max2) {
        return field.hasQuestionMarkChar ? "?" : "*";
      }
      if (step !== 1 && range2.start === field.min && range2.end && range2.end >= max2 - step + 1) {
        return `*/${step}`;
      }
      return null;
    }
    /**
     * Handles multiple ranges.
     * @param {FieldRange} range {start: number, end: number, step: number, count: number} The range to handle.
     * @param {number} max The maximum value for the field.
     * @returns {string} The stringified range.
     * @private
     */
    static #handleMultipleRanges(range2, max2) {
      const step = range2.step;
      if (step === 1) {
        return `${range2.start}-${range2.end}`;
      }
      const multiplier = range2.start === 0 ? range2.count - 1 : range2.count;
      if (!step) {
        throw new Error("Unexpected range step");
      }
      if (!range2.end) {
        throw new Error("Unexpected range end");
      }
      if (step * multiplier > range2.end) {
        const mapFn = (_, index2) => {
          if (typeof range2.start !== "number") {
            throw new Error("Unexpected range start");
          }
          return index2 % step === 0 ? range2.start + index2 : null;
        };
        if (typeof range2.start !== "number") {
          throw new Error("Unexpected range start");
        }
        const seed = { length: range2.end - range2.start + 1 };
        return Array.from(seed, mapFn).filter((value) => value !== null).join(",");
      }
      return range2.end === max2 - step + 1 ? `${range2.start}/${step}` : `${range2.start}-${range2.end}/${step}`;
    }
    /**
     * Returns a string representation of the cron fields.
     * @param {CronField} field - The cron field to stringify
     * @static
     * @returns {string} - The stringified cron field
     */
    stringifyField(field) {
      let max2 = field.max;
      let values = field.values;
      if (field instanceof fields_1.CronDayOfWeek) {
        max2 = 6;
        const dayOfWeek2 = this.#dayOfWeek.values;
        values = dayOfWeek2[dayOfWeek2.length - 1] === 7 ? dayOfWeek2.slice(0, -1) : dayOfWeek2;
      }
      if (field instanceof fields_1.CronDayOfMonth) {
        max2 = this.#month.values.length === 1 ? fields_1.CronMonth.daysInMonth[this.#month.values[0] - 1] : field.max;
      }
      const ranges = CronFieldCollection2.compactField(values);
      if (ranges.length === 1) {
        const singleRangeResult = CronFieldCollection2.#handleSingleRange(field, ranges[0], max2);
        if (singleRangeResult) {
          return singleRangeResult;
        }
      }
      return ranges.map((range2) => {
        const value = range2.count === 1 ? range2.start.toString() : CronFieldCollection2.#handleMultipleRanges(range2, max2);
        if (field instanceof fields_1.CronDayOfWeek && field.nthDay > 0) {
          return `${value}#${field.nthDay}`;
        }
        return value;
      }).join(",");
    }
    /**
     * Returns a string representation of the cron field values.
     * @param {boolean} includeSeconds - Whether to include seconds in the output
     * @returns {string} The formatted cron string
     */
    stringify(includeSeconds = false) {
      const arr = [];
      if (includeSeconds) {
        arr.push(this.stringifyField(this.#second));
      }
      arr.push(
        this.stringifyField(this.#minute),
        // minute
        this.stringifyField(this.#hour),
        // hour
        this.stringifyField(this.#dayOfMonth),
        // dayOfMonth
        this.stringifyField(this.#month),
        // month
        this.stringifyField(this.#dayOfWeek)
      );
      return arr.join(" ");
    }
    /**
     * Returns a serialized representation of the cron fields values.
     * @returns {SerializedCronFields} An object containing the cron field values
     */
    serialize() {
      return {
        second: this.#second.serialize(),
        minute: this.#minute.serialize(),
        hour: this.#hour.serialize(),
        dayOfMonth: this.#dayOfMonth.serialize(),
        month: this.#month.serialize(),
        dayOfWeek: this.#dayOfWeek.serialize()
      };
    }
  };
  CronFieldCollection.CronFieldCollection = CronFieldCollection$1;
  return CronFieldCollection;
}
var CronExpression = {};
var hasRequiredCronExpression;
function requireCronExpression() {
  if (hasRequiredCronExpression) return CronExpression;
  hasRequiredCronExpression = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.CronExpression = exports$1.LOOPS_LIMIT_EXCEEDED_ERROR_MESSAGE = exports$1.TIME_SPAN_OUT_OF_BOUNDS_ERROR_MESSAGE = void 0;
    const CronDate_1 = requireCronDate();
    exports$1.TIME_SPAN_OUT_OF_BOUNDS_ERROR_MESSAGE = "Out of the time span range";
    exports$1.LOOPS_LIMIT_EXCEEDED_ERROR_MESSAGE = "Invalid expression, loop limit exceeded";
    const LOOP_LIMIT = 1e4;
    class CronExpression2 {
      #options;
      #tz;
      #currentDate;
      #startDate;
      #endDate;
      #fields;
      #dstTransitionDayKey = null;
      #isDstTransitionDay = false;
      /**
       * Creates a new CronExpression instance.
       *
       * @param {CronFieldCollection} fields - Cron fields.
       * @param {CronExpressionOptions} options - Parser options.
       */
      constructor(fields2, options) {
        this.#options = options;
        this.#tz = options.tz;
        this.#startDate = options.startDate ? new CronDate_1.CronDate(options.startDate, this.#tz) : null;
        this.#endDate = options.endDate ? new CronDate_1.CronDate(options.endDate, this.#tz) : null;
        let currentDateValue = options.currentDate ?? options.startDate;
        if (currentDateValue) {
          const tempCurrentDate = new CronDate_1.CronDate(currentDateValue, this.#tz);
          if (this.#startDate && tempCurrentDate.getTime() < this.#startDate.getTime()) {
            currentDateValue = this.#startDate;
          } else if (this.#endDate && tempCurrentDate.getTime() > this.#endDate.getTime()) {
            currentDateValue = this.#endDate;
          }
        }
        this.#currentDate = new CronDate_1.CronDate(currentDateValue, this.#tz);
        this.#fields = fields2;
      }
      /**
       * Getter for the cron fields.
       *
       * @returns {CronFieldCollection} Cron fields.
       */
      get fields() {
        return this.#fields;
      }
      /**
       * Converts cron fields back to a CronExpression instance.
       *
       * @public
       * @param {Record<string, number[]>} fields - The input cron fields object.
       * @param {CronExpressionOptions} [options] - Optional parsing options.
       * @returns {CronExpression} - A new CronExpression instance.
       */
      static fieldsToExpression(fields2, options) {
        return new CronExpression2(fields2, options || {});
      }
      /**
       * Checks if the given value matches any element in the sequence.
       *
       * @param {number} value - The value to be matched.
       * @param {number[]} sequence - The sequence to be checked against.
       * @returns {boolean} - True if the value matches an element in the sequence; otherwise, false.
       * @memberof CronExpression
       * @private
       */
      static #matchSchedule(value, sequence) {
        return sequence.some((element) => element === value);
      }
      /**
       * Returns the minimum or maximum value from the given array of numbers.
       *
       * @param {number[]} values - An array of numbers.
       * @param {boolean} reverse - If true, returns the maximum value; otherwise, returns the minimum value.
       * @returns {number} - The minimum or maximum value.
       */
      #getMinOrMax(values, reverse) {
        return values[reverse ? values.length - 1 : 0];
      }
      /**
       * Checks whether the given date falls on a DST transition day in its timezone.
       *
       * This is used to disable certain direct set fast paths on DST days, because setting the hour
       * directly may land on a non-existent or repeated local time. We cache the result per calendar day
       * to keep iteration overhead low.
       *
       * @param {CronDate} currentDate - Date to check (in the cron timezone)
       * @returns {boolean} True when the day has a DST transition
       * @private
       */
      #checkDstTransition(currentDate) {
        const key = `${currentDate.getFullYear()}-${currentDate.getMonth() + 1}-${currentDate.getDate()}`;
        if (this.#dstTransitionDayKey === key) {
          return this.#isDstTransitionDay;
        }
        const startOfDay = new CronDate_1.CronDate(currentDate);
        startOfDay.setStartOfDay();
        const endOfDay = new CronDate_1.CronDate(currentDate);
        endOfDay.setEndOfDay();
        this.#dstTransitionDayKey = key;
        this.#isDstTransitionDay = startOfDay.getUTCOffset() !== endOfDay.getUTCOffset();
        return this.#isDstTransitionDay;
      }
      /**
       * Moves the date to the next/previous allowed second value. If there is no remaining allowed second
       * within the current minute, rolls to the next/previous minute and resets seconds to the min/max allowed.
       *
       * @param {CronDate} currentDate - Mutable date being iterated
       * @param {DateMathOp} dateMathVerb - Add/Subtract depending on direction
       * @param {boolean} reverse - When true, iterating backwards
       * @private
       */
      #moveToNextSecond(currentDate, dateMathVerb, reverse) {
        const seconds = this.#fields.second.values;
        const currentSecond = currentDate.getSeconds();
        const nextSecond = this.#fields.second.findNearestValue(currentSecond, reverse);
        if (nextSecond !== null) {
          currentDate.setSeconds(nextSecond);
          return;
        }
        currentDate.applyDateOperation(dateMathVerb, CronDate_1.TimeUnit.Minute, this.#fields.hour.values.length);
        currentDate.setSeconds(this.#getMinOrMax(seconds, reverse));
      }
      /**
       * Moves the date to the next/previous allowed minute value and resets seconds to the min/max allowed.
       * If there is no remaining allowed minute within the current hour, rolls to the next/previous hour and
       * resets minutes/seconds to their extrema.
       *
       * @param {CronDate} currentDate - Mutable date being iterated
       * @param {DateMathOp} dateMathVerb - Add/Subtract depending on direction
       * @param {boolean} reverse - When true, iterating backwards
       * @private
       */
      #moveToNextMinute(currentDate, dateMathVerb, reverse) {
        const minutes = this.#fields.minute.values;
        const seconds = this.#fields.second.values;
        const currentMinute = currentDate.getMinutes();
        const nextMinute = this.#fields.minute.findNearestValue(currentMinute, reverse);
        if (nextMinute !== null) {
          currentDate.setMinutes(nextMinute);
          currentDate.setSeconds(this.#getMinOrMax(seconds, reverse));
          return;
        }
        currentDate.applyDateOperation(dateMathVerb, CronDate_1.TimeUnit.Hour, this.#fields.hour.values.length);
        currentDate.setMinutes(this.#getMinOrMax(minutes, reverse));
        currentDate.setSeconds(this.#getMinOrMax(seconds, reverse));
      }
      /**
       * Determines if the current date matches the last specified weekday of the month.
       *
       * @param {Array<(number|string)>} expressions - An array of expressions containing weekdays and "L" for the last weekday.
       * @param {CronDate} currentDate - The current date object.
       * @returns {boolean} - True if the current date matches the last specified weekday of the month; otherwise, false.
       * @memberof CronExpression
       * @private
       */
      static #isLastWeekdayOfMonthMatch(expressions, currentDate) {
        const isLastWeekdayOfMonth = currentDate.isLastWeekdayOfMonth();
        return expressions.some((expression) => {
          const weekday = parseInt(expression.toString().charAt(0), 10) % 7;
          if (Number.isNaN(weekday)) {
            throw new Error(`Invalid last weekday of the month expression: ${expression}`);
          }
          return currentDate.getDay() === weekday && isLastWeekdayOfMonth;
        });
      }
      /**
       * Find the next scheduled date based on the cron expression.
       * @returns {CronDate} - The next scheduled date or an ES6 compatible iterator object.
       * @memberof CronExpression
       * @public
       */
      next() {
        return this.#findSchedule();
      }
      /**
       * Find the previous scheduled date based on the cron expression.
       * @returns {CronDate} - The previous scheduled date or an ES6 compatible iterator object.
       * @memberof CronExpression
       * @public
       */
      prev() {
        return this.#findSchedule(true);
      }
      /**
       * Check if there is a next scheduled date based on the current date and cron expression.
       * @returns {boolean} - Returns true if there is a next scheduled date, false otherwise.
       * @memberof CronExpression
       * @public
       */
      hasNext() {
        const current = this.#currentDate;
        try {
          this.#findSchedule();
          return true;
        } catch {
          return false;
        } finally {
          this.#currentDate = current;
        }
      }
      /**
       * Check if there is a previous scheduled date based on the current date and cron expression.
       * @returns {boolean} - Returns true if there is a previous scheduled date, false otherwise.
       * @memberof CronExpression
       * @public
       */
      hasPrev() {
        const current = this.#currentDate;
        try {
          this.#findSchedule(true);
          return true;
        } catch {
          return false;
        } finally {
          this.#currentDate = current;
        }
      }
      /**
       * Iterate over a specified number of steps and optionally execute a callback function for each step.
       * @param {number} steps - The number of steps to iterate. Positive value iterates forward, negative value iterates backward.
       * @returns {CronDate[]} - An array of iterator fields or CronDate objects.
       * @memberof CronExpression
       * @public
       */
      take(limit) {
        const items = [];
        if (limit >= 0) {
          for (let i = 0; i < limit; i++) {
            try {
              items.push(this.next());
            } catch {
              return items;
            }
          }
        } else {
          for (let i = 0; i > limit; i--) {
            try {
              items.push(this.prev());
            } catch {
              return items;
            }
          }
        }
        return items;
      }
      /**
       * Reset the iterators current date to a new date or the initial date.
       * @param {Date | CronDate} [newDate] - Optional new date to reset to. If not provided, it will reset to the initial date.
       * @memberof CronExpression
       * @public
       */
      reset(newDate) {
        this.#currentDate = new CronDate_1.CronDate(newDate || this.#options.currentDate);
      }
      /**
       * Generate a string representation of the cron expression.
       * @param {boolean} [includeSeconds=false] - Whether to include the seconds field in the string representation.
       * @returns {string} - The string representation of the cron expression.
       * @memberof CronExpression
       * @public
       */
      stringify(includeSeconds = false) {
        return this.#fields.stringify(includeSeconds);
      }
      /**
       * Check if the cron expression includes the given date
       * @param {Date|CronDate} date
       * @returns {boolean}
       */
      includesDate(date2) {
        const { second, minute: minute2, hour: hour2, month } = this.#fields;
        const dt = new CronDate_1.CronDate(date2, this.#tz);
        if (!second.values.includes(dt.getSeconds()) || !minute2.values.includes(dt.getMinutes()) || !hour2.values.includes(dt.getHours()) || !month.values.includes(dt.getMonth() + 1)) {
          return false;
        }
        if (!this.#matchDayOfMonth(dt)) {
          return false;
        }
        if (this.#fields.dayOfWeek.nthDay > 0) {
          const weekInMonth = Math.ceil(dt.getDate() / 7);
          if (weekInMonth !== this.#fields.dayOfWeek.nthDay) {
            return false;
          }
        }
        return true;
      }
      /**
       * Returns the string representation of the cron expression.
       * @returns {CronDate} - The next schedule date.
       */
      toString() {
        return this.#options.expression || this.stringify(true);
      }
      /**
       * Determines if the given date matches the cron expression's day of month and day of week fields.
       *
       * The function checks the following rules:
       * Rule 1: If both "day of month" and "day of week" are restricted (not wildcard), then one or both must match the current day.
       * Rule 2: If "day of month" is restricted and "day of week" is not restricted, then "day of month" must match the current day.
       * Rule 3: If "day of month" is a wildcard, "day of week" is not a wildcard, and "day of week" matches the current day, then the match is accepted.
       * If none of the rules match, the match is rejected.
       *
       * @param {CronDate} currentDate - The current date to be evaluated against the cron expression.
       * @returns {boolean} Returns true if the current date matches the cron expression's day of month and day of week fields, otherwise false.
       * @memberof CronExpression
       * @private
       */
      #matchDayOfMonth(currentDate) {
        const isDayOfMonthWildcardMatch = this.#fields.dayOfMonth.isWildcard;
        const isRestrictedDayOfMonth = !isDayOfMonthWildcardMatch;
        const isDayOfWeekWildcardMatch = this.#fields.dayOfWeek.isWildcard;
        const isRestrictedDayOfWeek = !isDayOfWeekWildcardMatch;
        const matchedDOM = CronExpression2.#matchSchedule(currentDate.getDate(), this.#fields.dayOfMonth.values) || this.#fields.dayOfMonth.hasLastChar && currentDate.isLastDayOfMonth();
        const matchedDOW = CronExpression2.#matchSchedule(currentDate.getDay(), this.#fields.dayOfWeek.values) || this.#fields.dayOfWeek.hasLastChar && CronExpression2.#isLastWeekdayOfMonthMatch(this.#fields.dayOfWeek.values, currentDate);
        if (isRestrictedDayOfMonth && isRestrictedDayOfWeek && (matchedDOM || matchedDOW)) {
          return true;
        }
        if (matchedDOM && !isRestrictedDayOfWeek) {
          return true;
        }
        if (isDayOfMonthWildcardMatch && !isDayOfWeekWildcardMatch && matchedDOW) {
          return true;
        }
        return false;
      }
      /**
       * Determines if the current hour matches the cron expression.
       *
       * @param {CronDate} currentDate - The current date object.
       * @param {DateMathOp} dateMathVerb - The date math operation enumeration value.
       * @param {boolean} reverse - A flag indicating whether the matching should be done in reverse order.
       * @returns {boolean} - True if the current hour matches the cron expression; otherwise, false.
       */
      #matchHour(currentDate, dateMathVerb, reverse) {
        const hourValues = this.#fields.hour.values;
        const hours = hourValues;
        const currentHour = currentDate.getHours();
        const isMatch2 = CronExpression2.#matchSchedule(currentHour, hourValues);
        const isDstStart = currentDate.dstStart === currentHour;
        const isDstEnd = currentDate.dstEnd === currentHour;
        if (isDstStart) {
          if (CronExpression2.#matchSchedule(currentHour - 1, hourValues)) {
            return true;
          }
          currentDate.invokeDateOperation(dateMathVerb, CronDate_1.TimeUnit.Hour);
          return false;
        }
        if (isDstEnd && !reverse) {
          currentDate.dstEnd = null;
          currentDate.applyDateOperation(CronDate_1.DateMathOp.Add, CronDate_1.TimeUnit.Hour, hours.length);
          return false;
        }
        if (isMatch2) {
          return true;
        }
        currentDate.dstStart = null;
        const nextHour = this.#fields.hour.findNearestValue(currentHour, reverse);
        if (nextHour === null) {
          currentDate.applyDateOperation(dateMathVerb, CronDate_1.TimeUnit.Day, hours.length);
          return false;
        }
        if (this.#checkDstTransition(currentDate)) {
          const steps = reverse ? currentHour - nextHour : nextHour - currentHour;
          for (let i = 0; i < steps; i++) {
            currentDate.applyDateOperation(dateMathVerb, CronDate_1.TimeUnit.Hour, hours.length);
          }
        } else {
          currentDate.setHours(nextHour);
        }
        currentDate.setMinutes(this.#getMinOrMax(this.#fields.minute.values, reverse));
        currentDate.setSeconds(this.#getMinOrMax(this.#fields.second.values, reverse));
        return false;
      }
      /**
       * Validates the current date against the start and end dates of the cron expression.
       * If the current date is outside the specified time span, an error is thrown.
       *
       * @param currentDate {CronDate} - The current date to validate.
       * @throws {Error} If the current date is outside the specified time span.
       * @private
       */
      #validateTimeSpan(currentDate) {
        if (!this.#startDate && !this.#endDate) {
          return;
        }
        const currentTime = currentDate.getTime();
        if (this.#startDate && currentTime < this.#startDate.getTime()) {
          throw new Error(exports$1.TIME_SPAN_OUT_OF_BOUNDS_ERROR_MESSAGE);
        }
        if (this.#endDate && currentTime > this.#endDate.getTime()) {
          throw new Error(exports$1.TIME_SPAN_OUT_OF_BOUNDS_ERROR_MESSAGE);
        }
      }
      /**
       * Finds the next or previous schedule based on the cron expression.
       *
       * @param {boolean} [reverse=false] - If true, finds the previous schedule; otherwise, finds the next schedule.
       * @returns {CronDate} - The next or previous schedule date.
       * @private
       */
      #findSchedule(reverse = false) {
        const dateMathVerb = reverse ? CronDate_1.DateMathOp.Subtract : CronDate_1.DateMathOp.Add;
        const currentDate = new CronDate_1.CronDate(this.#currentDate);
        const startTimestamp = currentDate.getTime();
        let stepCount = 0;
        while (++stepCount < LOOP_LIMIT) {
          this.#validateTimeSpan(currentDate);
          if (!this.#matchDayOfMonth(currentDate)) {
            currentDate.applyDateOperation(dateMathVerb, CronDate_1.TimeUnit.Day, this.#fields.hour.values.length);
            continue;
          }
          if (!(this.#fields.dayOfWeek.nthDay <= 0 || Math.ceil(currentDate.getDate() / 7) === this.#fields.dayOfWeek.nthDay)) {
            currentDate.applyDateOperation(dateMathVerb, CronDate_1.TimeUnit.Day, this.#fields.hour.values.length);
            continue;
          }
          if (!CronExpression2.#matchSchedule(currentDate.getMonth() + 1, this.#fields.month.values)) {
            currentDate.applyDateOperation(dateMathVerb, CronDate_1.TimeUnit.Month, this.#fields.hour.values.length);
            continue;
          }
          if (!this.#matchHour(currentDate, dateMathVerb, reverse)) {
            continue;
          }
          if (!CronExpression2.#matchSchedule(currentDate.getMinutes(), this.#fields.minute.values)) {
            this.#moveToNextMinute(currentDate, dateMathVerb, reverse);
            continue;
          }
          if (!CronExpression2.#matchSchedule(currentDate.getSeconds(), this.#fields.second.values)) {
            this.#moveToNextSecond(currentDate, dateMathVerb, reverse);
            continue;
          }
          if (startTimestamp === currentDate.getTime()) {
            if (dateMathVerb === "Add" || currentDate.getMilliseconds() === 0) {
              currentDate.applyDateOperation(dateMathVerb, CronDate_1.TimeUnit.Second, this.#fields.hour.values.length);
            }
            continue;
          }
          break;
        }
        if (stepCount > LOOP_LIMIT) {
          throw new Error(exports$1.LOOPS_LIMIT_EXCEEDED_ERROR_MESSAGE);
        }
        if (currentDate.getMilliseconds() !== 0) {
          currentDate.setMilliseconds(0);
        }
        this.#currentDate = currentDate;
        return currentDate;
      }
      /**
       * Returns an iterator for iterating through future CronDate instances
       *
       * @name Symbol.iterator
       * @memberof CronExpression
       * @returns {Iterator<CronDate>} An iterator object for CronExpression that returns CronDate values.
       */
      [Symbol.iterator]() {
        return {
          next: () => {
            const schedule2 = this.#findSchedule();
            return { value: schedule2, done: !this.hasNext() };
          }
        };
      }
    }
    exports$1.CronExpression = CronExpression2;
    exports$1.default = CronExpression2;
  })(CronExpression);
  return CronExpression;
}
var random = {};
var hasRequiredRandom;
function requireRandom() {
  if (hasRequiredRandom) return random;
  hasRequiredRandom = 1;
  Object.defineProperty(random, "__esModule", { value: true });
  random.seededRandom = seededRandom;
  function xfnv1a(str) {
    let h = 2166136261 >>> 0;
    for (let i = 0; i < str.length; i++) {
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return () => h >>> 0;
  }
  function mulberry32(seed) {
    return () => {
      let t2 = seed += 1831565813;
      t2 = Math.imul(t2 ^ t2 >>> 15, t2 | 1);
      t2 ^= t2 + Math.imul(t2 ^ t2 >>> 7, t2 | 61);
      return ((t2 ^ t2 >>> 14) >>> 0) / 4294967296;
    };
  }
  function seededRandom(str) {
    const seed = str ? xfnv1a(str)() : Math.floor(Math.random() * 1e10);
    return mulberry32(seed);
  }
  return random;
}
var hasRequiredCronExpressionParser;
function requireCronExpressionParser() {
  if (hasRequiredCronExpressionParser) return CronExpressionParser;
  hasRequiredCronExpressionParser = 1;
  Object.defineProperty(CronExpressionParser, "__esModule", { value: true });
  CronExpressionParser.CronExpressionParser = CronExpressionParser.DayOfWeek = CronExpressionParser.Months = CronExpressionParser.CronUnit = CronExpressionParser.PredefinedExpressions = void 0;
  const CronFieldCollection_1 = requireCronFieldCollection();
  const CronExpression_1 = requireCronExpression();
  const random_1 = requireRandom();
  const fields_1 = requireFields();
  var PredefinedExpressions;
  (function(PredefinedExpressions2) {
    PredefinedExpressions2["@yearly"] = "0 0 0 1 1 *";
    PredefinedExpressions2["@annually"] = "0 0 0 1 1 *";
    PredefinedExpressions2["@monthly"] = "0 0 0 1 * *";
    PredefinedExpressions2["@weekly"] = "0 0 0 * * 0";
    PredefinedExpressions2["@daily"] = "0 0 0 * * *";
    PredefinedExpressions2["@hourly"] = "0 0 * * * *";
    PredefinedExpressions2["@minutely"] = "0 * * * * *";
    PredefinedExpressions2["@secondly"] = "* * * * * *";
    PredefinedExpressions2["@weekdays"] = "0 0 0 * * 1-5";
    PredefinedExpressions2["@weekends"] = "0 0 0 * * 0,6";
  })(PredefinedExpressions || (CronExpressionParser.PredefinedExpressions = PredefinedExpressions = {}));
  var CronUnit;
  (function(CronUnit2) {
    CronUnit2["Second"] = "Second";
    CronUnit2["Minute"] = "Minute";
    CronUnit2["Hour"] = "Hour";
    CronUnit2["DayOfMonth"] = "DayOfMonth";
    CronUnit2["Month"] = "Month";
    CronUnit2["DayOfWeek"] = "DayOfWeek";
  })(CronUnit || (CronExpressionParser.CronUnit = CronUnit = {}));
  var Months;
  (function(Months2) {
    Months2[Months2["jan"] = 1] = "jan";
    Months2[Months2["feb"] = 2] = "feb";
    Months2[Months2["mar"] = 3] = "mar";
    Months2[Months2["apr"] = 4] = "apr";
    Months2[Months2["may"] = 5] = "may";
    Months2[Months2["jun"] = 6] = "jun";
    Months2[Months2["jul"] = 7] = "jul";
    Months2[Months2["aug"] = 8] = "aug";
    Months2[Months2["sep"] = 9] = "sep";
    Months2[Months2["oct"] = 10] = "oct";
    Months2[Months2["nov"] = 11] = "nov";
    Months2[Months2["dec"] = 12] = "dec";
  })(Months || (CronExpressionParser.Months = Months = {}));
  var DayOfWeek;
  (function(DayOfWeek2) {
    DayOfWeek2[DayOfWeek2["sun"] = 0] = "sun";
    DayOfWeek2[DayOfWeek2["mon"] = 1] = "mon";
    DayOfWeek2[DayOfWeek2["tue"] = 2] = "tue";
    DayOfWeek2[DayOfWeek2["wed"] = 3] = "wed";
    DayOfWeek2[DayOfWeek2["thu"] = 4] = "thu";
    DayOfWeek2[DayOfWeek2["fri"] = 5] = "fri";
    DayOfWeek2[DayOfWeek2["sat"] = 6] = "sat";
  })(DayOfWeek || (CronExpressionParser.DayOfWeek = DayOfWeek = {}));
  let CronExpressionParser$1 = class CronExpressionParser2 {
    /**
     * Parses a cron expression and returns a CronExpression object.
     * @param {string} expression - The cron expression to parse.
     * @param {CronExpressionOptions} [options={}] - The options to use when parsing the expression.
     * @param {boolean} [options.strict=false] - If true, will throw an error if the expression contains both dayOfMonth and dayOfWeek.
     * @param {CronDate} [options.currentDate=new CronDate(undefined, 'UTC')] - The date to use when calculating the next/previous occurrence.
     *
     * @returns {CronExpression} A CronExpression object.
     */
    static parse(expression, options = {}) {
      const { strict = false, hashSeed } = options;
      const rand = (0, random_1.seededRandom)(hashSeed);
      expression = PredefinedExpressions[expression] || expression;
      const rawFields = CronExpressionParser2.#getRawFields(expression, strict);
      if (!(rawFields.dayOfMonth === "*" || rawFields.dayOfWeek === "*" || !strict)) {
        throw new Error("Cannot use both dayOfMonth and dayOfWeek together in strict mode!");
      }
      const second = CronExpressionParser2.#parseField(CronUnit.Second, rawFields.second, fields_1.CronSecond.constraints, rand);
      const minute2 = CronExpressionParser2.#parseField(CronUnit.Minute, rawFields.minute, fields_1.CronMinute.constraints, rand);
      const hour2 = CronExpressionParser2.#parseField(CronUnit.Hour, rawFields.hour, fields_1.CronHour.constraints, rand);
      const month = CronExpressionParser2.#parseField(CronUnit.Month, rawFields.month, fields_1.CronMonth.constraints, rand);
      const dayOfMonth = CronExpressionParser2.#parseField(CronUnit.DayOfMonth, rawFields.dayOfMonth, fields_1.CronDayOfMonth.constraints, rand);
      const { dayOfWeek: _dayOfWeek, nthDayOfWeek } = CronExpressionParser2.#parseNthDay(rawFields.dayOfWeek);
      const dayOfWeek2 = CronExpressionParser2.#parseField(CronUnit.DayOfWeek, _dayOfWeek, fields_1.CronDayOfWeek.constraints, rand);
      const fields2 = new CronFieldCollection_1.CronFieldCollection({
        second: new fields_1.CronSecond(second, { rawValue: rawFields.second }),
        minute: new fields_1.CronMinute(minute2, { rawValue: rawFields.minute }),
        hour: new fields_1.CronHour(hour2, { rawValue: rawFields.hour }),
        dayOfMonth: new fields_1.CronDayOfMonth(dayOfMonth, { rawValue: rawFields.dayOfMonth }),
        month: new fields_1.CronMonth(month, { rawValue: rawFields.month }),
        dayOfWeek: new fields_1.CronDayOfWeek(dayOfWeek2, { rawValue: rawFields.dayOfWeek, nthDayOfWeek })
      });
      return new CronExpression_1.CronExpression(fields2, { ...options, expression });
    }
    /**
     * Get the raw fields from a cron expression.
     * @param {string} expression - The cron expression to parse.
     * @param {boolean} strict - If true, will throw an error if the expression contains both dayOfMonth and dayOfWeek.
     * @private
     * @returns {RawCronFields} The raw fields.
     */
    static #getRawFields(expression, strict) {
      if (strict && !expression.length) {
        throw new Error("Invalid cron expression");
      }
      expression = expression || "0 * * * * *";
      const atoms = expression.trim().split(/\s+/);
      if (strict && atoms.length < 6) {
        throw new Error("Invalid cron expression, expected 6 fields");
      }
      if (atoms.length > 6) {
        throw new Error("Invalid cron expression, too many fields");
      }
      const defaults2 = ["*", "*", "*", "*", "*", "0"];
      if (atoms.length < defaults2.length) {
        atoms.unshift(...defaults2.slice(atoms.length));
      }
      const [second, minute2, hour2, dayOfMonth, month, dayOfWeek2] = atoms;
      return { second, minute: minute2, hour: hour2, dayOfMonth, month, dayOfWeek: dayOfWeek2 };
    }
    /**
     * Parse a field from a cron expression.
     * @param {CronUnit} field - The field to parse.
     * @param {string} value - The value of the field.
     * @param {CronConstraints} constraints - The constraints for the field.
     * @private
     * @returns {(number | string)[]} The parsed field.
     */
    static #parseField(field, value, constraints, rand) {
      if (field === CronUnit.Month || field === CronUnit.DayOfWeek) {
        value = value.replace(/[a-z]{3}/gi, (match2) => {
          match2 = match2.toLowerCase();
          const replacer = Months[match2] || DayOfWeek[match2];
          if (replacer === void 0) {
            throw new Error(`Validation error, cannot resolve alias "${match2}"`);
          }
          return replacer.toString();
        });
      }
      if (!constraints.validChars.test(value)) {
        throw new Error(`Invalid characters, got value: ${value}`);
      }
      value = this.#parseWildcard(value, constraints);
      value = this.#parseHashed(value, constraints, rand);
      return this.#parseSequence(field, value, constraints);
    }
    /**
     * Parse a wildcard from a cron expression.
     * @param {string} value - The value to parse.
     * @param {CronConstraints} constraints - The constraints for the field.
     * @private
     */
    static #parseWildcard(value, constraints) {
      return value.replace(/[*?]/g, constraints.min + "-" + constraints.max);
    }
    /**
     * Parse a hashed value from a cron expression.
     * @param {string} value - The value to parse.
     * @param {CronConstraints} constraints - The constraints for the field.
     * @param {PRNG} rand - The random number generator to use.
     * @private
     */
    static #parseHashed(value, constraints, rand) {
      const randomValue = rand();
      return value.replace(/H(?:\((\d+)-(\d+)\))?(?:\/(\d+))?/g, (_, min2, max2, step) => {
        if (min2 && max2 && step) {
          const minNum = parseInt(min2, 10);
          const maxNum = parseInt(max2, 10);
          const stepNum = parseInt(step, 10);
          if (minNum > maxNum) {
            throw new Error(`Invalid range: ${minNum}-${maxNum}, min > max`);
          }
          if (stepNum <= 0) {
            throw new Error(`Invalid step: ${stepNum}, must be positive`);
          }
          const minStart = Math.max(minNum, constraints.min);
          const offset2 = Math.floor(randomValue * stepNum);
          const values = [];
          for (let i = Math.floor(minStart / stepNum) * stepNum + offset2; i <= maxNum; i += stepNum) {
            if (i >= minStart) {
              values.push(i);
            }
          }
          return values.join(",");
        } else if (min2 && max2) {
          const minNum = parseInt(min2, 10);
          const maxNum = parseInt(max2, 10);
          if (minNum > maxNum) {
            throw new Error(`Invalid range: ${minNum}-${maxNum}, min > max`);
          }
          return String(Math.floor(randomValue * (maxNum - minNum + 1)) + minNum);
        } else if (step) {
          const stepNum = parseInt(step, 10);
          if (stepNum <= 0) {
            throw new Error(`Invalid step: ${stepNum}, must be positive`);
          }
          const offset2 = Math.floor(randomValue * stepNum);
          const values = [];
          for (let i = Math.floor(constraints.min / stepNum) * stepNum + offset2; i <= constraints.max; i += stepNum) {
            if (i >= constraints.min) {
              values.push(i);
            }
          }
          return values.join(",");
        } else {
          return String(Math.floor(randomValue * (constraints.max - constraints.min + 1) + constraints.min));
        }
      });
    }
    /**
     * Parse a sequence from a cron expression.
     * @param {CronUnit} field - The field to parse.
     * @param {string} val - The sequence to parse.
     * @param {CronConstraints} constraints - The constraints for the field.
     * @private
     */
    static #parseSequence(field, val, constraints) {
      const stack = [];
      function handleResult(result2, constraints2) {
        if (Array.isArray(result2)) {
          stack.push(...result2);
        } else {
          if (CronExpressionParser2.#isValidConstraintChar(constraints2, result2)) {
            stack.push(result2);
          } else {
            const v = parseInt(result2.toString(), 10);
            const isValid = v >= constraints2.min && v <= constraints2.max;
            if (!isValid) {
              throw new Error(`Constraint error, got value ${result2} expected range ${constraints2.min}-${constraints2.max}`);
            }
            stack.push(field === CronUnit.DayOfWeek ? v % 7 : result2);
          }
        }
      }
      const atoms = val.split(",");
      atoms.forEach((atom) => {
        if (!(atom.length > 0)) {
          throw new Error("Invalid list value format");
        }
        handleResult(CronExpressionParser2.#parseRepeat(field, atom, constraints), constraints);
      });
      return stack;
    }
    /**
     * Parse repeat from a cron expression.
     * @param {CronUnit} field - The field to parse.
     * @param {string} val - The repeat to parse.
     * @param {CronConstraints} constraints - The constraints for the field.
     * @private
     * @returns {(number | string)[]} The parsed repeat.
     */
    static #parseRepeat(field, val, constraints) {
      const atoms = val.split("/");
      if (atoms.length > 2) {
        throw new Error(`Invalid repeat: ${val}`);
      }
      if (atoms.length === 2) {
        if (!isNaN(parseInt(atoms[0], 10))) {
          atoms[0] = `${atoms[0]}-${constraints.max}`;
        }
        return CronExpressionParser2.#parseRange(field, atoms[0], parseInt(atoms[1], 10), constraints);
      }
      return CronExpressionParser2.#parseRange(field, val, 1, constraints);
    }
    /**
     * Validate a cron range.
     * @param {number} min - The minimum value of the range.
     * @param {number} max - The maximum value of the range.
     * @param {CronConstraints} constraints - The constraints for the field.
     * @private
     * @returns {void}
     * @throws {Error} Throws an error if the range is invalid.
     */
    static #validateRange(min2, max2, constraints) {
      const isValid = !isNaN(min2) && !isNaN(max2) && min2 >= constraints.min && max2 <= constraints.max;
      if (!isValid) {
        throw new Error(`Constraint error, got range ${min2}-${max2} expected range ${constraints.min}-${constraints.max}`);
      }
      if (min2 > max2) {
        throw new Error(`Invalid range: ${min2}-${max2}, min(${min2}) > max(${max2})`);
      }
    }
    /**
     * Validate a cron repeat interval.
     * @param {number} repeatInterval - The repeat interval to validate.
     * @private
     * @returns {void}
     * @throws {Error} Throws an error if the repeat interval is invalid.
     */
    static #validateRepeatInterval(repeatInterval) {
      if (!(!isNaN(repeatInterval) && repeatInterval > 0)) {
        throw new Error(`Constraint error, cannot repeat at every ${repeatInterval} time.`);
      }
    }
    /**
     * Create a range from a cron expression.
     * @param {CronUnit} field - The field to parse.
     * @param {number} min - The minimum value of the range.
     * @param {number} max - The maximum value of the range.
     * @param {number} repeatInterval - The repeat interval of the range.
     * @private
     * @returns {number[]} The created range.
     */
    static #createRange(field, min2, max2, repeatInterval) {
      const stack = [];
      if (field === CronUnit.DayOfWeek && max2 % 7 === 0) {
        stack.push(0);
      }
      for (let index2 = min2; index2 <= max2; index2 += repeatInterval) {
        if (stack.indexOf(index2) === -1) {
          stack.push(index2);
        }
      }
      return stack;
    }
    /**
     * Parse a range from a cron expression.
     * @param {CronUnit} field - The field to parse.
     * @param {string} val - The range to parse.
     * @param {number} repeatInterval - The repeat interval of the range.
     * @param {CronConstraints} constraints - The constraints for the field.
     * @private
     * @returns {number[] | string[] | number | string} The parsed range.
     */
    static #parseRange(field, val, repeatInterval, constraints) {
      const atoms = val.split("-");
      if (atoms.length <= 1) {
        return isNaN(+val) ? val : +val;
      }
      const [min2, max2] = atoms.map((num) => parseInt(num, 10));
      this.#validateRange(min2, max2, constraints);
      this.#validateRepeatInterval(repeatInterval);
      return this.#createRange(field, min2, max2, repeatInterval);
    }
    /**
     * Parse a cron expression.
     * @param {string} val - The cron expression to parse.
     * @private
     * @returns {string} The parsed cron expression.
     */
    static #parseNthDay(val) {
      const atoms = val.split("#");
      if (atoms.length <= 1) {
        return { dayOfWeek: atoms[0] };
      }
      const nthValue = +atoms[atoms.length - 1];
      const matches = val.match(/([,-/])/);
      if (matches !== null) {
        throw new Error(`Constraint error, invalid dayOfWeek \`#\` and \`${matches?.[0]}\` special characters are incompatible`);
      }
      if (!(atoms.length <= 2 && !isNaN(nthValue) && nthValue >= 1 && nthValue <= 5)) {
        throw new Error("Constraint error, invalid dayOfWeek occurrence number (#)");
      }
      return { dayOfWeek: atoms[0], nthDayOfWeek: nthValue };
    }
    /**
     * Checks if a character is valid for a field.
     * @param {CronConstraints} constraints - The constraints for the field.
     * @param {string | number} value - The value to check.
     * @private
     * @returns {boolean} Whether the character is valid for the field.
     */
    static #isValidConstraintChar(constraints, value) {
      return constraints.chars.some((char2) => value.toString().includes(char2));
    }
  };
  CronExpressionParser.CronExpressionParser = CronExpressionParser$1;
  return CronExpressionParser;
}
var CronFileParser = {};
var hasRequiredCronFileParser;
function requireCronFileParser() {
  if (hasRequiredCronFileParser) return CronFileParser;
  hasRequiredCronFileParser = 1;
  var __createBinding = CronFileParser && CronFileParser.__createBinding || (Object.create ? (function(o2, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o2, k2, desc2);
  }) : (function(o2, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o2[k2] = m[k];
  }));
  var __setModuleDefault = CronFileParser && CronFileParser.__setModuleDefault || (Object.create ? (function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  }) : function(o2, v) {
    o2["default"] = v;
  });
  var __importStar = CronFileParser && CronFileParser.__importStar || /* @__PURE__ */ (function() {
    var ownKeys = function(o2) {
      ownKeys = Object.getOwnPropertyNames || function(o3) {
        var ar = [];
        for (var k in o3) if (Object.prototype.hasOwnProperty.call(o3, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o2);
    };
    return function(mod) {
      if (mod && mod.__esModule) return mod;
      var result2 = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result2, mod, k[i]);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
  })();
  Object.defineProperty(CronFileParser, "__esModule", { value: true });
  CronFileParser.CronFileParser = void 0;
  const CronExpressionParser_1 = requireCronExpressionParser();
  let CronFileParser$1 = class CronFileParser2 {
    /**
     * Parse a crontab file asynchronously
     * @param filePath Path to crontab file
     * @returns Promise resolving to parse results
     * @throws If file cannot be read
     */
    static async parseFile(filePath) {
      const { readFile } = await Promise.resolve().then(() => __importStar(fsp__default));
      const data = await readFile(filePath, "utf8");
      return CronFileParser2.#parseContent(data);
    }
    /**
     * Parse a crontab file synchronously
     * @param filePath Path to crontab file
     * @returns Parse results
     * @throws If file cannot be read
     */
    static parseFileSync(filePath) {
      const { readFileSync: readFileSync2 } = require$$1$2;
      const data = readFileSync2(filePath, "utf8");
      return CronFileParser2.#parseContent(data);
    }
    /**
     * Internal method to parse crontab file content
     * @private
     */
    static #parseContent(data) {
      const blocks2 = data.split("\n");
      const result2 = {
        variables: {},
        expressions: [],
        errors: {}
      };
      for (const block of blocks2) {
        const entry = block.trim();
        if (entry.length === 0 || entry.startsWith("#")) {
          continue;
        }
        const variableMatch = entry.match(/^(.*)=(.*)$/);
        if (variableMatch) {
          const [, key, value] = variableMatch;
          result2.variables[key] = value.replace(/["']/g, "");
          continue;
        }
        try {
          const parsedEntry = CronFileParser2.#parseEntry(entry);
          result2.expressions.push(parsedEntry.interval);
        } catch (err2) {
          result2.errors[entry] = err2;
        }
      }
      return result2;
    }
    /**
     * Parse a single crontab entry
     * @private
     */
    static #parseEntry(entry) {
      const atoms = entry.split(" ");
      return {
        interval: CronExpressionParser_1.CronExpressionParser.parse(atoms.slice(0, 5).join(" ")),
        command: atoms.slice(5, atoms.length)
      };
    }
  };
  CronFileParser.CronFileParser = CronFileParser$1;
  return CronFileParser;
}
var hasRequiredDist$1;
function requireDist$1() {
  if (hasRequiredDist$1) return dist$1;
  hasRequiredDist$1 = 1;
  (function(exports$1) {
    var __createBinding = dist$1 && dist$1.__createBinding || (Object.create ? (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc2 = Object.getOwnPropertyDescriptor(m, k);
      if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc2);
    }) : (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m[k];
    }));
    var __exportStar = dist$1 && dist$1.__exportStar || function(m, exports$12) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$12, p)) __createBinding(exports$12, m, p);
    };
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.CronFileParser = exports$1.CronExpressionParser = exports$1.CronExpression = exports$1.CronFieldCollection = exports$1.CronDate = void 0;
    const CronExpressionParser_1 = requireCronExpressionParser();
    var CronDate_1 = requireCronDate();
    Object.defineProperty(exports$1, "CronDate", { enumerable: true, get: function() {
      return CronDate_1.CronDate;
    } });
    var CronFieldCollection_1 = requireCronFieldCollection();
    Object.defineProperty(exports$1, "CronFieldCollection", { enumerable: true, get: function() {
      return CronFieldCollection_1.CronFieldCollection;
    } });
    var CronExpression_1 = requireCronExpression();
    Object.defineProperty(exports$1, "CronExpression", { enumerable: true, get: function() {
      return CronExpression_1.CronExpression;
    } });
    var CronExpressionParser_2 = requireCronExpressionParser();
    Object.defineProperty(exports$1, "CronExpressionParser", { enumerable: true, get: function() {
      return CronExpressionParser_2.CronExpressionParser;
    } });
    var CronFileParser_1 = requireCronFileParser();
    Object.defineProperty(exports$1, "CronFileParser", { enumerable: true, get: function() {
      return CronFileParser_1.CronFileParser;
    } });
    __exportStar(requireFields(), exports$1);
    exports$1.default = CronExpressionParser_1.CronExpressionParser;
  })(dist$1);
  return dist$1;
}
var distExports$1 = requireDist$1();
const QUEUES = {
  SEND_IT: "__pgboss__send-it"
};
const EVENTS = {
  error: "error",
  schedule: "schedule",
  warning: "warning"
};
const WARNINGS$1 = {
  CLOCK_SKEW: {
    message: "Warning: Clock skew between this instance and the database server. This will not break scheduling, but is emitted any time the skew exceeds 60 seconds."
  }
};
class Timekeeper extends EventEmitter {
  db;
  config;
  manager;
  stopped = true;
  cronMonitorInterval;
  skewMonitorInterval;
  timekeeping;
  clockSkew = 0;
  events = EVENTS;
  constructor(db, manager, config2) {
    super();
    this.db = db;
    this.config = config2;
    this.manager = manager;
  }
  async start() {
    this.stopped = false;
    await this.cacheClockSkew();
    await this.manager.createQueue(QUEUES.SEND_IT);
    const options = {
      pollingIntervalSeconds: this.config.cronWorkerIntervalSeconds,
      batchSize: 50
    };
    await this.manager.work(QUEUES.SEND_IT, options, (jobs) => this.onSendIt(jobs));
    setImmediate(() => this.onCron());
    this.cronMonitorInterval = setInterval(async () => await this.onCron(), this.config.cronMonitorIntervalSeconds * 1e3);
    this.skewMonitorInterval = setInterval(async () => await this.cacheClockSkew(), this.config.clockMonitorIntervalSeconds * 1e3);
  }
  async stop() {
    if (this.stopped) {
      return;
    }
    this.stopped = true;
    await this.manager.offWork(QUEUES.SEND_IT, { wait: true });
    if (this.skewMonitorInterval) {
      clearInterval(this.skewMonitorInterval);
      this.skewMonitorInterval = null;
    }
    if (this.cronMonitorInterval) {
      clearInterval(this.cronMonitorInterval);
      this.cronMonitorInterval = null;
    }
  }
  async cacheClockSkew() {
    let skew = 0;
    try {
      if (this.config.__test__force_clock_monitoring_error) {
        throw new Error(this.config.__test__force_clock_monitoring_error);
      }
      const { rows } = await this.db.executeSql(getTime());
      const local = Date.now();
      const dbTime = parseFloat(rows[0].time);
      skew = dbTime - local;
      const skewSeconds = Math.abs(skew) / 1e3;
      if (skewSeconds >= 60 || this.config.__test__force_clock_skew_warning) {
        this.emit(this.events.warning, { message: WARNINGS$1.CLOCK_SKEW.message, data: { seconds: skewSeconds, direction: skew > 0 ? "slower" : "faster" } });
      }
    } catch (err2) {
      this.emit(this.events.error, err2);
    } finally {
      this.clockSkew = skew;
    }
  }
  async onCron() {
    try {
      if (this.stopped || this.timekeeping)
        return;
      if (this.config.__test__force_cron_monitoring_error) {
        throw new Error(this.config.__test__force_cron_monitoring_error);
      }
      this.timekeeping = true;
      const sql2 = trySetCronTime(this.config.schema, this.config.cronMonitorIntervalSeconds);
      if (!this.stopped) {
        const { rows } = await this.db.executeSql(sql2);
        if (!this.stopped && rows.length === 1) {
          await this.cron();
        }
      }
    } catch (err2) {
      this.emit(this.events.error, err2);
    } finally {
      this.timekeeping = false;
    }
  }
  async cron() {
    const schedules = await this.getSchedules();
    const scheduled = schedules.filter((i) => this.shouldSendIt(i.cron, i.timezone)).map(({ name: name2, key, data, options }) => ({ data: { name: name2, data, options }, singletonKey: `${name2}__${key}`, singletonSeconds: 60 }));
    if (scheduled.length > 0 && !this.stopped) {
      await this.manager.insert(QUEUES.SEND_IT, scheduled);
    }
  }
  shouldSendIt(cron, tz) {
    const interval = distExports$1.CronExpressionParser.parse(cron, { tz, strict: false });
    const prevTime = interval.prev();
    const databaseTime = Date.now() + this.clockSkew;
    const prevDiff = (databaseTime - prevTime.getTime()) / 1e3;
    return prevDiff < 60;
  }
  async onSendIt(jobs) {
    await Promise.allSettled(jobs.map(({ data }) => this.manager.send(data)));
  }
  async getSchedules(name2, key = "") {
    let sql2 = getSchedules(this.config.schema);
    let params = [];
    if (name2) {
      sql2 = getSchedulesByQueue(this.config.schema);
      params = [name2, key];
    }
    const { rows } = await this.db.executeSql(sql2, params);
    return rows;
  }
  async schedule(name2, cron, data, options = {}) {
    const { tz = "UTC", key = "", ...rest } = options;
    distExports$1.CronExpressionParser.parse(cron, { tz, strict: false });
    checkSendArgs([name2, data, { ...rest }]);
    assertKey(key);
    try {
      const sql2 = schedule(this.config.schema);
      await this.db.executeSql(sql2, [name2, key, cron, tz, data, options]);
    } catch (err2) {
      if (err2.message.includes("foreign key")) {
        err2.message = `Queue ${name2} not found`;
      }
      throw err2;
    }
  }
  async unschedule(name2, key = "") {
    const sql2 = unschedule(this.config.schema);
    await this.db.executeSql(sql2, [name2, key]);
  }
}
function unwrapSQLResult(result2) {
  if (Array.isArray(result2)) {
    return { rows: result2.flatMap((i) => i.rows) };
  }
  return result2;
}
function delay(ms2, error2, abortController) {
  const ac = abortController || new AbortController();
  const promise = new Promise((resolve2, reject) => {
    setTimeout$1(ms2, null, { signal: ac.signal }).then(() => {
      if (error2) {
        reject(new Error(error2));
      } else {
        resolve2();
      }
    }).catch(resolve2);
  });
  promise.abort = () => {
    if (!ac.signal.aborted) {
      ac.abort();
    }
  };
  return promise;
}
async function resolveWithinSeconds(promise, seconds, message2, abortController) {
  const timeout = Math.max(1, seconds) * 1e3;
  const reject = delay(timeout, message2, abortController);
  let result2;
  try {
    result2 = await Promise.race([promise, reject]);
  } finally {
    reject.abort();
  }
  return result2;
}
const WORKER_STATES = {
  created: "created",
  active: "active",
  stopping: "stopping",
  stopped: "stopped"
};
class Worker {
  id;
  name;
  options;
  fetch;
  onFetch;
  onError;
  interval;
  jobs = [];
  createdOn = Date.now();
  state = WORKER_STATES.created;
  lastFetchedOn = null;
  lastJobStartedOn = null;
  lastJobEndedOn = null;
  lastJobDuration = null;
  lastError = null;
  lastErrorOn = null;
  stopping = false;
  stopped = false;
  abortController = null;
  loopDelayPromise = null;
  beenNotified = false;
  runPromise = null;
  constructor({ id, name: name2, options, interval, fetch: fetch2, onFetch, onError }) {
    this.id = id;
    this.name = name2;
    this.options = options;
    this.fetch = fetch2;
    this.onFetch = onFetch;
    this.onError = onError;
    this.interval = interval;
  }
  start() {
    this.runPromise = this.run();
  }
  async run() {
    this.state = WORKER_STATES.active;
    while (!this.stopping) {
      const started = Date.now();
      try {
        this.beenNotified = false;
        const jobs = await this.fetch();
        this.lastFetchedOn = Date.now();
        if (jobs) {
          this.jobs = jobs;
          this.lastJobStartedOn = this.lastFetchedOn;
          await this.onFetch(jobs);
          this.lastJobEndedOn = Date.now();
          this.jobs = [];
        }
      } catch (err2) {
        this.lastErrorOn = Date.now();
        this.lastError = err2;
        err2.message = `${err2.message} (Queue: ${this.name}, Worker: ${this.id})`;
        this.onError(err2);
      }
      const duration = Date.now() - started;
      this.lastJobDuration = duration;
      if (!this.stopping && !this.beenNotified && this.interval - duration > 100) {
        this.loopDelayPromise = delay(this.interval - duration);
        await this.loopDelayPromise;
        this.loopDelayPromise = null;
      }
    }
    this.stopping = false;
    this.stopped = true;
    this.state = WORKER_STATES.stopped;
  }
  notify() {
    this.beenNotified = true;
    if (this.loopDelayPromise) {
      this.loopDelayPromise.abort();
    }
  }
  async stop() {
    this.stopping = true;
    this.state = WORKER_STATES.stopping;
    if (this.loopDelayPromise) {
      this.loopDelayPromise.abort();
    }
    await this.runPromise;
  }
  abort() {
    if (this.abortController && !this.abortController.signal.aborted) {
      this.abortController.abort();
    }
  }
  toWipData() {
    return {
      id: this.id,
      name: this.name,
      options: this.options,
      state: this.state,
      count: this.jobs.length,
      createdOn: this.createdOn,
      lastFetchedOn: this.lastFetchedOn,
      lastJobStartedOn: this.lastJobStartedOn,
      lastJobEndedOn: this.lastJobEndedOn,
      lastError: this.lastError,
      lastErrorOn: this.lastErrorOn,
      lastJobDuration: this.lastJobDuration
    };
  }
}
class JobSpy {
  #jobResults = /* @__PURE__ */ new Map();
  #pendingPromises = [];
  clear() {
    this.#jobResults.clear();
    this.#pendingPromises = [];
  }
  waitForJobWithId(id, awaitedState) {
    return this.waitForJob(() => true, awaitedState, id);
  }
  waitForJob(dataSelector, awaitedState, specificId) {
    const selector = (job) => {
      if (specificId && job.id !== specificId) {
        return false;
      }
      return dataSelector(job.data);
    };
    for (const job of this.#jobResults.values()) {
      if (job.state === awaitedState && selector(job)) {
        return Promise.resolve(this.#cloneJob(job));
      }
    }
    return this.#registerPromise(selector, awaitedState);
  }
  #registerPromise(selector, awaitedState) {
    let resolve2;
    const promise = new Promise((_resolve) => {
      resolve2 = _resolve;
    });
    this.#pendingPromises.push({ selector, awaitedState, resolve: resolve2 });
    return promise;
  }
  #getJobResultKey(id, state) {
    return `${id}:${state}`;
  }
  #cloneJob(job) {
    return {
      id: job.id,
      name: job.name,
      data: structuredClone(job.data),
      state: job.state,
      output: job.output ? structuredClone(job.output) : void 0
    };
  }
  addJob(id, name2, data, state, output) {
    const job = {
      id,
      name: name2,
      data: structuredClone(data),
      state,
      output: output ? structuredClone(output) : void 0
    };
    const key = this.#getJobResultKey(id, state);
    this.#jobResults.set(key, job);
    const matchingPromises = [];
    const remainingPromises = [];
    for (const pending of this.#pendingPromises) {
      if (pending.awaitedState === state && pending.selector(job)) {
        matchingPromises.push(pending);
      } else {
        remainingPromises.push(pending);
      }
    }
    this.#pendingPromises = remainingPromises;
    for (const pending of matchingPromises) {
      pending.resolve(this.#cloneJob(job));
    }
  }
}
const INTERNAL_QUEUES = Object.values(QUEUES).reduce((acc, i) => ({ ...acc, [i]: i }), {});
const events$3 = {
  error: "error",
  wip: "wip"
};
class Manager extends EventEmitter {
  events = events$3;
  db;
  config;
  wipTs;
  workers;
  stopped;
  queueCacheInterval;
  timekeeper;
  queues;
  pendingOffWorkCleanups;
  #spies;
  #localGroupActive;
  #localGroupConfig;
  constructor(db, config2) {
    super();
    this.config = config2;
    this.db = db;
    this.wipTs = Date.now();
    this.workers = /* @__PURE__ */ new Map();
    this.queues = null;
    this.pendingOffWorkCleanups = /* @__PURE__ */ new Set();
    this.#spies = /* @__PURE__ */ new Map();
    this.#localGroupActive = /* @__PURE__ */ new Map();
    this.#localGroupConfig = /* @__PURE__ */ new Map();
  }
  getSpy(name2) {
    if (!this.config.__test__enableSpies) {
      throw new Error("Spy is not enabled. Set __test__enableSpies: true in constructor options to use spies.");
    }
    let spy = this.#spies.get(name2);
    if (!spy) {
      spy = new JobSpy();
      this.#spies.set(name2, spy);
    }
    return spy;
  }
  clearSpies() {
    for (const spy of this.#spies.values()) {
      spy.clear();
    }
    this.#spies.clear();
  }
  #getLocalGroupLimit(queueName, groupTier) {
    const config2 = this.#localGroupConfig.get(queueName);
    if (!config2)
      return Infinity;
    if (groupTier && config2.tiers && groupTier in config2.tiers) {
      return config2.tiers[groupTier];
    }
    return config2.default;
  }
  #getGroupsAtLocalCapacity(queueName) {
    const config2 = this.#localGroupConfig.get(queueName);
    if (!config2)
      return [];
    const queueGroups = this.#localGroupActive.get(queueName);
    if (!queueGroups)
      return [];
    const atCapacity = [];
    for (const [groupId, activeCount] of queueGroups.entries()) {
      const limit = config2.default;
      if (activeCount >= limit) {
        atCapacity.push(groupId);
      }
    }
    return atCapacity;
  }
  #incrementLocalGroupCount(queueName, groupId) {
    let queueGroups = this.#localGroupActive.get(queueName);
    if (!queueGroups) {
      queueGroups = /* @__PURE__ */ new Map();
      this.#localGroupActive.set(queueName, queueGroups);
    }
    const current = queueGroups.get(groupId) || 0;
    queueGroups.set(groupId, current + 1);
  }
  #decrementLocalGroupCount(queueName, groupId) {
    const queueGroups = this.#localGroupActive.get(queueName);
    if (!queueGroups)
      return;
    const current = queueGroups.get(groupId) || 0;
    if (current <= 1) {
      queueGroups.delete(groupId);
    } else {
      queueGroups.set(groupId, current - 1);
    }
  }
  #trackJobsActive(name2, jobs) {
    const spy = this.config.__test__enableSpies ? this.#spies.get(name2) : void 0;
    if (spy) {
      for (const job of jobs) {
        spy.addJob(job.id, name2, job.data, "active");
      }
    }
  }
  #trackJobsCompleted(name2, jobs, result2) {
    const spy = this.config.__test__enableSpies ? this.#spies.get(name2) : void 0;
    if (spy) {
      const output = jobs.length === 1 ? result2 : void 0;
      for (const job of jobs) {
        spy.addJob(job.id, name2, job.data, "completed", output);
      }
    }
  }
  #trackJobsFailed(name2, jobs, err2) {
    const spy = this.config.__test__enableSpies ? this.#spies.get(name2) : void 0;
    if (spy) {
      for (const job of jobs) {
        spy.addJob(job.id, name2, job.data, "failed", { message: err2?.message, stack: err2?.stack });
      }
    }
  }
  #storeLocalGroupConfig(name2, localGroupConcurrency) {
    const config2 = typeof localGroupConcurrency === "number" ? { default: localGroupConcurrency } : localGroupConcurrency;
    this.#localGroupConfig.set(name2, config2);
  }
  #cleanupLocalGroupTracking(name2) {
    const hasWorkersForQueue = this.getWorkers().some((w) => w.name === name2 && !w.stopping && !w.stopped);
    if (!hasWorkersForQueue) {
      this.#localGroupConfig.delete(name2);
      this.#localGroupActive.delete(name2);
    }
  }
  #trackLocalGroupStart(name2, jobs) {
    const allowed2 = [];
    const excess = [];
    const groupedJobs = [];
    for (const job of jobs) {
      if (!job.groupId) {
        allowed2.push(job);
        continue;
      }
      const currentCount = this.#localGroupActive.get(name2)?.get(job.groupId) || 0;
      const limit = this.#getLocalGroupLimit(name2, job.groupTier);
      if (currentCount < limit) {
        this.#incrementLocalGroupCount(name2, job.groupId);
        allowed2.push(job);
        groupedJobs.push(job);
      } else {
        excess.push(job);
      }
    }
    return { allowed: allowed2, excess, groupedJobs };
  }
  #trackLocalGroupEnd(name2, groupedJobs) {
    for (const job of groupedJobs) {
      if (job.groupId) {
        this.#decrementLocalGroupCount(name2, job.groupId);
      }
    }
  }
  async #processJobs(name2, jobs, callback, worker) {
    const jobIds = jobs.map((job) => job.id);
    const maxExpiration = jobs.reduce((acc, i) => Math.max(acc, i.expireInSeconds), 0);
    const ac = new AbortController();
    jobs.forEach((job) => {
      job.signal = ac.signal;
    });
    if (worker) {
      worker.abortController = ac;
    }
    try {
      const result2 = await resolveWithinSeconds(callback(jobs), maxExpiration, `handler execution exceeded ${maxExpiration}s`, ac);
      await this.complete(name2, jobIds, jobIds.length === 1 ? result2 : void 0);
      this.#trackJobsCompleted(name2, jobs, result2);
    } catch (err2) {
      await this.fail(name2, jobIds, err2);
      this.#trackJobsFailed(name2, jobs, err2);
    } finally {
      if (worker) {
        worker.abortController = null;
      }
    }
  }
  async start() {
    this.stopped = false;
    this.queueCacheInterval = setInterval(() => this.onCacheQueues({ emit: true }), this.config.queueCacheIntervalSeconds * 1e3);
    await this.onCacheQueues();
  }
  async onCacheQueues({ emit = false } = {}) {
    try {
      assert(!this.config.__test__throw_queueCache, "test error");
      const queues = await this.getQueues();
      this.queues = queues.reduce((acc, i) => {
        acc[i.name] = i;
        return acc;
      }, {});
    } catch (error2) {
      emit && this.emit(events$3.error, { ...error2, message: error2.message, stack: error2.stack });
    }
  }
  async getQueueCache(name2) {
    assert(this.queues, "Queue cache is not initialized");
    let queue = this.queues[name2];
    if (queue) {
      return queue;
    }
    queue = await this.getQueue(name2);
    if (!queue) {
      throw new Error(`Queue ${name2} does not exist`);
    }
    this.queues[name2] = queue;
    return queue;
  }
  async stop() {
    this.stopped = true;
    clearInterval(this.queueCacheInterval);
    await Promise.allSettled([...this.workers.values()].filter((worker) => !INTERNAL_QUEUES[worker.name]).map(async (worker) => await this.offWork(worker.name, { wait: false })));
    this.#localGroupConfig.clear();
    this.#localGroupActive.clear();
  }
  async failWip() {
    for (const worker of this.workers.values()) {
      const jobIds = worker.jobs.map((j) => j.id);
      if (jobIds.length) {
        await this.fail(worker.name, jobIds, "pg-boss shut down while active");
      }
      worker.abort();
    }
  }
  async work(name2, ...args) {
    const { options, callback } = checkWorkArgs(name2, args);
    if (this.stopped) {
      throw new Error("Workers are disabled. pg-boss is stopped");
    }
    const { pollingInterval: interval, batchSize = 1, includeMetadata = false, priority = true, localConcurrency = 1, localGroupConcurrency, groupConcurrency, orderByCreatedOn = true } = options;
    if (localGroupConcurrency != null) {
      this.#storeLocalGroupConfig(name2, localGroupConcurrency);
    }
    const firstWorkerId = randomUUID({ disableEntropyCache: true });
    const createWorker = (workerId) => {
      const fetch2 = () => {
        const ignoreGroups = localGroupConcurrency != null ? this.#getGroupsAtLocalCapacity(name2) : void 0;
        return this.fetch(name2, { batchSize, includeMetadata, priority, orderByCreatedOn, groupConcurrency, ignoreGroups });
      };
      const onFetch = async (jobs) => {
        if (!jobs.length)
          return;
        if (this.config.__test__throw_worker)
          throw new Error("__test__throw_worker");
        this.emitWip(name2);
        this.#trackJobsActive(name2, jobs);
        const worker = this.workers.get(workerId);
        if (localGroupConcurrency == null) {
          await this.#processJobs(name2, jobs, callback, worker);
        } else {
          const { allowed: allowed2, excess, groupedJobs } = this.#trackLocalGroupStart(name2, jobs);
          if (excess.length > 0) {
            const excessIds = excess.map((job) => job.id);
            await this.restore(name2, excessIds);
          }
          if (allowed2.length > 0) {
            try {
              await this.#processJobs(name2, allowed2, callback, worker);
            } finally {
              this.#trackLocalGroupEnd(name2, groupedJobs);
            }
          }
        }
        this.emitWip(name2);
      };
      const onError = (error2) => {
        this.emit(events$3.error, { ...error2, message: error2.message, stack: error2.stack, queue: name2, worker: workerId });
      };
      return new Worker({ id: workerId, name: name2, options, interval, fetch: fetch2, onFetch, onError });
    };
    for (let i = 0; i < localConcurrency; i++) {
      const workerId = i === 0 ? firstWorkerId : randomUUID({ disableEntropyCache: true });
      const worker = createWorker(workerId);
      this.addWorker(worker);
      worker.start();
    }
    return firstWorkerId;
  }
  addWorker(worker) {
    this.workers.set(worker.id, worker);
  }
  removeWorker(worker) {
    this.workers.delete(worker.id);
  }
  getWorkers() {
    return Array.from(this.workers.values());
  }
  emitWip(name2) {
    if (!INTERNAL_QUEUES[name2]) {
      const now2 = Date.now();
      if (now2 - this.wipTs > 2e3) {
        this.emit(events$3.wip, this.getWipData());
        this.wipTs = now2;
      }
    }
  }
  getWipData(options = {}) {
    const { includeInternal = false } = options;
    const data = this.getWorkers().map((i) => i.toWipData()).filter((i) => i.state !== "stopped" && (!INTERNAL_QUEUES[i.name] || includeInternal));
    return data;
  }
  hasPendingCleanups() {
    return this.pendingOffWorkCleanups.size > 0;
  }
  async offWork(name2, options = { wait: true }) {
    assert(name2, "queue name is required");
    assert(typeof name2 === "string", "queue name must be a string");
    const query2 = (i) => options?.id ? i.id === options.id : i.name === name2;
    const workers = this.getWorkers().filter((i) => query2(i) && !i.stopping && !i.stopped);
    if (workers.length === 0) {
      return;
    }
    const cleanupPromise = Promise.allSettled(workers.map(async (worker) => {
      await worker.stop();
      this.removeWorker(worker);
    }));
    if (options.wait) {
      await cleanupPromise;
      this.#cleanupLocalGroupTracking(name2);
    } else {
      this.pendingOffWorkCleanups.add(cleanupPromise);
      cleanupPromise.finally(() => {
        this.pendingOffWorkCleanups.delete(cleanupPromise);
        this.#cleanupLocalGroupTracking(name2);
      });
    }
  }
  notifyWorker(workerId) {
    this.workers.get(workerId)?.notify();
  }
  async subscribe(event, name2) {
    assert(event, "Missing required argument");
    assert(name2, "Missing required argument");
    const sql2 = subscribe(this.config.schema);
    await this.db.executeSql(sql2, [event, name2]);
  }
  async unsubscribe(event, name2) {
    assert(event, "Missing required argument");
    assert(name2, "Missing required argument");
    const sql2 = unsubscribe(this.config.schema);
    await this.db.executeSql(sql2, [event, name2]);
  }
  async publish(event, data, options) {
    assert(event, "Missing required argument");
    const sql2 = getQueuesForEvent(this.config.schema);
    const { rows } = await this.db.executeSql(sql2, [event]);
    await Promise.allSettled(rows.map(({ name: name2 }) => this.send(name2, data, options)));
  }
  async send(...args) {
    const result2 = checkSendArgs(args);
    return await this.createJob(result2);
  }
  async sendAfter(name2, data, options, after) {
    options = options ? { ...options } : {};
    options.startAfter = after;
    const result2 = checkSendArgs([name2, data, options]);
    return await this.createJob(result2);
  }
  async sendThrottled(name2, data, options, seconds, key) {
    options = options ? { ...options } : {};
    options.singletonSeconds = seconds;
    options.singletonNextSlot = false;
    options.singletonKey = key;
    const result2 = checkSendArgs([name2, data, options]);
    return await this.createJob(result2);
  }
  async sendDebounced(name2, data, options, seconds, key) {
    options = options ? { ...options } : {};
    options.singletonSeconds = seconds;
    options.singletonNextSlot = true;
    options.singletonKey = key;
    const result2 = checkSendArgs([name2, data, options]);
    return await this.createJob(result2);
  }
  async createJob(request) {
    const { name: name2, data = null, options = {} } = request;
    const { id = null, db: wrapper, priority, startAfter, singletonKey = null, singletonSeconds, singletonNextSlot, expireInSeconds, deleteAfterSeconds, retentionSeconds, keepUntil, retryLimit, retryDelay, retryBackoff, retryDelayMax, group, deadLetter = null } = options;
    const job = {
      id,
      name: name2,
      data,
      priority,
      startAfter,
      singletonKey,
      singletonSeconds,
      singletonOffset: 0,
      groupId: group?.id ?? null,
      groupTier: group?.tier ?? null,
      expireInSeconds,
      deleteAfterSeconds,
      retentionSeconds,
      keepUntil,
      retryLimit,
      retryDelay,
      retryBackoff,
      retryDelayMax,
      deadLetter
    };
    const db = wrapper || this.db;
    const { table } = await this.getQueueCache(name2);
    const sql2 = insertJobs(this.config.schema, { table, name: name2, returnId: true });
    const { rows: try1 } = await db.executeSql(sql2, [JSON.stringify([job])]);
    if (try1.length === 1) {
      const jobId = try1[0].id;
      if (this.config.__test__enableSpies) {
        const spy = this.#spies.get(name2);
        if (spy) {
          spy.addJob(jobId, name2, data || {}, "created");
        }
      }
      return jobId;
    }
    if (singletonNextSlot) {
      job.startAfter = this.getDebounceStartAfter(singletonSeconds, this.timekeeper.clockSkew);
      job.singletonOffset = singletonSeconds;
      const { rows: try2 } = await db.executeSql(sql2, [JSON.stringify([job])]);
      if (try2.length === 1) {
        const jobId = try2[0].id;
        if (this.config.__test__enableSpies) {
          const spy = this.#spies.get(name2);
          if (spy) {
            spy.addJob(jobId, name2, data || {}, "created");
          }
        }
        return jobId;
      }
    }
    return null;
  }
  async insert(name2, jobs, options = {}) {
    assert(Array.isArray(jobs), "jobs argument should be an array");
    const { table } = await this.getQueueCache(name2);
    const db = this.assertDb(options);
    const spy = this.config.__test__enableSpies ? this.#spies.get(name2) : void 0;
    const returnId = !!spy || !!options.returnId;
    const sql2 = insertJobs(this.config.schema, { table, name: name2, returnId });
    const { rows } = await db.executeSql(sql2, [JSON.stringify(jobs)]);
    if (rows.length) {
      if (spy) {
        for (let i = 0; i < rows.length; i++) {
          spy.addJob(rows[i].id, name2, jobs[i].data || {}, "created");
        }
      }
      return rows.map((i) => i.id);
    }
    return null;
  }
  getDebounceStartAfter(singletonSeconds, clockOffset) {
    const debounceInterval = singletonSeconds * 1e3;
    const now2 = Date.now() + clockOffset;
    const slot = Math.floor(now2 / debounceInterval) * debounceInterval;
    let startAfter = singletonSeconds - Math.floor((now2 - slot) / 1e3) || 1;
    if (singletonSeconds > 1) {
      startAfter++;
    }
    return startAfter;
  }
  async fetch(name2, options = {}) {
    checkFetchArgs(name2, options);
    const db = this.assertDb(options);
    const { table, policy, singletonsActive } = await this.getQueueCache(name2);
    const fetchOptions = {
      ...options,
      schema: this.config.schema,
      table,
      name: name2,
      policy,
      limit: options.batchSize || 1,
      ignoreSingletons: singletonsActive
    };
    const query2 = fetchNextJob(fetchOptions);
    let result2;
    try {
      result2 = await db.executeSql(query2.text, query2.values);
    } catch (err2) {
    }
    return result2?.rows || [];
  }
  mapCompletionIdArg(id, funcName) {
    const errorMessage = `${funcName}() requires an id`;
    assert(id, errorMessage);
    const ids = Array.isArray(id) ? id : [id];
    assert(ids.length, errorMessage);
    return ids;
  }
  mapCompletionDataArg(data) {
    if (data === null || typeof data === "undefined" || typeof data === "function") {
      return null;
    }
    const result2 = typeof data === "object" && !Array.isArray(data) ? data : { value: data };
    return serializeError(result2);
  }
  mapCommandResponse(ids, result2) {
    return {
      jobs: ids,
      requested: ids.length,
      affected: result2 && result2.rows ? parseInt(result2.rows[0].count) : 0
    };
  }
  async complete(name2, id, data, options = {}) {
    assertQueueName(name2);
    const db = this.assertDb(options);
    const ids = this.mapCompletionIdArg(id, "complete");
    const { table } = await this.getQueueCache(name2);
    const sql2 = completeJobs(this.config.schema, table, options.includeQueued);
    const result2 = await db.executeSql(sql2, [name2, ids, this.mapCompletionDataArg(data)]);
    return this.mapCommandResponse(ids, result2);
  }
  async fail(name2, id, data, options = {}) {
    assertQueueName(name2);
    const db = this.assertDb(options);
    const ids = this.mapCompletionIdArg(id, "fail");
    const { table } = await this.getQueueCache(name2);
    const sql2 = failJobsById(this.config.schema, table);
    const result2 = await db.executeSql(sql2, [name2, ids, this.mapCompletionDataArg(data)]);
    return this.mapCommandResponse(ids, result2);
  }
  async deleteJob(name2, id, options = {}) {
    assertQueueName(name2);
    const db = this.assertDb(options);
    const ids = this.mapCompletionIdArg(id, "deleteJob");
    const { table } = await this.getQueueCache(name2);
    const sql2 = deleteJobsById(this.config.schema, table);
    const result2 = await db.executeSql(sql2, [name2, ids]);
    return this.mapCommandResponse(ids, result2);
  }
  async cancel(name2, id, options = {}) {
    assertQueueName(name2);
    const db = this.assertDb(options);
    const ids = this.mapCompletionIdArg(id, "cancel");
    const { table } = await this.getQueueCache(name2);
    const sql2 = cancelJobs(this.config.schema, table);
    const result2 = await db.executeSql(sql2, [name2, ids]);
    return this.mapCommandResponse(ids, result2);
  }
  async resume(name2, id, options = {}) {
    assertQueueName(name2);
    const db = this.assertDb(options);
    const ids = this.mapCompletionIdArg(id, "resume");
    const { table } = await this.getQueueCache(name2);
    const sql2 = resumeJobs(this.config.schema, table);
    const result2 = await db.executeSql(sql2, [name2, ids]);
    return this.mapCommandResponse(ids, result2);
  }
  async restore(name2, id, options = {}) {
    assertQueueName(name2);
    const db = this.assertDb(options);
    const ids = this.mapCompletionIdArg(id, "restore");
    const { table } = await this.getQueueCache(name2);
    const sql2 = restoreJobs(this.config.schema, table);
    await db.executeSql(sql2, [name2, ids]);
  }
  async retry(name2, id, options = {}) {
    assertQueueName(name2);
    const db = options.db || this.db;
    const ids = this.mapCompletionIdArg(id, "retry");
    const { table } = await this.getQueueCache(name2);
    const sql2 = retryJobs(this.config.schema);
    const result2 = await db.executeSql(sql2, [name2, ids]);
    return this.mapCommandResponse(ids, result2);
  }
  async createQueue(name2, options = {}) {
    name2 = name2 || options.name;
    assertQueueName(name2);
    const policy = options.policy || QUEUE_POLICIES.standard;
    assert(policy in QUEUE_POLICIES, `${policy} is not a valid queue policy`);
    validateQueueArgs(options);
    if (options.deadLetter) {
      assertQueueName(options.deadLetter);
      notStrictEqual(name2, options.deadLetter, "deadLetter cannot be itself");
      await this.getQueueCache(options.deadLetter);
    }
    const sql2 = createQueue(this.config.schema, name2, { ...options, policy });
    await this.db.executeSql(sql2);
  }
  async getQueues(names) {
    names = Array.isArray(names) ? names : typeof names === "string" ? [names] : void 0;
    if (names) {
      for (const name2 of names) {
        assertQueueName(name2);
      }
    }
    const query2 = getQueues(this.config.schema, names);
    const { rows } = await this.db.executeSql(query2.text, query2.values);
    return rows;
  }
  async updateQueue(name2, options = {}) {
    assertQueueName(name2);
    assert(Object.keys(options).length > 0, "no properties found to update");
    if ("policy" in options) {
      throw new Error("queue policy cannot be changed after creation");
    }
    if ("partition" in options) {
      throw new Error("queue partitioning cannot be changed after creation");
    }
    validateQueueArgs(options);
    const { deadLetter } = options;
    if (deadLetter) {
      assertQueueName(deadLetter);
      notStrictEqual(name2, deadLetter, "deadLetter cannot be itself");
    }
    const sql2 = updateQueue(this.config.schema, { deadLetter });
    await this.db.executeSql(sql2, [name2, options]);
  }
  async getQueue(name2) {
    assertQueueName(name2);
    const query2 = getQueues(this.config.schema, [name2]);
    const { rows } = await this.db.executeSql(query2.text, query2.values);
    return rows[0] || null;
  }
  async deleteQueue(name2) {
    assertQueueName(name2);
    try {
      await this.getQueueCache(name2);
      const sql2 = deleteQueue(this.config.schema, name2);
      await this.db.executeSql(sql2);
    } catch {
    }
  }
  async deleteQueuedJobs(name2) {
    assertQueueName(name2);
    const { table } = await this.getQueueCache(name2);
    const sql2 = deleteQueuedJobs(this.config.schema, table);
    await this.db.executeSql(sql2, [name2]);
  }
  async deleteStoredJobs(name2) {
    assertQueueName(name2);
    const { table } = await this.getQueueCache(name2);
    const sql2 = deleteStoredJobs(this.config.schema, table);
    await this.db.executeSql(sql2, [name2]);
  }
  async deleteAllJobs(name2) {
    if (!name2) {
      const sql2 = truncateTable(this.config.schema, "job");
      await this.db.executeSql(sql2);
      return;
    }
    assertQueueName(name2);
    const { table, partition: partition2 } = await this.getQueueCache(name2);
    if (partition2) {
      const sql2 = truncateTable(this.config.schema, table);
      await this.db.executeSql(sql2);
    } else {
      const sql2 = deleteAllJobs(this.config.schema, table);
      await this.db.executeSql(sql2, [name2]);
    }
  }
  async getQueueStats(name2) {
    assertQueueName(name2);
    const queue = await this.getQueueCache(name2);
    const query2 = getQueueStats(this.config.schema, queue.table, [name2]);
    const { rows } = await this.db.executeSql(query2.text, query2.values);
    return Object.assign(queue, rows.at(0) || {
      deferredCount: 0,
      queuedCount: 0,
      activeCount: 0,
      totalCount: 0
    });
  }
  async getJobById(name2, id, options = {}) {
    assertQueueName(name2);
    const db = this.assertDb(options);
    const { table } = await this.getQueueCache(name2);
    const sql2 = getJobById(this.config.schema, table);
    const result1 = await db.executeSql(sql2, [name2, id]);
    if (result1?.rows?.length === 1) {
      return result1.rows[0];
    } else {
      return null;
    }
  }
  async findJobs(name2, options = {}) {
    assertQueueName(name2);
    const db = this.assertDb(options);
    const { table } = await this.getQueueCache(name2);
    const { id, key, data, queued = false } = options;
    const sql2 = findJobs(this.config.schema, table, {
      byId: id !== void 0,
      byKey: key !== void 0,
      byData: data !== void 0,
      queued
    });
    const values = [name2];
    if (id !== void 0)
      values.push(id);
    if (key !== void 0)
      values.push(key);
    if (data !== void 0)
      values.push(JSON.stringify(data));
    const result2 = await db.executeSql(sql2, values);
    return result2?.rows || [];
  }
  assertDb(options) {
    if (options.db) {
      return options.db;
    }
    if (this.db._pgbdb) {
      assert(this.db.opened, "Database connection is not opened");
    }
    return this.db;
  }
}
const events$2 = {
  error: "error",
  warning: "warning"
};
const WARNINGS = {
  SLOW_QUERY: { seconds: 30, message: "Warning: slow query. Your queues and/or database server should be reviewed" },
  LARGE_QUEUE: { size: 1e4, message: "Warning: large queue backlog. Your queue should be reviewed" }
};
class Boss extends EventEmitter {
  #stopped;
  #stopping;
  #maintaining;
  #superviseInterval;
  #db;
  #config;
  #manager;
  events = events$2;
  constructor(db, manager, config2) {
    super();
    this.#db = db;
    this.#config = config2;
    this.#manager = manager;
    this.#stopped = true;
    this.#stopping = false;
    if (config2.warningSlowQuerySeconds) {
      WARNINGS.SLOW_QUERY.seconds = config2.warningSlowQuerySeconds;
    }
    if (config2.warningQueueSize) {
      WARNINGS.LARGE_QUEUE.size = config2.warningQueueSize;
    }
  }
  async start() {
    if (this.#stopped) {
      this.#stopping = false;
      this.#superviseInterval = setInterval(() => this.#onSupervise(), this.#config.superviseIntervalSeconds * 1e3);
      this.#stopped = false;
    }
  }
  async stop() {
    if (!this.#stopped) {
      this.#stopping = true;
      if (this.#superviseInterval)
        clearInterval(this.#superviseInterval);
      this.#stopped = true;
    }
  }
  async #executeSql(sql2) {
    const started = Date.now();
    const result2 = unwrapSQLResult(await this.#db.executeSql(sql2));
    const elapsed = (Date.now() - started) / 1e3;
    if (elapsed > WARNINGS.SLOW_QUERY.seconds || this.#config.__test__warn_slow_query) {
      this.emit(events$2.warning, {
        message: WARNINGS.SLOW_QUERY.message,
        data: { elapsed, sql: sql2 }
      });
    }
    return result2;
  }
  async #executeQuery(query2) {
    const started = Date.now();
    const result2 = unwrapSQLResult(await this.#db.executeSql(query2.text, query2.values));
    const elapsed = (Date.now() - started) / 1e3;
    if (elapsed > WARNINGS.SLOW_QUERY.seconds || this.#config.__test__warn_slow_query) {
      this.emit(events$2.warning, {
        message: WARNINGS.SLOW_QUERY.message,
        data: { elapsed, sql: query2.text, values: query2.values }
      });
    }
    return result2;
  }
  async #onSupervise() {
    try {
      if (this.#stopped)
        return;
      if (this.#maintaining)
        return;
      if (this.#config.__test__throw_maint) {
        throw new Error(this.#config.__test__throw_maint);
      }
      this.#maintaining = true;
      const queues = await this.#manager.getQueues();
      !this.#stopped && await this.supervise(queues);
    } catch (err2) {
      this.emit(events$2.error, err2);
    } finally {
      this.#maintaining = false;
    }
  }
  async supervise(value) {
    let queues;
    if (Array.isArray(value)) {
      queues = value;
    } else {
      queues = await this.#manager.getQueues(value);
    }
    const queueGroups = queues.reduce((acc, q2) => {
      const { table } = q2;
      acc[table] = acc[table] || { table, queues: [] };
      acc[table].queues.push(q2);
      return acc;
    }, {});
    for (const queueGroup of Object.values(queueGroups)) {
      if (this.#stopping)
        return;
      const { table, queues: queues2 } = queueGroup;
      const names = queues2.map((i) => i.name);
      while (names.length) {
        if (this.#stopping)
          return;
        const chunk = names.splice(0, 100);
        await this.#monitor(table, chunk);
        await this.#maintain(table, chunk);
      }
    }
  }
  async #monitor(table, names) {
    if (this.#stopping)
      return;
    const command = trySetQueueMonitorTime(this.#config.schema, names, this.#config.monitorIntervalSeconds);
    const { rows } = await this.#executeQuery(command);
    if (this.#stopping)
      return;
    if (rows.length) {
      const queues = rows.map((q2) => q2.name);
      const cacheStatsSql = cacheQueueStats(this.#config.schema, table, queues);
      const { rows: rowsCacheStats } = await this.#executeSql(cacheStatsSql);
      if (this.#stopping)
        return;
      const warnings = rowsCacheStats.filter((i) => i.queuedCount > (i.warningQueueSize || WARNINGS.LARGE_QUEUE.size));
      for (const warning of warnings) {
        this.emit(events$2.warning, {
          message: WARNINGS.LARGE_QUEUE.message,
          data: warning
        });
      }
      const sql2 = failJobsByTimeout(this.#config.schema, table, queues);
      await this.#executeSql(sql2);
    }
  }
  async #maintain(table, names) {
    if (this.#stopping)
      return;
    const command = trySetQueueDeletionTime(this.#config.schema, names, this.#config.maintenanceIntervalSeconds);
    const { rows } = await this.#executeQuery(command);
    if (this.#stopping)
      return;
    if (rows.length) {
      const queues = rows.map((q2) => q2.name);
      const sql2 = deletion(this.#config.schema, table, queues);
      await this.#executeSql(sql2);
    }
  }
}
const events$1 = {
  error: "error",
  bam: "bam"
};
class Bam extends EventEmitter {
  #stopped;
  #working;
  #pollInterval;
  #db;
  #config;
  events = events$1;
  constructor(db, config2) {
    super();
    this.#db = db;
    this.#config = config2;
    this.#stopped = true;
    this.#working = false;
  }
  async start() {
    if (!this.#stopped)
      return;
    this.#stopped = false;
    setImmediate(() => this.#onPoll());
    this.#pollInterval = setInterval(() => this.#onPoll(), this.#config.bamIntervalSeconds * 1e3);
  }
  async stop() {
    if (this.#stopped)
      return;
    this.#stopped = true;
    if (this.#pollInterval) {
      clearInterval(this.#pollInterval);
      this.#pollInterval = void 0;
    }
  }
  async #onPoll() {
    if (this.#stopped || this.#working || !this.#config.migrate)
      return;
    this.#working = true;
    try {
      if (this.#config.__test__throw_bam) {
        throw new Error(this.#config.__test__throw_bam);
      }
      const sql2 = trySetBamTime(this.#config.schema, this.#config.bamIntervalSeconds);
      const { rows } = await this.#db.executeSql(sql2);
      if (rows.length === 1) {
        await this.#processCommands();
      }
    } catch (err2) {
      this.emit(events$1.error, err2);
    } finally {
      this.#working = false;
    }
  }
  async #processCommands() {
    if (this.#stopped)
      return;
    const entry = await this.#getNextCommand();
    if (!entry || this.#stopped)
      return;
    this.emit(events$1.bam, {
      id: entry.id,
      name: entry.name,
      status: "in_progress",
      queue: entry.queue,
      table: entry.table
    });
    try {
      await this.#db.executeSql(entry.command);
      if (this.#stopped)
        return;
      await this.#markCompleted(entry.id);
      this.emit(events$1.bam, {
        id: entry.id,
        name: entry.name,
        status: "completed",
        queue: entry.queue,
        table: entry.table
      });
    } catch (err2) {
      if (this.#stopped)
        return;
      await this.#markFailed(entry.id, err2);
      this.emit(events$1.error, err2);
      this.emit(events$1.bam, {
        id: entry.id,
        name: entry.name,
        status: "failed",
        queue: entry.queue,
        table: entry.table,
        error: String(err2)
      });
    }
  }
  async #getNextCommand() {
    const sql2 = getNextBamCommand(this.#config.schema);
    const { rows } = await this.#db.executeSql(sql2);
    return rows[0] || null;
  }
  async #markCompleted(id) {
    const sql2 = setBamCompleted(this.#config.schema, id);
    await this.#db.executeSql(sql2);
  }
  async #markFailed(id, error2) {
    const sql2 = setBamFailed(this.#config.schema, id, String(error2));
    await this.#db.executeSql(sql2);
  }
}
var lib$1 = { exports: {} };
var defaults$1 = { exports: {} };
var pgTypes = {};
var postgresArray = {};
var hasRequiredPostgresArray;
function requirePostgresArray() {
  if (hasRequiredPostgresArray) return postgresArray;
  hasRequiredPostgresArray = 1;
  postgresArray.parse = function(source, transform2) {
    return new ArrayParser(source, transform2).parse();
  };
  class ArrayParser {
    constructor(source, transform2) {
      this.source = source;
      this.transform = transform2 || identity;
      this.position = 0;
      this.entries = [];
      this.recorded = [];
      this.dimension = 0;
    }
    isEof() {
      return this.position >= this.source.length;
    }
    nextCharacter() {
      var character = this.source[this.position++];
      if (character === "\\") {
        return {
          value: this.source[this.position++],
          escaped: true
        };
      }
      return {
        value: character,
        escaped: false
      };
    }
    record(character) {
      this.recorded.push(character);
    }
    newEntry(includeEmpty) {
      var entry;
      if (this.recorded.length > 0 || includeEmpty) {
        entry = this.recorded.join("");
        if (entry === "NULL" && !includeEmpty) {
          entry = null;
        }
        if (entry !== null) entry = this.transform(entry);
        this.entries.push(entry);
        this.recorded = [];
      }
    }
    consumeDimensions() {
      if (this.source[0] === "[") {
        while (!this.isEof()) {
          var char2 = this.nextCharacter();
          if (char2.value === "=") break;
        }
      }
    }
    parse(nested) {
      var character, parser2, quote;
      this.consumeDimensions();
      while (!this.isEof()) {
        character = this.nextCharacter();
        if (character.value === "{" && !quote) {
          this.dimension++;
          if (this.dimension > 1) {
            parser2 = new ArrayParser(this.source.substr(this.position - 1), this.transform);
            this.entries.push(parser2.parse(true));
            this.position += parser2.position - 2;
          }
        } else if (character.value === "}" && !quote) {
          this.dimension--;
          if (!this.dimension) {
            this.newEntry();
            if (nested) return this.entries;
          }
        } else if (character.value === '"' && !character.escaped) {
          if (quote) this.newEntry(true);
          quote = !quote;
        } else if (character.value === "," && !quote) {
          this.newEntry();
        } else {
          this.record(character.value);
        }
      }
      if (this.dimension !== 0) {
        throw new Error("array dimension not balanced");
      }
      return this.entries;
    }
  }
  function identity(value) {
    return value;
  }
  return postgresArray;
}
var arrayParser;
var hasRequiredArrayParser;
function requireArrayParser() {
  if (hasRequiredArrayParser) return arrayParser;
  hasRequiredArrayParser = 1;
  var array = requirePostgresArray();
  arrayParser = {
    create: function(source, transform2) {
      return {
        parse: function() {
          return array.parse(source, transform2);
        }
      };
    }
  };
  return arrayParser;
}
var postgresDate;
var hasRequiredPostgresDate;
function requirePostgresDate() {
  if (hasRequiredPostgresDate) return postgresDate;
  hasRequiredPostgresDate = 1;
  var DATE_TIME = /(\d{1,})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})(\.\d{1,})?.*?( BC)?$/;
  var DATE = /^(\d{1,})-(\d{2})-(\d{2})( BC)?$/;
  var TIME_ZONE = /([Z+-])(\d{2})?:?(\d{2})?:?(\d{2})?/;
  var INFINITY = /^-?infinity$/;
  postgresDate = function parseDate(isoDate) {
    if (INFINITY.test(isoDate)) {
      return Number(isoDate.replace("i", "I"));
    }
    var matches = DATE_TIME.exec(isoDate);
    if (!matches) {
      return getDate2(isoDate) || null;
    }
    var isBC = !!matches[8];
    var year2 = parseInt(matches[1], 10);
    if (isBC) {
      year2 = bcYearToNegativeYear(year2);
    }
    var month = parseInt(matches[2], 10) - 1;
    var day2 = matches[3];
    var hour2 = parseInt(matches[4], 10);
    var minute2 = parseInt(matches[5], 10);
    var second = parseInt(matches[6], 10);
    var ms2 = matches[7];
    ms2 = ms2 ? 1e3 * parseFloat(ms2) : 0;
    var date2;
    var offset2 = timeZoneOffset(isoDate);
    if (offset2 != null) {
      date2 = new Date(Date.UTC(year2, month, day2, hour2, minute2, second, ms2));
      if (is0To99(year2)) {
        date2.setUTCFullYear(year2);
      }
      if (offset2 !== 0) {
        date2.setTime(date2.getTime() - offset2);
      }
    } else {
      date2 = new Date(year2, month, day2, hour2, minute2, second, ms2);
      if (is0To99(year2)) {
        date2.setFullYear(year2);
      }
    }
    return date2;
  };
  function getDate2(isoDate) {
    var matches = DATE.exec(isoDate);
    if (!matches) {
      return;
    }
    var year2 = parseInt(matches[1], 10);
    var isBC = !!matches[4];
    if (isBC) {
      year2 = bcYearToNegativeYear(year2);
    }
    var month = parseInt(matches[2], 10) - 1;
    var day2 = matches[3];
    var date2 = new Date(year2, month, day2);
    if (is0To99(year2)) {
      date2.setFullYear(year2);
    }
    return date2;
  }
  function timeZoneOffset(isoDate) {
    if (isoDate.endsWith("+00")) {
      return 0;
    }
    var zone = TIME_ZONE.exec(isoDate.split(" ")[1]);
    if (!zone) return;
    var type2 = zone[1];
    if (type2 === "Z") {
      return 0;
    }
    var sign2 = type2 === "-" ? -1 : 1;
    var offset2 = parseInt(zone[2], 10) * 3600 + parseInt(zone[3] || 0, 10) * 60 + parseInt(zone[4] || 0, 10);
    return offset2 * sign2 * 1e3;
  }
  function bcYearToNegativeYear(year2) {
    return -(year2 - 1);
  }
  function is0To99(num) {
    return num >= 0 && num < 100;
  }
  return postgresDate;
}
var mutable;
var hasRequiredMutable;
function requireMutable() {
  if (hasRequiredMutable) return mutable;
  hasRequiredMutable = 1;
  mutable = extend;
  var hasOwnProperty2 = Object.prototype.hasOwnProperty;
  function extend(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (hasOwnProperty2.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  }
  return mutable;
}
var postgresInterval;
var hasRequiredPostgresInterval;
function requirePostgresInterval() {
  if (hasRequiredPostgresInterval) return postgresInterval;
  hasRequiredPostgresInterval = 1;
  var extend = requireMutable();
  postgresInterval = PostgresInterval;
  function PostgresInterval(raw) {
    if (!(this instanceof PostgresInterval)) {
      return new PostgresInterval(raw);
    }
    extend(this, parse2(raw));
  }
  var properties = ["seconds", "minutes", "hours", "days", "months", "years"];
  PostgresInterval.prototype.toPostgres = function() {
    var filtered = properties.filter(this.hasOwnProperty, this);
    if (this.milliseconds && filtered.indexOf("seconds") < 0) {
      filtered.push("seconds");
    }
    if (filtered.length === 0) return "0";
    return filtered.map(function(property) {
      var value = this[property] || 0;
      if (property === "seconds" && this.milliseconds) {
        value = (value + this.milliseconds / 1e3).toFixed(6).replace(/\.?0+$/, "");
      }
      return value + " " + property;
    }, this).join(" ");
  };
  var propertiesISOEquivalent = {
    years: "Y",
    months: "M",
    days: "D",
    hours: "H",
    minutes: "M",
    seconds: "S"
  };
  var dateProperties = ["years", "months", "days"];
  var timeProperties = ["hours", "minutes", "seconds"];
  PostgresInterval.prototype.toISOString = PostgresInterval.prototype.toISO = function() {
    var datePart = dateProperties.map(buildProperty, this).join("");
    var timePart = timeProperties.map(buildProperty, this).join("");
    return "P" + datePart + "T" + timePart;
    function buildProperty(property) {
      var value = this[property] || 0;
      if (property === "seconds" && this.milliseconds) {
        value = (value + this.milliseconds / 1e3).toFixed(6).replace(/0+$/, "");
      }
      return value + propertiesISOEquivalent[property];
    }
  };
  var NUMBER = "([+-]?\\d+)";
  var YEAR2 = NUMBER + "\\s+years?";
  var MONTH2 = NUMBER + "\\s+mons?";
  var DAY2 = NUMBER + "\\s+days?";
  var TIME = "([+-])?([\\d]*):(\\d\\d):(\\d\\d)\\.?(\\d{1,6})?";
  var INTERVAL = new RegExp([YEAR2, MONTH2, DAY2, TIME].map(function(regexString) {
    return "(" + regexString + ")?";
  }).join("\\s*"));
  var positions = {
    years: 2,
    months: 4,
    days: 6,
    hours: 9,
    minutes: 10,
    seconds: 11,
    milliseconds: 12
  };
  var negatives = ["hours", "minutes", "seconds", "milliseconds"];
  function parseMilliseconds(fraction) {
    var microseconds = fraction + "000000".slice(fraction.length);
    return parseInt(microseconds, 10) / 1e3;
  }
  function parse2(interval) {
    if (!interval) return {};
    var matches = INTERVAL.exec(interval);
    var isNegative = matches[8] === "-";
    return Object.keys(positions).reduce(function(parsed, property) {
      var position = positions[property];
      var value = matches[position];
      if (!value) return parsed;
      value = property === "milliseconds" ? parseMilliseconds(value) : parseInt(value, 10);
      if (!value) return parsed;
      if (isNegative && ~negatives.indexOf(property)) {
        value *= -1;
      }
      parsed[property] = value;
      return parsed;
    }, {});
  }
  return postgresInterval;
}
var postgresBytea;
var hasRequiredPostgresBytea;
function requirePostgresBytea() {
  if (hasRequiredPostgresBytea) return postgresBytea;
  hasRequiredPostgresBytea = 1;
  var bufferFrom = Buffer.from || Buffer;
  postgresBytea = function parseBytea(input) {
    if (/^\\x/.test(input)) {
      return bufferFrom(input.substr(2), "hex");
    }
    var output = "";
    var i = 0;
    while (i < input.length) {
      if (input[i] !== "\\") {
        output += input[i];
        ++i;
      } else {
        if (/[0-7]{3}/.test(input.substr(i + 1, 3))) {
          output += String.fromCharCode(parseInt(input.substr(i + 1, 3), 8));
          i += 4;
        } else {
          var backslashes = 1;
          while (i + backslashes < input.length && input[i + backslashes] === "\\") {
            backslashes++;
          }
          for (var k = 0; k < Math.floor(backslashes / 2); ++k) {
            output += "\\";
          }
          i += Math.floor(backslashes / 2) * 2;
        }
      }
    }
    return bufferFrom(output, "binary");
  };
  return postgresBytea;
}
var textParsers;
var hasRequiredTextParsers;
function requireTextParsers() {
  if (hasRequiredTextParsers) return textParsers;
  hasRequiredTextParsers = 1;
  var array = requirePostgresArray();
  var arrayParser2 = requireArrayParser();
  var parseDate = requirePostgresDate();
  var parseInterval = requirePostgresInterval();
  var parseByteA = requirePostgresBytea();
  function allowNull(fn2) {
    return function nullAllowed(value) {
      if (value === null) return value;
      return fn2(value);
    };
  }
  function parseBool(value) {
    if (value === null) return value;
    return value === "TRUE" || value === "t" || value === "true" || value === "y" || value === "yes" || value === "on" || value === "1";
  }
  function parseBoolArray(value) {
    if (!value) return null;
    return array.parse(value, parseBool);
  }
  function parseBaseTenInt(string) {
    return parseInt(string, 10);
  }
  function parseIntegerArray(value) {
    if (!value) return null;
    return array.parse(value, allowNull(parseBaseTenInt));
  }
  function parseBigIntegerArray(value) {
    if (!value) return null;
    return array.parse(value, allowNull(function(entry) {
      return parseBigInteger(entry).trim();
    }));
  }
  var parsePointArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser2.create(value, function(entry) {
      if (entry !== null) {
        entry = parsePoint(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseFloatArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser2.create(value, function(entry) {
      if (entry !== null) {
        entry = parseFloat(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseStringArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser2.create(value);
    return p.parse();
  };
  var parseDateArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser2.create(value, function(entry) {
      if (entry !== null) {
        entry = parseDate(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseIntervalArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser2.create(value, function(entry) {
      if (entry !== null) {
        entry = parseInterval(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseByteAArray = function(value) {
    if (!value) {
      return null;
    }
    return array.parse(value, allowNull(parseByteA));
  };
  var parseInteger2 = function(value) {
    return parseInt(value, 10);
  };
  var parseBigInteger = function(value) {
    var valStr = String(value);
    if (/^\d+$/.test(valStr)) {
      return valStr;
    }
    return value;
  };
  var parseJsonArray = function(value) {
    if (!value) {
      return null;
    }
    return array.parse(value, allowNull(JSON.parse));
  };
  var parsePoint = function(value) {
    if (value[0] !== "(") {
      return null;
    }
    value = value.substring(1, value.length - 1).split(",");
    return {
      x: parseFloat(value[0]),
      y: parseFloat(value[1])
    };
  };
  var parseCircle = function(value) {
    if (value[0] !== "<" && value[1] !== "(") {
      return null;
    }
    var point = "(";
    var radius = "";
    var pointParsed = false;
    for (var i = 2; i < value.length - 1; i++) {
      if (!pointParsed) {
        point += value[i];
      }
      if (value[i] === ")") {
        pointParsed = true;
        continue;
      } else if (!pointParsed) {
        continue;
      }
      if (value[i] === ",") {
        continue;
      }
      radius += value[i];
    }
    var result2 = parsePoint(point);
    result2.radius = parseFloat(radius);
    return result2;
  };
  var init2 = function(register) {
    register(20, parseBigInteger);
    register(21, parseInteger2);
    register(23, parseInteger2);
    register(26, parseInteger2);
    register(700, parseFloat);
    register(701, parseFloat);
    register(16, parseBool);
    register(1082, parseDate);
    register(1114, parseDate);
    register(1184, parseDate);
    register(600, parsePoint);
    register(651, parseStringArray);
    register(718, parseCircle);
    register(1e3, parseBoolArray);
    register(1001, parseByteAArray);
    register(1005, parseIntegerArray);
    register(1007, parseIntegerArray);
    register(1028, parseIntegerArray);
    register(1016, parseBigIntegerArray);
    register(1017, parsePointArray);
    register(1021, parseFloatArray);
    register(1022, parseFloatArray);
    register(1231, parseFloatArray);
    register(1014, parseStringArray);
    register(1015, parseStringArray);
    register(1008, parseStringArray);
    register(1009, parseStringArray);
    register(1040, parseStringArray);
    register(1041, parseStringArray);
    register(1115, parseDateArray);
    register(1182, parseDateArray);
    register(1185, parseDateArray);
    register(1186, parseInterval);
    register(1187, parseIntervalArray);
    register(17, parseByteA);
    register(114, JSON.parse.bind(JSON));
    register(3802, JSON.parse.bind(JSON));
    register(199, parseJsonArray);
    register(3807, parseJsonArray);
    register(3907, parseStringArray);
    register(2951, parseStringArray);
    register(791, parseStringArray);
    register(1183, parseStringArray);
    register(1270, parseStringArray);
  };
  textParsers = {
    init: init2
  };
  return textParsers;
}
var pgInt8;
var hasRequiredPgInt8;
function requirePgInt8() {
  if (hasRequiredPgInt8) return pgInt8;
  hasRequiredPgInt8 = 1;
  var BASE = 1e6;
  function readInt8(buffer) {
    var high = buffer.readInt32BE(0);
    var low = buffer.readUInt32BE(4);
    var sign2 = "";
    if (high < 0) {
      high = ~high + (low === 0);
      low = ~low + 1 >>> 0;
      sign2 = "-";
    }
    var result2 = "";
    var carry;
    var t2;
    var digits;
    var pad;
    var l2;
    var i;
    {
      carry = high % BASE;
      high = high / BASE >>> 0;
      t2 = 4294967296 * carry + low;
      low = t2 / BASE >>> 0;
      digits = "" + (t2 - BASE * low);
      if (low === 0 && high === 0) {
        return sign2 + digits + result2;
      }
      pad = "";
      l2 = 6 - digits.length;
      for (i = 0; i < l2; i++) {
        pad += "0";
      }
      result2 = pad + digits + result2;
    }
    {
      carry = high % BASE;
      high = high / BASE >>> 0;
      t2 = 4294967296 * carry + low;
      low = t2 / BASE >>> 0;
      digits = "" + (t2 - BASE * low);
      if (low === 0 && high === 0) {
        return sign2 + digits + result2;
      }
      pad = "";
      l2 = 6 - digits.length;
      for (i = 0; i < l2; i++) {
        pad += "0";
      }
      result2 = pad + digits + result2;
    }
    {
      carry = high % BASE;
      high = high / BASE >>> 0;
      t2 = 4294967296 * carry + low;
      low = t2 / BASE >>> 0;
      digits = "" + (t2 - BASE * low);
      if (low === 0 && high === 0) {
        return sign2 + digits + result2;
      }
      pad = "";
      l2 = 6 - digits.length;
      for (i = 0; i < l2; i++) {
        pad += "0";
      }
      result2 = pad + digits + result2;
    }
    {
      carry = high % BASE;
      t2 = 4294967296 * carry + low;
      digits = "" + t2 % BASE;
      return sign2 + digits + result2;
    }
  }
  pgInt8 = readInt8;
  return pgInt8;
}
var binaryParsers;
var hasRequiredBinaryParsers;
function requireBinaryParsers() {
  if (hasRequiredBinaryParsers) return binaryParsers;
  hasRequiredBinaryParsers = 1;
  var parseInt64 = requirePgInt8();
  var parseBits = function(data, bits, offset2, invert, callback) {
    offset2 = offset2 || 0;
    invert = invert || false;
    callback = callback || function(lastValue, newValue, bits2) {
      return lastValue * Math.pow(2, bits2) + newValue;
    };
    var offsetBytes = offset2 >> 3;
    var inv = function(value) {
      if (invert) {
        return ~value & 255;
      }
      return value;
    };
    var mask = 255;
    var firstBits = 8 - offset2 % 8;
    if (bits < firstBits) {
      mask = 255 << 8 - bits & 255;
      firstBits = bits;
    }
    if (offset2) {
      mask = mask >> offset2 % 8;
    }
    var result2 = 0;
    if (offset2 % 8 + bits >= 8) {
      result2 = callback(0, inv(data[offsetBytes]) & mask, firstBits);
    }
    var bytes = bits + offset2 >> 3;
    for (var i = offsetBytes + 1; i < bytes; i++) {
      result2 = callback(result2, inv(data[i]), 8);
    }
    var lastBits = (bits + offset2) % 8;
    if (lastBits > 0) {
      result2 = callback(result2, inv(data[bytes]) >> 8 - lastBits, lastBits);
    }
    return result2;
  };
  var parseFloatFromBits = function(data, precisionBits, exponentBits) {
    var bias = Math.pow(2, exponentBits - 1) - 1;
    var sign2 = parseBits(data, 1);
    var exponent = parseBits(data, exponentBits, 1);
    if (exponent === 0) {
      return 0;
    }
    var precisionBitsCounter = 1;
    var parsePrecisionBits = function(lastValue, newValue, bits) {
      if (lastValue === 0) {
        lastValue = 1;
      }
      for (var i = 1; i <= bits; i++) {
        precisionBitsCounter /= 2;
        if ((newValue & 1 << bits - i) > 0) {
          lastValue += precisionBitsCounter;
        }
      }
      return lastValue;
    };
    var mantissa = parseBits(data, precisionBits, exponentBits + 1, false, parsePrecisionBits);
    if (exponent == Math.pow(2, exponentBits + 1) - 1) {
      if (mantissa === 0) {
        return sign2 === 0 ? Infinity : -Infinity;
      }
      return NaN;
    }
    return (sign2 === 0 ? 1 : -1) * Math.pow(2, exponent - bias) * mantissa;
  };
  var parseInt16 = function(value) {
    if (parseBits(value, 1) == 1) {
      return -1 * (parseBits(value, 15, 1, true) + 1);
    }
    return parseBits(value, 15, 1);
  };
  var parseInt32 = function(value) {
    if (parseBits(value, 1) == 1) {
      return -1 * (parseBits(value, 31, 1, true) + 1);
    }
    return parseBits(value, 31, 1);
  };
  var parseFloat32 = function(value) {
    return parseFloatFromBits(value, 23, 8);
  };
  var parseFloat64 = function(value) {
    return parseFloatFromBits(value, 52, 11);
  };
  var parseNumeric = function(value) {
    var sign2 = parseBits(value, 16, 32);
    if (sign2 == 49152) {
      return NaN;
    }
    var weight = Math.pow(1e4, parseBits(value, 16, 16));
    var result2 = 0;
    var ndigits = parseBits(value, 16);
    for (var i = 0; i < ndigits; i++) {
      result2 += parseBits(value, 16, 64 + 16 * i) * weight;
      weight /= 1e4;
    }
    var scale = Math.pow(10, parseBits(value, 16, 48));
    return (sign2 === 0 ? 1 : -1) * Math.round(result2 * scale) / scale;
  };
  var parseDate = function(isUTC, value) {
    var sign2 = parseBits(value, 1);
    var rawValue = parseBits(value, 63, 1);
    var result2 = new Date((sign2 === 0 ? 1 : -1) * rawValue / 1e3 + 9466848e5);
    if (!isUTC) {
      result2.setTime(result2.getTime() + result2.getTimezoneOffset() * 6e4);
    }
    result2.usec = rawValue % 1e3;
    result2.getMicroSeconds = function() {
      return this.usec;
    };
    result2.setMicroSeconds = function(value2) {
      this.usec = value2;
    };
    result2.getUTCMicroSeconds = function() {
      return this.usec;
    };
    return result2;
  };
  var parseArray = function(value) {
    var dim = parseBits(value, 32);
    parseBits(value, 32, 32);
    var elementType = parseBits(value, 32, 64);
    var offset2 = 96;
    var dims = [];
    for (var i = 0; i < dim; i++) {
      dims[i] = parseBits(value, 32, offset2);
      offset2 += 32;
      offset2 += 32;
    }
    var parseElement = function(elementType2) {
      var length = parseBits(value, 32, offset2);
      offset2 += 32;
      if (length == 4294967295) {
        return null;
      }
      var result2;
      if (elementType2 == 23 || elementType2 == 20) {
        result2 = parseBits(value, length * 8, offset2);
        offset2 += length * 8;
        return result2;
      } else if (elementType2 == 25) {
        result2 = value.toString(this.encoding, offset2 >> 3, (offset2 += length << 3) >> 3);
        return result2;
      } else {
        console.log("ERROR: ElementType not implemented: " + elementType2);
      }
    };
    var parse2 = function(dimension, elementType2) {
      var array = [];
      var i2;
      if (dimension.length > 1) {
        var count2 = dimension.shift();
        for (i2 = 0; i2 < count2; i2++) {
          array[i2] = parse2(dimension, elementType2);
        }
        dimension.unshift(count2);
      } else {
        for (i2 = 0; i2 < dimension[0]; i2++) {
          array[i2] = parseElement(elementType2);
        }
      }
      return array;
    };
    return parse2(dims, elementType);
  };
  var parseText = function(value) {
    return value.toString("utf8");
  };
  var parseBool = function(value) {
    if (value === null) return null;
    return parseBits(value, 8) > 0;
  };
  var init2 = function(register) {
    register(20, parseInt64);
    register(21, parseInt16);
    register(23, parseInt32);
    register(26, parseInt32);
    register(1700, parseNumeric);
    register(700, parseFloat32);
    register(701, parseFloat64);
    register(16, parseBool);
    register(1114, parseDate.bind(null, false));
    register(1184, parseDate.bind(null, true));
    register(1e3, parseArray);
    register(1007, parseArray);
    register(1016, parseArray);
    register(1008, parseArray);
    register(1009, parseArray);
    register(25, parseText);
  };
  binaryParsers = {
    init: init2
  };
  return binaryParsers;
}
var builtins;
var hasRequiredBuiltins;
function requireBuiltins() {
  if (hasRequiredBuiltins) return builtins;
  hasRequiredBuiltins = 1;
  builtins = {
    BOOL: 16,
    BYTEA: 17,
    CHAR: 18,
    INT8: 20,
    INT2: 21,
    INT4: 23,
    REGPROC: 24,
    TEXT: 25,
    OID: 26,
    TID: 27,
    XID: 28,
    CID: 29,
    JSON: 114,
    XML: 142,
    PG_NODE_TREE: 194,
    SMGR: 210,
    PATH: 602,
    POLYGON: 604,
    CIDR: 650,
    FLOAT4: 700,
    FLOAT8: 701,
    ABSTIME: 702,
    RELTIME: 703,
    TINTERVAL: 704,
    CIRCLE: 718,
    MACADDR8: 774,
    MONEY: 790,
    MACADDR: 829,
    INET: 869,
    ACLITEM: 1033,
    BPCHAR: 1042,
    VARCHAR: 1043,
    DATE: 1082,
    TIME: 1083,
    TIMESTAMP: 1114,
    TIMESTAMPTZ: 1184,
    INTERVAL: 1186,
    TIMETZ: 1266,
    BIT: 1560,
    VARBIT: 1562,
    NUMERIC: 1700,
    REFCURSOR: 1790,
    REGPROCEDURE: 2202,
    REGOPER: 2203,
    REGOPERATOR: 2204,
    REGCLASS: 2205,
    REGTYPE: 2206,
    UUID: 2950,
    TXID_SNAPSHOT: 2970,
    PG_LSN: 3220,
    PG_NDISTINCT: 3361,
    PG_DEPENDENCIES: 3402,
    TSVECTOR: 3614,
    TSQUERY: 3615,
    GTSVECTOR: 3642,
    REGCONFIG: 3734,
    REGDICTIONARY: 3769,
    JSONB: 3802,
    REGNAMESPACE: 4089,
    REGROLE: 4096
  };
  return builtins;
}
var hasRequiredPgTypes;
function requirePgTypes() {
  if (hasRequiredPgTypes) return pgTypes;
  hasRequiredPgTypes = 1;
  var textParsers2 = requireTextParsers();
  var binaryParsers2 = requireBinaryParsers();
  var arrayParser2 = requireArrayParser();
  var builtinTypes = requireBuiltins();
  pgTypes.getTypeParser = getTypeParser;
  pgTypes.setTypeParser = setTypeParser;
  pgTypes.arrayParser = arrayParser2;
  pgTypes.builtins = builtinTypes;
  var typeParsers = {
    text: {},
    binary: {}
  };
  function noParse(val) {
    return String(val);
  }
  function getTypeParser(oid, format2) {
    format2 = format2 || "text";
    if (!typeParsers[format2]) {
      return noParse;
    }
    return typeParsers[format2][oid] || noParse;
  }
  function setTypeParser(oid, format2, parseFn) {
    if (typeof format2 == "function") {
      parseFn = format2;
      format2 = "text";
    }
    typeParsers[format2][oid] = parseFn;
  }
  textParsers2.init(function(oid, converter) {
    typeParsers.text[oid] = converter;
  });
  binaryParsers2.init(function(oid, converter) {
    typeParsers.binary[oid] = converter;
  });
  return pgTypes;
}
var hasRequiredDefaults;
function requireDefaults() {
  if (hasRequiredDefaults) return defaults$1.exports;
  hasRequiredDefaults = 1;
  (function(module) {
    let user;
    try {
      user = process.platform === "win32" ? process.env.USERNAME : process.env.USER;
    } catch {
    }
    module.exports = {
      // database host. defaults to localhost
      host: "localhost",
      // database user's name
      user,
      // name of database to connect
      database: void 0,
      // database user's password
      password: null,
      // a Postgres connection string to be used instead of setting individual connection items
      // NOTE:  Setting this value will cause it to override any other value (such as database or user) defined
      // in the defaults object.
      connectionString: void 0,
      // database port
      port: 5432,
      // number of rows to return at a time from a prepared statement's
      // portal. 0 will return all rows at once
      rows: 0,
      // binary result mode
      binary: false,
      // Connection pool options - see https://github.com/brianc/node-pg-pool
      // number of connections to use in connection pool
      // 0 will disable connection pooling
      max: 10,
      // max milliseconds a client can go unused before it is removed
      // from the pool and destroyed
      idleTimeoutMillis: 3e4,
      client_encoding: "",
      ssl: false,
      application_name: void 0,
      fallback_application_name: void 0,
      options: void 0,
      parseInputDatesAsUTC: false,
      // max milliseconds any query using this connection will execute for before timing out in error.
      // false=unlimited
      statement_timeout: false,
      // Abort any statement that waits longer than the specified duration in milliseconds while attempting to acquire a lock.
      // false=unlimited
      lock_timeout: false,
      // Terminate any session with an open transaction that has been idle for longer than the specified duration in milliseconds
      // false=unlimited
      idle_in_transaction_session_timeout: false,
      // max milliseconds to wait for query to complete (client side)
      query_timeout: false,
      connect_timeout: 0,
      keepalives: 1,
      keepalives_idle: 0
    };
    const pgTypes2 = requirePgTypes();
    const parseBigInteger = pgTypes2.getTypeParser(20, "text");
    const parseBigIntegerArray = pgTypes2.getTypeParser(1016, "text");
    module.exports.__defineSetter__("parseInt8", function(val) {
      pgTypes2.setTypeParser(20, "text", val ? pgTypes2.getTypeParser(23, "text") : parseBigInteger);
      pgTypes2.setTypeParser(1016, "text", val ? pgTypes2.getTypeParser(1007, "text") : parseBigIntegerArray);
    });
  })(defaults$1);
  return defaults$1.exports;
}
var utils$1;
var hasRequiredUtils$1;
function requireUtils$1() {
  if (hasRequiredUtils$1) return utils$1;
  hasRequiredUtils$1 = 1;
  const defaults2 = requireDefaults();
  const util = require$$1$1;
  const { isDate: isDate2 } = util.types || util;
  function escapeElement(elementRepresentation) {
    const escaped = elementRepresentation.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
    return '"' + escaped + '"';
  }
  function arrayString(val) {
    let result2 = "{";
    for (let i = 0; i < val.length; i++) {
      if (i > 0) {
        result2 = result2 + ",";
      }
      if (val[i] === null || typeof val[i] === "undefined") {
        result2 = result2 + "NULL";
      } else if (Array.isArray(val[i])) {
        result2 = result2 + arrayString(val[i]);
      } else if (ArrayBuffer.isView(val[i])) {
        let item = val[i];
        if (!(item instanceof Buffer)) {
          const buf = Buffer.from(item.buffer, item.byteOffset, item.byteLength);
          if (buf.length === item.byteLength) {
            item = buf;
          } else {
            item = buf.slice(item.byteOffset, item.byteOffset + item.byteLength);
          }
        }
        result2 += "\\\\x" + item.toString("hex");
      } else {
        result2 += escapeElement(prepareValue(val[i]));
      }
    }
    result2 = result2 + "}";
    return result2;
  }
  const prepareValue = function(val, seen) {
    if (val == null) {
      return null;
    }
    if (typeof val === "object") {
      if (val instanceof Buffer) {
        return val;
      }
      if (ArrayBuffer.isView(val)) {
        const buf = Buffer.from(val.buffer, val.byteOffset, val.byteLength);
        if (buf.length === val.byteLength) {
          return buf;
        }
        return buf.slice(val.byteOffset, val.byteOffset + val.byteLength);
      }
      if (isDate2(val)) {
        if (defaults2.parseInputDatesAsUTC) {
          return dateToStringUTC(val);
        } else {
          return dateToString(val);
        }
      }
      if (Array.isArray(val)) {
        return arrayString(val);
      }
      return prepareObject(val, seen);
    }
    return val.toString();
  };
  function prepareObject(val, seen) {
    if (val && typeof val.toPostgres === "function") {
      seen = seen || [];
      if (seen.indexOf(val) !== -1) {
        throw new Error('circular reference detected while preparing "' + val + '" for query');
      }
      seen.push(val);
      return prepareValue(val.toPostgres(prepareValue), seen);
    }
    return JSON.stringify(val);
  }
  function dateToString(date2) {
    let offset2 = -date2.getTimezoneOffset();
    let year2 = date2.getFullYear();
    const isBCYear = year2 < 1;
    if (isBCYear) year2 = Math.abs(year2) + 1;
    let ret = String(year2).padStart(4, "0") + "-" + String(date2.getMonth() + 1).padStart(2, "0") + "-" + String(date2.getDate()).padStart(2, "0") + "T" + String(date2.getHours()).padStart(2, "0") + ":" + String(date2.getMinutes()).padStart(2, "0") + ":" + String(date2.getSeconds()).padStart(2, "0") + "." + String(date2.getMilliseconds()).padStart(3, "0");
    if (offset2 < 0) {
      ret += "-";
      offset2 *= -1;
    } else {
      ret += "+";
    }
    ret += String(Math.floor(offset2 / 60)).padStart(2, "0") + ":" + String(offset2 % 60).padStart(2, "0");
    if (isBCYear) ret += " BC";
    return ret;
  }
  function dateToStringUTC(date2) {
    let year2 = date2.getUTCFullYear();
    const isBCYear = year2 < 1;
    if (isBCYear) year2 = Math.abs(year2) + 1;
    let ret = String(year2).padStart(4, "0") + "-" + String(date2.getUTCMonth() + 1).padStart(2, "0") + "-" + String(date2.getUTCDate()).padStart(2, "0") + "T" + String(date2.getUTCHours()).padStart(2, "0") + ":" + String(date2.getUTCMinutes()).padStart(2, "0") + ":" + String(date2.getUTCSeconds()).padStart(2, "0") + "." + String(date2.getUTCMilliseconds()).padStart(3, "0");
    ret += "+00:00";
    if (isBCYear) ret += " BC";
    return ret;
  }
  function normalizeQueryConfig(config2, values, callback) {
    config2 = typeof config2 === "string" ? { text: config2 } : config2;
    if (values) {
      if (typeof values === "function") {
        config2.callback = values;
      } else {
        config2.values = values;
      }
    }
    if (callback) {
      config2.callback = callback;
    }
    return config2;
  }
  const escapeIdentifier2 = function(str) {
    return '"' + str.replace(/"/g, '""') + '"';
  };
  const escapeLiteral2 = function(str) {
    let hasBackslash = false;
    let escaped = "'";
    if (str == null) {
      return "''";
    }
    if (typeof str !== "string") {
      return "''";
    }
    for (let i = 0; i < str.length; i++) {
      const c2 = str[i];
      if (c2 === "'") {
        escaped += c2 + c2;
      } else if (c2 === "\\") {
        escaped += c2 + c2;
        hasBackslash = true;
      } else {
        escaped += c2;
      }
    }
    escaped += "'";
    if (hasBackslash === true) {
      escaped = " E" + escaped;
    }
    return escaped;
  };
  utils$1 = {
    prepareValue: function prepareValueWrapper(value) {
      return prepareValue(value);
    },
    normalizeQueryConfig,
    escapeIdentifier: escapeIdentifier2,
    escapeLiteral: escapeLiteral2
  };
  return utils$1;
}
var utils = { exports: {} };
var utilsLegacy;
var hasRequiredUtilsLegacy;
function requireUtilsLegacy() {
  if (hasRequiredUtilsLegacy) return utilsLegacy;
  hasRequiredUtilsLegacy = 1;
  const nodeCrypto = require$$0$5;
  function md5(string) {
    return nodeCrypto.createHash("md5").update(string, "utf-8").digest("hex");
  }
  function postgresMd5PasswordHash(user, password, salt) {
    const inner = md5(password + user);
    const outer = md5(Buffer.concat([Buffer.from(inner), salt]));
    return "md5" + outer;
  }
  function sha2562(text2) {
    return nodeCrypto.createHash("sha256").update(text2).digest();
  }
  function hashByName(hashName, text2) {
    hashName = hashName.replace(/(\D)-/, "$1");
    return nodeCrypto.createHash(hashName).update(text2).digest();
  }
  function hmacSha256(key, msg) {
    return nodeCrypto.createHmac("sha256", key).update(msg).digest();
  }
  async function deriveKey2(password, salt, iterations) {
    return nodeCrypto.pbkdf2Sync(password, salt, iterations, 32, "sha256");
  }
  utilsLegacy = {
    postgresMd5PasswordHash,
    randomBytes: nodeCrypto.randomBytes,
    deriveKey: deriveKey2,
    sha256: sha2562,
    hashByName,
    hmacSha256,
    md5
  };
  return utilsLegacy;
}
var utilsWebcrypto;
var hasRequiredUtilsWebcrypto;
function requireUtilsWebcrypto() {
  if (hasRequiredUtilsWebcrypto) return utilsWebcrypto;
  hasRequiredUtilsWebcrypto = 1;
  const nodeCrypto = require$$0$5;
  utilsWebcrypto = {
    postgresMd5PasswordHash,
    randomBytes: randomBytes2,
    deriveKey: deriveKey2,
    sha256: sha2562,
    hashByName,
    hmacSha256,
    md5
  };
  const webCrypto = nodeCrypto.webcrypto || globalThis.crypto;
  const subtleCrypto = webCrypto.subtle;
  const textEncoder = new TextEncoder();
  function randomBytes2(length) {
    return webCrypto.getRandomValues(Buffer.alloc(length));
  }
  async function md5(string) {
    try {
      return nodeCrypto.createHash("md5").update(string, "utf-8").digest("hex");
    } catch (e2) {
      const data = typeof string === "string" ? textEncoder.encode(string) : string;
      const hash = await subtleCrypto.digest("MD5", data);
      return Array.from(new Uint8Array(hash)).map((b) => b.toString(16).padStart(2, "0")).join("");
    }
  }
  async function postgresMd5PasswordHash(user, password, salt) {
    const inner = await md5(password + user);
    const outer = await md5(Buffer.concat([Buffer.from(inner), salt]));
    return "md5" + outer;
  }
  async function sha2562(text2) {
    return await subtleCrypto.digest("SHA-256", text2);
  }
  async function hashByName(hashName, text2) {
    return await subtleCrypto.digest(hashName, text2);
  }
  async function hmacSha256(keyBuffer, msg) {
    const key = await subtleCrypto.importKey("raw", keyBuffer, { name: "HMAC", hash: "SHA-256" }, false, ["sign"]);
    return await subtleCrypto.sign("HMAC", key, textEncoder.encode(msg));
  }
  async function deriveKey2(password, salt, iterations) {
    const key = await subtleCrypto.importKey("raw", textEncoder.encode(password), "PBKDF2", false, ["deriveBits"]);
    const params = { name: "PBKDF2", hash: "SHA-256", salt, iterations };
    return await subtleCrypto.deriveBits(params, key, 32 * 8, ["deriveBits"]);
  }
  return utilsWebcrypto;
}
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils.exports;
  hasRequiredUtils = 1;
  const useLegacyCrypto = parseInt(process.versions && process.versions.node && process.versions.node.split(".")[0]) < 15;
  if (useLegacyCrypto) {
    utils.exports = requireUtilsLegacy();
  } else {
    utils.exports = requireUtilsWebcrypto();
  }
  return utils.exports;
}
var certSignatures;
var hasRequiredCertSignatures;
function requireCertSignatures() {
  if (hasRequiredCertSignatures) return certSignatures;
  hasRequiredCertSignatures = 1;
  function x509Error(msg, cert) {
    return new Error("SASL channel binding: " + msg + " when parsing public certificate " + cert.toString("base64"));
  }
  function readASN1Length(data, index2) {
    let length = data[index2++];
    if (length < 128) return { length, index: index2 };
    const lengthBytes = length & 127;
    if (lengthBytes > 4) throw x509Error("bad length", data);
    length = 0;
    for (let i = 0; i < lengthBytes; i++) {
      length = length << 8 | data[index2++];
    }
    return { length, index: index2 };
  }
  function readASN1OID(data, index2) {
    if (data[index2++] !== 6) throw x509Error("non-OID data", data);
    const { length: OIDLength, index: indexAfterOIDLength } = readASN1Length(data, index2);
    index2 = indexAfterOIDLength;
    const lastIndex = index2 + OIDLength;
    const byte1 = data[index2++];
    let oid = (byte1 / 40 >> 0) + "." + byte1 % 40;
    while (index2 < lastIndex) {
      let value = 0;
      while (index2 < lastIndex) {
        const nextByte = data[index2++];
        value = value << 7 | nextByte & 127;
        if (nextByte < 128) break;
      }
      oid += "." + value;
    }
    return { oid, index: index2 };
  }
  function expectASN1Seq(data, index2) {
    if (data[index2++] !== 48) throw x509Error("non-sequence data", data);
    return readASN1Length(data, index2);
  }
  function signatureAlgorithmHashFromCertificate(data, index2) {
    if (index2 === void 0) index2 = 0;
    index2 = expectASN1Seq(data, index2).index;
    const { length: certInfoLength, index: indexAfterCertInfoLength } = expectASN1Seq(data, index2);
    index2 = indexAfterCertInfoLength + certInfoLength;
    index2 = expectASN1Seq(data, index2).index;
    const { oid, index: indexAfterOID } = readASN1OID(data, index2);
    switch (oid) {
      // RSA
      case "1.2.840.113549.1.1.4":
        return "MD5";
      case "1.2.840.113549.1.1.5":
        return "SHA-1";
      case "1.2.840.113549.1.1.11":
        return "SHA-256";
      case "1.2.840.113549.1.1.12":
        return "SHA-384";
      case "1.2.840.113549.1.1.13":
        return "SHA-512";
      case "1.2.840.113549.1.1.14":
        return "SHA-224";
      case "1.2.840.113549.1.1.15":
        return "SHA512-224";
      case "1.2.840.113549.1.1.16":
        return "SHA512-256";
      // ECDSA
      case "1.2.840.10045.4.1":
        return "SHA-1";
      case "1.2.840.10045.4.3.1":
        return "SHA-224";
      case "1.2.840.10045.4.3.2":
        return "SHA-256";
      case "1.2.840.10045.4.3.3":
        return "SHA-384";
      case "1.2.840.10045.4.3.4":
        return "SHA-512";
      // RSASSA-PSS: hash is indicated separately
      case "1.2.840.113549.1.1.10": {
        index2 = indexAfterOID;
        index2 = expectASN1Seq(data, index2).index;
        if (data[index2++] !== 160) throw x509Error("non-tag data", data);
        index2 = readASN1Length(data, index2).index;
        index2 = expectASN1Seq(data, index2).index;
        const { oid: hashOID } = readASN1OID(data, index2);
        switch (hashOID) {
          // standalone hash OIDs
          case "1.2.840.113549.2.5":
            return "MD5";
          case "1.3.14.3.2.26":
            return "SHA-1";
          case "2.16.840.1.101.3.4.2.1":
            return "SHA-256";
          case "2.16.840.1.101.3.4.2.2":
            return "SHA-384";
          case "2.16.840.1.101.3.4.2.3":
            return "SHA-512";
        }
        throw x509Error("unknown hash OID " + hashOID, data);
      }
      // Ed25519 -- see https: return//github.com/openssl/openssl/issues/15477
      case "1.3.101.110":
      case "1.3.101.112":
        return "SHA-512";
      // Ed448 -- still not in pg 17.2 (if supported, digest would be SHAKE256 x 64 bytes)
      case "1.3.101.111":
      case "1.3.101.113":
        throw x509Error("Ed448 certificate channel binding is not currently supported by Postgres");
    }
    throw x509Error("unknown OID " + oid, data);
  }
  certSignatures = { signatureAlgorithmHashFromCertificate };
  return certSignatures;
}
var sasl;
var hasRequiredSasl;
function requireSasl() {
  if (hasRequiredSasl) return sasl;
  hasRequiredSasl = 1;
  const crypto2 = requireUtils();
  const { signatureAlgorithmHashFromCertificate } = requireCertSignatures();
  function startSession(mechanisms, stream2) {
    const candidates = ["SCRAM-SHA-256"];
    if (stream2) candidates.unshift("SCRAM-SHA-256-PLUS");
    const mechanism = candidates.find((candidate) => mechanisms.includes(candidate));
    if (!mechanism) {
      throw new Error("SASL: Only mechanism(s) " + candidates.join(" and ") + " are supported");
    }
    if (mechanism === "SCRAM-SHA-256-PLUS" && typeof stream2.getPeerCertificate !== "function") {
      throw new Error("SASL: Mechanism SCRAM-SHA-256-PLUS requires a certificate");
    }
    const clientNonce = crypto2.randomBytes(18).toString("base64");
    const gs2Header = mechanism === "SCRAM-SHA-256-PLUS" ? "p=tls-server-end-point" : stream2 ? "y" : "n";
    return {
      mechanism,
      clientNonce,
      response: gs2Header + ",,n=*,r=" + clientNonce,
      message: "SASLInitialResponse"
    };
  }
  async function continueSession(session, password, serverData, stream2) {
    if (session.message !== "SASLInitialResponse") {
      throw new Error("SASL: Last message was not SASLInitialResponse");
    }
    if (typeof password !== "string") {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a string");
    }
    if (password === "") {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a non-empty string");
    }
    if (typeof serverData !== "string") {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: serverData must be a string");
    }
    const sv = parseServerFirstMessage(serverData);
    if (!sv.nonce.startsWith(session.clientNonce)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not start with client nonce");
    } else if (sv.nonce.length === session.clientNonce.length) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce is too short");
    }
    const clientFirstMessageBare = "n=*,r=" + session.clientNonce;
    const serverFirstMessage = "r=" + sv.nonce + ",s=" + sv.salt + ",i=" + sv.iteration;
    let channelBinding = stream2 ? "eSws" : "biws";
    if (session.mechanism === "SCRAM-SHA-256-PLUS") {
      const peerCert = stream2.getPeerCertificate().raw;
      let hashName = signatureAlgorithmHashFromCertificate(peerCert);
      if (hashName === "MD5" || hashName === "SHA-1") hashName = "SHA-256";
      const certHash = await crypto2.hashByName(hashName, peerCert);
      const bindingData = Buffer.concat([Buffer.from("p=tls-server-end-point,,"), Buffer.from(certHash)]);
      channelBinding = bindingData.toString("base64");
    }
    const clientFinalMessageWithoutProof = "c=" + channelBinding + ",r=" + sv.nonce;
    const authMessage = clientFirstMessageBare + "," + serverFirstMessage + "," + clientFinalMessageWithoutProof;
    const saltBytes = Buffer.from(sv.salt, "base64");
    const saltedPassword = await crypto2.deriveKey(password, saltBytes, sv.iteration);
    const clientKey = await crypto2.hmacSha256(saltedPassword, "Client Key");
    const storedKey = await crypto2.sha256(clientKey);
    const clientSignature = await crypto2.hmacSha256(storedKey, authMessage);
    const clientProof = xorBuffers(Buffer.from(clientKey), Buffer.from(clientSignature)).toString("base64");
    const serverKey = await crypto2.hmacSha256(saltedPassword, "Server Key");
    const serverSignatureBytes = await crypto2.hmacSha256(serverKey, authMessage);
    session.message = "SASLResponse";
    session.serverSignature = Buffer.from(serverSignatureBytes).toString("base64");
    session.response = clientFinalMessageWithoutProof + ",p=" + clientProof;
  }
  function finalizeSession(session, serverData) {
    if (session.message !== "SASLResponse") {
      throw new Error("SASL: Last message was not SASLResponse");
    }
    if (typeof serverData !== "string") {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: serverData must be a string");
    }
    const { serverSignature } = parseServerFinalMessage(serverData);
    if (serverSignature !== session.serverSignature) {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature does not match");
    }
  }
  function isPrintableChars(text2) {
    if (typeof text2 !== "string") {
      throw new TypeError("SASL: text must be a string");
    }
    return text2.split("").map((_, i) => text2.charCodeAt(i)).every((c2) => c2 >= 33 && c2 <= 43 || c2 >= 45 && c2 <= 126);
  }
  function isBase64(text2) {
    return /^(?:[a-zA-Z0-9+/]{4})*(?:[a-zA-Z0-9+/]{2}==|[a-zA-Z0-9+/]{3}=)?$/.test(text2);
  }
  function parseAttributePairs(text2) {
    if (typeof text2 !== "string") {
      throw new TypeError("SASL: attribute pairs text must be a string");
    }
    return new Map(
      text2.split(",").map((attrValue) => {
        if (!/^.=/.test(attrValue)) {
          throw new Error("SASL: Invalid attribute pair entry");
        }
        const name2 = attrValue[0];
        const value = attrValue.substring(2);
        return [name2, value];
      })
    );
  }
  function parseServerFirstMessage(data) {
    const attrPairs = parseAttributePairs(data);
    const nonce = attrPairs.get("r");
    if (!nonce) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce missing");
    } else if (!isPrintableChars(nonce)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce must only contain printable characters");
    }
    const salt = attrPairs.get("s");
    if (!salt) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt missing");
    } else if (!isBase64(salt)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt must be base64");
    }
    const iterationText = attrPairs.get("i");
    if (!iterationText) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: iteration missing");
    } else if (!/^[1-9][0-9]*$/.test(iterationText)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: invalid iteration count");
    }
    const iteration = parseInt(iterationText, 10);
    return {
      nonce,
      salt,
      iteration
    };
  }
  function parseServerFinalMessage(serverData) {
    const attrPairs = parseAttributePairs(serverData);
    const serverSignature = attrPairs.get("v");
    if (!serverSignature) {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature is missing");
    } else if (!isBase64(serverSignature)) {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature must be base64");
    }
    return {
      serverSignature
    };
  }
  function xorBuffers(a, b) {
    if (!Buffer.isBuffer(a)) {
      throw new TypeError("first argument must be a Buffer");
    }
    if (!Buffer.isBuffer(b)) {
      throw new TypeError("second argument must be a Buffer");
    }
    if (a.length !== b.length) {
      throw new Error("Buffer lengths must match");
    }
    if (a.length === 0) {
      throw new Error("Buffers cannot be empty");
    }
    return Buffer.from(a.map((_, i) => a[i] ^ b[i]));
  }
  sasl = {
    startSession,
    continueSession,
    finalizeSession
  };
  return sasl;
}
var typeOverrides;
var hasRequiredTypeOverrides;
function requireTypeOverrides() {
  if (hasRequiredTypeOverrides) return typeOverrides;
  hasRequiredTypeOverrides = 1;
  const types2 = requirePgTypes();
  function TypeOverrides2(userTypes) {
    this._types = userTypes || types2;
    this.text = {};
    this.binary = {};
  }
  TypeOverrides2.prototype.getOverrides = function(format2) {
    switch (format2) {
      case "text":
        return this.text;
      case "binary":
        return this.binary;
      default:
        return {};
    }
  };
  TypeOverrides2.prototype.setTypeParser = function(oid, format2, parseFn) {
    if (typeof format2 === "function") {
      parseFn = format2;
      format2 = "text";
    }
    this.getOverrides(format2)[oid] = parseFn;
  };
  TypeOverrides2.prototype.getTypeParser = function(oid, format2) {
    format2 = format2 || "text";
    return this.getOverrides(format2)[oid] || this._types.getTypeParser(oid, format2);
  };
  typeOverrides = TypeOverrides2;
  return typeOverrides;
}
var pgConnectionString;
var hasRequiredPgConnectionString;
function requirePgConnectionString() {
  if (hasRequiredPgConnectionString) return pgConnectionString;
  hasRequiredPgConnectionString = 1;
  function parse2(str, options = {}) {
    if (str.charAt(0) === "/") {
      const config3 = str.split(" ");
      return { host: config3[0], database: config3[1] };
    }
    const config2 = {};
    let result2;
    let dummyHost = false;
    if (/ |%[^a-f0-9]|%[a-f0-9][^a-f0-9]/i.test(str)) {
      str = encodeURI(str).replace(/%25(\d\d)/g, "%$1");
    }
    try {
      try {
        result2 = new URL(str, "postgres://base");
      } catch (e2) {
        result2 = new URL(str.replace("@/", "@___DUMMY___/"), "postgres://base");
        dummyHost = true;
      }
    } catch (err2) {
      err2.input && (err2.input = "*****REDACTED*****");
      throw err2;
    }
    for (const entry of result2.searchParams.entries()) {
      config2[entry[0]] = entry[1];
    }
    config2.user = config2.user || decodeURIComponent(result2.username);
    config2.password = config2.password || decodeURIComponent(result2.password);
    if (result2.protocol == "socket:") {
      config2.host = decodeURI(result2.pathname);
      config2.database = result2.searchParams.get("db");
      config2.client_encoding = result2.searchParams.get("encoding");
      return config2;
    }
    const hostname = dummyHost ? "" : result2.hostname;
    if (!config2.host) {
      config2.host = decodeURIComponent(hostname);
    } else if (hostname && /^%2f/i.test(hostname)) {
      result2.pathname = hostname + result2.pathname;
    }
    if (!config2.port) {
      config2.port = result2.port;
    }
    const pathname = result2.pathname.slice(1) || null;
    config2.database = pathname ? decodeURI(pathname) : null;
    if (config2.ssl === "true" || config2.ssl === "1") {
      config2.ssl = true;
    }
    if (config2.ssl === "0") {
      config2.ssl = false;
    }
    if (config2.sslcert || config2.sslkey || config2.sslrootcert || config2.sslmode) {
      config2.ssl = {};
    }
    const fs = config2.sslcert || config2.sslkey || config2.sslrootcert ? require$$1$2 : null;
    if (config2.sslcert) {
      config2.ssl.cert = fs.readFileSync(config2.sslcert).toString();
    }
    if (config2.sslkey) {
      config2.ssl.key = fs.readFileSync(config2.sslkey).toString();
    }
    if (config2.sslrootcert) {
      config2.ssl.ca = fs.readFileSync(config2.sslrootcert).toString();
    }
    if (options.useLibpqCompat && config2.uselibpqcompat) {
      throw new Error("Both useLibpqCompat and uselibpqcompat are set. Please use only one of them.");
    }
    if (config2.uselibpqcompat === "true" || options.useLibpqCompat) {
      switch (config2.sslmode) {
        case "disable": {
          config2.ssl = false;
          break;
        }
        case "prefer": {
          config2.ssl.rejectUnauthorized = false;
          break;
        }
        case "require": {
          if (config2.sslrootcert) {
            config2.ssl.checkServerIdentity = function() {
            };
          } else {
            config2.ssl.rejectUnauthorized = false;
          }
          break;
        }
        case "verify-ca": {
          if (!config2.ssl.ca) {
            throw new Error(
              "SECURITY WARNING: Using sslmode=verify-ca requires specifying a CA with sslrootcert. If a public CA is used, verify-ca allows connections to a server that somebody else may have registered with the CA, making you vulnerable to Man-in-the-Middle attacks. Either specify a custom CA certificate with sslrootcert parameter or use sslmode=verify-full for proper security."
            );
          }
          config2.ssl.checkServerIdentity = function() {
          };
          break;
        }
      }
    } else {
      switch (config2.sslmode) {
        case "disable": {
          config2.ssl = false;
          break;
        }
        case "prefer":
        case "require":
        case "verify-ca":
        case "verify-full": {
          if (config2.sslmode !== "verify-full") {
            deprecatedSslModeWarning(config2.sslmode);
          }
          break;
        }
        case "no-verify": {
          config2.ssl.rejectUnauthorized = false;
          break;
        }
      }
    }
    return config2;
  }
  function toConnectionOptions(sslConfig) {
    const connectionOptions = Object.entries(sslConfig).reduce((c2, [key, value]) => {
      if (value !== void 0 && value !== null) {
        c2[key] = value;
      }
      return c2;
    }, {});
    return connectionOptions;
  }
  function toClientConfig2(config2) {
    const poolConfig = Object.entries(config2).reduce((c2, [key, value]) => {
      if (key === "ssl") {
        const sslConfig = value;
        if (typeof sslConfig === "boolean") {
          c2[key] = sslConfig;
        }
        if (typeof sslConfig === "object") {
          c2[key] = toConnectionOptions(sslConfig);
        }
      } else if (value !== void 0 && value !== null) {
        if (key === "port") {
          if (value !== "") {
            const v = parseInt(value, 10);
            if (isNaN(v)) {
              throw new Error(`Invalid ${key}: ${value}`);
            }
            c2[key] = v;
          }
        } else {
          c2[key] = value;
        }
      }
      return c2;
    }, {});
    return poolConfig;
  }
  function parseIntoClientConfig2(str) {
    return toClientConfig2(parse2(str));
  }
  function deprecatedSslModeWarning(sslmode) {
    if (!deprecatedSslModeWarning.warned && typeof process !== "undefined" && process.emitWarning) {
      deprecatedSslModeWarning.warned = true;
      process.emitWarning(`SECURITY WARNING: The SSL modes 'prefer', 'require', and 'verify-ca' are treated as aliases for 'verify-full'.
In the next major version (pg-connection-string v3.0.0 and pg v9.0.0), these modes will adopt standard libpq semantics, which have weaker security guarantees.

To prepare for this change:
- If you want the current behavior, explicitly use 'sslmode=verify-full'
- If you want libpq compatibility now, use 'uselibpqcompat=true&sslmode=${sslmode}'

See https://www.postgresql.org/docs/current/libpq-ssl.html for libpq SSL mode definitions.`);
    }
  }
  pgConnectionString = parse2;
  parse2.parse = parse2;
  parse2.toClientConfig = toClientConfig2;
  parse2.parseIntoClientConfig = parseIntoClientConfig2;
  return pgConnectionString;
}
var pgConnectionStringExports = requirePgConnectionString();
const connectionString = /* @__PURE__ */ getDefaultExportFromCjs(pgConnectionStringExports);
const index$1 = connectionString.parse;
const parse$1 = connectionString.parse;
const toClientConfig = connectionString.toClientConfig;
const parseIntoClientConfig = connectionString.parseIntoClientConfig;
const esm$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: index$1,
  parse: parse$1,
  parseIntoClientConfig,
  toClientConfig
}, Symbol.toStringTag, { value: "Module" }));
const require$$2 = /* @__PURE__ */ getAugmentedNamespace(esm$3);
var connectionParameters;
var hasRequiredConnectionParameters;
function requireConnectionParameters() {
  if (hasRequiredConnectionParameters) return connectionParameters;
  hasRequiredConnectionParameters = 1;
  const dns = require$$4;
  const defaults2 = requireDefaults();
  const parse2 = require$$2.parse;
  const val = function(key, config2, envVar) {
    if (config2[key]) {
      return config2[key];
    }
    if (envVar === void 0) {
      envVar = process.env["PG" + key.toUpperCase()];
    } else if (envVar === false) ;
    else {
      envVar = process.env[envVar];
    }
    return envVar || defaults2[key];
  };
  const readSSLConfigFromEnvironment = function() {
    switch (process.env.PGSSLMODE) {
      case "disable":
        return false;
      case "prefer":
      case "require":
      case "verify-ca":
      case "verify-full":
        return true;
      case "no-verify":
        return { rejectUnauthorized: false };
    }
    return defaults2.ssl;
  };
  const quoteParamValue = function(value) {
    return "'" + ("" + value).replace(/\\/g, "\\\\").replace(/'/g, "\\'") + "'";
  };
  const add = function(params, config2, paramName) {
    const value = config2[paramName];
    if (value !== void 0 && value !== null) {
      params.push(paramName + "=" + quoteParamValue(value));
    }
  };
  class ConnectionParameters {
    constructor(config2) {
      config2 = typeof config2 === "string" ? parse2(config2) : config2 || {};
      if (config2.connectionString) {
        config2 = Object.assign({}, config2, parse2(config2.connectionString));
      }
      this.user = val("user", config2);
      this.database = val("database", config2);
      if (this.database === void 0) {
        this.database = this.user;
      }
      this.port = parseInt(val("port", config2), 10);
      this.host = val("host", config2);
      Object.defineProperty(this, "password", {
        configurable: true,
        enumerable: false,
        writable: true,
        value: val("password", config2)
      });
      this.binary = val("binary", config2);
      this.options = val("options", config2);
      this.ssl = typeof config2.ssl === "undefined" ? readSSLConfigFromEnvironment() : config2.ssl;
      if (typeof this.ssl === "string") {
        if (this.ssl === "true") {
          this.ssl = true;
        }
      }
      if (this.ssl === "no-verify") {
        this.ssl = { rejectUnauthorized: false };
      }
      if (this.ssl && this.ssl.key) {
        Object.defineProperty(this.ssl, "key", {
          enumerable: false
        });
      }
      this.client_encoding = val("client_encoding", config2);
      this.replication = val("replication", config2);
      this.isDomainSocket = !(this.host || "").indexOf("/");
      this.application_name = val("application_name", config2, "PGAPPNAME");
      this.fallback_application_name = val("fallback_application_name", config2, false);
      this.statement_timeout = val("statement_timeout", config2, false);
      this.lock_timeout = val("lock_timeout", config2, false);
      this.idle_in_transaction_session_timeout = val("idle_in_transaction_session_timeout", config2, false);
      this.query_timeout = val("query_timeout", config2, false);
      if (config2.connectionTimeoutMillis === void 0) {
        this.connect_timeout = process.env.PGCONNECT_TIMEOUT || 0;
      } else {
        this.connect_timeout = Math.floor(config2.connectionTimeoutMillis / 1e3);
      }
      if (config2.keepAlive === false) {
        this.keepalives = 0;
      } else if (config2.keepAlive === true) {
        this.keepalives = 1;
      }
      if (typeof config2.keepAliveInitialDelayMillis === "number") {
        this.keepalives_idle = Math.floor(config2.keepAliveInitialDelayMillis / 1e3);
      }
    }
    getLibpqConnectionString(cb) {
      const params = [];
      add(params, this, "user");
      add(params, this, "password");
      add(params, this, "port");
      add(params, this, "application_name");
      add(params, this, "fallback_application_name");
      add(params, this, "connect_timeout");
      add(params, this, "options");
      const ssl = typeof this.ssl === "object" ? this.ssl : this.ssl ? { sslmode: this.ssl } : {};
      add(params, ssl, "sslmode");
      add(params, ssl, "sslca");
      add(params, ssl, "sslkey");
      add(params, ssl, "sslcert");
      add(params, ssl, "sslrootcert");
      if (this.database) {
        params.push("dbname=" + quoteParamValue(this.database));
      }
      if (this.replication) {
        params.push("replication=" + quoteParamValue(this.replication));
      }
      if (this.host) {
        params.push("host=" + quoteParamValue(this.host));
      }
      if (this.isDomainSocket) {
        return cb(null, params.join(" "));
      }
      if (this.client_encoding) {
        params.push("client_encoding=" + quoteParamValue(this.client_encoding));
      }
      dns.lookup(this.host, function(err2, address) {
        if (err2) return cb(err2, null);
        params.push("hostaddr=" + quoteParamValue(address));
        return cb(null, params.join(" "));
      });
    }
  }
  connectionParameters = ConnectionParameters;
  return connectionParameters;
}
var result;
var hasRequiredResult;
function requireResult() {
  if (hasRequiredResult) return result;
  hasRequiredResult = 1;
  const types2 = requirePgTypes();
  const matchRegexp = /^([A-Za-z]+)(?: (\d+))?(?: (\d+))?/;
  class Result2 {
    constructor(rowMode, types3) {
      this.command = null;
      this.rowCount = null;
      this.oid = null;
      this.rows = [];
      this.fields = [];
      this._parsers = void 0;
      this._types = types3;
      this.RowCtor = null;
      this.rowAsArray = rowMode === "array";
      if (this.rowAsArray) {
        this.parseRow = this._parseRowAsArray;
      }
      this._prebuiltEmptyResultObject = null;
    }
    // adds a command complete message
    addCommandComplete(msg) {
      let match2;
      if (msg.text) {
        match2 = matchRegexp.exec(msg.text);
      } else {
        match2 = matchRegexp.exec(msg.command);
      }
      if (match2) {
        this.command = match2[1];
        if (match2[3]) {
          this.oid = parseInt(match2[2], 10);
          this.rowCount = parseInt(match2[3], 10);
        } else if (match2[2]) {
          this.rowCount = parseInt(match2[2], 10);
        }
      }
    }
    _parseRowAsArray(rowData) {
      const row = new Array(rowData.length);
      for (let i = 0, len = rowData.length; i < len; i++) {
        const rawValue = rowData[i];
        if (rawValue !== null) {
          row[i] = this._parsers[i](rawValue);
        } else {
          row[i] = null;
        }
      }
      return row;
    }
    parseRow(rowData) {
      const row = { ...this._prebuiltEmptyResultObject };
      for (let i = 0, len = rowData.length; i < len; i++) {
        const rawValue = rowData[i];
        const field = this.fields[i].name;
        if (rawValue !== null) {
          const v = this.fields[i].format === "binary" ? Buffer.from(rawValue) : rawValue;
          row[field] = this._parsers[i](v);
        } else {
          row[field] = null;
        }
      }
      return row;
    }
    addRow(row) {
      this.rows.push(row);
    }
    addFields(fieldDescriptions) {
      this.fields = fieldDescriptions;
      if (this.fields.length) {
        this._parsers = new Array(fieldDescriptions.length);
      }
      const row = {};
      for (let i = 0; i < fieldDescriptions.length; i++) {
        const desc2 = fieldDescriptions[i];
        row[desc2.name] = null;
        if (this._types) {
          this._parsers[i] = this._types.getTypeParser(desc2.dataTypeID, desc2.format || "text");
        } else {
          this._parsers[i] = types2.getTypeParser(desc2.dataTypeID, desc2.format || "text");
        }
      }
      this._prebuiltEmptyResultObject = { ...row };
    }
  }
  result = Result2;
  return result;
}
var query$1;
var hasRequiredQuery$1;
function requireQuery$1() {
  if (hasRequiredQuery$1) return query$1;
  hasRequiredQuery$1 = 1;
  const { EventEmitter: EventEmitter2 } = require$$0$7;
  const Result2 = requireResult();
  const utils2 = requireUtils$1();
  class Query2 extends EventEmitter2 {
    constructor(config2, values, callback) {
      super();
      config2 = utils2.normalizeQueryConfig(config2, values, callback);
      this.text = config2.text;
      this.values = config2.values;
      this.rows = config2.rows;
      this.types = config2.types;
      this.name = config2.name;
      this.queryMode = config2.queryMode;
      this.binary = config2.binary;
      this.portal = config2.portal || "";
      this.callback = config2.callback;
      this._rowMode = config2.rowMode;
      if (process.domain && config2.callback) {
        this.callback = process.domain.bind(config2.callback);
      }
      this._result = new Result2(this._rowMode, this.types);
      this._results = this._result;
      this._canceledDueToError = false;
    }
    requiresPreparation() {
      if (this.queryMode === "extended") {
        return true;
      }
      if (this.name) {
        return true;
      }
      if (this.rows) {
        return true;
      }
      if (!this.text) {
        return false;
      }
      if (!this.values) {
        return false;
      }
      return this.values.length > 0;
    }
    _checkForMultirow() {
      if (this._result.command) {
        if (!Array.isArray(this._results)) {
          this._results = [this._result];
        }
        this._result = new Result2(this._rowMode, this._result._types);
        this._results.push(this._result);
      }
    }
    // associates row metadata from the supplied
    // message with this query object
    // metadata used when parsing row results
    handleRowDescription(msg) {
      this._checkForMultirow();
      this._result.addFields(msg.fields);
      this._accumulateRows = this.callback || !this.listeners("row").length;
    }
    handleDataRow(msg) {
      let row;
      if (this._canceledDueToError) {
        return;
      }
      try {
        row = this._result.parseRow(msg.fields);
      } catch (err2) {
        this._canceledDueToError = err2;
        return;
      }
      this.emit("row", row, this._result);
      if (this._accumulateRows) {
        this._result.addRow(row);
      }
    }
    handleCommandComplete(msg, connection2) {
      this._checkForMultirow();
      this._result.addCommandComplete(msg);
      if (this.rows) {
        connection2.sync();
      }
    }
    // if a named prepared statement is created with empty query text
    // the backend will send an emptyQuery message but *not* a command complete message
    // since we pipeline sync immediately after execute we don't need to do anything here
    // unless we have rows specified, in which case we did not pipeline the initial sync call
    handleEmptyQuery(connection2) {
      if (this.rows) {
        connection2.sync();
      }
    }
    handleError(err2, connection2) {
      if (this._canceledDueToError) {
        err2 = this._canceledDueToError;
        this._canceledDueToError = false;
      }
      if (this.callback) {
        return this.callback(err2);
      }
      this.emit("error", err2);
    }
    handleReadyForQuery(con) {
      if (this._canceledDueToError) {
        return this.handleError(this._canceledDueToError, con);
      }
      if (this.callback) {
        try {
          this.callback(null, this._results);
        } catch (err2) {
          process.nextTick(() => {
            throw err2;
          });
        }
      }
      this.emit("end", this._results);
    }
    submit(connection2) {
      if (typeof this.text !== "string" && typeof this.name !== "string") {
        return new Error("A query must have either text or a name. Supplying neither is unsupported.");
      }
      const previous = connection2.parsedStatements[this.name];
      if (this.text && previous && this.text !== previous) {
        return new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);
      }
      if (this.values && !Array.isArray(this.values)) {
        return new Error("Query values must be an array");
      }
      if (this.requiresPreparation()) {
        connection2.stream.cork && connection2.stream.cork();
        try {
          this.prepare(connection2);
        } finally {
          connection2.stream.uncork && connection2.stream.uncork();
        }
      } else {
        connection2.query(this.text);
      }
      return null;
    }
    hasBeenParsed(connection2) {
      return this.name && connection2.parsedStatements[this.name];
    }
    handlePortalSuspended(connection2) {
      this._getRows(connection2, this.rows);
    }
    _getRows(connection2, rows) {
      connection2.execute({
        portal: this.portal,
        rows
      });
      if (!rows) {
        connection2.sync();
      } else {
        connection2.flush();
      }
    }
    // http://developer.postgresql.org/pgdocs/postgres/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY
    prepare(connection2) {
      if (!this.hasBeenParsed(connection2)) {
        connection2.parse({
          text: this.text,
          name: this.name,
          types: this.types
        });
      }
      try {
        connection2.bind({
          portal: this.portal,
          statement: this.name,
          values: this.values,
          binary: this.binary,
          valueMapper: utils2.prepareValue
        });
      } catch (err2) {
        this.handleError(err2, connection2);
        return;
      }
      connection2.describe({
        type: "P",
        name: this.portal || ""
      });
      this._getRows(connection2, this.rows);
    }
    handleCopyInResponse(connection2) {
      connection2.sendCopyFail("No source stream defined");
    }
    handleCopyData(msg, connection2) {
    }
  }
  query$1 = Query2;
  return query$1;
}
var dist = {};
var messages$1 = {};
var hasRequiredMessages;
function requireMessages() {
  if (hasRequiredMessages) return messages$1;
  hasRequiredMessages = 1;
  Object.defineProperty(messages$1, "__esModule", { value: true });
  messages$1.NoticeMessage = messages$1.DataRowMessage = messages$1.CommandCompleteMessage = messages$1.ReadyForQueryMessage = messages$1.NotificationResponseMessage = messages$1.BackendKeyDataMessage = messages$1.AuthenticationMD5Password = messages$1.ParameterStatusMessage = messages$1.ParameterDescriptionMessage = messages$1.RowDescriptionMessage = messages$1.Field = messages$1.CopyResponse = messages$1.CopyDataMessage = messages$1.DatabaseError = messages$1.copyDone = messages$1.emptyQuery = messages$1.replicationStart = messages$1.portalSuspended = messages$1.noData = messages$1.closeComplete = messages$1.bindComplete = messages$1.parseComplete = void 0;
  messages$1.parseComplete = {
    name: "parseComplete",
    length: 5
  };
  messages$1.bindComplete = {
    name: "bindComplete",
    length: 5
  };
  messages$1.closeComplete = {
    name: "closeComplete",
    length: 5
  };
  messages$1.noData = {
    name: "noData",
    length: 5
  };
  messages$1.portalSuspended = {
    name: "portalSuspended",
    length: 5
  };
  messages$1.replicationStart = {
    name: "replicationStart",
    length: 4
  };
  messages$1.emptyQuery = {
    name: "emptyQuery",
    length: 4
  };
  messages$1.copyDone = {
    name: "copyDone",
    length: 4
  };
  class DatabaseError2 extends Error {
    constructor(message2, length, name2) {
      super(message2);
      this.length = length;
      this.name = name2;
    }
  }
  messages$1.DatabaseError = DatabaseError2;
  class CopyDataMessage {
    constructor(length, chunk) {
      this.length = length;
      this.chunk = chunk;
      this.name = "copyData";
    }
  }
  messages$1.CopyDataMessage = CopyDataMessage;
  class CopyResponse {
    constructor(length, name2, binary2, columnCount) {
      this.length = length;
      this.name = name2;
      this.binary = binary2;
      this.columnTypes = new Array(columnCount);
    }
  }
  messages$1.CopyResponse = CopyResponse;
  class Field {
    constructor(name2, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, format2) {
      this.name = name2;
      this.tableID = tableID;
      this.columnID = columnID;
      this.dataTypeID = dataTypeID;
      this.dataTypeSize = dataTypeSize;
      this.dataTypeModifier = dataTypeModifier;
      this.format = format2;
    }
  }
  messages$1.Field = Field;
  class RowDescriptionMessage {
    constructor(length, fieldCount) {
      this.length = length;
      this.fieldCount = fieldCount;
      this.name = "rowDescription";
      this.fields = new Array(this.fieldCount);
    }
  }
  messages$1.RowDescriptionMessage = RowDescriptionMessage;
  class ParameterDescriptionMessage {
    constructor(length, parameterCount) {
      this.length = length;
      this.parameterCount = parameterCount;
      this.name = "parameterDescription";
      this.dataTypeIDs = new Array(this.parameterCount);
    }
  }
  messages$1.ParameterDescriptionMessage = ParameterDescriptionMessage;
  class ParameterStatusMessage {
    constructor(length, parameterName, parameterValue) {
      this.length = length;
      this.parameterName = parameterName;
      this.parameterValue = parameterValue;
      this.name = "parameterStatus";
    }
  }
  messages$1.ParameterStatusMessage = ParameterStatusMessage;
  class AuthenticationMD5Password {
    constructor(length, salt) {
      this.length = length;
      this.salt = salt;
      this.name = "authenticationMD5Password";
    }
  }
  messages$1.AuthenticationMD5Password = AuthenticationMD5Password;
  class BackendKeyDataMessage {
    constructor(length, processID, secretKey) {
      this.length = length;
      this.processID = processID;
      this.secretKey = secretKey;
      this.name = "backendKeyData";
    }
  }
  messages$1.BackendKeyDataMessage = BackendKeyDataMessage;
  class NotificationResponseMessage {
    constructor(length, processId, channel, payload) {
      this.length = length;
      this.processId = processId;
      this.channel = channel;
      this.payload = payload;
      this.name = "notification";
    }
  }
  messages$1.NotificationResponseMessage = NotificationResponseMessage;
  class ReadyForQueryMessage {
    constructor(length, status) {
      this.length = length;
      this.status = status;
      this.name = "readyForQuery";
    }
  }
  messages$1.ReadyForQueryMessage = ReadyForQueryMessage;
  class CommandCompleteMessage {
    constructor(length, text2) {
      this.length = length;
      this.text = text2;
      this.name = "commandComplete";
    }
  }
  messages$1.CommandCompleteMessage = CommandCompleteMessage;
  class DataRowMessage {
    constructor(length, fields2) {
      this.length = length;
      this.fields = fields2;
      this.name = "dataRow";
      this.fieldCount = fields2.length;
    }
  }
  messages$1.DataRowMessage = DataRowMessage;
  class NoticeMessage {
    constructor(length, message2) {
      this.length = length;
      this.message = message2;
      this.name = "notice";
    }
  }
  messages$1.NoticeMessage = NoticeMessage;
  return messages$1;
}
var serializer = {};
var bufferWriter = {};
var hasRequiredBufferWriter;
function requireBufferWriter() {
  if (hasRequiredBufferWriter) return bufferWriter;
  hasRequiredBufferWriter = 1;
  Object.defineProperty(bufferWriter, "__esModule", { value: true });
  bufferWriter.Writer = void 0;
  class Writer {
    constructor(size = 256) {
      this.size = size;
      this.offset = 5;
      this.headerPosition = 0;
      this.buffer = Buffer.allocUnsafe(size);
    }
    ensure(size) {
      const remaining = this.buffer.length - this.offset;
      if (remaining < size) {
        const oldBuffer = this.buffer;
        const newSize = oldBuffer.length + (oldBuffer.length >> 1) + size;
        this.buffer = Buffer.allocUnsafe(newSize);
        oldBuffer.copy(this.buffer);
      }
    }
    addInt32(num) {
      this.ensure(4);
      this.buffer[this.offset++] = num >>> 24 & 255;
      this.buffer[this.offset++] = num >>> 16 & 255;
      this.buffer[this.offset++] = num >>> 8 & 255;
      this.buffer[this.offset++] = num >>> 0 & 255;
      return this;
    }
    addInt16(num) {
      this.ensure(2);
      this.buffer[this.offset++] = num >>> 8 & 255;
      this.buffer[this.offset++] = num >>> 0 & 255;
      return this;
    }
    addCString(string) {
      if (!string) {
        this.ensure(1);
      } else {
        const len = Buffer.byteLength(string);
        this.ensure(len + 1);
        this.buffer.write(string, this.offset, "utf-8");
        this.offset += len;
      }
      this.buffer[this.offset++] = 0;
      return this;
    }
    addString(string = "") {
      const len = Buffer.byteLength(string);
      this.ensure(len);
      this.buffer.write(string, this.offset);
      this.offset += len;
      return this;
    }
    add(otherBuffer) {
      this.ensure(otherBuffer.length);
      otherBuffer.copy(this.buffer, this.offset);
      this.offset += otherBuffer.length;
      return this;
    }
    join(code) {
      if (code) {
        this.buffer[this.headerPosition] = code;
        const length = this.offset - (this.headerPosition + 1);
        this.buffer.writeInt32BE(length, this.headerPosition + 1);
      }
      return this.buffer.slice(code ? 0 : 5, this.offset);
    }
    flush(code) {
      const result2 = this.join(code);
      this.offset = 5;
      this.headerPosition = 0;
      this.buffer = Buffer.allocUnsafe(this.size);
      return result2;
    }
  }
  bufferWriter.Writer = Writer;
  return bufferWriter;
}
var hasRequiredSerializer;
function requireSerializer() {
  if (hasRequiredSerializer) return serializer;
  hasRequiredSerializer = 1;
  Object.defineProperty(serializer, "__esModule", { value: true });
  serializer.serialize = void 0;
  const buffer_writer_1 = requireBufferWriter();
  const writer = new buffer_writer_1.Writer();
  const startup = (opts) => {
    writer.addInt16(3).addInt16(0);
    for (const key of Object.keys(opts)) {
      writer.addCString(key).addCString(opts[key]);
    }
    writer.addCString("client_encoding").addCString("UTF8");
    const bodyBuffer = writer.addCString("").flush();
    const length = bodyBuffer.length + 4;
    return new buffer_writer_1.Writer().addInt32(length).add(bodyBuffer).flush();
  };
  const requestSsl = () => {
    const response = Buffer.allocUnsafe(8);
    response.writeInt32BE(8, 0);
    response.writeInt32BE(80877103, 4);
    return response;
  };
  const password = (password2) => {
    return writer.addCString(password2).flush(
      112
      /* code.startup */
    );
  };
  const sendSASLInitialResponseMessage = function(mechanism, initialResponse) {
    writer.addCString(mechanism).addInt32(Buffer.byteLength(initialResponse)).addString(initialResponse);
    return writer.flush(
      112
      /* code.startup */
    );
  };
  const sendSCRAMClientFinalMessage = function(additionalData) {
    return writer.addString(additionalData).flush(
      112
      /* code.startup */
    );
  };
  const query2 = (text2) => {
    return writer.addCString(text2).flush(
      81
      /* code.query */
    );
  };
  const emptyArray = [];
  const parse2 = (query3) => {
    const name2 = query3.name || "";
    if (name2.length > 63) {
      console.error("Warning! Postgres only supports 63 characters for query names.");
      console.error("You supplied %s (%s)", name2, name2.length);
      console.error("This can cause conflicts and silent errors executing queries");
    }
    const types2 = query3.types || emptyArray;
    const len = types2.length;
    const buffer = writer.addCString(name2).addCString(query3.text).addInt16(len);
    for (let i = 0; i < len; i++) {
      buffer.addInt32(types2[i]);
    }
    return writer.flush(
      80
      /* code.parse */
    );
  };
  const paramWriter = new buffer_writer_1.Writer();
  const writeValues = function(values, valueMapper) {
    for (let i = 0; i < values.length; i++) {
      const mappedVal = valueMapper ? valueMapper(values[i], i) : values[i];
      if (mappedVal == null) {
        writer.addInt16(
          0
          /* ParamType.STRING */
        );
        paramWriter.addInt32(-1);
      } else if (mappedVal instanceof Buffer) {
        writer.addInt16(
          1
          /* ParamType.BINARY */
        );
        paramWriter.addInt32(mappedVal.length);
        paramWriter.add(mappedVal);
      } else {
        writer.addInt16(
          0
          /* ParamType.STRING */
        );
        paramWriter.addInt32(Buffer.byteLength(mappedVal));
        paramWriter.addString(mappedVal);
      }
    }
  };
  const bind2 = (config2 = {}) => {
    const portal = config2.portal || "";
    const statement = config2.statement || "";
    const binary2 = config2.binary || false;
    const values = config2.values || emptyArray;
    const len = values.length;
    writer.addCString(portal).addCString(statement);
    writer.addInt16(len);
    writeValues(values, config2.valueMapper);
    writer.addInt16(len);
    writer.add(paramWriter.flush());
    writer.addInt16(1);
    writer.addInt16(
      binary2 ? 1 : 0
      /* ParamType.STRING */
    );
    return writer.flush(
      66
      /* code.bind */
    );
  };
  const emptyExecute = Buffer.from([69, 0, 0, 0, 9, 0, 0, 0, 0, 0]);
  const execute = (config2) => {
    if (!config2 || !config2.portal && !config2.rows) {
      return emptyExecute;
    }
    const portal = config2.portal || "";
    const rows = config2.rows || 0;
    const portalLength = Buffer.byteLength(portal);
    const len = 4 + portalLength + 1 + 4;
    const buff = Buffer.allocUnsafe(1 + len);
    buff[0] = 69;
    buff.writeInt32BE(len, 1);
    buff.write(portal, 5, "utf-8");
    buff[portalLength + 5] = 0;
    buff.writeUInt32BE(rows, buff.length - 4);
    return buff;
  };
  const cancel = (processID, secretKey) => {
    const buffer = Buffer.allocUnsafe(16);
    buffer.writeInt32BE(16, 0);
    buffer.writeInt16BE(1234, 4);
    buffer.writeInt16BE(5678, 6);
    buffer.writeInt32BE(processID, 8);
    buffer.writeInt32BE(secretKey, 12);
    return buffer;
  };
  const cstringMessage = (code, string) => {
    const stringLen = Buffer.byteLength(string);
    const len = 4 + stringLen + 1;
    const buffer = Buffer.allocUnsafe(1 + len);
    buffer[0] = code;
    buffer.writeInt32BE(len, 1);
    buffer.write(string, 5, "utf-8");
    buffer[len] = 0;
    return buffer;
  };
  const emptyDescribePortal = writer.addCString("P").flush(
    68
    /* code.describe */
  );
  const emptyDescribeStatement = writer.addCString("S").flush(
    68
    /* code.describe */
  );
  const describe = (msg) => {
    return msg.name ? cstringMessage(68, `${msg.type}${msg.name || ""}`) : msg.type === "P" ? emptyDescribePortal : emptyDescribeStatement;
  };
  const close = (msg) => {
    const text2 = `${msg.type}${msg.name || ""}`;
    return cstringMessage(67, text2);
  };
  const copyData = (chunk) => {
    return writer.add(chunk).flush(
      100
      /* code.copyFromChunk */
    );
  };
  const copyFail = (message2) => {
    return cstringMessage(102, message2);
  };
  const codeOnlyBuffer = (code) => Buffer.from([code, 0, 0, 0, 4]);
  const flushBuffer = codeOnlyBuffer(
    72
    /* code.flush */
  );
  const syncBuffer = codeOnlyBuffer(
    83
    /* code.sync */
  );
  const endBuffer = codeOnlyBuffer(
    88
    /* code.end */
  );
  const copyDoneBuffer = codeOnlyBuffer(
    99
    /* code.copyDone */
  );
  const serialize2 = {
    startup,
    password,
    requestSsl,
    sendSASLInitialResponseMessage,
    sendSCRAMClientFinalMessage,
    query: query2,
    parse: parse2,
    bind: bind2,
    execute,
    describe,
    close,
    flush: () => flushBuffer,
    sync: () => syncBuffer,
    end: () => endBuffer,
    copyData,
    copyDone: () => copyDoneBuffer,
    copyFail,
    cancel
  };
  serializer.serialize = serialize2;
  return serializer;
}
var parser = {};
var bufferReader = {};
var hasRequiredBufferReader;
function requireBufferReader() {
  if (hasRequiredBufferReader) return bufferReader;
  hasRequiredBufferReader = 1;
  Object.defineProperty(bufferReader, "__esModule", { value: true });
  bufferReader.BufferReader = void 0;
  const emptyBuffer = Buffer.allocUnsafe(0);
  class BufferReader {
    constructor(offset2 = 0) {
      this.offset = offset2;
      this.buffer = emptyBuffer;
      this.encoding = "utf-8";
    }
    setBuffer(offset2, buffer) {
      this.offset = offset2;
      this.buffer = buffer;
    }
    int16() {
      const result2 = this.buffer.readInt16BE(this.offset);
      this.offset += 2;
      return result2;
    }
    byte() {
      const result2 = this.buffer[this.offset];
      this.offset++;
      return result2;
    }
    int32() {
      const result2 = this.buffer.readInt32BE(this.offset);
      this.offset += 4;
      return result2;
    }
    uint32() {
      const result2 = this.buffer.readUInt32BE(this.offset);
      this.offset += 4;
      return result2;
    }
    string(length) {
      const result2 = this.buffer.toString(this.encoding, this.offset, this.offset + length);
      this.offset += length;
      return result2;
    }
    cstring() {
      const start = this.offset;
      let end = start;
      while (this.buffer[end++] !== 0) {
      }
      this.offset = end;
      return this.buffer.toString(this.encoding, start, end - 1);
    }
    bytes(length) {
      const result2 = this.buffer.slice(this.offset, this.offset + length);
      this.offset += length;
      return result2;
    }
  }
  bufferReader.BufferReader = BufferReader;
  return bufferReader;
}
var hasRequiredParser;
function requireParser() {
  if (hasRequiredParser) return parser;
  hasRequiredParser = 1;
  Object.defineProperty(parser, "__esModule", { value: true });
  parser.Parser = void 0;
  const messages_1 = requireMessages();
  const buffer_reader_1 = requireBufferReader();
  const CODE_LENGTH = 1;
  const LEN_LENGTH = 4;
  const HEADER_LENGTH = CODE_LENGTH + LEN_LENGTH;
  const LATEINIT_LENGTH = -1;
  const emptyBuffer = Buffer.allocUnsafe(0);
  class Parser2 {
    constructor(opts) {
      this.buffer = emptyBuffer;
      this.bufferLength = 0;
      this.bufferOffset = 0;
      this.reader = new buffer_reader_1.BufferReader();
      if ((opts === null || opts === void 0 ? void 0 : opts.mode) === "binary") {
        throw new Error("Binary mode not supported yet");
      }
      this.mode = (opts === null || opts === void 0 ? void 0 : opts.mode) || "text";
    }
    parse(buffer, callback) {
      this.mergeBuffer(buffer);
      const bufferFullLength = this.bufferOffset + this.bufferLength;
      let offset2 = this.bufferOffset;
      while (offset2 + HEADER_LENGTH <= bufferFullLength) {
        const code = this.buffer[offset2];
        const length = this.buffer.readUInt32BE(offset2 + CODE_LENGTH);
        const fullMessageLength = CODE_LENGTH + length;
        if (fullMessageLength + offset2 <= bufferFullLength) {
          const message2 = this.handlePacket(offset2 + HEADER_LENGTH, code, length, this.buffer);
          callback(message2);
          offset2 += fullMessageLength;
        } else {
          break;
        }
      }
      if (offset2 === bufferFullLength) {
        this.buffer = emptyBuffer;
        this.bufferLength = 0;
        this.bufferOffset = 0;
      } else {
        this.bufferLength = bufferFullLength - offset2;
        this.bufferOffset = offset2;
      }
    }
    mergeBuffer(buffer) {
      if (this.bufferLength > 0) {
        const newLength = this.bufferLength + buffer.byteLength;
        const newFullLength = newLength + this.bufferOffset;
        if (newFullLength > this.buffer.byteLength) {
          let newBuffer;
          if (newLength <= this.buffer.byteLength && this.bufferOffset >= this.bufferLength) {
            newBuffer = this.buffer;
          } else {
            let newBufferLength = this.buffer.byteLength * 2;
            while (newLength >= newBufferLength) {
              newBufferLength *= 2;
            }
            newBuffer = Buffer.allocUnsafe(newBufferLength);
          }
          this.buffer.copy(newBuffer, 0, this.bufferOffset, this.bufferOffset + this.bufferLength);
          this.buffer = newBuffer;
          this.bufferOffset = 0;
        }
        buffer.copy(this.buffer, this.bufferOffset + this.bufferLength);
        this.bufferLength = newLength;
      } else {
        this.buffer = buffer;
        this.bufferOffset = 0;
        this.bufferLength = buffer.byteLength;
      }
    }
    handlePacket(offset2, code, length, bytes) {
      const { reader } = this;
      reader.setBuffer(offset2, bytes);
      let message2;
      switch (code) {
        case 50:
          message2 = messages_1.bindComplete;
          break;
        case 49:
          message2 = messages_1.parseComplete;
          break;
        case 51:
          message2 = messages_1.closeComplete;
          break;
        case 110:
          message2 = messages_1.noData;
          break;
        case 115:
          message2 = messages_1.portalSuspended;
          break;
        case 99:
          message2 = messages_1.copyDone;
          break;
        case 87:
          message2 = messages_1.replicationStart;
          break;
        case 73:
          message2 = messages_1.emptyQuery;
          break;
        case 68:
          message2 = parseDataRowMessage(reader);
          break;
        case 67:
          message2 = parseCommandCompleteMessage(reader);
          break;
        case 90:
          message2 = parseReadyForQueryMessage(reader);
          break;
        case 65:
          message2 = parseNotificationMessage(reader);
          break;
        case 82:
          message2 = parseAuthenticationResponse(reader, length);
          break;
        case 83:
          message2 = parseParameterStatusMessage(reader);
          break;
        case 75:
          message2 = parseBackendKeyData(reader);
          break;
        case 69:
          message2 = parseErrorMessage(reader, "error");
          break;
        case 78:
          message2 = parseErrorMessage(reader, "notice");
          break;
        case 84:
          message2 = parseRowDescriptionMessage(reader);
          break;
        case 116:
          message2 = parseParameterDescriptionMessage(reader);
          break;
        case 71:
          message2 = parseCopyInMessage(reader);
          break;
        case 72:
          message2 = parseCopyOutMessage(reader);
          break;
        case 100:
          message2 = parseCopyData(reader, length);
          break;
        default:
          return new messages_1.DatabaseError("received invalid response: " + code.toString(16), length, "error");
      }
      reader.setBuffer(0, emptyBuffer);
      message2.length = length;
      return message2;
    }
  }
  parser.Parser = Parser2;
  const parseReadyForQueryMessage = (reader) => {
    const status = reader.string(1);
    return new messages_1.ReadyForQueryMessage(LATEINIT_LENGTH, status);
  };
  const parseCommandCompleteMessage = (reader) => {
    const text2 = reader.cstring();
    return new messages_1.CommandCompleteMessage(LATEINIT_LENGTH, text2);
  };
  const parseCopyData = (reader, length) => {
    const chunk = reader.bytes(length - 4);
    return new messages_1.CopyDataMessage(LATEINIT_LENGTH, chunk);
  };
  const parseCopyInMessage = (reader) => parseCopyMessage(reader, "copyInResponse");
  const parseCopyOutMessage = (reader) => parseCopyMessage(reader, "copyOutResponse");
  const parseCopyMessage = (reader, messageName) => {
    const isBinary = reader.byte() !== 0;
    const columnCount = reader.int16();
    const message2 = new messages_1.CopyResponse(LATEINIT_LENGTH, messageName, isBinary, columnCount);
    for (let i = 0; i < columnCount; i++) {
      message2.columnTypes[i] = reader.int16();
    }
    return message2;
  };
  const parseNotificationMessage = (reader) => {
    const processId = reader.int32();
    const channel = reader.cstring();
    const payload = reader.cstring();
    return new messages_1.NotificationResponseMessage(LATEINIT_LENGTH, processId, channel, payload);
  };
  const parseRowDescriptionMessage = (reader) => {
    const fieldCount = reader.int16();
    const message2 = new messages_1.RowDescriptionMessage(LATEINIT_LENGTH, fieldCount);
    for (let i = 0; i < fieldCount; i++) {
      message2.fields[i] = parseField(reader);
    }
    return message2;
  };
  const parseField = (reader) => {
    const name2 = reader.cstring();
    const tableID = reader.uint32();
    const columnID = reader.int16();
    const dataTypeID = reader.uint32();
    const dataTypeSize = reader.int16();
    const dataTypeModifier = reader.int32();
    const mode = reader.int16() === 0 ? "text" : "binary";
    return new messages_1.Field(name2, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, mode);
  };
  const parseParameterDescriptionMessage = (reader) => {
    const parameterCount = reader.int16();
    const message2 = new messages_1.ParameterDescriptionMessage(LATEINIT_LENGTH, parameterCount);
    for (let i = 0; i < parameterCount; i++) {
      message2.dataTypeIDs[i] = reader.int32();
    }
    return message2;
  };
  const parseDataRowMessage = (reader) => {
    const fieldCount = reader.int16();
    const fields2 = new Array(fieldCount);
    for (let i = 0; i < fieldCount; i++) {
      const len = reader.int32();
      fields2[i] = len === -1 ? null : reader.string(len);
    }
    return new messages_1.DataRowMessage(LATEINIT_LENGTH, fields2);
  };
  const parseParameterStatusMessage = (reader) => {
    const name2 = reader.cstring();
    const value = reader.cstring();
    return new messages_1.ParameterStatusMessage(LATEINIT_LENGTH, name2, value);
  };
  const parseBackendKeyData = (reader) => {
    const processID = reader.int32();
    const secretKey = reader.int32();
    return new messages_1.BackendKeyDataMessage(LATEINIT_LENGTH, processID, secretKey);
  };
  const parseAuthenticationResponse = (reader, length) => {
    const code = reader.int32();
    const message2 = {
      name: "authenticationOk",
      length
    };
    switch (code) {
      case 0:
        break;
      case 3:
        if (message2.length === 8) {
          message2.name = "authenticationCleartextPassword";
        }
        break;
      case 5:
        if (message2.length === 12) {
          message2.name = "authenticationMD5Password";
          const salt = reader.bytes(4);
          return new messages_1.AuthenticationMD5Password(LATEINIT_LENGTH, salt);
        }
        break;
      case 10:
        {
          message2.name = "authenticationSASL";
          message2.mechanisms = [];
          let mechanism;
          do {
            mechanism = reader.cstring();
            if (mechanism) {
              message2.mechanisms.push(mechanism);
            }
          } while (mechanism);
        }
        break;
      case 11:
        message2.name = "authenticationSASLContinue";
        message2.data = reader.string(length - 8);
        break;
      case 12:
        message2.name = "authenticationSASLFinal";
        message2.data = reader.string(length - 8);
        break;
      default:
        throw new Error("Unknown authenticationOk message type " + code);
    }
    return message2;
  };
  const parseErrorMessage = (reader, name2) => {
    const fields2 = {};
    let fieldType = reader.string(1);
    while (fieldType !== "\0") {
      fields2[fieldType] = reader.cstring();
      fieldType = reader.string(1);
    }
    const messageValue = fields2.M;
    const message2 = name2 === "notice" ? new messages_1.NoticeMessage(LATEINIT_LENGTH, messageValue) : new messages_1.DatabaseError(messageValue, LATEINIT_LENGTH, name2);
    message2.severity = fields2.S;
    message2.code = fields2.C;
    message2.detail = fields2.D;
    message2.hint = fields2.H;
    message2.position = fields2.P;
    message2.internalPosition = fields2.p;
    message2.internalQuery = fields2.q;
    message2.where = fields2.W;
    message2.schema = fields2.s;
    message2.table = fields2.t;
    message2.column = fields2.c;
    message2.dataType = fields2.d;
    message2.constraint = fields2.n;
    message2.file = fields2.F;
    message2.line = fields2.L;
    message2.routine = fields2.R;
    return message2;
  };
  return parser;
}
var hasRequiredDist;
function requireDist() {
  if (hasRequiredDist) return dist;
  hasRequiredDist = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.DatabaseError = exports$1.serialize = exports$1.parse = void 0;
    const messages_1 = requireMessages();
    Object.defineProperty(exports$1, "DatabaseError", { enumerable: true, get: function() {
      return messages_1.DatabaseError;
    } });
    const serializer_1 = requireSerializer();
    Object.defineProperty(exports$1, "serialize", { enumerable: true, get: function() {
      return serializer_1.serialize;
    } });
    const parser_1 = requireParser();
    function parse2(stream2, callback) {
      const parser2 = new parser_1.Parser();
      stream2.on("data", (buffer) => parser2.parse(buffer, callback));
      return new Promise((resolve2) => stream2.on("end", () => resolve2()));
    }
    exports$1.parse = parse2;
  })(dist);
  return dist;
}
var distExports = requireDist();
const index = /* @__PURE__ */ getDefaultExportFromCjs(distExports);
const protocol = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index
}, [distExports]);
const DatabaseError$1 = distExports.DatabaseError;
const SASL = distExports.SASL;
const serialize = distExports.serialize;
const parse = distExports.parse;
const esm$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DatabaseError: DatabaseError$1,
  SASL,
  default: protocol,
  parse,
  serialize
}, Symbol.toStringTag, { value: "Module" }));
const require$$7 = /* @__PURE__ */ getAugmentedNamespace(esm$2);
var empty = {};
var hasRequiredEmpty;
function requireEmpty() {
  if (hasRequiredEmpty) return empty;
  hasRequiredEmpty = 1;
  Object.defineProperty(empty, "__esModule", { value: true });
  empty.default = {};
  return empty;
}
var stream;
var hasRequiredStream;
function requireStream() {
  if (hasRequiredStream) return stream;
  hasRequiredStream = 1;
  const { getStream, getSecureStream } = getStreamFuncs();
  stream = {
    /**
     * Get a socket stream compatible with the current runtime environment.
     * @returns {Duplex}
     */
    getStream,
    /**
     * Get a TLS secured socket, compatible with the current environment,
     * using the socket and other settings given in `options`.
     * @returns {Duplex}
     */
    getSecureStream
  };
  function getNodejsStreamFuncs() {
    function getStream2(ssl) {
      const net = require$$0$d;
      return new net.Socket();
    }
    function getSecureStream2(options) {
      const tls = require$$1$4;
      return tls.connect(options);
    }
    return {
      getStream: getStream2,
      getSecureStream: getSecureStream2
    };
  }
  function getCloudflareStreamFuncs() {
    function getStream2(ssl) {
      const { CloudflareSocket } = requireEmpty();
      return new CloudflareSocket(ssl);
    }
    function getSecureStream2(options) {
      options.socket.startTls(options);
      return options.socket;
    }
    return {
      getStream: getStream2,
      getSecureStream: getSecureStream2
    };
  }
  function isCloudflareRuntime() {
    if (typeof navigator === "object" && navigator !== null && typeof navigator.userAgent === "string") {
      return navigator.userAgent === "Cloudflare-Workers";
    }
    if (typeof Response === "function") {
      const resp = new Response(null, { cf: { thing: true } });
      if (typeof resp.cf === "object" && resp.cf !== null && resp.cf.thing) {
        return true;
      }
    }
    return false;
  }
  function getStreamFuncs() {
    if (isCloudflareRuntime()) {
      return getCloudflareStreamFuncs();
    }
    return getNodejsStreamFuncs();
  }
  return stream;
}
var connection;
var hasRequiredConnection;
function requireConnection() {
  if (hasRequiredConnection) return connection;
  hasRequiredConnection = 1;
  const EventEmitter2 = require$$0$7.EventEmitter;
  const { parse: parse2, serialize: serialize2 } = require$$7;
  const { getStream, getSecureStream } = requireStream();
  const flushBuffer = serialize2.flush();
  const syncBuffer = serialize2.sync();
  const endBuffer = serialize2.end();
  class Connection2 extends EventEmitter2 {
    constructor(config2) {
      super();
      config2 = config2 || {};
      this.stream = config2.stream || getStream(config2.ssl);
      if (typeof this.stream === "function") {
        this.stream = this.stream(config2);
      }
      this._keepAlive = config2.keepAlive;
      this._keepAliveInitialDelayMillis = config2.keepAliveInitialDelayMillis;
      this.parsedStatements = {};
      this.ssl = config2.ssl || false;
      this._ending = false;
      this._emitMessage = false;
      const self2 = this;
      this.on("newListener", function(eventName) {
        if (eventName === "message") {
          self2._emitMessage = true;
        }
      });
    }
    connect(port, host) {
      const self2 = this;
      this._connecting = true;
      this.stream.setNoDelay(true);
      this.stream.connect(port, host);
      this.stream.once("connect", function() {
        if (self2._keepAlive) {
          self2.stream.setKeepAlive(true, self2._keepAliveInitialDelayMillis);
        }
        self2.emit("connect");
      });
      const reportStreamError = function(error2) {
        if (self2._ending && (error2.code === "ECONNRESET" || error2.code === "EPIPE")) {
          return;
        }
        self2.emit("error", error2);
      };
      this.stream.on("error", reportStreamError);
      this.stream.on("close", function() {
        self2.emit("end");
      });
      if (!this.ssl) {
        return this.attachListeners(this.stream);
      }
      this.stream.once("data", function(buffer) {
        const responseCode = buffer.toString("utf8");
        switch (responseCode) {
          case "S":
            break;
          case "N":
            self2.stream.end();
            return self2.emit("error", new Error("The server does not support SSL connections"));
          default:
            self2.stream.end();
            return self2.emit("error", new Error("There was an error establishing an SSL connection"));
        }
        const options = {
          socket: self2.stream
        };
        if (self2.ssl !== true) {
          Object.assign(options, self2.ssl);
          if ("key" in self2.ssl) {
            options.key = self2.ssl.key;
          }
        }
        const net = require$$0$d;
        if (net.isIP && net.isIP(host) === 0) {
          options.servername = host;
        }
        try {
          self2.stream = getSecureStream(options);
        } catch (err2) {
          return self2.emit("error", err2);
        }
        self2.attachListeners(self2.stream);
        self2.stream.on("error", reportStreamError);
        self2.emit("sslconnect");
      });
    }
    attachListeners(stream2) {
      parse2(stream2, (msg) => {
        const eventName = msg.name === "error" ? "errorMessage" : msg.name;
        if (this._emitMessage) {
          this.emit("message", msg);
        }
        this.emit(eventName, msg);
      });
    }
    requestSsl() {
      this.stream.write(serialize2.requestSsl());
    }
    startup(config2) {
      this.stream.write(serialize2.startup(config2));
    }
    cancel(processID, secretKey) {
      this._send(serialize2.cancel(processID, secretKey));
    }
    password(password) {
      this._send(serialize2.password(password));
    }
    sendSASLInitialResponseMessage(mechanism, initialResponse) {
      this._send(serialize2.sendSASLInitialResponseMessage(mechanism, initialResponse));
    }
    sendSCRAMClientFinalMessage(additionalData) {
      this._send(serialize2.sendSCRAMClientFinalMessage(additionalData));
    }
    _send(buffer) {
      if (!this.stream.writable) {
        return false;
      }
      return this.stream.write(buffer);
    }
    query(text2) {
      this._send(serialize2.query(text2));
    }
    // send parse message
    parse(query2) {
      this._send(serialize2.parse(query2));
    }
    // send bind message
    bind(config2) {
      this._send(serialize2.bind(config2));
    }
    // send execute message
    execute(config2) {
      this._send(serialize2.execute(config2));
    }
    flush() {
      if (this.stream.writable) {
        this.stream.write(flushBuffer);
      }
    }
    sync() {
      this._ending = true;
      this._send(syncBuffer);
    }
    ref() {
      this.stream.ref();
    }
    unref() {
      this.stream.unref();
    }
    end() {
      this._ending = true;
      if (!this._connecting || !this.stream.writable) {
        this.stream.end();
        return;
      }
      return this.stream.write(endBuffer, () => {
        this.stream.end();
      });
    }
    close(msg) {
      this._send(serialize2.close(msg));
    }
    describe(msg) {
      this._send(serialize2.describe(msg));
    }
    sendCopyFromChunk(chunk) {
      this._send(serialize2.copyData(chunk));
    }
    endCopyFrom() {
      this._send(serialize2.copyDone());
    }
    sendCopyFail(msg) {
      this._send(serialize2.copyFail(msg));
    }
  }
  connection = Connection2;
  return connection;
}
var lib = { exports: {} };
var helper = { exports: {} };
var split2;
var hasRequiredSplit2;
function requireSplit2() {
  if (hasRequiredSplit2) return split2;
  hasRequiredSplit2 = 1;
  const { Transform } = require$$0$c;
  const { StringDecoder } = require$$1$5;
  const kLast = /* @__PURE__ */ Symbol("last");
  const kDecoder = /* @__PURE__ */ Symbol("decoder");
  function transform2(chunk, enc2, cb) {
    let list;
    if (this.overflow) {
      const buf = this[kDecoder].write(chunk);
      list = buf.split(this.matcher);
      if (list.length === 1) return cb();
      list.shift();
      this.overflow = false;
    } else {
      this[kLast] += this[kDecoder].write(chunk);
      list = this[kLast].split(this.matcher);
    }
    this[kLast] = list.pop();
    for (let i = 0; i < list.length; i++) {
      try {
        push(this, this.mapper(list[i]));
      } catch (error2) {
        return cb(error2);
      }
    }
    this.overflow = this[kLast].length > this.maxLength;
    if (this.overflow && !this.skipOverflow) {
      cb(new Error("maximum buffer reached"));
      return;
    }
    cb();
  }
  function flush(cb) {
    this[kLast] += this[kDecoder].end();
    if (this[kLast]) {
      try {
        push(this, this.mapper(this[kLast]));
      } catch (error2) {
        return cb(error2);
      }
    }
    cb();
  }
  function push(self2, val) {
    if (val !== void 0) {
      self2.push(val);
    }
  }
  function noop2(incoming) {
    return incoming;
  }
  function split(matcher, mapper, options) {
    matcher = matcher || /\r?\n/;
    mapper = mapper || noop2;
    options = options || {};
    switch (arguments.length) {
      case 1:
        if (typeof matcher === "function") {
          mapper = matcher;
          matcher = /\r?\n/;
        } else if (typeof matcher === "object" && !(matcher instanceof RegExp) && !matcher[Symbol.split]) {
          options = matcher;
          matcher = /\r?\n/;
        }
        break;
      case 2:
        if (typeof matcher === "function") {
          options = mapper;
          mapper = matcher;
          matcher = /\r?\n/;
        } else if (typeof mapper === "object") {
          options = mapper;
          mapper = noop2;
        }
    }
    options = Object.assign({}, options);
    options.autoDestroy = true;
    options.transform = transform2;
    options.flush = flush;
    options.readableObjectMode = true;
    const stream2 = new Transform(options);
    stream2[kLast] = "";
    stream2[kDecoder] = new StringDecoder("utf8");
    stream2.matcher = matcher;
    stream2.mapper = mapper;
    stream2.maxLength = options.maxLength;
    stream2.skipOverflow = options.skipOverflow || false;
    stream2.overflow = false;
    stream2._destroy = function(err2, cb) {
      this._writableState.errorEmitted = false;
      cb(err2);
    };
    return stream2;
  }
  split2 = split;
  return split2;
}
var hasRequiredHelper;
function requireHelper() {
  if (hasRequiredHelper) return helper.exports;
  hasRequiredHelper = 1;
  (function(module) {
    var path = require$$0$6, Stream = require$$0$c.Stream, split = requireSplit2(), util = require$$1$1, defaultPort = 5432, isWin = process.platform === "win32", warnStream = process.stderr;
    var S_IRWXG = 56, S_IRWXO = 7, S_IFMT = 61440, S_IFREG = 32768;
    function isRegFile(mode) {
      return (mode & S_IFMT) == S_IFREG;
    }
    var fieldNames = ["host", "port", "database", "user", "password"];
    var nrOfFields = fieldNames.length;
    var passKey = fieldNames[nrOfFields - 1];
    function warn() {
      var isWritable = warnStream instanceof Stream && true === warnStream.writable;
      if (isWritable) {
        var args = Array.prototype.slice.call(arguments).concat("\n");
        warnStream.write(util.format.apply(util, args));
      }
    }
    Object.defineProperty(module.exports, "isWin", {
      get: function() {
        return isWin;
      },
      set: function(val) {
        isWin = val;
      }
    });
    module.exports.warnTo = function(stream2) {
      var old = warnStream;
      warnStream = stream2;
      return old;
    };
    module.exports.getFileName = function(rawEnv) {
      var env2 = rawEnv || process.env;
      var file = env2.PGPASSFILE || (isWin ? path.join(env2.APPDATA || "./", "postgresql", "pgpass.conf") : path.join(env2.HOME || "./", ".pgpass"));
      return file;
    };
    module.exports.usePgPass = function(stats, fname) {
      if (Object.prototype.hasOwnProperty.call(process.env, "PGPASSWORD")) {
        return false;
      }
      if (isWin) {
        return true;
      }
      fname = fname || "<unkn>";
      if (!isRegFile(stats.mode)) {
        warn('WARNING: password file "%s" is not a plain file', fname);
        return false;
      }
      if (stats.mode & (S_IRWXG | S_IRWXO)) {
        warn('WARNING: password file "%s" has group or world access; permissions should be u=rw (0600) or less', fname);
        return false;
      }
      return true;
    };
    var matcher = module.exports.match = function(connInfo, entry) {
      return fieldNames.slice(0, -1).reduce(function(prev, field, idx) {
        if (idx == 1) {
          if (Number(connInfo[field] || defaultPort) === Number(entry[field])) {
            return prev && true;
          }
        }
        return prev && (entry[field] === "*" || entry[field] === connInfo[field]);
      }, true);
    };
    module.exports.getPassword = function(connInfo, stream2, cb) {
      var pass;
      var lineStream = stream2.pipe(split());
      function onLine(line2) {
        var entry = parseLine(line2);
        if (entry && isValidEntry(entry) && matcher(connInfo, entry)) {
          pass = entry[passKey];
          lineStream.end();
        }
      }
      var onEnd = function() {
        stream2.destroy();
        cb(pass);
      };
      var onErr = function(err2) {
        stream2.destroy();
        warn("WARNING: error on reading file: %s", err2);
        cb(void 0);
      };
      stream2.on("error", onErr);
      lineStream.on("data", onLine).on("end", onEnd).on("error", onErr);
    };
    var parseLine = module.exports.parseLine = function(line2) {
      if (line2.length < 11 || line2.match(/^\s+#/)) {
        return null;
      }
      var curChar = "";
      var prevChar = "";
      var fieldIdx = 0;
      var startIdx = 0;
      var obj = {};
      var isLastField = false;
      var addToObj = function(idx, i0, i1) {
        var field = line2.substring(i0, i1);
        if (!Object.hasOwnProperty.call(process.env, "PGPASS_NO_DEESCAPE")) {
          field = field.replace(/\\([:\\])/g, "$1");
        }
        obj[fieldNames[idx]] = field;
      };
      for (var i = 0; i < line2.length - 1; i += 1) {
        curChar = line2.charAt(i + 1);
        prevChar = line2.charAt(i);
        isLastField = fieldIdx == nrOfFields - 1;
        if (isLastField) {
          addToObj(fieldIdx, startIdx);
          break;
        }
        if (i >= 0 && curChar == ":" && prevChar !== "\\") {
          addToObj(fieldIdx, startIdx, i + 1);
          startIdx = i + 2;
          fieldIdx += 1;
        }
      }
      obj = Object.keys(obj).length === nrOfFields ? obj : null;
      return obj;
    };
    var isValidEntry = module.exports.isValidEntry = function(entry) {
      var rules = {
        // host
        0: function(x) {
          return x.length > 0;
        },
        // port
        1: function(x) {
          if (x === "*") {
            return true;
          }
          x = Number(x);
          return isFinite(x) && x > 0 && x < 9007199254740992 && Math.floor(x) === x;
        },
        // database
        2: function(x) {
          return x.length > 0;
        },
        // username
        3: function(x) {
          return x.length > 0;
        },
        // password
        4: function(x) {
          return x.length > 0;
        }
      };
      for (var idx = 0; idx < fieldNames.length; idx += 1) {
        var rule = rules[idx];
        var value = entry[fieldNames[idx]] || "";
        var res2 = rule(value);
        if (!res2) {
          return false;
        }
      }
      return true;
    };
  })(helper);
  return helper.exports;
}
var hasRequiredLib$1;
function requireLib$1() {
  if (hasRequiredLib$1) return lib.exports;
  hasRequiredLib$1 = 1;
  var fs = require$$1$2, helper2 = requireHelper();
  lib.exports = function(connInfo, cb) {
    var file = helper2.getFileName();
    fs.stat(file, function(err2, stat) {
      if (err2 || !helper2.usePgPass(stat, file)) {
        return cb(void 0);
      }
      var st = fs.createReadStream(file);
      helper2.getPassword(connInfo, st, cb);
    });
  };
  lib.exports.warnTo = helper2.warnTo;
  return lib.exports;
}
var client$1;
var hasRequiredClient$1;
function requireClient$1() {
  if (hasRequiredClient$1) return client$1;
  hasRequiredClient$1 = 1;
  const EventEmitter2 = require$$0$7.EventEmitter;
  const utils2 = requireUtils$1();
  const nodeUtils = require$$1$1;
  const sasl2 = requireSasl();
  const TypeOverrides2 = requireTypeOverrides();
  const ConnectionParameters = requireConnectionParameters();
  const Query2 = requireQuery$1();
  const defaults2 = requireDefaults();
  const Connection2 = requireConnection();
  const crypto2 = requireUtils();
  const activeQueryDeprecationNotice = nodeUtils.deprecate(
    () => {
    },
    "Client.activeQuery is deprecated and will be removed in a future version."
  );
  const queryQueueDeprecationNotice = nodeUtils.deprecate(
    () => {
    },
    "Client.queryQueue is deprecated and will be removed in a future version."
  );
  const pgPassDeprecationNotice = nodeUtils.deprecate(
    () => {
    },
    "pgpass support is deprecated and will be removed in a future version. You can provide an async function as the password property to the Client/Pool constructor that returns a password instead. Within this funciton you can call the pgpass module in your own code."
  );
  const byoPromiseDeprecationNotice = nodeUtils.deprecate(
    () => {
    },
    "Passing a custom Promise implementation to the Client/Pool constructor is deprecated and will be removed in a future version."
  );
  class Client2 extends EventEmitter2 {
    constructor(config2) {
      super();
      this.connectionParameters = new ConnectionParameters(config2);
      this.user = this.connectionParameters.user;
      this.database = this.connectionParameters.database;
      this.port = this.connectionParameters.port;
      this.host = this.connectionParameters.host;
      Object.defineProperty(this, "password", {
        configurable: true,
        enumerable: false,
        writable: true,
        value: this.connectionParameters.password
      });
      this.replication = this.connectionParameters.replication;
      const c2 = config2 || {};
      if (c2.Promise) {
        byoPromiseDeprecationNotice();
      }
      this._Promise = c2.Promise || commonjsGlobal.Promise;
      this._types = new TypeOverrides2(c2.types);
      this._ending = false;
      this._ended = false;
      this._connecting = false;
      this._connected = false;
      this._connectionError = false;
      this._queryable = true;
      this._activeQuery = null;
      this.enableChannelBinding = Boolean(c2.enableChannelBinding);
      this.connection = c2.connection || new Connection2({
        stream: c2.stream,
        ssl: this.connectionParameters.ssl,
        keepAlive: c2.keepAlive || false,
        keepAliveInitialDelayMillis: c2.keepAliveInitialDelayMillis || 0,
        encoding: this.connectionParameters.client_encoding || "utf8"
      });
      this._queryQueue = [];
      this.binary = c2.binary || defaults2.binary;
      this.processID = null;
      this.secretKey = null;
      this.ssl = this.connectionParameters.ssl || false;
      if (this.ssl && this.ssl.key) {
        Object.defineProperty(this.ssl, "key", {
          enumerable: false
        });
      }
      this._connectionTimeoutMillis = c2.connectionTimeoutMillis || 0;
    }
    get activeQuery() {
      activeQueryDeprecationNotice();
      return this._activeQuery;
    }
    set activeQuery(val) {
      activeQueryDeprecationNotice();
      this._activeQuery = val;
    }
    _getActiveQuery() {
      return this._activeQuery;
    }
    _errorAllQueries(err2) {
      const enqueueError = (query2) => {
        process.nextTick(() => {
          query2.handleError(err2, this.connection);
        });
      };
      const activeQuery = this._getActiveQuery();
      if (activeQuery) {
        enqueueError(activeQuery);
        this._activeQuery = null;
      }
      this._queryQueue.forEach(enqueueError);
      this._queryQueue.length = 0;
    }
    _connect(callback) {
      const self2 = this;
      const con = this.connection;
      this._connectionCallback = callback;
      if (this._connecting || this._connected) {
        const err2 = new Error("Client has already been connected. You cannot reuse a client.");
        process.nextTick(() => {
          callback(err2);
        });
        return;
      }
      this._connecting = true;
      if (this._connectionTimeoutMillis > 0) {
        this.connectionTimeoutHandle = setTimeout(() => {
          con._ending = true;
          con.stream.destroy(new Error("timeout expired"));
        }, this._connectionTimeoutMillis);
        if (this.connectionTimeoutHandle.unref) {
          this.connectionTimeoutHandle.unref();
        }
      }
      if (this.host && this.host.indexOf("/") === 0) {
        con.connect(this.host + "/.s.PGSQL." + this.port);
      } else {
        con.connect(this.port, this.host);
      }
      con.on("connect", function() {
        if (self2.ssl) {
          con.requestSsl();
        } else {
          con.startup(self2.getStartupConf());
        }
      });
      con.on("sslconnect", function() {
        con.startup(self2.getStartupConf());
      });
      this._attachListeners(con);
      con.once("end", () => {
        const error2 = this._ending ? new Error("Connection terminated") : new Error("Connection terminated unexpectedly");
        clearTimeout(this.connectionTimeoutHandle);
        this._errorAllQueries(error2);
        this._ended = true;
        if (!this._ending) {
          if (this._connecting && !this._connectionError) {
            if (this._connectionCallback) {
              this._connectionCallback(error2);
            } else {
              this._handleErrorEvent(error2);
            }
          } else if (!this._connectionError) {
            this._handleErrorEvent(error2);
          }
        }
        process.nextTick(() => {
          this.emit("end");
        });
      });
    }
    connect(callback) {
      if (callback) {
        this._connect(callback);
        return;
      }
      return new this._Promise((resolve2, reject) => {
        this._connect((error2) => {
          if (error2) {
            reject(error2);
          } else {
            resolve2(this);
          }
        });
      });
    }
    _attachListeners(con) {
      con.on("authenticationCleartextPassword", this._handleAuthCleartextPassword.bind(this));
      con.on("authenticationMD5Password", this._handleAuthMD5Password.bind(this));
      con.on("authenticationSASL", this._handleAuthSASL.bind(this));
      con.on("authenticationSASLContinue", this._handleAuthSASLContinue.bind(this));
      con.on("authenticationSASLFinal", this._handleAuthSASLFinal.bind(this));
      con.on("backendKeyData", this._handleBackendKeyData.bind(this));
      con.on("error", this._handleErrorEvent.bind(this));
      con.on("errorMessage", this._handleErrorMessage.bind(this));
      con.on("readyForQuery", this._handleReadyForQuery.bind(this));
      con.on("notice", this._handleNotice.bind(this));
      con.on("rowDescription", this._handleRowDescription.bind(this));
      con.on("dataRow", this._handleDataRow.bind(this));
      con.on("portalSuspended", this._handlePortalSuspended.bind(this));
      con.on("emptyQuery", this._handleEmptyQuery.bind(this));
      con.on("commandComplete", this._handleCommandComplete.bind(this));
      con.on("parseComplete", this._handleParseComplete.bind(this));
      con.on("copyInResponse", this._handleCopyInResponse.bind(this));
      con.on("copyData", this._handleCopyData.bind(this));
      con.on("notification", this._handleNotification.bind(this));
    }
    _getPassword(cb) {
      const con = this.connection;
      if (typeof this.password === "function") {
        this._Promise.resolve().then(() => this.password()).then((pass) => {
          if (pass !== void 0) {
            if (typeof pass !== "string") {
              con.emit("error", new TypeError("Password must be a string"));
              return;
            }
            this.connectionParameters.password = this.password = pass;
          } else {
            this.connectionParameters.password = this.password = null;
          }
          cb();
        }).catch((err2) => {
          con.emit("error", err2);
        });
      } else if (this.password !== null) {
        cb();
      } else {
        try {
          const pgPass = requireLib$1();
          pgPass(this.connectionParameters, (pass) => {
            if (void 0 !== pass) {
              pgPassDeprecationNotice();
              this.connectionParameters.password = this.password = pass;
            }
            cb();
          });
        } catch (e2) {
          this.emit("error", e2);
        }
      }
    }
    _handleAuthCleartextPassword(msg) {
      this._getPassword(() => {
        this.connection.password(this.password);
      });
    }
    _handleAuthMD5Password(msg) {
      this._getPassword(async () => {
        try {
          const hashedPassword = await crypto2.postgresMd5PasswordHash(this.user, this.password, msg.salt);
          this.connection.password(hashedPassword);
        } catch (e2) {
          this.emit("error", e2);
        }
      });
    }
    _handleAuthSASL(msg) {
      this._getPassword(() => {
        try {
          this.saslSession = sasl2.startSession(msg.mechanisms, this.enableChannelBinding && this.connection.stream);
          this.connection.sendSASLInitialResponseMessage(this.saslSession.mechanism, this.saslSession.response);
        } catch (err2) {
          this.connection.emit("error", err2);
        }
      });
    }
    async _handleAuthSASLContinue(msg) {
      try {
        await sasl2.continueSession(
          this.saslSession,
          this.password,
          msg.data,
          this.enableChannelBinding && this.connection.stream
        );
        this.connection.sendSCRAMClientFinalMessage(this.saslSession.response);
      } catch (err2) {
        this.connection.emit("error", err2);
      }
    }
    _handleAuthSASLFinal(msg) {
      try {
        sasl2.finalizeSession(this.saslSession, msg.data);
        this.saslSession = null;
      } catch (err2) {
        this.connection.emit("error", err2);
      }
    }
    _handleBackendKeyData(msg) {
      this.processID = msg.processID;
      this.secretKey = msg.secretKey;
    }
    _handleReadyForQuery(msg) {
      if (this._connecting) {
        this._connecting = false;
        this._connected = true;
        clearTimeout(this.connectionTimeoutHandle);
        if (this._connectionCallback) {
          this._connectionCallback(null, this);
          this._connectionCallback = null;
        }
        this.emit("connect");
      }
      const activeQuery = this._getActiveQuery();
      this._activeQuery = null;
      this.readyForQuery = true;
      if (activeQuery) {
        activeQuery.handleReadyForQuery(this.connection);
      }
      this._pulseQueryQueue();
    }
    // if we receive an error event or error message
    // during the connection process we handle it here
    _handleErrorWhileConnecting(err2) {
      if (this._connectionError) {
        return;
      }
      this._connectionError = true;
      clearTimeout(this.connectionTimeoutHandle);
      if (this._connectionCallback) {
        return this._connectionCallback(err2);
      }
      this.emit("error", err2);
    }
    // if we're connected and we receive an error event from the connection
    // this means the socket is dead - do a hard abort of all queries and emit
    // the socket error on the client as well
    _handleErrorEvent(err2) {
      if (this._connecting) {
        return this._handleErrorWhileConnecting(err2);
      }
      this._queryable = false;
      this._errorAllQueries(err2);
      this.emit("error", err2);
    }
    // handle error messages from the postgres backend
    _handleErrorMessage(msg) {
      if (this._connecting) {
        return this._handleErrorWhileConnecting(msg);
      }
      const activeQuery = this._getActiveQuery();
      if (!activeQuery) {
        this._handleErrorEvent(msg);
        return;
      }
      this._activeQuery = null;
      activeQuery.handleError(msg, this.connection);
    }
    _handleRowDescription(msg) {
      const activeQuery = this._getActiveQuery();
      if (activeQuery == null) {
        const error2 = new Error("Received unexpected rowDescription message from backend.");
        this._handleErrorEvent(error2);
        return;
      }
      activeQuery.handleRowDescription(msg);
    }
    _handleDataRow(msg) {
      const activeQuery = this._getActiveQuery();
      if (activeQuery == null) {
        const error2 = new Error("Received unexpected dataRow message from backend.");
        this._handleErrorEvent(error2);
        return;
      }
      activeQuery.handleDataRow(msg);
    }
    _handlePortalSuspended(msg) {
      const activeQuery = this._getActiveQuery();
      if (activeQuery == null) {
        const error2 = new Error("Received unexpected portalSuspended message from backend.");
        this._handleErrorEvent(error2);
        return;
      }
      activeQuery.handlePortalSuspended(this.connection);
    }
    _handleEmptyQuery(msg) {
      const activeQuery = this._getActiveQuery();
      if (activeQuery == null) {
        const error2 = new Error("Received unexpected emptyQuery message from backend.");
        this._handleErrorEvent(error2);
        return;
      }
      activeQuery.handleEmptyQuery(this.connection);
    }
    _handleCommandComplete(msg) {
      const activeQuery = this._getActiveQuery();
      if (activeQuery == null) {
        const error2 = new Error("Received unexpected commandComplete message from backend.");
        this._handleErrorEvent(error2);
        return;
      }
      activeQuery.handleCommandComplete(msg, this.connection);
    }
    _handleParseComplete() {
      const activeQuery = this._getActiveQuery();
      if (activeQuery == null) {
        const error2 = new Error("Received unexpected parseComplete message from backend.");
        this._handleErrorEvent(error2);
        return;
      }
      if (activeQuery.name) {
        this.connection.parsedStatements[activeQuery.name] = activeQuery.text;
      }
    }
    _handleCopyInResponse(msg) {
      const activeQuery = this._getActiveQuery();
      if (activeQuery == null) {
        const error2 = new Error("Received unexpected copyInResponse message from backend.");
        this._handleErrorEvent(error2);
        return;
      }
      activeQuery.handleCopyInResponse(this.connection);
    }
    _handleCopyData(msg) {
      const activeQuery = this._getActiveQuery();
      if (activeQuery == null) {
        const error2 = new Error("Received unexpected copyData message from backend.");
        this._handleErrorEvent(error2);
        return;
      }
      activeQuery.handleCopyData(msg, this.connection);
    }
    _handleNotification(msg) {
      this.emit("notification", msg);
    }
    _handleNotice(msg) {
      this.emit("notice", msg);
    }
    getStartupConf() {
      const params = this.connectionParameters;
      const data = {
        user: params.user,
        database: params.database
      };
      const appName = params.application_name || params.fallback_application_name;
      if (appName) {
        data.application_name = appName;
      }
      if (params.replication) {
        data.replication = "" + params.replication;
      }
      if (params.statement_timeout) {
        data.statement_timeout = String(parseInt(params.statement_timeout, 10));
      }
      if (params.lock_timeout) {
        data.lock_timeout = String(parseInt(params.lock_timeout, 10));
      }
      if (params.idle_in_transaction_session_timeout) {
        data.idle_in_transaction_session_timeout = String(parseInt(params.idle_in_transaction_session_timeout, 10));
      }
      if (params.options) {
        data.options = params.options;
      }
      return data;
    }
    cancel(client2, query2) {
      if (client2.activeQuery === query2) {
        const con = this.connection;
        if (this.host && this.host.indexOf("/") === 0) {
          con.connect(this.host + "/.s.PGSQL." + this.port);
        } else {
          con.connect(this.port, this.host);
        }
        con.on("connect", function() {
          con.cancel(client2.processID, client2.secretKey);
        });
      } else if (client2._queryQueue.indexOf(query2) !== -1) {
        client2._queryQueue.splice(client2._queryQueue.indexOf(query2), 1);
      }
    }
    setTypeParser(oid, format2, parseFn) {
      return this._types.setTypeParser(oid, format2, parseFn);
    }
    getTypeParser(oid, format2) {
      return this._types.getTypeParser(oid, format2);
    }
    // escapeIdentifier and escapeLiteral moved to utility functions & exported
    // on PG
    // re-exported here for backwards compatibility
    escapeIdentifier(str) {
      return utils2.escapeIdentifier(str);
    }
    escapeLiteral(str) {
      return utils2.escapeLiteral(str);
    }
    _pulseQueryQueue() {
      if (this.readyForQuery === true) {
        this._activeQuery = this._queryQueue.shift();
        const activeQuery = this._getActiveQuery();
        if (activeQuery) {
          this.readyForQuery = false;
          this.hasExecuted = true;
          const queryError = activeQuery.submit(this.connection);
          if (queryError) {
            process.nextTick(() => {
              activeQuery.handleError(queryError, this.connection);
              this.readyForQuery = true;
              this._pulseQueryQueue();
            });
          }
        } else if (this.hasExecuted) {
          this._activeQuery = null;
          this.emit("drain");
        }
      }
    }
    query(config2, values, callback) {
      let query2;
      let result2;
      let readTimeout;
      let readTimeoutTimer;
      let queryCallback;
      if (config2 === null || config2 === void 0) {
        throw new TypeError("Client was passed a null or undefined query");
      } else if (typeof config2.submit === "function") {
        readTimeout = config2.query_timeout || this.connectionParameters.query_timeout;
        result2 = query2 = config2;
        if (typeof values === "function") {
          query2.callback = query2.callback || values;
        }
      } else {
        readTimeout = config2.query_timeout || this.connectionParameters.query_timeout;
        query2 = new Query2(config2, values, callback);
        if (!query2.callback) {
          result2 = new this._Promise((resolve2, reject) => {
            query2.callback = (err2, res2) => err2 ? reject(err2) : resolve2(res2);
          }).catch((err2) => {
            Error.captureStackTrace(err2);
            throw err2;
          });
        }
      }
      if (readTimeout) {
        queryCallback = query2.callback;
        readTimeoutTimer = setTimeout(() => {
          const error2 = new Error("Query read timeout");
          process.nextTick(() => {
            query2.handleError(error2, this.connection);
          });
          queryCallback(error2);
          query2.callback = () => {
          };
          const index2 = this._queryQueue.indexOf(query2);
          if (index2 > -1) {
            this._queryQueue.splice(index2, 1);
          }
          this._pulseQueryQueue();
        }, readTimeout);
        query2.callback = (err2, res2) => {
          clearTimeout(readTimeoutTimer);
          queryCallback(err2, res2);
        };
      }
      if (this.binary && !query2.binary) {
        query2.binary = true;
      }
      if (query2._result && !query2._result._types) {
        query2._result._types = this._types;
      }
      if (!this._queryable) {
        process.nextTick(() => {
          query2.handleError(new Error("Client has encountered a connection error and is not queryable"), this.connection);
        });
        return result2;
      }
      if (this._ending) {
        process.nextTick(() => {
          query2.handleError(new Error("Client was closed and is not queryable"), this.connection);
        });
        return result2;
      }
      this._queryQueue.push(query2);
      this._pulseQueryQueue();
      return result2;
    }
    ref() {
      this.connection.ref();
    }
    unref() {
      this.connection.unref();
    }
    end(cb) {
      this._ending = true;
      if (!this.connection._connecting || this._ended) {
        if (cb) {
          cb();
        } else {
          return this._Promise.resolve();
        }
      }
      if (this._getActiveQuery() || !this._queryable) {
        this.connection.stream.destroy();
      } else {
        this.connection.end();
      }
      if (cb) {
        this.connection.once("end", cb);
      } else {
        return new this._Promise((resolve2) => {
          this.connection.once("end", resolve2);
        });
      }
    }
    get queryQueue() {
      queryQueueDeprecationNotice();
      return this._queryQueue;
    }
  }
  Client2.Query = Query2;
  client$1 = Client2;
  return client$1;
}
const require$$1 = /* @__PURE__ */ getAugmentedNamespace(esm);
var pgPool;
var hasRequiredPgPool;
function requirePgPool() {
  if (hasRequiredPgPool) return pgPool;
  hasRequiredPgPool = 1;
  const EventEmitter2 = require$$0$7.EventEmitter;
  const NOOP = function() {
  };
  const removeWhere = (list, predicate) => {
    const i = list.findIndex(predicate);
    return i === -1 ? void 0 : list.splice(i, 1)[0];
  };
  class IdleItem {
    constructor(client2, idleListener, timeoutId) {
      this.client = client2;
      this.idleListener = idleListener;
      this.timeoutId = timeoutId;
    }
  }
  class PendingItem {
    constructor(callback) {
      this.callback = callback;
    }
  }
  function throwOnDoubleRelease() {
    throw new Error("Release called on client which has already been released to the pool.");
  }
  function promisify(Promise2, callback) {
    if (callback) {
      return { callback, result: void 0 };
    }
    let rej;
    let res2;
    const cb = function(err2, client2) {
      err2 ? rej(err2) : res2(client2);
    };
    const result2 = new Promise2(function(resolve2, reject) {
      res2 = resolve2;
      rej = reject;
    }).catch((err2) => {
      Error.captureStackTrace(err2);
      throw err2;
    });
    return { callback: cb, result: result2 };
  }
  function makeIdleListener(pool, client2) {
    return function idleListener(err2) {
      err2.client = client2;
      client2.removeListener("error", idleListener);
      client2.on("error", () => {
        pool.log("additional client error after disconnection due to error", err2);
      });
      pool._remove(client2);
      pool.emit("error", err2, client2);
    };
  }
  class Pool2 extends EventEmitter2 {
    constructor(options, Client2) {
      super();
      this.options = Object.assign({}, options);
      if (options != null && "password" in options) {
        Object.defineProperty(this.options, "password", {
          configurable: true,
          enumerable: false,
          writable: true,
          value: options.password
        });
      }
      if (options != null && options.ssl && options.ssl.key) {
        Object.defineProperty(this.options.ssl, "key", {
          enumerable: false
        });
      }
      this.options.max = this.options.max || this.options.poolSize || 10;
      this.options.min = this.options.min || 0;
      this.options.maxUses = this.options.maxUses || Infinity;
      this.options.allowExitOnIdle = this.options.allowExitOnIdle || false;
      this.options.maxLifetimeSeconds = this.options.maxLifetimeSeconds || 0;
      this.log = this.options.log || function() {
      };
      this.Client = this.options.Client || Client2 || require$$1.Client;
      this.Promise = this.options.Promise || commonjsGlobal.Promise;
      if (typeof this.options.idleTimeoutMillis === "undefined") {
        this.options.idleTimeoutMillis = 1e4;
      }
      this._clients = [];
      this._idle = [];
      this._expired = /* @__PURE__ */ new WeakSet();
      this._pendingQueue = [];
      this._endCallback = void 0;
      this.ending = false;
      this.ended = false;
    }
    _isFull() {
      return this._clients.length >= this.options.max;
    }
    _isAboveMin() {
      return this._clients.length > this.options.min;
    }
    _pulseQueue() {
      this.log("pulse queue");
      if (this.ended) {
        this.log("pulse queue ended");
        return;
      }
      if (this.ending) {
        this.log("pulse queue on ending");
        if (this._idle.length) {
          this._idle.slice().map((item) => {
            this._remove(item.client);
          });
        }
        if (!this._clients.length) {
          this.ended = true;
          this._endCallback();
        }
        return;
      }
      if (!this._pendingQueue.length) {
        this.log("no queued requests");
        return;
      }
      if (!this._idle.length && this._isFull()) {
        return;
      }
      const pendingItem = this._pendingQueue.shift();
      if (this._idle.length) {
        const idleItem = this._idle.pop();
        clearTimeout(idleItem.timeoutId);
        const client2 = idleItem.client;
        client2.ref && client2.ref();
        const idleListener = idleItem.idleListener;
        return this._acquireClient(client2, pendingItem, idleListener, false);
      }
      if (!this._isFull()) {
        return this.newClient(pendingItem);
      }
      throw new Error("unexpected condition");
    }
    _remove(client2, callback) {
      const removed = removeWhere(this._idle, (item) => item.client === client2);
      if (removed !== void 0) {
        clearTimeout(removed.timeoutId);
      }
      this._clients = this._clients.filter((c2) => c2 !== client2);
      const context = this;
      client2.end(() => {
        context.emit("remove", client2);
        if (typeof callback === "function") {
          callback();
        }
      });
    }
    connect(cb) {
      if (this.ending) {
        const err2 = new Error("Cannot use a pool after calling end on the pool");
        return cb ? cb(err2) : this.Promise.reject(err2);
      }
      const response = promisify(this.Promise, cb);
      const result2 = response.result;
      if (this._isFull() || this._idle.length) {
        if (this._idle.length) {
          process.nextTick(() => this._pulseQueue());
        }
        if (!this.options.connectionTimeoutMillis) {
          this._pendingQueue.push(new PendingItem(response.callback));
          return result2;
        }
        const queueCallback = (err2, res2, done) => {
          clearTimeout(tid);
          response.callback(err2, res2, done);
        };
        const pendingItem = new PendingItem(queueCallback);
        const tid = setTimeout(() => {
          removeWhere(this._pendingQueue, (i) => i.callback === queueCallback);
          pendingItem.timedOut = true;
          response.callback(new Error("timeout exceeded when trying to connect"));
        }, this.options.connectionTimeoutMillis);
        if (tid.unref) {
          tid.unref();
        }
        this._pendingQueue.push(pendingItem);
        return result2;
      }
      this.newClient(new PendingItem(response.callback));
      return result2;
    }
    newClient(pendingItem) {
      const client2 = new this.Client(this.options);
      this._clients.push(client2);
      const idleListener = makeIdleListener(this, client2);
      this.log("checking client timeout");
      let tid;
      let timeoutHit = false;
      if (this.options.connectionTimeoutMillis) {
        tid = setTimeout(() => {
          this.log("ending client due to timeout");
          timeoutHit = true;
          client2.connection ? client2.connection.stream.destroy() : client2.end();
        }, this.options.connectionTimeoutMillis);
      }
      this.log("connecting new client");
      client2.connect((err2) => {
        if (tid) {
          clearTimeout(tid);
        }
        client2.on("error", idleListener);
        if (err2) {
          this.log("client failed to connect", err2);
          this._clients = this._clients.filter((c2) => c2 !== client2);
          if (timeoutHit) {
            err2 = new Error("Connection terminated due to connection timeout", { cause: err2 });
          }
          this._pulseQueue();
          if (!pendingItem.timedOut) {
            pendingItem.callback(err2, void 0, NOOP);
          }
        } else {
          this.log("new client connected");
          if (this.options.maxLifetimeSeconds !== 0) {
            const maxLifetimeTimeout = setTimeout(() => {
              this.log("ending client due to expired lifetime");
              this._expired.add(client2);
              const idleIndex = this._idle.findIndex((idleItem) => idleItem.client === client2);
              if (idleIndex !== -1) {
                this._acquireClient(
                  client2,
                  new PendingItem((err3, client3, clientRelease) => clientRelease()),
                  idleListener,
                  false
                );
              }
            }, this.options.maxLifetimeSeconds * 1e3);
            maxLifetimeTimeout.unref();
            client2.once("end", () => clearTimeout(maxLifetimeTimeout));
          }
          return this._acquireClient(client2, pendingItem, idleListener, true);
        }
      });
    }
    // acquire a client for a pending work item
    _acquireClient(client2, pendingItem, idleListener, isNew) {
      if (isNew) {
        this.emit("connect", client2);
      }
      this.emit("acquire", client2);
      client2.release = this._releaseOnce(client2, idleListener);
      client2.removeListener("error", idleListener);
      if (!pendingItem.timedOut) {
        if (isNew && this.options.verify) {
          this.options.verify(client2, (err2) => {
            if (err2) {
              client2.release(err2);
              return pendingItem.callback(err2, void 0, NOOP);
            }
            pendingItem.callback(void 0, client2, client2.release);
          });
        } else {
          pendingItem.callback(void 0, client2, client2.release);
        }
      } else {
        if (isNew && this.options.verify) {
          this.options.verify(client2, client2.release);
        } else {
          client2.release();
        }
      }
    }
    // returns a function that wraps _release and throws if called more than once
    _releaseOnce(client2, idleListener) {
      let released = false;
      return (err2) => {
        if (released) {
          throwOnDoubleRelease();
        }
        released = true;
        this._release(client2, idleListener, err2);
      };
    }
    // release a client back to the poll, include an error
    // to remove it from the pool
    _release(client2, idleListener, err2) {
      client2.on("error", idleListener);
      client2._poolUseCount = (client2._poolUseCount || 0) + 1;
      this.emit("release", err2, client2);
      if (err2 || this.ending || !client2._queryable || client2._ending || client2._poolUseCount >= this.options.maxUses) {
        if (client2._poolUseCount >= this.options.maxUses) {
          this.log("remove expended client");
        }
        return this._remove(client2, this._pulseQueue.bind(this));
      }
      const isExpired = this._expired.has(client2);
      if (isExpired) {
        this.log("remove expired client");
        this._expired.delete(client2);
        return this._remove(client2, this._pulseQueue.bind(this));
      }
      let tid;
      if (this.options.idleTimeoutMillis && this._isAboveMin()) {
        tid = setTimeout(() => {
          if (this._isAboveMin()) {
            this.log("remove idle client");
            this._remove(client2, this._pulseQueue.bind(this));
          }
        }, this.options.idleTimeoutMillis);
        if (this.options.allowExitOnIdle) {
          tid.unref();
        }
      }
      if (this.options.allowExitOnIdle) {
        client2.unref();
      }
      this._idle.push(new IdleItem(client2, idleListener, tid));
      this._pulseQueue();
    }
    query(text2, values, cb) {
      if (typeof text2 === "function") {
        const response2 = promisify(this.Promise, text2);
        setImmediate(function() {
          return response2.callback(new Error("Passing a function as the first parameter to pool.query is not supported"));
        });
        return response2.result;
      }
      if (typeof values === "function") {
        cb = values;
        values = void 0;
      }
      const response = promisify(this.Promise, cb);
      cb = response.callback;
      this.connect((err2, client2) => {
        if (err2) {
          return cb(err2);
        }
        let clientReleased = false;
        const onError = (err3) => {
          if (clientReleased) {
            return;
          }
          clientReleased = true;
          client2.release(err3);
          cb(err3);
        };
        client2.once("error", onError);
        this.log("dispatching query");
        try {
          client2.query(text2, values, (err3, res2) => {
            this.log("query dispatched");
            client2.removeListener("error", onError);
            if (clientReleased) {
              return;
            }
            clientReleased = true;
            client2.release(err3);
            if (err3) {
              return cb(err3);
            }
            return cb(void 0, res2);
          });
        } catch (err3) {
          client2.release(err3);
          return cb(err3);
        }
      });
      return response.result;
    }
    end(cb) {
      this.log("ending");
      if (this.ending) {
        const err2 = new Error("Called end on pool more than once");
        return cb ? cb(err2) : this.Promise.reject(err2);
      }
      this.ending = true;
      const promised = promisify(this.Promise, cb);
      this._endCallback = promised.callback;
      this._pulseQueue();
      return promised.result;
    }
    get waitingCount() {
      return this._pendingQueue.length;
    }
    get idleCount() {
      return this._idle.length;
    }
    get expiredCount() {
      return this._clients.reduce((acc, client2) => acc + (this._expired.has(client2) ? 1 : 0), 0);
    }
    get totalCount() {
      return this._clients.length;
    }
  }
  pgPool = Pool2;
  return pgPool;
}
var pgPoolExports = requirePgPool();
const Pool$1 = /* @__PURE__ */ getDefaultExportFromCjs(pgPoolExports);
const esm$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Pool$1
}, Symbol.toStringTag, { value: "Module" }));
const require$$5 = /* @__PURE__ */ getAugmentedNamespace(esm$1);
var client = { exports: {} };
const __viteOptionalPeerDep_pgNative_pg_true = {};
const __viteOptionalPeerDep_pgNative_pg_true$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteOptionalPeerDep_pgNative_pg_true
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteOptionalPeerDep_pgNative_pg_true$1);
var query = { exports: {} };
var hasRequiredQuery;
function requireQuery() {
  if (hasRequiredQuery) return query.exports;
  hasRequiredQuery = 1;
  const EventEmitter2 = require$$0$7.EventEmitter;
  const util = require$$1$1;
  const utils2 = requireUtils$1();
  const NativeQuery = query.exports = function(config2, values, callback) {
    EventEmitter2.call(this);
    config2 = utils2.normalizeQueryConfig(config2, values, callback);
    this.text = config2.text;
    this.values = config2.values;
    this.name = config2.name;
    this.queryMode = config2.queryMode;
    this.callback = config2.callback;
    this.state = "new";
    this._arrayMode = config2.rowMode === "array";
    this._emitRowEvents = false;
    this.on(
      "newListener",
      (function(event) {
        if (event === "row") this._emitRowEvents = true;
      }).bind(this)
    );
  };
  util.inherits(NativeQuery, EventEmitter2);
  const errorFieldMap = {
    sqlState: "code",
    statementPosition: "position",
    messagePrimary: "message",
    context: "where",
    schemaName: "schema",
    tableName: "table",
    columnName: "column",
    dataTypeName: "dataType",
    constraintName: "constraint",
    sourceFile: "file",
    sourceLine: "line",
    sourceFunction: "routine"
  };
  NativeQuery.prototype.handleError = function(err2) {
    const fields2 = this.native.pq.resultErrorFields();
    if (fields2) {
      for (const key in fields2) {
        const normalizedFieldName = errorFieldMap[key] || key;
        err2[normalizedFieldName] = fields2[key];
      }
    }
    if (this.callback) {
      this.callback(err2);
    } else {
      this.emit("error", err2);
    }
    this.state = "error";
  };
  NativeQuery.prototype.then = function(onSuccess, onFailure) {
    return this._getPromise().then(onSuccess, onFailure);
  };
  NativeQuery.prototype.catch = function(callback) {
    return this._getPromise().catch(callback);
  };
  NativeQuery.prototype._getPromise = function() {
    if (this._promise) return this._promise;
    this._promise = new Promise(
      (function(resolve2, reject) {
        this._once("end", resolve2);
        this._once("error", reject);
      }).bind(this)
    );
    return this._promise;
  };
  NativeQuery.prototype.submit = function(client2) {
    this.state = "running";
    const self2 = this;
    this.native = client2.native;
    client2.native.arrayMode = this._arrayMode;
    let after = function(err2, rows, results) {
      client2.native.arrayMode = false;
      setImmediate(function() {
        self2.emit("_done");
      });
      if (err2) {
        return self2.handleError(err2);
      }
      if (self2._emitRowEvents) {
        if (results.length > 1) {
          rows.forEach((rowOfRows, i) => {
            rowOfRows.forEach((row) => {
              self2.emit("row", row, results[i]);
            });
          });
        } else {
          rows.forEach(function(row) {
            self2.emit("row", row, results);
          });
        }
      }
      self2.state = "end";
      self2.emit("end", results);
      if (self2.callback) {
        self2.callback(null, results);
      }
    };
    if (process.domain) {
      after = process.domain.bind(after);
    }
    if (this.name) {
      if (this.name.length > 63) {
        console.error("Warning! Postgres only supports 63 characters for query names.");
        console.error("You supplied %s (%s)", this.name, this.name.length);
        console.error("This can cause conflicts and silent errors executing queries");
      }
      const values = (this.values || []).map(utils2.prepareValue);
      if (client2.namedQueries[this.name]) {
        if (this.text && client2.namedQueries[this.name] !== this.text) {
          const err2 = new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);
          return after(err2);
        }
        return client2.native.execute(this.name, values, after);
      }
      return client2.native.prepare(this.name, this.text, values.length, function(err2) {
        if (err2) return after(err2);
        client2.namedQueries[self2.name] = self2.text;
        return self2.native.execute(self2.name, values, after);
      });
    } else if (this.values) {
      if (!Array.isArray(this.values)) {
        const err2 = new Error("Query values must be an array");
        return after(err2);
      }
      const vals = this.values.map(utils2.prepareValue);
      client2.native.query(this.text, vals, after);
    } else if (this.queryMode === "extended") {
      client2.native.query(this.text, [], after);
    } else {
      client2.native.query(this.text, after);
    }
  };
  return query.exports;
}
var hasRequiredClient;
function requireClient() {
  if (hasRequiredClient) return client.exports;
  hasRequiredClient = 1;
  var Native;
  try {
    Native = require$$0;
  } catch (e2) {
    throw e2;
  }
  const TypeOverrides2 = requireTypeOverrides();
  const EventEmitter2 = require$$0$7.EventEmitter;
  const util = require$$1$1;
  const ConnectionParameters = requireConnectionParameters();
  const NativeQuery = requireQuery();
  const Client2 = client.exports = function(config2) {
    EventEmitter2.call(this);
    config2 = config2 || {};
    this._Promise = config2.Promise || commonjsGlobal.Promise;
    this._types = new TypeOverrides2(config2.types);
    this.native = new Native({
      types: this._types
    });
    this._queryQueue = [];
    this._ending = false;
    this._connecting = false;
    this._connected = false;
    this._queryable = true;
    const cp = this.connectionParameters = new ConnectionParameters(config2);
    if (config2.nativeConnectionString) cp.nativeConnectionString = config2.nativeConnectionString;
    this.user = cp.user;
    Object.defineProperty(this, "password", {
      configurable: true,
      enumerable: false,
      writable: true,
      value: cp.password
    });
    this.database = cp.database;
    this.host = cp.host;
    this.port = cp.port;
    this.namedQueries = {};
  };
  Client2.Query = NativeQuery;
  util.inherits(Client2, EventEmitter2);
  Client2.prototype._errorAllQueries = function(err2) {
    const enqueueError = (query2) => {
      process.nextTick(() => {
        query2.native = this.native;
        query2.handleError(err2);
      });
    };
    if (this._hasActiveQuery()) {
      enqueueError(this._activeQuery);
      this._activeQuery = null;
    }
    this._queryQueue.forEach(enqueueError);
    this._queryQueue.length = 0;
  };
  Client2.prototype._connect = function(cb) {
    const self2 = this;
    if (this._connecting) {
      process.nextTick(() => cb(new Error("Client has already been connected. You cannot reuse a client.")));
      return;
    }
    this._connecting = true;
    this.connectionParameters.getLibpqConnectionString(function(err2, conString) {
      if (self2.connectionParameters.nativeConnectionString) conString = self2.connectionParameters.nativeConnectionString;
      if (err2) return cb(err2);
      self2.native.connect(conString, function(err3) {
        if (err3) {
          self2.native.end();
          return cb(err3);
        }
        self2._connected = true;
        self2.native.on("error", function(err4) {
          self2._queryable = false;
          self2._errorAllQueries(err4);
          self2.emit("error", err4);
        });
        self2.native.on("notification", function(msg) {
          self2.emit("notification", {
            channel: msg.relname,
            payload: msg.extra
          });
        });
        self2.emit("connect");
        self2._pulseQueryQueue(true);
        cb(null, this);
      });
    });
  };
  Client2.prototype.connect = function(callback) {
    if (callback) {
      this._connect(callback);
      return;
    }
    return new this._Promise((resolve2, reject) => {
      this._connect((error2) => {
        if (error2) {
          reject(error2);
        } else {
          resolve2(this);
        }
      });
    });
  };
  Client2.prototype.query = function(config2, values, callback) {
    let query2;
    let result2;
    let readTimeout;
    let readTimeoutTimer;
    let queryCallback;
    if (config2 === null || config2 === void 0) {
      throw new TypeError("Client was passed a null or undefined query");
    } else if (typeof config2.submit === "function") {
      readTimeout = config2.query_timeout || this.connectionParameters.query_timeout;
      result2 = query2 = config2;
      if (typeof values === "function") {
        config2.callback = values;
      }
    } else {
      readTimeout = config2.query_timeout || this.connectionParameters.query_timeout;
      query2 = new NativeQuery(config2, values, callback);
      if (!query2.callback) {
        let resolveOut, rejectOut;
        result2 = new this._Promise((resolve2, reject) => {
          resolveOut = resolve2;
          rejectOut = reject;
        }).catch((err2) => {
          Error.captureStackTrace(err2);
          throw err2;
        });
        query2.callback = (err2, res2) => err2 ? rejectOut(err2) : resolveOut(res2);
      }
    }
    if (readTimeout) {
      queryCallback = query2.callback;
      readTimeoutTimer = setTimeout(() => {
        const error2 = new Error("Query read timeout");
        process.nextTick(() => {
          query2.handleError(error2, this.connection);
        });
        queryCallback(error2);
        query2.callback = () => {
        };
        const index2 = this._queryQueue.indexOf(query2);
        if (index2 > -1) {
          this._queryQueue.splice(index2, 1);
        }
        this._pulseQueryQueue();
      }, readTimeout);
      query2.callback = (err2, res2) => {
        clearTimeout(readTimeoutTimer);
        queryCallback(err2, res2);
      };
    }
    if (!this._queryable) {
      query2.native = this.native;
      process.nextTick(() => {
        query2.handleError(new Error("Client has encountered a connection error and is not queryable"));
      });
      return result2;
    }
    if (this._ending) {
      query2.native = this.native;
      process.nextTick(() => {
        query2.handleError(new Error("Client was closed and is not queryable"));
      });
      return result2;
    }
    this._queryQueue.push(query2);
    this._pulseQueryQueue();
    return result2;
  };
  Client2.prototype.end = function(cb) {
    const self2 = this;
    this._ending = true;
    if (!this._connected) {
      this.once("connect", this.end.bind(this, cb));
    }
    let result2;
    if (!cb) {
      result2 = new this._Promise(function(resolve2, reject) {
        cb = (err2) => err2 ? reject(err2) : resolve2();
      });
    }
    this.native.end(function() {
      self2._errorAllQueries(new Error("Connection terminated"));
      process.nextTick(() => {
        self2.emit("end");
        if (cb) cb();
      });
    });
    return result2;
  };
  Client2.prototype._hasActiveQuery = function() {
    return this._activeQuery && this._activeQuery.state !== "error" && this._activeQuery.state !== "end";
  };
  Client2.prototype._pulseQueryQueue = function(initialConnection) {
    if (!this._connected) {
      return;
    }
    if (this._hasActiveQuery()) {
      return;
    }
    const query2 = this._queryQueue.shift();
    if (!query2) {
      if (!initialConnection) {
        this.emit("drain");
      }
      return;
    }
    this._activeQuery = query2;
    query2.submit(this);
    const self2 = this;
    query2.once("_done", function() {
      self2._pulseQueryQueue();
    });
  };
  Client2.prototype.cancel = function(query2) {
    if (this._activeQuery === query2) {
      this.native.cancel(function() {
      });
    } else if (this._queryQueue.indexOf(query2) !== -1) {
      this._queryQueue.splice(this._queryQueue.indexOf(query2), 1);
    }
  };
  Client2.prototype.ref = function() {
  };
  Client2.prototype.unref = function() {
  };
  Client2.prototype.setTypeParser = function(oid, format2, parseFn) {
    return this._types.setTypeParser(oid, format2, parseFn);
  };
  Client2.prototype.getTypeParser = function(oid, format2) {
    return this._types.getTypeParser(oid, format2);
  };
  return client.exports;
}
var native;
var hasRequiredNative;
function requireNative() {
  if (hasRequiredNative) return native;
  hasRequiredNative = 1;
  native = requireClient();
  return native;
}
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib$1.exports;
  hasRequiredLib = 1;
  (function(module) {
    const Client2 = requireClient$1();
    const defaults2 = requireDefaults();
    const Connection2 = requireConnection();
    const Result2 = requireResult();
    const utils2 = requireUtils$1();
    const Pool2 = require$$5;
    const TypeOverrides2 = requireTypeOverrides();
    const { DatabaseError: DatabaseError2 } = require$$7;
    const { escapeIdentifier: escapeIdentifier2, escapeLiteral: escapeLiteral2 } = requireUtils$1();
    const poolFactory = (Client3) => {
      return class BoundPool extends Pool2 {
        constructor(options) {
          super(options, Client3);
        }
      };
    };
    const PG = function(clientConstructor2) {
      this.defaults = defaults2;
      this.Client = clientConstructor2;
      this.Query = this.Client.Query;
      this.Pool = poolFactory(this.Client);
      this._pools = [];
      this.Connection = Connection2;
      this.types = requirePgTypes();
      this.DatabaseError = DatabaseError2;
      this.TypeOverrides = TypeOverrides2;
      this.escapeIdentifier = escapeIdentifier2;
      this.escapeLiteral = escapeLiteral2;
      this.Result = Result2;
      this.utils = utils2;
    };
    let clientConstructor = Client2;
    let forceNative = false;
    try {
      forceNative = !!process.env.NODE_PG_FORCE_NATIVE;
    } catch {
    }
    if (forceNative) {
      clientConstructor = requireNative();
    }
    module.exports = new PG(clientConstructor);
    Object.defineProperty(module.exports, "native", {
      configurable: true,
      enumerable: false,
      get() {
        let native2 = null;
        try {
          native2 = new PG(requireNative());
        } catch (err2) {
          if (err2.code !== "MODULE_NOT_FOUND") {
            throw err2;
          }
        }
        Object.defineProperty(module.exports, "native", {
          value: native2
        });
        return native2;
      }
    });
  })(lib$1);
  return lib$1.exports;
}
var libExports = requireLib();
const pg = /* @__PURE__ */ getDefaultExportFromCjs(libExports);
const Client = pg.Client;
const Pool = pg.Pool;
const Connection = pg.Connection;
const types$1 = pg.types;
const Query = pg.Query;
const DatabaseError = pg.DatabaseError;
const escapeIdentifier = pg.escapeIdentifier;
const escapeLiteral = pg.escapeLiteral;
const Result = pg.Result;
const TypeOverrides = pg.TypeOverrides;
const defaults = pg.defaults;
class Db extends EventEmitter {
  pool;
  config;
  /** @internal */
  _pgbdb;
  opened;
  constructor(config2) {
    super();
    config2.application_name = config2.application_name || "pgboss";
    config2.connectionTimeoutMillis = config2.connectionTimeoutMillis || 1e4;
    this.config = config2;
    this._pgbdb = true;
    this.opened = false;
  }
  events = {
    error: "error"
  };
  async open() {
    this.pool = new pg.Pool(this.config);
    this.pool.on("error", (error2) => this.emit("error", error2));
    this.opened = true;
  }
  async close() {
    if (!this.pool.ending) {
      this.opened = false;
      await this.pool.end();
    }
  }
  async executeSql(text2, values) {
    assert(this.opened, "Database not opened. Call open() before executing SQL.");
    return await this.pool.query(text2, values);
  }
}
const events = Object.freeze({
  error: "error",
  warning: "warning",
  wip: "wip",
  stopped: "stopped",
  bam: "bam"
});
class PgBoss extends EventEmitter {
  #stoppingOn;
  #stopped;
  #starting;
  #started;
  #config;
  #db;
  #boss;
  #contractor;
  #manager;
  #timekeeper;
  #bam;
  constructor(value) {
    super();
    this.#stoppingOn = null;
    this.#stopped = true;
    const config2 = getConfig(value);
    this.#config = config2;
    const db = this.getDb();
    this.#db = db;
    if ("_pgbdb" in this.#db && this.#db._pgbdb) {
      this.#promoteEvents(this.#db);
    }
    const contractor = new Contractor(db, config2);
    const manager = new Manager(db, config2);
    const boss = new Boss(db, manager, config2);
    const timekeeper = new Timekeeper(db, manager, config2);
    manager.timekeeper = timekeeper;
    const bam = new Bam(db, config2);
    this.#promoteEvents(manager);
    this.#promoteEvents(boss);
    this.#promoteEvents(timekeeper);
    this.#promoteEvents(bam);
    this.#boss = boss;
    this.#contractor = contractor;
    this.#manager = manager;
    this.#timekeeper = timekeeper;
    this.#bam = bam;
  }
  #promoteEvents(emitter) {
    for (const event of Object.values(emitter?.events)) {
      emitter.on(event, (arg) => this.emit(event, arg));
    }
  }
  async start() {
    if (this.#starting || this.#started) {
      return this;
    }
    this.#starting = true;
    if (this.#db._pgbdb && !this.#db.opened) {
      await this.#db.open();
    }
    if (this.#config.migrate) {
      await this.#contractor.start();
    } else {
      await this.#contractor.check();
    }
    await this.#manager.start();
    if (this.#config.supervise) {
      await this.#boss.start();
    }
    if (this.#config.schedule) {
      await this.#timekeeper.start();
    }
    if (this.#config.migrate) {
      await this.#bam.start();
    }
    this.#starting = false;
    this.#started = true;
    this.#stopped = false;
    return this;
  }
  async stop(options = {}) {
    if (this.#stoppingOn || this.#stopped) {
      return;
    }
    let { close = true, graceful = true, timeout = 3e4 } = options;
    timeout = Math.max(timeout, 1e3);
    this.#stoppingOn = Date.now();
    await this.#manager.stop();
    await this.#timekeeper.stop();
    await this.#boss.stop();
    await this.#bam.stop();
    const shutdown = async () => {
      await this.#manager.failWip();
      if (this.#db._pgbdb && this.#db.opened && close) {
        await this.#db.close();
        await delay(10);
      }
      this.#stopped = true;
      this.#stoppingOn = null;
      this.#started = false;
      this.emit(events.stopped);
    };
    if (!graceful) {
      return await shutdown();
    }
    while (Date.now() - this.#stoppingOn < timeout && this.#manager.hasPendingCleanups()) {
      await delay(500);
    }
    await shutdown();
  }
  async send(...args) {
    return await this.#manager.send(...args);
  }
  async sendAfter(name2, data, options, after) {
    return this.#manager.sendAfter(name2, data, options, after);
  }
  sendThrottled(name2, data, options, seconds, key) {
    return this.#manager.sendThrottled(name2, data, options, seconds, key);
  }
  sendDebounced(name2, data, options, seconds, key) {
    return this.#manager.sendDebounced(name2, data, options, seconds, key);
  }
  insert(name2, jobs, options) {
    return this.#manager.insert(name2, jobs, options);
  }
  fetch(name2, options = {}) {
    return this.#manager.fetch(name2, options);
  }
  work(...args) {
    return this.#manager.work(...args);
  }
  offWork(name2, options) {
    return this.#manager.offWork(name2, options);
  }
  notifyWorker(workerId) {
    return this.#manager.notifyWorker(workerId);
  }
  subscribe(event, name2) {
    return this.#manager.subscribe(event, name2);
  }
  unsubscribe(event, name2) {
    return this.#manager.unsubscribe(event, name2);
  }
  publish(event, data, options) {
    return this.#manager.publish(event, data, options);
  }
  cancel(name2, id, options) {
    return this.#manager.cancel(name2, id, options);
  }
  resume(name2, id, options) {
    return this.#manager.resume(name2, id, options);
  }
  retry(name2, id, options) {
    return this.#manager.retry(name2, id, options);
  }
  deleteJob(name2, id, options) {
    return this.#manager.deleteJob(name2, id, options);
  }
  deleteQueuedJobs(name2) {
    return this.#manager.deleteQueuedJobs(name2);
  }
  deleteStoredJobs(name2) {
    return this.#manager.deleteStoredJobs(name2);
  }
  deleteAllJobs(name2) {
    return this.#manager.deleteAllJobs(name2);
  }
  complete(name2, id, data, options) {
    return this.#manager.complete(name2, id, data, options);
  }
  fail(name2, id, data, options) {
    return this.#manager.fail(name2, id, data, options);
  }
  /**
   * @deprecated Use findJobs() instead
   */
  getJobById(name2, id, options) {
    return this.#manager.getJobById(name2, id, options);
  }
  findJobs(name2, options) {
    return this.#manager.findJobs(name2, options);
  }
  createQueue(name2, options) {
    return this.#manager.createQueue(name2, options);
  }
  updateQueue(name2, options) {
    return this.#manager.updateQueue(name2, options);
  }
  deleteQueue(name2) {
    return this.#manager.deleteQueue(name2);
  }
  getQueues(names) {
    return this.#manager.getQueues();
  }
  getQueue(name2) {
    return this.#manager.getQueue(name2);
  }
  getQueueStats(name2) {
    return this.#manager.getQueueStats(name2);
  }
  supervise(name2) {
    return this.#boss.supervise(name2);
  }
  getSpy(name2) {
    return this.#manager.getSpy(name2);
  }
  clearSpies() {
    this.#manager.clearSpies();
  }
  isInstalled() {
    return this.#contractor.isInstalled();
  }
  schemaVersion() {
    return this.#contractor.schemaVersion();
  }
  schedule(name2, cron, data, options) {
    return this.#timekeeper.schedule(name2, cron, data, options);
  }
  unschedule(name2, key) {
    return this.#timekeeper.unschedule(name2, key);
  }
  getSchedules(name2, key) {
    return this.#timekeeper.getSchedules(name2, key);
  }
  async getBamStatus() {
    const sql2 = getBamStatus(this.#config.schema);
    const { rows } = await this.#db.executeSql(sql2);
    return rows;
  }
  async getBamEntries() {
    const sql2 = getBamEntries(this.#config.schema);
    const { rows } = await this.#db.executeSql(sql2);
    return rows;
  }
  getDb() {
    if (this.#db) {
      return this.#db;
    }
    if (this.#config.db) {
      return this.#config.db;
    }
    return new Db(this.#config);
  }
}
class PgBossAdapter {
  capabilities = {
    longRunningConsumer: true,
    runOnceConsumer: true,
    pushConsumer: false,
    scheduling: true,
    singleton: true
  };
  boss;
  started = false;
  createdQueues = /* @__PURE__ */ new Set();
  constructor(options) {
    this.boss = new PgBoss(options);
  }
  async start() {
    if (!this.started) {
      await this.boss.start();
      this.started = true;
    }
  }
  async stop() {
    if (this.started) {
      await this.boss.stop();
      this.started = false;
    }
  }
  async ensureQueue(jobName) {
    if (!this.createdQueues.has(jobName)) {
      await this.boss.createQueue(jobName);
      this.createdQueues.add(jobName);
    }
  }
  async publish(jobName, payload, options) {
    await this.start();
    await this.ensureQueue(jobName);
    return this.boss.send(jobName, payload, options);
  }
  async schedule(jobName, cron, payload, options) {
    await this.start();
    await this.ensureQueue(jobName);
    await this.boss.schedule(jobName, cron, payload, options);
  }
  async unschedule(jobName) {
    await this.start();
    await this.boss.unschedule(jobName);
  }
  async listen(handlers, options) {
    await this.start();
    for (const jobName of Object.keys(handlers)) {
      await this.ensureQueue(jobName);
      const handler2 = handlers[jobName];
      if (!handler2) continue;
      await this.boss.work(jobName, options, async (job) => {
        await handler2({ id: job.id, data: job.data });
      });
    }
  }
  async runOnce(handlers, options) {
    await this.start();
    const selectedJobNames = options?.jobs && options.jobs.length > 0 ? options.jobs : Object.keys(handlers);
    if (selectedJobNames.length === 0) {
      return { processed: 0 };
    }
    const batchSize = Math.max(1, options?.batchSize ?? 10);
    let processed = 0;
    for (const jobName of selectedJobNames) {
      const handler2 = handlers[jobName];
      if (!handler2) continue;
      await this.ensureQueue(jobName);
      const fetchFn = this.boss.fetch;
      if (!fetchFn) {
        throw new Error(
          "PgBossAdapter.runOnce requires pg-boss fetch() support."
        );
      }
      const fetched = await fetchFn.call(this.boss, jobName, {
        batchSize
      });
      const jobs = Array.isArray(fetched) ? fetched : fetched ? [fetched] : [];
      for (const job of jobs) {
        await handler2({ id: String(job.id), data: job.data });
        processed += 1;
      }
    }
    return { processed };
  }
  on(event, handler2) {
    this.boss.on(event, handler2);
  }
}
function pgBossAdapter(options) {
  return new PgBossAdapter(options);
}
const defaultLogger = {
  info: (msg, ...args) => console.log(msg, ...args),
  warn: (msg, ...args) => console.warn(msg, ...args),
  error: (msg, ...args) => console.error(msg, ...args)
};
function resolveCapabilities(adapter) {
  return {
    longRunningConsumer: adapter.capabilities?.longRunningConsumer ?? !!adapter.listen,
    runOnceConsumer: adapter.capabilities?.runOnceConsumer ?? !!adapter.runOnce,
    pushConsumer: adapter.capabilities?.pushConsumer ?? !!adapter.createPushConsumer,
    scheduling: adapter.capabilities?.scheduling ?? (typeof adapter.schedule === "function" && typeof adapter.unschedule === "function"),
    singleton: adapter.capabilities?.singleton ?? false
  };
}
function normalizeSelectedJobs(jobs, selected) {
  if (!selected || selected.length === 0) return jobs;
  const selectedSet = new Set(selected);
  const filteredEntries = Object.entries(jobs).filter(
    ([registrationKey, jobDef]) => selectedSet.has(registrationKey) || selectedSet.has(jobDef.name)
  );
  return Object.fromEntries(filteredEntries);
}
function buildWorkOptions(options) {
  if (!options?.teamSize && !options?.batchSize) {
    return void 0;
  }
  return {
    teamSize: options.teamSize,
    batchSize: options.batchSize
  };
}
function createQueueClient(jobs, adapter, runtimeOptions = {}) {
  const logger2 = runtimeOptions.logger ?? defaultLogger;
  const capabilities = resolveCapabilities(adapter);
  let started = false;
  let signalCleanup;
  let shutdownInProgress = false;
  const ensureStarted = async () => {
    if (!started) {
      await adapter.start();
      started = true;
    }
  };
  adapter.on("error", (error2) => {
    logger2.error("[QUESTPIE Queue] Adapter error:", error2);
  });
  const getContextOrThrow = async () => {
    if (!runtimeOptions.createContext) {
      throw new Error(
        "QUESTPIE Queue: createContext is not configured. Queue consumer methods must be called from a built CMS instance."
      );
    }
    return runtimeOptions.createContext();
  };
  const getAppOrThrow = () => {
    if (!runtimeOptions.getApp) {
      throw new Error(
        "QUESTPIE Queue: app resolver is not configured. Queue consumer methods must be called from a built CMS instance."
      );
    }
    return runtimeOptions.getApp();
  };
  const buildHandlers = (selectedJobs) => {
    const sourceJobs = selectedJobs ?? jobs;
    const handlers = {};
    for (const jobDef of Object.values(sourceJobs)) {
      handlers[jobDef.name] = async (job) => {
        const context = await getContextOrThrow();
        const validated = jobDef.schema.parse(job.data);
        await jobDef.handler({
          payload: validated,
          app: getAppOrThrow(),
          session: context.session,
          locale: context.locale,
          db: context.db
        });
      };
    }
    return handlers;
  };
  const registerSchedules = async (options) => {
    await ensureStarted();
    if (!capabilities.scheduling || !adapter.schedule) {
      if (options?.jobs && options.jobs.length > 0) {
        throw new Error(
          "QUESTPIE Queue: selected adapter does not support scheduling."
        );
      }
      return;
    }
    const selectedJobs = normalizeSelectedJobs(jobs, options?.jobs);
    for (const jobDef of Object.values(selectedJobs)) {
      if (!jobDef.options?.cron) continue;
      let schedulePayload;
      try {
        schedulePayload = jobDef.schema.parse({});
      } catch (error2) {
        throw new Error(
          `QUESTPIE Queue: Job "${jobDef.name}" has cron schedule but schema does not accept an empty payload.`,
          { cause: error2 }
        );
      }
      const { cron, startAfter, ...scheduleOptions } = jobDef.options ?? {};
      await adapter.schedule(
        jobDef.name,
        jobDef.options.cron,
        schedulePayload,
        scheduleOptions
      );
    }
  };
  const stopInternal = async () => {
    signalCleanup?.();
    signalCleanup = void 0;
    shutdownInProgress = false;
    if (started) {
      await adapter.stop();
      started = false;
    }
  };
  const setupGracefulShutdown = (options) => {
    const enabled = options?.gracefulShutdown ?? true;
    if (!enabled) return;
    if (typeof process === "undefined" || typeof process.on !== "function") {
      return;
    }
    signalCleanup?.();
    const signals = options?.shutdownSignals && options.shutdownSignals.length > 0 ? options.shutdownSignals : ["SIGINT", "SIGTERM"];
    const timeoutMs = Math.max(0, options?.shutdownTimeoutMs ?? 1e4);
    const handlers = /* @__PURE__ */ new Map();
    for (const signal of signals) {
      const onSignal = () => {
        if (shutdownInProgress) return;
        shutdownInProgress = true;
        logger2.info(
          `[QUESTPIE Queue] Received ${signal}. Starting graceful shutdown...`
        );
        const shutdownPromise = stopInternal();
        const timeoutPromise = timeoutMs > 0 ? new Promise((resolve2) => {
          setTimeout(() => resolve2("timeout"), timeoutMs);
        }) : Promise.resolve("timeout");
        void Promise.race([shutdownPromise, timeoutPromise]).then((result2) => {
          if (result2 === "timeout") {
            logger2.warn(
              `[QUESTPIE Queue] Graceful shutdown timed out after ${timeoutMs}ms. Forcing exit.`
            );
          }
          process.exit(0);
        }).catch((error2) => {
          logger2.error(
            "[QUESTPIE Queue] Error during graceful shutdown:",
            error2
          );
          process.exit(1);
        });
      };
      handlers.set(signal, onSignal);
      process.on(signal, onSignal);
    }
    signalCleanup = () => {
      for (const [signal, handler2] of handlers) {
        process.off(signal, handler2);
      }
      handlers.clear();
    };
  };
  const client2 = {
    capabilities,
    listen: async (options) => {
      await ensureStarted();
      await registerSchedules();
      if (!capabilities.longRunningConsumer || !adapter.listen) {
        throw new Error(
          "QUESTPIE Queue: selected adapter does not support long-running listen() mode."
        );
      }
      await adapter.listen(buildHandlers(), buildWorkOptions(options));
      setupGracefulShutdown(options);
      return {
        stop: async () => {
          await stopInternal();
        }
      };
    },
    runOnce: async (options) => {
      await ensureStarted();
      if (!capabilities.runOnceConsumer || !adapter.runOnce) {
        throw new Error(
          "QUESTPIE Queue: selected adapter does not support runOnce() mode."
        );
      }
      const selectedJobs = normalizeSelectedJobs(jobs, options?.jobs);
      const selectedJobNames = Object.values(selectedJobs).map(
        (job) => job.name
      );
      return adapter.runOnce(buildHandlers(selectedJobs), {
        batchSize: options?.batchSize,
        jobs: selectedJobNames
      });
    },
    registerSchedules,
    stop: async () => {
      await stopInternal();
    },
    createPushConsumer: () => {
      if (!capabilities.pushConsumer || !adapter.createPushConsumer) {
        throw new Error(
          "QUESTPIE Queue: selected adapter does not support push consumer mode."
        );
      }
      const consumer = adapter.createPushConsumer({
        handlers: buildHandlers()
      });
      return async (batch) => {
        await ensureStarted();
        await consumer(batch);
      };
    },
    _adapter: adapter,
    _start: async () => {
      await ensureStarted();
    },
    _stop: async () => {
      await stopInternal();
    }
  };
  for (const [jobName, jobDef] of Object.entries(jobs)) {
    client2[jobName] = {
      /**
       * Publish a job to the queue
       */
      publish: async (payload, publishOptions) => {
        await ensureStarted();
        const validated = jobDef.schema.parse(payload);
        const options = {
          ...jobDef.options,
          ...publishOptions
        };
        return adapter.publish(jobDef.name, validated, options);
      },
      /**
       * Schedule a recurring job
       */
      schedule: async (payload, cron, publishOptions) => {
        await ensureStarted();
        if (!capabilities.scheduling || !adapter.schedule) {
          throw new Error(
            "QUESTPIE Queue: selected adapter does not support scheduling."
          );
        }
        const validated = jobDef.schema.parse(payload);
        const options = {
          ...jobDef.options,
          ...publishOptions
        };
        await adapter.schedule(jobDef.name, cron, validated, options);
      },
      /**
       * Unschedule a recurring job
       */
      unschedule: async () => {
        await ensureStarted();
        if (!capabilities.scheduling || !adapter.unschedule) {
          throw new Error(
            "QUESTPIE Queue: selected adapter does not support scheduling."
          );
        }
        await adapter.unschedule(jobDef.name);
      }
    };
  }
  return client2;
}
const questpieRealtimeLogTable = pgTable(
  "questpie_realtime_log",
  {
    seq: bigserial("seq", { mode: "number" }).primaryKey(),
    resourceType: text("resource_type").notNull(),
    resource: text("resource").notNull(),
    operation: text("operation").notNull(),
    recordId: text("record_id"),
    locale: text("locale"),
    payload: jsonb("payload").default({}),
    createdAt: timestamp("created_at", { mode: "date" }).defaultNow().notNull()
  },
  (t2) => [
    index$2("idx_realtime_log_seq").on(t2.seq),
    index$2("idx_realtime_log_resource").on(t2.resourceType, t2.resource),
    index$2("idx_realtime_log_created_at").on(t2.createdAt)
  ]
);
function extractSimpleEquality(where) {
  if (!where || typeof where !== "object") return {};
  const result2 = {};
  for (const [key, value] of Object.entries(where)) {
    if (["AND", "OR", "NOT", "RAW"].includes(key)) continue;
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      result2[key] = value;
    } else if (value && typeof value === "object" && "eq" in value) {
      result2[key] = value.eq;
    }
  }
  return result2;
}
function analyzeWhere(where) {
  if (!where || typeof where !== "object") {
    return { filters: {}, hasComplex: false };
  }
  const filters = {};
  let hasComplex = false;
  for (const [key, value] of Object.entries(where)) {
    if (["AND", "OR", "NOT", "RAW"].includes(key)) {
      hasComplex = true;
      continue;
    }
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      filters[key] = value;
      continue;
    }
    if (value && typeof value === "object") {
      const valueObject = value;
      if ("eq" in valueObject) {
        filters[key] = valueObject.eq;
        const operatorKeys = Object.keys(valueObject).filter((k) => k !== "eq");
        if (operatorKeys.length > 0) {
          hasComplex = true;
        }
        continue;
      }
      hasComplex = true;
      continue;
    }
    hasComplex = true;
  }
  return { filters, hasComplex };
}
class RealtimeService {
  constructor(db, config2 = {}, pgConnectionString2) {
    this.db = db;
    this.pgConnectionString = pgConnectionString2;
    if (config2.adapter) {
      this.adapter = config2.adapter;
    }
    this.batchSize = config2.batchSize ?? 500;
    this.pollIntervalMs = config2.pollIntervalMs ?? (this.adapter ? 0 : 2e3);
    this.retentionDays = typeof config2.retentionDays === "number" && config2.retentionDays > 0 ? config2.retentionDays : void 0;
    this.retentionCleanupIntervalMs = 60 * 60 * 1e3;
  }
  adapter;
  listeners = /* @__PURE__ */ new Set();
  directCollectionListeners = /* @__PURE__ */ new Map();
  directGlobalListeners = /* @__PURE__ */ new Map();
  watchedCollectionListeners = /* @__PURE__ */ new Map();
  watchedGlobalListeners = /* @__PURE__ */ new Map();
  pollIntervalMs;
  batchSize;
  draining = false;
  started = false;
  startPromise = null;
  lastSeq = 0;
  pollTimer = null;
  unsubscribeAdapter = null;
  subscriptionContext;
  retentionDays;
  retentionCleanupIntervalMs;
  nextRetentionCleanupAt = 0;
  retentionCleanupInProgress = false;
  /**
   * Set context for resolving dependencies from WITH config.
   * Called by CMS to provide collection/global resolution functions.
   */
  setSubscriptionContext(context) {
    this.subscriptionContext = context;
  }
  addIndexedListener(index2, resource, entry) {
    if (!index2.has(resource)) {
      index2.set(resource, /* @__PURE__ */ new Set());
    }
    index2.get(resource)?.add(entry);
  }
  removeIndexedListener(index2, resource, entry) {
    const listeners = index2.get(resource);
    if (!listeners) return;
    listeners.delete(entry);
    if (listeners.size === 0) {
      index2.delete(resource);
    }
  }
  collectIndexedCandidates(index2, resource, collector) {
    const exact = index2.get(resource);
    if (exact) {
      for (const entry of exact) collector.add(entry);
    }
    const wildcard = index2.get("*");
    if (wildcard) {
      for (const entry of wildcard) collector.add(entry);
    }
  }
  async appendChange(input, options = {}) {
    const db = options.db ?? this.db;
    const [row] = await db.insert(questpieRealtimeLogTable).values({
      resourceType: input.resourceType,
      resource: input.resource,
      operation: input.operation,
      recordId: input.recordId ?? null,
      locale: input.locale ?? null,
      payload: input.payload ?? {}
    }).returning();
    const event = {
      seq: Number(row.seq),
      resourceType: row.resourceType,
      resource: row.resource,
      operation: row.operation,
      recordId: row.recordId ?? null,
      locale: row.locale ?? null,
      payload: row.payload ?? {},
      createdAt: row.createdAt
    };
    void this.scheduleRetentionCleanup();
    return event;
  }
  async notify(event) {
    if (!this.adapter) return;
    await this.adapter.notify(event);
  }
  /**
   * Run realtime outbox cleanup immediately.
   *
   * Useful for scheduled queue jobs (for example starter module cron jobs).
   */
  async cleanupOutbox(force = true) {
    await this.scheduleRetentionCleanup(force);
  }
  subscribe(listener, topics) {
    const resolvedTopics = topics ?? {
      resourceType: "collection",
      resource: "*"
    };
    const whereAnalysis = analyzeWhere(resolvedTopics.where);
    let watchedResources;
    if (resolvedTopics.resourceType === "collection" && resolvedTopics.with) {
      const collections = this.subscriptionContext?.resolveCollectionDependencies?.(
        resolvedTopics.resource,
        resolvedTopics.with
      ) ?? /* @__PURE__ */ new Set([resolvedTopics.resource]);
      watchedResources = { collections, globals: /* @__PURE__ */ new Set() };
    } else if (resolvedTopics.resourceType === "global" && resolvedTopics.with) {
      watchedResources = this.subscriptionContext?.resolveGlobalDependencies?.(
        resolvedTopics.resource,
        resolvedTopics.with
      ) ?? {
        collections: /* @__PURE__ */ new Set(),
        globals: /* @__PURE__ */ new Set([resolvedTopics.resource])
      };
    } else {
      watchedResources = resolvedTopics.resourceType === "collection" ? {
        collections: /* @__PURE__ */ new Set([resolvedTopics.resource]),
        globals: /* @__PURE__ */ new Set()
      } : {
        collections: /* @__PURE__ */ new Set(),
        globals: /* @__PURE__ */ new Set([resolvedTopics.resource])
      };
    }
    const entry = {
      listener,
      topics: resolvedTopics,
      whereFilters: whereAnalysis.filters,
      hasComplexWhere: whereAnalysis.hasComplex,
      lastDeliveredSeq: this.lastSeq,
      watchedResources
    };
    this.listeners.add(entry);
    const directIndex = resolvedTopics.resourceType === "collection" ? this.directCollectionListeners : this.directGlobalListeners;
    this.addIndexedListener(directIndex, resolvedTopics.resource, entry);
    for (const resource of watchedResources.collections) {
      this.addIndexedListener(this.watchedCollectionListeners, resource, entry);
    }
    for (const resource of watchedResources.globals) {
      this.addIndexedListener(this.watchedGlobalListeners, resource, entry);
    }
    void this.ensureStarted();
    return () => {
      this.listeners.delete(entry);
      const removeDirectIndex = resolvedTopics.resourceType === "collection" ? this.directCollectionListeners : this.directGlobalListeners;
      this.removeIndexedListener(
        removeDirectIndex,
        resolvedTopics.resource,
        entry
      );
      for (const resource of watchedResources.collections) {
        this.removeIndexedListener(
          this.watchedCollectionListeners,
          resource,
          entry
        );
      }
      for (const resource of watchedResources.globals) {
        this.removeIndexedListener(
          this.watchedGlobalListeners,
          resource,
          entry
        );
      }
      if (this.listeners.size === 0) {
        void this.stop();
      }
    };
  }
  async getLatestSeq() {
    const rows = await this.db.select({ seq: questpieRealtimeLogTable.seq }).from(questpieRealtimeLogTable).orderBy(desc(questpieRealtimeLogTable.seq)).limit(1);
    return rows[0]?.seq ? Number(rows[0].seq) : 0;
  }
  async readSince(seq) {
    const rows = await this.db.select().from(questpieRealtimeLogTable).where(gt(questpieRealtimeLogTable.seq, seq)).orderBy(asc(questpieRealtimeLogTable.seq)).limit(this.batchSize);
    return rows.map((row) => ({
      seq: Number(row.seq),
      resourceType: row.resourceType,
      resource: row.resource,
      operation: row.operation,
      recordId: row.recordId ?? null,
      locale: row.locale ?? null,
      payload: row.payload ?? {},
      createdAt: row.createdAt
    }));
  }
  async ensureStarted() {
    if (this.started) return;
    if (this.startPromise) {
      await this.startPromise;
      return;
    }
    this.startPromise = (async () => {
      const latestSeq = await this.getLatestSeq();
      if (!this.adapter && this.pgConnectionString) {
        const { PgNotifyAdapter } = await import("./pg-notify-Cnptf8Rb.js");
        this.adapter = new PgNotifyAdapter({
          connectionString: this.pgConnectionString,
          channel: "questpie_realtime"
        });
      }
      if (this.adapter) {
        await this.adapter.start();
        this.unsubscribeAdapter = this.adapter.subscribe(() => {
          void this.drain();
        });
      } else if (this.pollIntervalMs > 0) {
        this.pollTimer = setInterval(() => {
          void this.drain();
        }, this.pollIntervalMs);
      }
      this.lastSeq = latestSeq;
      this.started = true;
      void this.drain();
      void this.scheduleRetentionCleanup(true);
    })().catch(async (error2) => {
      this.started = false;
      if (this.pollTimer) {
        clearInterval(this.pollTimer);
        this.pollTimer = null;
      }
      if (this.unsubscribeAdapter) {
        this.unsubscribeAdapter();
        this.unsubscribeAdapter = null;
      }
      if (this.adapter) {
        try {
          await this.adapter.stop();
        } catch {
        }
      }
      throw error2;
    }).finally(() => {
      this.startPromise = null;
    });
    await this.startPromise;
  }
  async stop() {
    if (!this.started && !this.startPromise) return;
    if (this.startPromise) {
      try {
        await this.startPromise;
      } catch {
      }
    }
    if (!this.started) return;
    this.started = false;
    if (this.pollTimer) {
      clearInterval(this.pollTimer);
      this.pollTimer = null;
    }
    if (this.unsubscribeAdapter) {
      this.unsubscribeAdapter();
      this.unsubscribeAdapter = null;
    }
    if (this.adapter) {
      await this.adapter.stop();
    }
  }
  async drain() {
    if (this.draining) return;
    this.draining = true;
    try {
      while (true) {
        const events2 = await this.readSince(this.lastSeq);
        if (events2.length === 0) break;
        this.lastSeq = events2[events2.length - 1].seq;
        for (const event of events2) {
          this.emit(event);
        }
        if (events2.length < this.batchSize) break;
      }
    } finally {
      this.draining = false;
    }
  }
  emit(event) {
    const eventFilters = event.payload ? extractSimpleEquality(event.payload) : {};
    const candidates = /* @__PURE__ */ new Set();
    if (event.resourceType === "collection") {
      this.collectIndexedCandidates(
        this.directCollectionListeners,
        event.resource,
        candidates
      );
      this.collectIndexedCandidates(
        this.watchedCollectionListeners,
        event.resource,
        candidates
      );
    } else {
      this.collectIndexedCandidates(
        this.directGlobalListeners,
        event.resource,
        candidates
      );
      this.collectIndexedCandidates(
        this.watchedGlobalListeners,
        event.resource,
        candidates
      );
    }
    const notifiedListeners = /* @__PURE__ */ new Set();
    for (const entry of candidates) {
      if (notifiedListeners.has(entry)) continue;
      const isDirectMatch = entry.topics.resourceType === event.resourceType && (entry.topics.resource === event.resource || entry.topics.resource === "*");
      if (!isDirectMatch) {
        notifiedListeners.add(entry);
        continue;
      }
      if (!entry.topics.where) {
        notifiedListeners.add(entry);
        continue;
      }
      if (event.operation !== "create") {
        notifiedListeners.add(entry);
        continue;
      }
      if (entry.hasComplexWhere) {
        notifiedListeners.add(entry);
        continue;
      }
      const allFiltersMatch = Object.entries(entry.whereFilters).every(
        ([key, value]) => eventFilters[key] === value
      );
      if (allFiltersMatch) {
        notifiedListeners.add(entry);
      }
    }
    for (const entry of notifiedListeners) {
      entry.lastDeliveredSeq = Math.max(entry.lastDeliveredSeq, event.seq);
      entry.listener(event);
    }
    void this.scheduleRetentionCleanup();
  }
  getMinConsumedSeq() {
    if (this.listeners.size === 0) return null;
    let min2 = Number.POSITIVE_INFINITY;
    for (const entry of this.listeners) {
      min2 = Math.min(min2, entry.lastDeliveredSeq);
    }
    if (!Number.isFinite(min2) || min2 <= 0) return null;
    return min2;
  }
  async scheduleRetentionCleanup(force = false) {
    const hasTimeRetention = !!this.retentionDays && this.retentionDays > 0;
    const minConsumedSeq = this.getMinConsumedSeq();
    const hasWatermarkCleanup = !!minConsumedSeq;
    if (!hasTimeRetention && !hasWatermarkCleanup) return;
    const now2 = Date.now();
    if (!force && now2 < this.nextRetentionCleanupAt) return;
    if (this.retentionCleanupInProgress) return;
    this.retentionCleanupInProgress = true;
    this.nextRetentionCleanupAt = now2 + this.retentionCleanupIntervalMs;
    try {
      if (hasTimeRetention) {
        const cutoff = new Date(
          now2 - this.retentionDays * 24 * 60 * 60 * 1e3
        );
        await this.db.delete(questpieRealtimeLogTable).where(lt(questpieRealtimeLogTable.createdAt, cutoff));
      }
      if (hasWatermarkCleanup) {
        await this.db.delete(questpieRealtimeLogTable).where(lt(questpieRealtimeLogTable.seq, minConsumedSeq));
      }
    } catch {
    } finally {
      this.retentionCleanupInProgress = false;
    }
  }
  static noticeFromEvent(event) {
    return {
      seq: event.seq,
      resourceType: event.resourceType,
      resource: event.resource,
      operation: event.operation
    };
  }
}
const tsvector = customType({
  dataType() {
    return "tsvector";
  }
});
const questpieSearchTable = pgTable(
  "questpie_search",
  {
    /**
     * Primary key with auto-generated UUID
     */
    id: text("id").primaryKey().default(sql$1`gen_random_uuid()`),
    /**
     * Collection name
     */
    collectionName: text("collection_name").notNull(),
    /**
     * Record ID in the source collection (text to support any ID type)
     */
    recordId: text("record_id").notNull(),
    /**
     * Locale for this search entry
     */
    locale: text("locale").notNull(),
    /**
     * Title (always indexed, from .title() method)
     */
    title: text("title").notNull(),
    /**
     * Content (optional, from .searchable({ content: ... }))
     */
    content: text("content"),
    /**
     * Custom metadata for filtering
     * @example { status: "published", authorId: "123" }
     */
    metadata: jsonb("metadata").default({}),
    /**
     * Full-text search vector (generated column)
     * Title gets higher weight (A) than content (B)
     *
     * Uses 'simple' configuration to avoid language-specific stemming
     * (better for multi-language support)
     *
     * Uses custom tsvector type so Drizzle generates correct DDL and indexes.
     */
    ftsVector: tsvector("fts_vector").generatedAlwaysAs(
      sql$1`setweight(to_tsvector('simple', coalesce(title, '')), 'A') || setweight(to_tsvector('simple', coalesce(content, '')), 'B')`
    ).notNull(),
    /**
     * Created timestamp
     */
    createdAt: timestamp("created_at", { mode: "date" }).defaultNow().notNull(),
    /**
     * Updated timestamp
     */
    updatedAt: timestamp("updated_at", { mode: "date" }).defaultNow().notNull()
  },
  (t2) => [
    // GIN index for full-text search on tsvector column
    index$2("idx_search_fts").using("gin", t2.ftsVector),
    // Trigram index for fuzzy/typo-tolerant search (requires pg_trgm extension)
    index$2("idx_search_trigram").using("gin", sql$1`${t2.title} gin_trgm_ops`),
    // Collection + locale filter index
    index$2("idx_search_collection_locale").on(t2.collectionName, t2.locale),
    // Record ID lookup index
    index$2("idx_search_record_id").on(t2.recordId),
    // Unique constraint: one entry per collection + record + locale
    unique("uq_search_entry").on(t2.collectionName, t2.recordId, t2.locale)
  ]
);
const questpieSearchFacetsTable = pgTable(
  "questpie_search_facets",
  {
    /**
     * Primary key with auto-generated UUID
     */
    id: text("id").primaryKey().default(sql$1`gen_random_uuid()`),
    /**
     * Reference to parent search record
     * CASCADE delete ensures facets are removed when search record is deleted
     */
    searchId: text("search_id").notNull(),
    /**
     * Collection name (denormalized for efficient aggregation)
     */
    collectionName: text("collection_name").notNull(),
    /**
     * Locale (denormalized for efficient aggregation)
     */
    locale: text("locale").notNull(),
    /**
     * Facet field name (e.g., "status", "category", "tags")
     */
    facetName: text("facet_name").notNull(),
    /**
     * Facet value (string label)
     * For range facets, this is the bucket label (e.g., "Under $50")
     * For hierarchical facets, this is the path (e.g., "Electronics > Phones")
     */
    facetValue: text("facet_value").notNull(),
    /**
     * Original numeric value (for range facets)
     * Used to compute min/max stats
     */
    numericValue: numeric("numeric_value"),
    /**
     * Created timestamp
     */
    createdAt: timestamp("created_at", { mode: "date" }).defaultNow().notNull()
  },
  (t2) => [
    /**
     * Primary aggregation index
     * Optimized for: GROUP BY facet_value WHERE collection + locale + facet_name
     */
    index$2("idx_facets_agg").on(
      t2.collectionName,
      t2.locale,
      t2.facetName,
      t2.facetValue
    ),
    /**
     * Search ID index
     * For joining with search results and cleanup on record deletion
     */
    index$2("idx_facets_search_id").on(t2.searchId),
    /**
     * Collection index
     * For clearing all facets for a collection
     */
    index$2("idx_facets_collection").on(t2.collectionName)
  ]
);
class PostgresSearchAdapter {
  name = "postgres";
  db = null;
  trigramThreshold;
  ftsWeight;
  constructor(options = {}) {
    this.trigramThreshold = options.trigramThreshold ?? 0.3;
    this.ftsWeight = options.ftsWeight ?? 0.7;
  }
  get capabilities() {
    return {
      lexical: true,
      trigram: true,
      // pg_trgm required, created by ensureExtensions()
      semantic: false,
      hybrid: true,
      // FTS + trigram
      facets: true
    };
  }
  // --------------------------------------------------------------------------
  // Lifecycle
  // --------------------------------------------------------------------------
  async initialize(ctx) {
    this.db = ctx.db;
    ctx.logger.info("[PostgresSearchAdapter] Initialized");
  }
  /**
   * Get migrations for backwards compatibility.
   *
   * NOTE: Drizzle now handles table and index creation via getTableSchemas().
   * These migrations are kept for existing projects that have already run them.
   * All statements use IF NOT EXISTS so they're safe to run on new or existing DBs.
   */
  getMigrations() {
    return [
      {
        name: "search_001_create_table",
        up: `
					CREATE TABLE IF NOT EXISTS questpie_search (
						id TEXT PRIMARY KEY DEFAULT gen_random_uuid()::text,
						collection_name TEXT NOT NULL,
						record_id TEXT NOT NULL,
						locale TEXT NOT NULL,
						title TEXT NOT NULL,
						content TEXT,
						metadata JSONB DEFAULT '{}',
						fts_vector TSVECTOR GENERATED ALWAYS AS (
							setweight(to_tsvector('simple', coalesce(title, '')), 'A') ||
							setweight(to_tsvector('simple', coalesce(content, '')), 'B')
						) STORED,
						created_at TIMESTAMP DEFAULT NOW() NOT NULL,
						updated_at TIMESTAMP DEFAULT NOW() NOT NULL,
						UNIQUE(collection_name, record_id, locale)
					);
				`,
        down: `DROP TABLE IF EXISTS questpie_search;`
      },
      {
        name: "search_002_fts_index",
        up: `CREATE INDEX IF NOT EXISTS idx_search_fts ON questpie_search USING GIN (fts_vector);`,
        down: `DROP INDEX IF EXISTS idx_search_fts;`
      },
      {
        name: "search_003_collection_locale_index",
        up: `CREATE INDEX IF NOT EXISTS idx_search_collection_locale ON questpie_search (collection_name, locale);`,
        down: `DROP INDEX IF EXISTS idx_search_collection_locale;`
      },
      {
        name: "search_004_record_id_index",
        up: `CREATE INDEX IF NOT EXISTS idx_search_record_id ON questpie_search (record_id);`,
        down: `DROP INDEX IF EXISTS idx_search_record_id;`
      },
      {
        name: "search_005_trigram_extension",
        up: `CREATE EXTENSION IF NOT EXISTS pg_trgm;`,
        down: `-- pg_trgm extension kept for other uses`
      },
      {
        name: "search_006_trigram_index",
        up: `CREATE INDEX IF NOT EXISTS idx_search_trigram ON questpie_search USING GIN (title gin_trgm_ops);`,
        down: `DROP INDEX IF EXISTS idx_search_trigram;`
      },
      {
        name: "search_007_facets_table",
        up: `
					CREATE TABLE IF NOT EXISTS questpie_search_facets (
						id TEXT PRIMARY KEY DEFAULT gen_random_uuid()::text,
						search_id TEXT NOT NULL REFERENCES questpie_search(id) ON DELETE CASCADE,
						collection_name TEXT NOT NULL,
						locale TEXT NOT NULL,
						facet_name TEXT NOT NULL,
						facet_value TEXT NOT NULL,
						numeric_value NUMERIC,
						created_at TIMESTAMP DEFAULT NOW() NOT NULL
					);
				`,
        down: `DROP TABLE IF EXISTS questpie_search_facets;`
      },
      {
        name: "search_008_facets_indexes",
        up: `
					CREATE INDEX IF NOT EXISTS idx_facets_agg ON questpie_search_facets (collection_name, locale, facet_name, facet_value);
					CREATE INDEX IF NOT EXISTS idx_facets_search_id ON questpie_search_facets (search_id);
					CREATE INDEX IF NOT EXISTS idx_facets_collection ON questpie_search_facets (collection_name);
				`,
        down: `
					DROP INDEX IF EXISTS idx_facets_agg;
					DROP INDEX IF EXISTS idx_facets_search_id;
					DROP INDEX IF EXISTS idx_facets_collection;
				`
      }
    ];
  }
  // --------------------------------------------------------------------------
  // Search
  // --------------------------------------------------------------------------
  async search(options) {
    if (!this.db) {
      throw new Error("PostgresSearchAdapter not initialized");
    }
    const {
      query: query2,
      collections,
      locale = DEFAULT_LOCALE,
      limit = 10,
      offset: offset2 = 0,
      mode = "hybrid",
      filters,
      highlights = true,
      facets: facetRequests,
      accessFilters
    } = options;
    const conditions = [];
    if (collections && collections.length > 0) {
      conditions.push(inArray(questpieSearchTable.collectionName, collections));
    }
    conditions.push(eq(questpieSearchTable.locale, locale));
    if (filters) {
      for (const [key, value] of Object.entries(filters)) {
        if (Array.isArray(value)) {
          conditions.push(
            or(
              ...value.map(
                (v) => sql$1`${questpieSearchTable.metadata}->>${key} = ${v}`
              )
            )
          );
        } else {
          conditions.push(
            sql$1`${questpieSearchTable.metadata}->>${key} = ${value}`
          );
        }
      }
    }
    const hasQuery = query2.trim().length > 0;
    const prefixQuery = hasQuery ? query2.trim().split(/\s+/).filter(Boolean).map((word) => `${word}:*`).join(" & ") : null;
    const tsQuery = prefixQuery ? sql$1`to_tsquery('simple', ${prefixQuery})` : null;
    const accessCondition = this.buildAccessCondition(accessFilters);
    let rows;
    if (!hasQuery) {
      rows = await this.browseRecordsWithAccess(
        conditions,
        accessFilters,
        accessCondition,
        limit,
        offset2
      );
    } else if (mode === "hybrid") {
      rows = await this.searchHybridWithAccess(
        query2,
        tsQuery,
        conditions,
        accessFilters,
        accessCondition,
        limit,
        offset2
      );
    } else {
      rows = await this.searchFTSWithAccess(
        tsQuery,
        conditions,
        accessFilters,
        accessCondition,
        limit,
        offset2
      );
    }
    const results = rows.map((row) => ({
      id: row.id,
      collection: row.collection_name,
      recordId: row.record_id,
      score: Number(row.score) || 0,
      title: row.title,
      content: row.content,
      highlights: highlights && hasQuery ? this.generateHighlights(query2, row.title, row.content) : void 0,
      metadata: row.metadata || {},
      locale: row.locale,
      updatedAt: row.updated_at
    }));
    const total = await this.getTotalWithAccess(
      conditions,
      tsQuery,
      accessFilters,
      accessCondition
    );
    let facets;
    if (facetRequests && facetRequests.length > 0) {
      facets = await this.getFacets(facetRequests, conditions, tsQuery, locale);
    }
    return { results, total, facets };
  }
  /**
   * Build CASE-based access condition for filtering by collection access rules
   */
  buildAccessCondition(accessFilters) {
    if (!accessFilters || accessFilters.length === 0) {
      return null;
    }
    const caseConditions = [];
    for (const filter of accessFilters) {
      const { collection, table, accessWhere, softDelete } = filter;
      const tableName = table[/* @__PURE__ */ Symbol.for("drizzle:Name")] || collection;
      if (accessWhere === false) {
        caseConditions.push(
          sql$1`WHEN ${questpieSearchTable.collectionName} = ${collection} THEN FALSE`
        );
      } else if (accessWhere === true) {
        if (softDelete) {
          caseConditions.push(
            sql$1`WHEN ${questpieSearchTable.collectionName} = ${collection} THEN (${sql$1.raw(`"${tableName}".id IS NOT NULL AND "${tableName}".deleted_at IS NULL`)})`
          );
        } else {
          caseConditions.push(
            sql$1`WHEN ${questpieSearchTable.collectionName} = ${collection} THEN (${sql$1.raw(`"${tableName}".id IS NOT NULL`)})`
          );
        }
      } else {
        let condition = `"${tableName}".id IS NOT NULL`;
        if (softDelete) {
          condition += ` AND "${tableName}".deleted_at IS NULL`;
        }
        const accessConditions = this.accessWhereToSql(accessWhere, tableName);
        if (accessConditions) {
          condition += ` AND (${accessConditions})`;
        }
        caseConditions.push(
          sql$1`WHEN ${questpieSearchTable.collectionName} = ${collection} THEN (${sql$1.raw(condition)})`
        );
      }
    }
    if (caseConditions.length === 0) {
      return null;
    }
    return sql$1`CASE ${sql$1.join(caseConditions, sql$1` `)} ELSE FALSE END`;
  }
  /**
   * Convert AccessWhere object to SQL string
   */
  accessWhereToSql(accessWhere, tableName) {
    const conditions = [];
    for (const [key, value] of Object.entries(accessWhere)) {
      if (key === "AND" && Array.isArray(value)) {
        const andConditions = value.map((v) => this.accessWhereToSql(v, tableName)).filter(Boolean);
        if (andConditions.length > 0) {
          conditions.push(`(${andConditions.join(" AND ")})`);
        }
      } else if (key === "OR" && Array.isArray(value)) {
        const orConditions = value.map((v) => this.accessWhereToSql(v, tableName)).filter(Boolean);
        if (orConditions.length > 0) {
          conditions.push(`(${orConditions.join(" OR ")})`);
        }
      } else if (key === "NOT" && typeof value === "object") {
        const notCondition = this.accessWhereToSql(value, tableName);
        if (notCondition) {
          conditions.push(`NOT (${notCondition})`);
        }
      } else {
        const escapedValue = typeof value === "string" ? `'${value.replace(/'/g, "''")}'` : value === null ? "NULL" : value;
        conditions.push(`"${tableName}"."${key}" = ${escapedValue}`);
      }
    }
    return conditions.length > 0 ? conditions.join(" AND ") : null;
  }
  /**
   * Build LEFT JOINs for access filtering
   */
  buildAccessJoins(accessFilters) {
    if (!accessFilters || accessFilters.length === 0) {
      return null;
    }
    const joinParts = [];
    for (const filter of accessFilters) {
      const { collection, table } = filter;
      const tableName = table[/* @__PURE__ */ Symbol.for("drizzle:Name")] || collection;
      joinParts.push(
        sql$1`LEFT JOIN ${sql$1.raw(`"${tableName}"`)} ON ${questpieSearchTable.collectionName} = ${collection} AND ${questpieSearchTable.recordId} = ${sql$1.raw(`"${tableName}".id::text`)}`
      );
    }
    return joinParts.length > 0 ? sql$1.join(joinParts, sql$1` `) : null;
  }
  /**
   * Browse records without a search query (for facet-only or browsing)
   */
  async browseRecords(conditions, limit, offset2) {
    return this.db.select({
      id: questpieSearchTable.id,
      collection_name: questpieSearchTable.collectionName,
      record_id: questpieSearchTable.recordId,
      title: questpieSearchTable.title,
      content: questpieSearchTable.content,
      metadata: questpieSearchTable.metadata,
      locale: questpieSearchTable.locale,
      updated_at: questpieSearchTable.updatedAt,
      score: sql$1`1`
      // Default score for browse
    }).from(questpieSearchTable).where(and(...conditions)).orderBy(desc(questpieSearchTable.updatedAt)).limit(limit).offset(offset2);
  }
  /**
   * Browse records with access filtering via JOINs
   */
  async browseRecordsWithAccess(conditions, accessFilters, accessCondition, limit, offset2) {
    if (!accessFilters || accessFilters.length === 0 || !accessCondition) {
      return this.browseRecords(conditions, limit, offset2);
    }
    const joins = this.buildAccessJoins(accessFilters);
    const allConditions = [...conditions];
    if (accessCondition) {
      allConditions.push(accessCondition);
    }
    const query2 = sql$1`
			SELECT
				${questpieSearchTable.id} as id,
				${questpieSearchTable.collectionName} as collection_name,
				${questpieSearchTable.recordId} as record_id,
				${questpieSearchTable.title} as title,
				${questpieSearchTable.content} as content,
				${questpieSearchTable.metadata} as metadata,
				${questpieSearchTable.locale} as locale,
				${questpieSearchTable.updatedAt} as updated_at,
				1 as score
			FROM ${questpieSearchTable}
			${joins}
			WHERE ${and(...allConditions)}
			ORDER BY ${questpieSearchTable.updatedAt} DESC
			LIMIT ${limit} OFFSET ${offset2}
		`;
    const result2 = await this.db.execute(query2);
    return result2.rows ?? result2;
  }
  /**
   * Get total count of matching records
   */
  async getTotal(conditions, tsQuery) {
    const countConditions = [...conditions];
    if (tsQuery) {
      countConditions.push(sql$1`${questpieSearchTable.ftsVector} @@ ${tsQuery}`);
    }
    const result2 = await this.db.select({
      count: sql$1`COUNT(*)`
    }).from(questpieSearchTable).where(and(...countConditions));
    return Number(result2[0]?.count) || 0;
  }
  /**
   * Get total count with access filtering
   */
  async getTotalWithAccess(conditions, tsQuery, accessFilters, accessCondition) {
    if (!accessFilters || accessFilters.length === 0 || !accessCondition) {
      return this.getTotal(conditions, tsQuery);
    }
    const joins = this.buildAccessJoins(accessFilters);
    const countConditions = [...conditions];
    if (tsQuery) {
      countConditions.push(sql$1`${questpieSearchTable.ftsVector} @@ ${tsQuery}`);
    }
    if (accessCondition) {
      countConditions.push(accessCondition);
    }
    const query2 = sql$1`
			SELECT COUNT(*) as count
			FROM ${questpieSearchTable}
			${joins}
			WHERE ${and(...countConditions)}
		`;
    const result2 = await this.db.execute(query2);
    const rows = result2.rows ?? result2;
    return Number(rows[0]?.count) || 0;
  }
  /**
   * Get facet aggregations
   */
  async getFacets(facetRequests, conditions, tsQuery, locale) {
    const results = [];
    const searchConditions = [...conditions];
    if (tsQuery) {
      searchConditions.push(
        sql$1`${questpieSearchTable.ftsVector} @@ ${tsQuery}`
      );
    }
    for (const facetReq of facetRequests) {
      const { field, limit = 10, sortBy = "count" } = facetReq;
      const facetRows = await this.db.select({
        value: questpieSearchFacetsTable.facetValue,
        count: sql$1`COUNT(*)`
      }).from(questpieSearchFacetsTable).where(
        and(
          eq(questpieSearchFacetsTable.facetName, field),
          eq(questpieSearchFacetsTable.locale, locale),
          // Join condition: facet's search_id must be in matching search results
          sql$1`${questpieSearchFacetsTable.searchId} IN (
							SELECT ${questpieSearchTable.id} FROM ${questpieSearchTable}
							WHERE ${and(...searchConditions)}
						)`
        )
      ).groupBy(questpieSearchFacetsTable.facetValue).orderBy(
        sortBy === "alpha" ? asc(questpieSearchFacetsTable.facetValue) : desc(sql$1`COUNT(*)`)
      ).limit(limit);
      const stats = await this.getFacetStats(field, searchConditions, locale);
      results.push({
        field,
        values: facetRows.map((row) => ({
          value: row.value,
          count: Number(row.count)
        })),
        stats
      });
    }
    return results;
  }
  /**
   * Get numeric stats (min/max) for range facets
   */
  async getFacetStats(field, searchConditions, locale) {
    const result2 = await this.db.select({
      min: sql$1`MIN(${questpieSearchFacetsTable.numericValue}::numeric)`,
      max: sql$1`MAX(${questpieSearchFacetsTable.numericValue}::numeric)`
    }).from(questpieSearchFacetsTable).where(
      and(
        eq(questpieSearchFacetsTable.facetName, field),
        eq(questpieSearchFacetsTable.locale, locale),
        sql$1`${questpieSearchFacetsTable.numericValue} IS NOT NULL`,
        sql$1`${questpieSearchFacetsTable.searchId} IN (
						SELECT ${questpieSearchTable.id} FROM ${questpieSearchTable}
						WHERE ${and(...searchConditions)}
					)`
      )
    );
    const row = result2[0];
    if (row && row.min !== null && row.max !== null) {
      return {
        min: Number(row.min),
        max: Number(row.max)
      };
    }
    return void 0;
  }
  /**
   * Pure FTS search using ts_rank_cd (no extensions required)
   */
  async searchFTS(tsQuery, conditions, limit, offset2) {
    return this.db.select({
      id: questpieSearchTable.id,
      collection_name: questpieSearchTable.collectionName,
      record_id: questpieSearchTable.recordId,
      title: questpieSearchTable.title,
      content: questpieSearchTable.content,
      metadata: questpieSearchTable.metadata,
      locale: questpieSearchTable.locale,
      updated_at: questpieSearchTable.updatedAt,
      score: sql$1`ts_rank_cd(${questpieSearchTable.ftsVector}, ${tsQuery})`
    }).from(questpieSearchTable).where(
      and(...conditions, sql$1`${questpieSearchTable.ftsVector} @@ ${tsQuery}`)
    ).orderBy(
      desc(sql$1`ts_rank_cd(${questpieSearchTable.ftsVector}, ${tsQuery})`)
    ).limit(limit).offset(offset2);
  }
  /**
   * Pure FTS search with access filtering via JOINs
   */
  async searchFTSWithAccess(tsQuery, conditions, accessFilters, accessCondition, limit, offset2) {
    if (!accessFilters || accessFilters.length === 0 || !accessCondition) {
      return this.searchFTS(tsQuery, conditions, limit, offset2);
    }
    const joins = this.buildAccessJoins(accessFilters);
    const allConditions = [
      ...conditions,
      sql$1`${questpieSearchTable.ftsVector} @@ ${tsQuery}`
    ];
    if (accessCondition) {
      allConditions.push(accessCondition);
    }
    const whereClause = and(...allConditions);
    const query2 = sql$1`
			SELECT
				${questpieSearchTable.id} as id,
				${questpieSearchTable.collectionName} as collection_name,
				${questpieSearchTable.recordId} as record_id,
				${questpieSearchTable.title} as title,
				${questpieSearchTable.content} as content,
				${questpieSearchTable.metadata} as metadata,
				${questpieSearchTable.locale} as locale,
				${questpieSearchTable.updatedAt} as updated_at,
				ts_rank_cd(${questpieSearchTable.ftsVector}, ${tsQuery}) as score
			FROM ${questpieSearchTable}
			${joins}
			WHERE ${whereClause}
			ORDER BY ts_rank_cd(${questpieSearchTable.ftsVector}, ${tsQuery}) DESC
			LIMIT ${limit} OFFSET ${offset2}
		`;
    const result2 = await this.db.execute(query2);
    return result2.rows ?? result2;
  }
  /**
   * Hybrid search combining FTS + trigram (requires pg_trgm)
   */
  async searchHybrid(query2, tsQuery, conditions, limit, offset2) {
    const ftsWeight = this.ftsWeight;
    const trigramWeight = 1 - ftsWeight;
    const threshold = this.trigramThreshold;
    const rows = await this.db.select({
      id: questpieSearchTable.id,
      collection_name: questpieSearchTable.collectionName,
      record_id: questpieSearchTable.recordId,
      title: questpieSearchTable.title,
      content: questpieSearchTable.content,
      metadata: questpieSearchTable.metadata,
      locale: questpieSearchTable.locale,
      updated_at: questpieSearchTable.updatedAt,
      // Combined score: FTS * ftsWeight + trigram * trigramWeight
      score: sql$1`(
						COALESCE(ts_rank_cd(${questpieSearchTable.ftsVector}, ${tsQuery}), 0) * ${ftsWeight} +
						COALESCE(similarity(${questpieSearchTable.title}, ${query2}), 0) * ${trigramWeight}
					)`
    }).from(questpieSearchTable).where(
      and(
        ...conditions,
        or(
          sql$1`${questpieSearchTable.ftsVector} @@ ${tsQuery}`,
          sql$1`similarity(${questpieSearchTable.title}, ${query2}) > ${threshold}`
        )
      )
    ).orderBy(
      desc(sql$1`(
					COALESCE(ts_rank_cd(${questpieSearchTable.ftsVector}, ${tsQuery}), 0) * ${ftsWeight} +
					COALESCE(similarity(${questpieSearchTable.title}, ${query2}), 0) * ${trigramWeight}
				)`)
    ).limit(limit).offset(offset2);
    return rows;
  }
  /**
   * Hybrid search with access filtering via JOINs
   */
  async searchHybridWithAccess(query2, tsQuery, conditions, accessFilters, accessCondition, limit, offset2) {
    if (!accessFilters || accessFilters.length === 0 || !accessCondition) {
      return this.searchHybrid(query2, tsQuery, conditions, limit, offset2);
    }
    const ftsWeight = this.ftsWeight;
    const trigramWeight = 1 - ftsWeight;
    const threshold = this.trigramThreshold;
    const joins = this.buildAccessJoins(accessFilters);
    const allConditions = [
      ...conditions,
      or(
        sql$1`${questpieSearchTable.ftsVector} @@ ${tsQuery}`,
        sql$1`similarity(${questpieSearchTable.title}, ${query2}) > ${threshold}`
      )
    ];
    if (accessCondition) {
      allConditions.push(accessCondition);
    }
    const scoreExpr = sql$1`(
			COALESCE(ts_rank_cd(${questpieSearchTable.ftsVector}, ${tsQuery}), 0) * ${ftsWeight} +
			COALESCE(similarity(${questpieSearchTable.title}, ${query2}), 0) * ${trigramWeight}
		)`;
    const sqlQuery = sql$1`
			SELECT
				${questpieSearchTable.id} as id,
				${questpieSearchTable.collectionName} as collection_name,
				${questpieSearchTable.recordId} as record_id,
				${questpieSearchTable.title} as title,
				${questpieSearchTable.content} as content,
				${questpieSearchTable.metadata} as metadata,
				${questpieSearchTable.locale} as locale,
				${questpieSearchTable.updatedAt} as updated_at,
				${scoreExpr} as score
			FROM ${questpieSearchTable}
			${joins}
			WHERE ${and(...allConditions)}
			ORDER BY ${scoreExpr} DESC
			LIMIT ${limit} OFFSET ${offset2}
		`;
    const result2 = await this.db.execute(sqlQuery);
    return result2.rows ?? result2;
  }
  /**
   * Generate highlights for search results
   */
  generateHighlights(query2, title, content2) {
    const highlights = {};
    const escapedQuery = query2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    if (title) {
      const regex = new RegExp(`(${escapedQuery})`, "gi");
      highlights.title = title.replace(regex, "<mark>$1</mark>");
    }
    if (content2) {
      const regex = new RegExp(`(${escapedQuery})`, "gi");
      const match2 = regex.exec(content2);
      if (match2) {
        const start = Math.max(0, match2.index - 50);
        const end = Math.min(content2.length, match2.index + query2.length + 50);
        let snippet = content2.slice(start, end);
        if (start > 0) snippet = "..." + snippet;
        if (end < content2.length) snippet = snippet + "...";
        highlights.content = snippet.replace(
          new RegExp(`(${escapedQuery})`, "gi"),
          "<mark>$1</mark>"
        );
      }
    }
    return highlights;
  }
  // --------------------------------------------------------------------------
  // Indexing
  // --------------------------------------------------------------------------
  async index(params) {
    if (!this.db) {
      throw new Error("PostgresSearchAdapter not initialized");
    }
    const { collection, recordId, locale, title, content: content2, metadata, facets } = params;
    const [searchRecord] = await this.db.insert(questpieSearchTable).values({
      collectionName: collection,
      recordId,
      locale,
      title,
      content: content2,
      metadata: metadata || {},
      updatedAt: /* @__PURE__ */ new Date()
    }).onConflictDoUpdate({
      target: [
        questpieSearchTable.collectionName,
        questpieSearchTable.recordId,
        questpieSearchTable.locale
      ],
      set: {
        title,
        content: content2,
        metadata: metadata || {},
        updatedAt: /* @__PURE__ */ new Date()
      }
    }).returning({ id: questpieSearchTable.id });
    if (facets && facets.length > 0 && searchRecord) {
      await this.db.delete(questpieSearchFacetsTable).where(eq(questpieSearchFacetsTable.searchId, searchRecord.id));
      await this.db.insert(questpieSearchFacetsTable).values(
        facets.map((f) => ({
          searchId: searchRecord.id,
          collectionName: collection,
          locale,
          facetName: f.name,
          facetValue: f.value,
          numericValue: f.numericValue?.toString()
        }))
      );
    }
  }
  async indexBatch(params) {
    if (!this.db) {
      throw new Error("PostgresSearchAdapter not initialized");
    }
    if (params.length === 0) return;
    const values = params.map((p) => ({
      collectionName: p.collection,
      recordId: p.recordId,
      locale: p.locale,
      title: p.title,
      content: p.content,
      metadata: p.metadata || {},
      updatedAt: /* @__PURE__ */ new Date()
    }));
    const insertedRecords = await this.db.insert(questpieSearchTable).values(values).onConflictDoUpdate({
      target: [
        questpieSearchTable.collectionName,
        questpieSearchTable.recordId,
        questpieSearchTable.locale
      ],
      set: {
        title: sql$1`excluded.title`,
        content: sql$1`excluded.content`,
        metadata: sql$1`excluded.metadata`,
        updatedAt: sql$1`now()`
      }
    }).returning({
      id: questpieSearchTable.id,
      collectionName: questpieSearchTable.collectionName,
      recordId: questpieSearchTable.recordId,
      locale: questpieSearchTable.locale
    });
    for (let i = 0; i < params.length; i++) {
      const param = params[i];
      const searchRecord = insertedRecords.find(
        (r2) => r2.collectionName === param.collection && r2.recordId === param.recordId && r2.locale === param.locale
      );
      if (param.facets && param.facets.length > 0 && searchRecord) {
        await this.db.delete(questpieSearchFacetsTable).where(eq(questpieSearchFacetsTable.searchId, searchRecord.id));
        await this.db.insert(questpieSearchFacetsTable).values(
          param.facets.map((f) => ({
            searchId: searchRecord.id,
            collectionName: param.collection,
            locale: param.locale,
            facetName: f.name,
            facetValue: f.value,
            numericValue: f.numericValue?.toString()
          }))
        );
      }
    }
  }
  async remove(params) {
    if (!this.db) {
      throw new Error("PostgresSearchAdapter not initialized");
    }
    const { collection, recordId, locale } = params;
    const conditions = [
      eq(questpieSearchTable.collectionName, collection),
      eq(questpieSearchTable.recordId, recordId)
    ];
    if (locale) {
      conditions.push(eq(questpieSearchTable.locale, locale));
    }
    await this.db.delete(questpieSearchTable).where(and(...conditions));
  }
  async reindex(_collection) {
    throw new Error("reindex() not yet implemented - requires CMS context");
  }
  async clear() {
    if (!this.db) {
      throw new Error("PostgresSearchAdapter not initialized");
    }
    await this.db.delete(questpieSearchTable);
  }
  // --------------------------------------------------------------------------
  // Schema & Extensions (for migration generation)
  // --------------------------------------------------------------------------
  /**
   * Get Drizzle table schemas for migration generation.
   * These tables will be included in cms.getSchema() for Drizzle migrations.
   */
  getTableSchemas() {
    return {
      questpie_search: questpieSearchTable,
      questpie_search_facets: questpieSearchFacetsTable
    };
  }
  /**
   * Get required PostgreSQL extensions.
   * These will be created before migrations are run.
   */
  getExtensions() {
    return ["CREATE EXTENSION IF NOT EXISTS pg_trgm;"];
  }
}
function createPostgresSearchAdapter(options) {
  return new PostgresSearchAdapter(options);
}
z$1.object({
  /**
   * Items to index - collection name and record ID pairs
   */
  items: z$1.array(
    z$1.object({
      collection: z$1.string(),
      recordId: z$1.string()
    })
  )
});
class SearchServiceWrapper {
  constructor(adapter, db, logger2) {
    this.adapter = adapter;
    this.db = db;
    this.logger = logger2;
  }
  initialized = false;
  /**
   * Initialize the adapter (called by CMS on startup)
   */
  async initialize() {
    if (this.initialized) return;
    await this.adapter.initialize({
      db: this.db,
      logger: this.logger
    });
    this.initialized = true;
  }
  /**
   * Get the underlying adapter
   */
  getAdapter() {
    return this.adapter;
  }
  /**
   * Search across collections
   * Returns results, total count, and optional facets
   */
  async search(options) {
    this.ensureInitialized();
    return this.adapter.search(options);
  }
  /**
   * Index a record
   */
  async index(params) {
    this.ensureInitialized();
    return this.adapter.index(params);
  }
  /**
   * Remove from index
   */
  async remove(params) {
    this.ensureInitialized();
    return this.adapter.remove(params);
  }
  /**
   * Reindex entire collection
   */
  async reindex(collection) {
    this.ensureInitialized();
    return this.adapter.reindex(collection);
  }
  /**
   * Clear entire search index
   */
  async clear() {
    this.ensureInitialized();
    return this.adapter.clear();
  }
  /**
   * Index multiple records in a batch (upsert).
   * More efficient than calling index() multiple times.
   * Falls back to sequential index() calls if adapter doesn't support batch.
   */
  async indexBatch(params) {
    this.ensureInitialized();
    if (params.length === 0) return;
    if (this.adapter.indexBatch) {
      return this.adapter.indexBatch(params);
    }
    for (const param of params) {
      await this.adapter.index(param);
    }
  }
  ensureInitialized() {
    if (!this.initialized) {
      throw new Error(
        "SearchService not initialized. Call initialize() first or ensure CMS is properly started."
      );
    }
  }
}
function createSearchService(adapter, db, logger2) {
  const resolvedAdapter = adapter ?? createPostgresSearchAdapter();
  const resolvedLogger = logger2 ?? {
    debug: (...args) => console.debug("[Search]", ...args),
    info: (...args) => console.info("[Search]", ...args),
    warn: (...args) => console.warn("[Search]", ...args),
    error: (...args) => console.error("[Search]", ...args)
  };
  return new SearchServiceWrapper(resolvedAdapter, db, resolvedLogger);
}
const DEFAULT_BASE_PATH = "/cms";
const resolveBasePath = (config2) => config2.storage?.basePath || DEFAULT_BASE_PATH;
const DEFAULT_LOCATION = "./uploads";
function getStorageLocation(config2) {
  if (config2.storage?.driver) {
    return null;
  }
  const location = config2.storage?.location || DEFAULT_LOCATION;
  return resolve(process.cwd(), location);
}
const createDiskDriver = (config2) => {
  if (config2.storage?.driver) {
    return config2.storage.driver;
  }
  const location = getStorageLocation(config2);
  const secret = config2.secret || "questpie-default-secret";
  const expiration = config2.storage?.signedUrlExpiration || 3600;
  const basePath = resolveBasePath(config2);
  return new FSDriver({
    location,
    visibility: "public",
    urlBuilder: {
      async generateURL(key) {
        return buildStorageFileUrl(config2.app.url, basePath, key);
      },
      async generateSignedURL(key, _filePath, options) {
        const tokenExpiration = options?.expiresIn ? Math.floor(
          (typeof options.expiresIn === "string" ? parseInt(options.expiresIn, 10) : options.expiresIn) / 1e3
        ) : expiration;
        const token2 = await generateSignedUrlToken(
          key,
          secret,
          tokenExpiration
        );
        return buildStorageFileUrl(config2.app.url, basePath, key, token2);
      }
    }
  });
};
class Questpie {
  static __internal = {
    storageDriverServiceName: "cmsDefault"
  };
  _collections = {};
  _globals = {};
  config;
  resolvedLocales = null;
  pgConnectionString;
  /**
   * Default access control for all collections and globals.
   * Applied when collection/global doesn't define its own access rules.
   */
  defaultAccess;
  /**
   * Backend translator function for i18n
   * Translates error messages and system messages
   *
   * When using .messages() on the builder, the keys are type-safe:
   * ```ts
   * const cms = questpie({ name: "app" })
   *   .use(starterModule) // Includes core messages
   *   .messages({ en: { "custom.key": "Value" } } as const)
   *   .build({ ... });
   *
   * cms.t("error.notFound"); // Type-safe from starterModule
   * cms.t("custom.key");     // Type-safe from .messages()
   * ```
   *
   * @example
   * ```ts
   * cms.t("error.notFound", { resource: "User" }, "sk");
   * // => "Zznam nenjden" (in Slovak)
   * ```
   */
  t;
  /**
   * Better Auth instance - properly typed based on auth configuration
   * Type is inferred from the AuthConfig passed to .auth() in the builder
   */
  auth;
  storage;
  queue;
  email;
  kv;
  logger;
  search;
  realtime;
  migrations;
  api;
  db;
  constructor(config2) {
    this.config = config2;
    this.defaultAccess = config2.defaultAccess;
    this.t = createTranslator(config2.translations);
    this.registerCollections(config2.collections);
    if (config2.globals) {
      this.registerGlobals(config2.globals);
    }
    this.validateRelations();
    if ("url" in config2.db) {
      const bunSqlClient = new SQL({ url: config2.db.url });
      this.db = drizzle({
        client: bunSqlClient,
        schema: this.getSchema()
      });
      this.pgConnectionString = config2.db.url;
    } else {
      this.db = drizzle$1({
        client: config2.db.pglite,
        schema: this.getSchema()
      });
    }
    this.kv = new KVService(config2.kv);
    this.logger = new LoggerService(config2.logger);
    this.search = createSearchService(
      config2.search,
      this.db,
      this.logger
    );
    this.search.initialize().catch((err2) => {
      this.logger.error("[CMS] Failed to initialize search adapter:", err2);
    });
    this.realtime = new RealtimeService(
      this.db,
      config2.realtime,
      this.pgConnectionString
    );
    this.realtime.setSubscriptionContext({
      resolveCollectionDependencies: (baseCollection, withConfig) => {
        return this.resolveCollectionDependencies(baseCollection, withConfig);
      },
      resolveGlobalDependencies: (globalName, withConfig) => {
        return this.resolveGlobalDependencies(globalName, withConfig);
      }
    });
    if (config2.queue) {
      if (!config2.queue.adapter) {
        throw new Error(
          "QUESTPIE: Queue adapter is required when jobs are defined. Provide adapter in .build({ queue: { adapter: ... } })"
        );
      }
      this.queue = createQueueClient(config2.queue.jobs, config2.queue.adapter, {
        createContext: async () => this.createContext({ accessMode: "system" }),
        getApp: () => this,
        logger: this.logger
      });
    } else {
      this.queue = {};
    }
    this.auth = betterAuth({
      ...config2.auth ?? {},
      database: drizzleAdapter(this.db, {
        provider: "pg",
        schema: this.getSchema(),
        transaction: true
      })
    });
    this.storage = new DriveManager({
      default: Questpie.__internal.storageDriverServiceName,
      fakes: {
        location: new URL(
          join$1(tmpdir(), "fakes", crypto.randomUUID()),
          import.meta.url
        ),
        urlBuilder: {
          // TODO: is this correct?
          generateSignedURL(key, _filePath, _optionss) {
            return Promise.resolve(`http://fake-storage.local/${key}`);
          },
          generateURL(key, _filePath) {
            return Promise.resolve(`http://fake-storage.local/${key}`);
          }
        }
      },
      services: {
        [Questpie.__internal.storageDriverServiceName]: () => createDiskDriver(this.config)
      }
    });
    if (config2.email?.adapter) {
      this.email = new MailerService(config2.email);
    } else {
      throw new Error(
        "QUESTPIE: 'email.adapter' is required. Provide adapter in .build({ email: { adapter: ... } })"
      );
    }
    this.migrations = new QuestpieMigrationsAPI(this);
    this.api = new QuestpieAPI(this);
  }
  registerCollections(collections) {
    for (const [key, item] of Object.entries(collections)) {
      const collection = item instanceof CollectionBuilder ? item.build() : item;
      if (this._collections[key]) {
        throw new Error(
          `Collection "${collection.name}" is already registered.`
        );
      }
      this._collections[key] = collection;
    }
  }
  registerGlobals(globals) {
    for (const [key, item] of Object.entries(globals)) {
      const global2 = item instanceof GlobalBuilder ? item.build() : item;
      if (this._globals[key]) {
        throw new Error(`Global "${key}" is already registered.`);
      }
      this._globals[key] = global2;
    }
  }
  /**
   * Validates that all relations reference existing collections.
   * This catches configuration errors early at build time rather than at runtime.
   */
  validateRelations() {
    const collectionKeys = Object.keys(this._collections);
    const globalKeys = Object.keys(this._globals);
    const relationTargetKeys = [...collectionKeys, ...globalKeys];
    const errors = [];
    for (const [collectionKey, collection] of Object.entries(
      this._collections
    )) {
      const relations = collection.state.relations || {};
      for (const [relationName, relation] of Object.entries(relations)) {
        if (relation.collection && !relationTargetKeys.includes(relation.collection)) {
          errors.push(
            `Collection "${collectionKey}" has relation "${relationName}" pointing to unknown target "${relation.collection}". Available collections/globals: ${relationTargetKeys.join(", ")}`
          );
        }
        if (relation.through && !collectionKeys.includes(relation.through)) {
          errors.push(
            `Collection "${collectionKey}" has relation "${relationName}" with "through: ${relation.through}" pointing to unknown collection. Did you mean one of: ${collectionKeys.join(", ")}?`
          );
        }
      }
    }
    for (const [globalKey, global2] of Object.entries(this._globals)) {
      const relations = global2.state.relations || {};
      for (const [relationName, relation] of Object.entries(relations)) {
        if (relation.collection && !relationTargetKeys.includes(relation.collection)) {
          errors.push(
            `Global "${globalKey}" has relation "${relationName}" pointing to unknown target "${relation.collection}". Available collections/globals: ${relationTargetKeys.join(", ")}`
          );
        }
        if (relation.through && !collectionKeys.includes(relation.through)) {
          errors.push(
            `Global "${globalKey}" has relation "${relationName}" with "through: ${relation.through}" pointing to unknown collection. Did you mean one of: ${collectionKeys.join(", ")}?`
          );
        }
      }
    }
    if (errors.length > 0) {
      throw new Error(
        `QUESTPIE: Invalid relation configuration:

${errors.map((e2) => `  - ${e2}`).join("\n\n")}`
      );
    }
  }
  getCollectionConfig(name2) {
    const collection = this._collections[name2];
    if (!collection) {
      throw new Error(`Collection "${String(name2)}" not found.`);
    }
    return collection;
  }
  getGlobalConfig(name2) {
    const global2 = this._globals[name2];
    if (!global2) {
      throw new Error(`Global "${String(name2)}" not found.`);
    }
    return global2;
  }
  async getLocales() {
    if (this.resolvedLocales) return this.resolvedLocales;
    if (!this.config.locale) {
      this.resolvedLocales = [
        {
          code: "en"
        }
      ];
      return this.resolvedLocales;
    }
    if (Array.isArray(this.config.locale.locales)) {
      this.resolvedLocales = this.config.locale.locales;
    } else {
      this.resolvedLocales = await this.config.locale.locales();
    }
    return this.resolvedLocales;
  }
  /**
   * Create request context
   * Returns minimal context with session, locale, accessMode
   * Services are accessed via cms.* not context.*
   * @default accessMode: 'system' - CMS API is backend-only by default
   */
  async createContext(userCtx = {}) {
    const defaultLocale2 = this.config.locale?.defaultLocale || DEFAULT_LOCALE;
    let locale = userCtx.locale || defaultLocale2;
    if (userCtx.locale) {
      const locales = await this.getLocales();
      if (!locales.find((l2) => l2.code === userCtx.locale)) {
        if (this.config.locale?.fallbacks?.[userCtx.locale]) {
          locale = this.config.locale.fallbacks[userCtx.locale];
        } else {
          locale = defaultLocale2;
        }
      }
    }
    return {
      ...userCtx,
      session: userCtx.session,
      locale,
      defaultLocale: defaultLocale2,
      accessMode: userCtx.accessMode ?? "system",
      // Default to system
      db: userCtx.db ?? this.db
    };
  }
  getCollections() {
    return this._collections;
  }
  getGlobals() {
    return this._globals;
  }
  getTables() {
    const tables = {};
    for (const [name2, collection] of Object.entries(this._collections)) {
      tables[name2] = collection.table;
      if (collection.i18nTable) {
        tables[`${name2}_i18n`] = collection.i18nTable;
      }
      if (collection.versionsTable) {
        tables[`${name2}_versions`] = collection.versionsTable;
      }
      if (collection.i18nVersionsTable) {
        tables[`${name2}_i18n_versions`] = collection.i18nVersionsTable;
      }
    }
    for (const [name2, global2] of Object.entries(this._globals)) {
      tables[name2] = global2.table;
      if (global2.i18nTable) {
        tables[`${name2}_i18n`] = global2.i18nTable;
      }
      if (global2.versionsTable) {
        tables[`${name2}_versions`] = global2.versionsTable;
      }
      if (global2.i18nVersionsTable) {
        tables[`${name2}_i18n_versions`] = global2.i18nVersionsTable;
      }
    }
    return tables;
  }
  getSchema() {
    const schema2 = {};
    for (const [name2, collection] of Object.entries(this._collections)) {
      schema2[name2] = collection.table;
      if (collection.i18nTable) {
        schema2[`${name2}_i18n`] = collection.i18nTable;
      }
      if (collection.versionsTable) {
        schema2[`${name2}_versions`] = collection.versionsTable;
      }
      if (collection.i18nVersionsTable) {
        schema2[`${name2}_i18n_versions`] = collection.i18nVersionsTable;
      }
    }
    for (const [name2, global2] of Object.entries(this._globals)) {
      schema2[name2] = global2.table;
      if (global2.i18nTable) {
        schema2[`${name2}_i18n`] = global2.i18nTable;
      }
      if (global2.versionsTable) {
        schema2[`${name2}_versions`] = global2.versionsTable;
      }
      if (global2.i18nVersionsTable) {
        schema2[`${name2}_i18n_versions`] = global2.i18nVersionsTable;
      }
    }
    schema2.questpie_realtime_log = questpieRealtimeLogTable;
    const searchAdapter = this.search?.getAdapter();
    if (searchAdapter?.getTableSchemas) {
      const searchTables = searchAdapter.getTableSchemas();
      if (searchTables) {
        Object.assign(schema2, searchTables);
      }
    }
    return schema2;
  }
  /**
   * Resolve collection dependencies from WITH config for realtime subscriptions.
   * Returns all collections that should trigger a refresh (main + relations).
   */
  resolveCollectionDependencies(baseCollection, withConfig) {
    const dependencies = /* @__PURE__ */ new Set([baseCollection]);
    if (!withConfig || typeof withConfig !== "object" || Array.isArray(withConfig)) {
      return dependencies;
    }
    const collectionMap = this.getCollections();
    this.visitCollectionRelations(
      collectionMap,
      dependencies,
      baseCollection,
      withConfig
    );
    return dependencies;
  }
  /**
   * Resolve global dependencies from WITH config for realtime subscriptions.
   */
  resolveGlobalDependencies(globalName, withConfig) {
    const dependencies = {
      collections: /* @__PURE__ */ new Set(),
      globals: /* @__PURE__ */ new Set([globalName])
    };
    if (!withConfig || typeof withConfig !== "object" || Array.isArray(withConfig)) {
      return dependencies;
    }
    const globalMap = this.getGlobals();
    const global2 = globalMap[globalName];
    if (!global2) return dependencies;
    const collectionMap = this.getCollections();
    for (const [relationName, relationOptions] of Object.entries(withConfig)) {
      if (!relationOptions) continue;
      const relation = global2.state.relations?.[relationName];
      if (!relation) continue;
      dependencies.collections.add(relation.collection);
      if (relation.type === "manyToMany" && relation.through) {
        dependencies.collections.add(relation.through);
      }
      const nestedWith = typeof relationOptions === "object" && !Array.isArray(relationOptions) ? relationOptions.with : void 0;
      if (nestedWith) {
        this.visitCollectionRelations(
          collectionMap,
          dependencies.collections,
          relation.collection,
          nestedWith
        );
      }
    }
    return dependencies;
  }
  /**
   * Visit collection relations recursively to build dependency tree.
   */
  visitCollectionRelations(collectionMap, dependencies, collectionName, withConfig) {
    if (!withConfig || typeof withConfig !== "object" || Array.isArray(withConfig)) {
      return;
    }
    const collection = collectionMap[collectionName];
    if (!collection) return;
    for (const [relationName, relationOptions] of Object.entries(withConfig)) {
      if (!relationOptions) continue;
      const relation = collection.state.relations?.[relationName];
      if (!relation) continue;
      dependencies.add(relation.collection);
      if (relation.type === "manyToMany" && relation.through) {
        dependencies.add(relation.through);
      }
      let nestedWith;
      if (typeof relationOptions === "object" && !Array.isArray(relationOptions)) {
        if ("with" in relationOptions) {
          nestedWith = relationOptions.with;
        } else if (relationOptions !== true) {
          nestedWith = relationOptions;
        }
      }
      if (nestedWith) {
        this.visitCollectionRelations(
          collectionMap,
          dependencies,
          relation.collection,
          nestedWith
        );
      }
    }
  }
}
function auth(options) {
  return options;
}
function mergeAuthOptions(base, overrides) {
  const {
    plugins: basePlugins,
    socialProviders: baseSocialProviders,
    ...baseRest
  } = base || {};
  const {
    plugins: overridePlugins,
    socialProviders: overrideSocialProviders,
    ...overridesRest
  } = overrides || {};
  const merged = {
    // we deepmerge all except plugins and socialProviders
    ...deepMerge(baseRest, overridesRest),
    // merge plugins, newer plugins take precedence
    plugins: dedupeBy(
      [...overridePlugins || [], ...basePlugins || []],
      (plugin) => plugin.id
    ),
    // social providers are merged shallowly
    socialProviders: {
      ...baseSocialProviders,
      ...overrideSocialProviders
    }
  };
  return merged;
}
class QuestpieBuilder {
  state;
  static empty(name2) {
    return new QuestpieBuilder({
      name: name2,
      collections: {},
      globals: {},
      jobs: {},
      emailTemplates: {},
      fields: {},
      auth: {},
      locale: void 0,
      migrations: void 0,
      translations: void 0,
      contextResolver: void 0,
      "~messageKeys": void 0
    });
  }
  constructor(state) {
    this.state = state;
  }
  /**
   * Define collections (as a map for type-safe access)
   *
   * @example
   * ```ts
   * .collections({
   *   posts: postsCollection,
   *   comments: commentsCollection,
   * })
   * ```
   */
  collections(collections) {
    return new QuestpieBuilder({
      ...this.state,
      collections: {
        ...this.state.collections,
        ...collections
      }
    });
  }
  /**
   * Define globals (as a map for type-safe access)
   *
   * @example
   * ```ts
   * .globals({
   *   siteSettings: siteSettingsGlobal,
   * })
   * ```
   */
  globals(globals) {
    return new QuestpieBuilder({
      ...this.state,
      globals: {
        ...this.state.globals,
        ...globals
      }
    });
  }
  /**
   * Define jobs (as a map for type-safe access)
   *
   * @example
   * ```ts
   * .jobs({
   *   sendEmail: sendEmailJob,
   *   processImage: processImageJob,
   * })
   * ```
   */
  jobs(jobs) {
    return new QuestpieBuilder({
      ...this.state,
      jobs: {
        ...this.state.jobs,
        ...jobs
      }
    });
  }
  /**
   * Define email templates (as a map for type-safe access)
   *
   * @example
   * ```ts
   * .emailTemplates({
   *   welcome: welcomeTemplate,
   *   resetPassword: resetPasswordTemplate,
   * })
   * ```
   */
  emailTemplates(emailTemplates) {
    return new QuestpieBuilder({
      ...this.state,
      emailTemplates: {
        ...this.state.emailTemplates,
        ...emailTemplates
      }
    });
  }
  /**
   * Register field types for the Field Builder system.
   * Fields are available when defining collections with `.fields((f) => ({ ... }))`.
   *
   * @example
   * ```ts
   * import { textField, numberField } from "@questpie/server/fields";
   *
   * const q = questpie({ name: "app" })
   *   .fields({
   *     text: textField,
   *     number: numberField,
   *   });
   *
   * // Now available in collections:
   * const posts = collection("posts")
   *   .fields((f) => ({
   *     title: f.text({ required: true }),
   *     views: f.number({ min: 0 }),
   *   }));
   * ```
   */
  fields(fields2) {
    return new QuestpieBuilder({
      ...this.state,
      fields: {
        ...this.state.fields,
        ...fields2
      }
    });
  }
  /**
   * Configure authentication (Better Auth)
   * Type-inferrable - affects auth instance type
   * Override strategy: Last wins
   *
   * @example
   * ```ts
   * // With BetterAuthOptions (merged with core auth defaults)
   * .auth({
   *   emailAndPassword: { enabled: true, requireEmailVerification: false },
   *   baseURL: "http://localhost:3000",
   *   secret: process.env.BETTER_AUTH_SECRET,
   * })
   * ```
   *
   * @example
   * ```ts
   * // With factory function (full control over DB wiring)
   * .auth((db) =>
   *   withAuthDatabase(mergeAuthOptions(coreAuthOptions, {
   *     emailAndPassword: { enabled: true, requireEmailVerification: false },
   *     baseURL: "http://localhost:3000",
   *     secret: process.env.BETTER_AUTH_SECRET,
   *   }), db)
   * )
   * ```
   *
   * @example
   * ```ts
   * // With Better Auth instance
   * .auth(betterAuth({
   *   database: drizzleAdapter(db, { provider: "pg" }),
   *   emailAndPassword: { enabled: true },
   *   baseURL: 'http://localhost:3000',
   * }))
   * ```
   */
  auth(auth2) {
    return new QuestpieBuilder({
      ...this.state,
      auth: mergeAuthOptions(
        this.state.auth,
        typeof auth2 === "function" ? auth2(this.state.auth) : auth2
      )
    });
  }
  /**
   * Configure localization
   * Type-inferrable - affects i18n table generation
   * Override strategy: Last wins
   *
   * @example
   * ```ts
   * .locale({
   *   locales: [{ code: 'en' }, { code: 'sk' }],
   *   defaultLocale: 'en',
   * })
   * ```
   */
  locale(locale) {
    return new QuestpieBuilder({
      ...this.state,
      locale
    });
  }
  /**
   * Add migrations
   * Merges with existing migrations
   *
   * @example
   * ```ts
   * .migrations([customMigration1, customMigration2])
   * ```
   */
  migrations(migrations) {
    return new QuestpieBuilder({
      ...this.state,
      migrations: [...this.state.migrations || [], ...migrations]
    });
  }
  /**
   * Configure custom context extension for all requests.
   *
   * The resolver function receives request, session, and db, and returns
   * custom properties that will be merged into the request context.
   * These properties are then available in all access functions, hooks, etc.
   *
   * Use module augmentation to get type-safe access to your custom properties:
   *
   * @example
   * ```ts
   * // builder.ts
   * export const qb = q
   *   .use(adminModule)
   *   .context(async ({ request, session, db }) => {
   *     const propertyId = request.headers.get('x-selected-property')
   *
   *     // Validate access if needed
   *     if (propertyId && session?.user) {
   *       const hasAccess = await db.query.propertyMembers.findFirst({
   *         where: and(
   *           eq(propertyMembers.propertyId, propertyId),
   *           eq(propertyMembers.userId, session.user.id)
   *         )
   *       })
   *       if (!hasAccess) {
   *         throw new Error('No access to this property')
   *       }
   *     }
   *
   *     return { propertyId }
   *   })
   *
   * // types.ts - Module augmentation for type safety
   * declare module 'questpie' {
   *   interface QuestpieContextExtension {
   *     propertyId: string | null
   *   }
   * }
   *
   * // In collections - ctx.propertyId is now typed
   * .access({
   *   read: ({ ctx }) => ctx.propertyId === data.propertyId
   * })
   * ```
   */
  context(resolver) {
    return new QuestpieBuilder({
      ...this.state,
      contextResolver: resolver
    });
  }
  /**
   * Add translated messages for backend (simple API)
   *
   * Messages are merged with existing messages from modules.
   * Custom messages override defaults with same key.
   * Message keys are tracked in the type system for type-safe access via cms.t().
   *
   * @example
   * ```ts
   * const messages = {
   *   en: {
   *     "booking.created": "Booking created for {{date}}",
   *     "booking.cancelled": "Booking was cancelled",
   *   },
   *   sk: {
   *     "booking.created": "Rezervcia vytvoren na {{date}}",
   *     "booking.cancelled": "Rezervcia bola zruen",
   *   },
   * } as const;
   *
   * const cms = q({ name: "app" })
   *   .messages(messages)
   *   .build({ ... });
   *
   * // cms.t("booking.created") is type-safe!
   * ```
   */
  messages(messages2, options) {
    return new QuestpieBuilder({
      ...this.state,
      translations: mergeMessagesIntoConfig(
        this.state.translations,
        messages2,
        options?.fallbackLocale
      )
    });
  }
  /**
   * Use (compose) another Questpie builder (module composition)
   * Override strategy: Last wins for all properties
   *
   * @example
   * ```ts
   * // Simple module composition
   * const blogModule = questpie({ name: 'blog' })
   *   .collections({
   *     posts: postsCollection,
   *     categories: categoriesCollection,
   *   })
   *   .jobs({
   *     publishPost: publishPostJob,
   *   })
   *
   * const cms = questpie({ name: 'app' })
   *   .use(blogModule)
   *   .collections({
   *     products: productsCollection,
   *   })
   *   .build({ ... })
   * ```
   *
   * @example
   * ```ts
   * // Override/extend collection from module using .merge()
   * const blogModule = questpie({ name: 'blog' })
   *   .collections({ posts: postsCollection })
   *
   * const cms = questpie({ name: 'app' })
   *   .use(blogModule)
   *   .collections({
   *     // Override posts collection with custom fields
   *     posts: blogModule.state.collections.posts.merge(
   *       collection("posts").fields({
   *         featured: boolean("featured").default(false),
   *         viewCount: integer("view_count").default(0),
   *       })
   *     )
   *   })
   * ```
   */
  use(other) {
    const otherState = other.state;
    return new QuestpieBuilder({
      name: this.state.name,
      // Keep current name
      collections: {
        ...this.state.collections,
        ...otherState.collections
      },
      globals: {
        ...this.state.globals,
        ...otherState.globals
      },
      jobs: {
        ...this.state.jobs,
        ...otherState.jobs
      },
      emailTemplates: {
        ...this.state.emailTemplates,
        ...otherState.emailTemplates
      },
      fields: {
        ...this.state.fields,
        ...otherState.fields
      },
      auth: mergeAuthOptions(this.state.auth, otherState.auth),
      locale: otherState.locale ?? this.state.locale,
      migrations: [
        ...this.state.migrations || [],
        ...otherState.migrations || []
      ],
      translations: mergeTranslationsConfig(
        this.state.translations,
        otherState.translations
      )
    });
  }
  // ============================================================================
  // Entity Creation Methods
  // ============================================================================
  /**
   * Create a collection builder bound to this Questpie builder.
   * The collection has access to all registered field types from `.fields()`.
   *
   * @example
   * ```ts
   * import { defaultFields } from "@questpie/server/fields/builtin";
   *
   * const q = questpie({ name: "app" })
   *   .fields(defaultFields);
   *
   * // Use q.collection() for type-safe field access:
   * const posts = q.collection("posts")
   *   .fields((f) => ({
   *     title: f.text({ required: true }),  //  autocomplete from defaultFields
   *     views: f.number({ min: 0 }),
   *   }));
   *
   * const cms = q
   *   .collections({ posts })
   *   .build({ ... });
   * ```
   */
  collection(name2) {
    return new CollectionBuilder({
      name: name2,
      fields: {},
      localized: [],
      virtuals: void 0,
      relations: {},
      indexes: {},
      title: void 0,
      options: {},
      hooks: {},
      access: {},
      functions: {},
      searchable: void 0,
      validation: void 0,
      output: void 0,
      upload: void 0,
      fieldDefinitions: {},
      "~questpieApp": this,
      "~fieldTypes": void 0
      // Type only - passed via generics
    });
  }
  /**
   * Create a global builder bound to this Questpie builder.
   * The global has access to all registered field types from `.fields()`.
   *
   * @example
   * ```ts
   * import { defaultFields } from "@questpie/server/fields/builtin";
   *
   * const q = questpie({ name: "app" })
   *   .fields(defaultFields);
   *
   * // Use q.global() for type-safe field access:
   * const settings = q.global("settings")
   *   .fields((f) => ({
   *     siteName: f.text({ required: true }),  //  autocomplete from defaultFields
   *     maintenanceMode: f.boolean({ default: false }),
   *   }));
   *
   * const cms = q
   *   .globals({ settings })
   *   .build({ ... });
   * ```
   */
  global(name2) {
    return new GlobalBuilder({
      name: name2,
      fields: {},
      localized: [],
      virtuals: {},
      relations: {},
      options: {},
      hooks: {},
      access: {},
      functions: {},
      fieldDefinitions: void 0,
      "~questpieApp": this,
      "~fieldTypes": void 0
      // Type only - passed via generics
    });
  }
  // ============================================================================
  // Factory Methods (passthrough helpers for type-safe definitions)
  // ============================================================================
  /**
   * Define a background job with type-safe payload and handler.
   *
   * @example
   * ```ts
   * const sendEmailJob = q.job({
   *   name: 'send-email',
   *   schema: z.object({
   *     to: z.string().email(),
   *     subject: z.string(),
   *   }),
   *   handler: async ({ payload, app }) => {
   *     await app.email.send({ to: payload.to, subject: payload.subject, html: '...' });
   *   },
   * });
   *
   * const cms = q.jobs({ sendEmail: sendEmailJob }).build({ ... });
   * ```
   */
  job(definition) {
    return definition;
  }
  fn(definition) {
    return definition;
  }
  /**
   * Define an email template with type-safe context.
   *
   * @example
   * ```ts
   * const welcomeEmail = q.email({
   *   name: 'welcome',
   *   schema: z.object({ name: z.string(), activationLink: z.string().url() }),
   *   render: ({ name, activationLink }) => (
   *     <div>
   *       <h1>Welcome, {name}!</h1>
   *       <a href={activationLink}>Activate</a>
   *     </div>
   *   ),
   *   subject: (ctx) => `Welcome, ${ctx.name}!`,
   * });
   *
   * const cms = q.emailTemplates({ welcome: welcomeEmail }).build({ ... });
   * ```
   */
  email(definition) {
    return definition;
  }
  /**
   * Build the final Questpie instance
   * Requires runtime configuration (app.url, db.url, etc.)
   *
   * @example
   * ```ts
   * .build({
   *   app: { url: process.env.APP_URL },
   *   db: { url: process.env.DATABASE_URL },
   *   secret: process.env.SECRET,
   *   storage: { driver: s3Driver(...) },
   *   email: { adapter: smtpAdapter(...) },
   *   queue: { adapter: pgBossAdapter(...) },
   * })
   * ```
   */
  build(runtimeConfig) {
    const cmsConfig = {
      app: runtimeConfig.app,
      db: runtimeConfig.db,
      secret: runtimeConfig.secret,
      collections: this.state.collections,
      globals: this.state.globals,
      locale: this.state.locale,
      auth: this.state.auth,
      storage: runtimeConfig.storage,
      email: runtimeConfig.email ? {
        ...runtimeConfig.email,
        templates: this.state.emailTemplates
      } : void 0,
      queue: Object.keys(this.state.jobs).length > 0 && runtimeConfig.queue ? {
        jobs: this.state.jobs,
        adapter: runtimeConfig.queue.adapter
      } : void 0,
      search: runtimeConfig.search,
      realtime: runtimeConfig.realtime,
      logger: runtimeConfig.logger,
      kv: runtimeConfig.kv,
      migrations: {
        migrations: this.state.migrations
      },
      translations: this.state.translations,
      contextResolver: this.state.contextResolver,
      defaultAccess: runtimeConfig.defaultAccess
    };
    return new Questpie(cmsConfig);
  }
}
function questpie(config2) {
  return QuestpieBuilder.empty(config2.name);
}
function createCallableBuilder(builder) {
  const callable = (config2) => {
    return QuestpieBuilder.empty(config2.name).fields(
      builder.state.fields
    );
  };
  Object.setPrototypeOf(callable, QuestpieBuilder.prototype);
  Object.assign(callable, builder);
  Object.defineProperty(callable, "state", {
    value: builder.state,
    writable: false,
    enumerable: true
  });
  return callable;
}
function fn(definition) {
  return definition;
}
fn.typed = function typedFn() {
  function createFn(definition) {
    return definition;
  }
  return createFn;
};
function role(statements) {
  return {
    authorize(request, connector = "AND") {
      let success = false;
      for (const [requestedResource, requestedActions] of Object.entries(request)) {
        const allowedActions = statements[requestedResource];
        if (!allowedActions) return {
          success: false,
          error: `You are not allowed to access resource: ${requestedResource}`
        };
        if (Array.isArray(requestedActions)) success = requestedActions.every((requestedAction) => allowedActions.includes(requestedAction));
        else if (typeof requestedActions === "object") {
          const actions = requestedActions;
          if (actions.connector === "OR") success = actions.actions.some((requestedAction) => allowedActions.includes(requestedAction));
          else success = actions.actions.every((requestedAction) => allowedActions.includes(requestedAction));
        } else throw new BetterAuthError("Invalid access control request");
        if (success && connector === "OR") return { success };
        if (!success && connector === "AND") return {
          success: false,
          error: `unauthorized to access resource "${requestedResource}"`
        };
      }
      if (success) return { success };
      return {
        success: false,
        error: "Not authorized"
      };
    },
    statements
  };
}
function createAccessControl(s2) {
  return {
    newRole(statements) {
      return role(statements);
    },
    statements: s2
  };
}
const defaultStatements = {
  user: [
    "create",
    "list",
    "set-role",
    "ban",
    "impersonate",
    "delete",
    "set-password",
    "get",
    "update"
  ],
  session: [
    "list",
    "revoke",
    "delete"
  ]
};
const defaultAc = createAccessControl(defaultStatements);
const adminAc = defaultAc.newRole({
  user: [
    "create",
    "list",
    "set-role",
    "ban",
    "impersonate",
    "delete",
    "set-password",
    "get",
    "update"
  ],
  session: [
    "list",
    "revoke",
    "delete"
  ]
});
const userAc = defaultAc.newRole({
  user: [],
  session: []
});
const defaultRoles$1 = {
  admin: adminAc,
  user: userAc
};
const getEndpointResponse = async (ctx) => {
  const returned = ctx.context.returned;
  if (!returned) return null;
  if (returned instanceof Response) {
    if (returned.status !== 200) return null;
    return await returned.clone().json();
  }
  if (returned instanceof APIError$1) return null;
  return returned;
};
const ADMIN_ERROR_CODES = defineErrorCodes({
  FAILED_TO_CREATE_USER: "Failed to create user",
  USER_ALREADY_EXISTS: "User already exists.",
  USER_ALREADY_EXISTS_USE_ANOTHER_EMAIL: "User already exists. Use another email.",
  YOU_CANNOT_BAN_YOURSELF: "You cannot ban yourself",
  YOU_ARE_NOT_ALLOWED_TO_CHANGE_USERS_ROLE: "You are not allowed to change users role",
  YOU_ARE_NOT_ALLOWED_TO_CREATE_USERS: "You are not allowed to create users",
  YOU_ARE_NOT_ALLOWED_TO_LIST_USERS: "You are not allowed to list users",
  YOU_ARE_NOT_ALLOWED_TO_LIST_USERS_SESSIONS: "You are not allowed to list users sessions",
  YOU_ARE_NOT_ALLOWED_TO_BAN_USERS: "You are not allowed to ban users",
  YOU_ARE_NOT_ALLOWED_TO_IMPERSONATE_USERS: "You are not allowed to impersonate users",
  YOU_ARE_NOT_ALLOWED_TO_REVOKE_USERS_SESSIONS: "You are not allowed to revoke users sessions",
  YOU_ARE_NOT_ALLOWED_TO_DELETE_USERS: "You are not allowed to delete users",
  YOU_ARE_NOT_ALLOWED_TO_SET_USERS_PASSWORD: "You are not allowed to set users password",
  BANNED_USER: "You have been banned from this application",
  YOU_ARE_NOT_ALLOWED_TO_GET_USER: "You are not allowed to get user",
  NO_DATA_TO_UPDATE: "No data to update",
  YOU_ARE_NOT_ALLOWED_TO_UPDATE_USERS: "You are not allowed to update users",
  YOU_CANNOT_REMOVE_YOURSELF: "You cannot remove yourself",
  YOU_ARE_NOT_ALLOWED_TO_SET_NON_EXISTENT_VALUE: "You are not allowed to set a non-existent role value",
  YOU_CANNOT_IMPERSONATE_ADMINS: "You cannot impersonate admins",
  INVALID_ROLE_TYPE: "Invalid role type"
});
const hasPermission = (input) => {
  if (input.userId && input.options?.adminUserIds?.includes(input.userId)) return true;
  if (!input.permissions && !input.permission) return false;
  const roles = (input.role || input.options?.defaultRole || "user").split(",");
  const acRoles = input.options?.roles || defaultRoles$1;
  for (const role2 of roles) if (acRoles[role2]?.authorize(input.permission ?? input.permissions)?.success) return true;
  return false;
};
const adminMiddleware = createAuthMiddleware(async (ctx) => {
  const session = await getSessionFromCtx(ctx);
  if (!session) throw new APIError$1("UNAUTHORIZED");
  return { session };
});
function parseRoles(roles) {
  return Array.isArray(roles) ? roles.join(",") : roles;
}
const setRoleBodySchema = z.object({
  userId: z.coerce.string().meta({ description: "The user id" }),
  role: z.union([z.string().meta({ description: "The role to set. `admin` or `user` by default" }), z.array(z.string().meta({ description: "The roles to set. `admin` or `user` by default" }))]).meta({ description: "The role to set, this can be a string or an array of strings. Eg: `admin` or `[admin, user]`" })
});
const setRole = (opts) => createAuthEndpoint("/admin/set-role", {
  method: "POST",
  body: setRoleBodySchema,
  requireHeaders: true,
  use: [adminMiddleware],
  metadata: {
    openapi: {
      operationId: "setUserRole",
      summary: "Set the role of a user",
      description: "Set the role of a user",
      responses: { 200: {
        description: "User role updated",
        content: { "application/json": { schema: {
          type: "object",
          properties: { user: { $ref: "#/components/schemas/User" } }
        } } }
      } }
    },
    $Infer: { body: {} }
  }
}, async (ctx) => {
  if (!hasPermission({
    userId: ctx.context.session.user.id,
    role: ctx.context.session.user.role,
    options: opts,
    permissions: { user: ["set-role"] }
  })) throw new APIError$1("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_CHANGE_USERS_ROLE });
  const roles = opts.roles;
  if (roles) {
    const inputRoles = Array.isArray(ctx.body.role) ? ctx.body.role : [ctx.body.role];
    for (const role2 of inputRoles) if (!roles[role2]) throw new APIError$1("BAD_REQUEST", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_SET_NON_EXISTENT_VALUE });
  }
  const updatedUser = await ctx.context.internalAdapter.updateUser(ctx.body.userId, { role: parseRoles(ctx.body.role) });
  return ctx.json({ user: parseUserOutput(ctx.context.options, updatedUser) });
});
const getUserQuerySchema = z.object({ id: z.string().meta({ description: "The id of the User" }) });
const getUser = (opts) => createAuthEndpoint("/admin/get-user", {
  method: "GET",
  query: getUserQuerySchema,
  use: [adminMiddleware],
  metadata: { openapi: {
    operationId: "getUser",
    summary: "Get an existing user",
    description: "Get an existing user",
    responses: { 200: {
      description: "User",
      content: { "application/json": { schema: {
        type: "object",
        properties: { user: { $ref: "#/components/schemas/User" } }
      } } }
    } }
  } }
}, async (ctx) => {
  const { id } = ctx.query;
  if (!hasPermission({
    userId: ctx.context.session.user.id,
    role: ctx.context.session.user.role,
    options: opts,
    permissions: { user: ["get"] }
  })) throw ctx.error("FORBIDDEN", {
    message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_GET_USER,
    code: "YOU_ARE_NOT_ALLOWED_TO_GET_USER"
  });
  const user = await ctx.context.internalAdapter.findUserById(id);
  if (!user) throw new APIError$1("NOT_FOUND", { message: BASE_ERROR_CODES.USER_NOT_FOUND });
  return parseUserOutput(ctx.context.options, user);
});
const createUserBodySchema = z.object({
  email: z.string().meta({ description: "The email of the user" }),
  password: z.string().optional().meta({ description: "The password of the user. If not provided, the user will be created without a credential account (useful for magic link or social login only users)." }),
  name: z.string().meta({ description: "The name of the user" }),
  role: z.union([z.string().meta({ description: "The role of the user" }), z.array(z.string().meta({ description: "The roles of user" }))]).optional().meta({ description: `A string or array of strings representing the roles to apply to the new user. Eg: "user"` }),
  data: z.record(z.string(), z.any()).optional().meta({ description: "Extra fields for the user. Including custom additional fields." })
});
const createUser = (opts) => createAuthEndpoint("/admin/create-user", {
  method: "POST",
  body: createUserBodySchema,
  metadata: {
    openapi: {
      operationId: "createUser",
      summary: "Create a new user",
      description: "Create a new user",
      responses: { 200: {
        description: "User created",
        content: { "application/json": { schema: {
          type: "object",
          properties: { user: { $ref: "#/components/schemas/User" } }
        } } }
      } }
    },
    $Infer: { body: {} }
  }
}, async (ctx) => {
  const session = await getSessionFromCtx(ctx);
  if (!session && (ctx.request || ctx.headers)) throw ctx.error("UNAUTHORIZED");
  if (session) {
    if (!hasPermission({
      userId: session.user.id,
      role: session.user.role,
      options: opts,
      permissions: { user: ["create"] }
    })) throw new APIError$1("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_CREATE_USERS });
  }
  const email = ctx.body.email.toLowerCase();
  if (!z.email().safeParse(email).success) throw new APIError$1("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_EMAIL });
  if (await ctx.context.internalAdapter.findUserByEmail(email)) throw new APIError$1("BAD_REQUEST", { message: ADMIN_ERROR_CODES.USER_ALREADY_EXISTS_USE_ANOTHER_EMAIL });
  const user = await ctx.context.internalAdapter.createUser({
    email,
    name: ctx.body.name,
    role: (ctx.body.role && parseRoles(ctx.body.role)) ?? opts?.defaultRole ?? "user",
    ...ctx.body.data
  });
  if (!user) throw new APIError$1("INTERNAL_SERVER_ERROR", { message: ADMIN_ERROR_CODES.FAILED_TO_CREATE_USER });
  if (ctx.body.password) {
    const hashedPassword = await ctx.context.password.hash(ctx.body.password);
    await ctx.context.internalAdapter.linkAccount({
      accountId: user.id,
      providerId: "credential",
      password: hashedPassword,
      userId: user.id
    });
  }
  return ctx.json({ user: parseUserOutput(ctx.context.options, user) });
});
const adminUpdateUserBodySchema = z.object({
  userId: z.coerce.string().meta({ description: "The user id" }),
  data: z.record(z.any(), z.any()).meta({ description: "The user data to update" })
});
const adminUpdateUser = (opts) => createAuthEndpoint("/admin/update-user", {
  method: "POST",
  body: adminUpdateUserBodySchema,
  use: [adminMiddleware],
  metadata: { openapi: {
    operationId: "updateUser",
    summary: "Update a user",
    description: "Update a user's details",
    responses: { 200: {
      description: "User updated",
      content: { "application/json": { schema: {
        type: "object",
        properties: { user: { $ref: "#/components/schemas/User" } }
      } } }
    } }
  } }
}, async (ctx) => {
  if (!hasPermission({
    userId: ctx.context.session.user.id,
    role: ctx.context.session.user.role,
    options: opts,
    permissions: { user: ["update"] }
  })) throw ctx.error("FORBIDDEN", {
    message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_UPDATE_USERS,
    code: "YOU_ARE_NOT_ALLOWED_TO_UPDATE_USERS"
  });
  if (Object.keys(ctx.body.data).length === 0) throw new APIError$1("BAD_REQUEST", { message: ADMIN_ERROR_CODES.NO_DATA_TO_UPDATE });
  if (Object.prototype.hasOwnProperty.call(ctx.body.data, "role")) {
    if (!hasPermission({
      userId: ctx.context.session.user.id,
      role: ctx.context.session.user.role,
      options: opts,
      permissions: { user: ["set-role"] }
    })) throw new APIError$1("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_CHANGE_USERS_ROLE });
    const roleValue = ctx.body.data.role;
    const inputRoles = Array.isArray(roleValue) ? roleValue : [roleValue];
    for (const role2 of inputRoles) {
      if (typeof role2 !== "string") throw new APIError$1("BAD_REQUEST", { message: ADMIN_ERROR_CODES.INVALID_ROLE_TYPE });
      if (opts.roles && !opts.roles[role2]) throw new APIError$1("BAD_REQUEST", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_SET_NON_EXISTENT_VALUE });
    }
    ctx.body.data.role = parseRoles(inputRoles);
  }
  const updatedUser = await ctx.context.internalAdapter.updateUser(ctx.body.userId, ctx.body.data);
  return ctx.json(parseUserOutput(ctx.context.options, updatedUser));
});
const listUsersQuerySchema = z.object({
  searchValue: z.string().optional().meta({ description: 'The value to search for. Eg: "some name"' }),
  searchField: z.enum(["email", "name"]).meta({ description: 'The field to search in, defaults to email. Can be `email` or `name`. Eg: "name"' }).optional(),
  searchOperator: z.enum([
    "contains",
    "starts_with",
    "ends_with"
  ]).meta({ description: 'The operator to use for the search. Can be `contains`, `starts_with` or `ends_with`. Eg: "contains"' }).optional(),
  limit: z.string().meta({ description: "The number of users to return" }).or(z.number()).optional(),
  offset: z.string().meta({ description: "The offset to start from" }).or(z.number()).optional(),
  sortBy: z.string().meta({ description: "The field to sort by" }).optional(),
  sortDirection: z.enum(["asc", "desc"]).meta({ description: "The direction to sort by" }).optional(),
  filterField: z.string().meta({ description: "The field to filter by" }).optional(),
  filterValue: z.string().meta({ description: "The value to filter by" }).or(z.number()).or(z.boolean()).optional(),
  filterOperator: z.enum([
    "eq",
    "ne",
    "lt",
    "lte",
    "gt",
    "gte",
    "contains"
  ]).meta({ description: "The operator to use for the filter" }).optional()
});
const listUsers = (opts) => createAuthEndpoint("/admin/list-users", {
  method: "GET",
  use: [adminMiddleware],
  query: listUsersQuerySchema,
  metadata: { openapi: {
    operationId: "listUsers",
    summary: "List users",
    description: "List users",
    responses: { 200: {
      description: "List of users",
      content: { "application/json": { schema: {
        type: "object",
        properties: {
          users: {
            type: "array",
            items: { $ref: "#/components/schemas/User" }
          },
          total: { type: "number" },
          limit: { type: "number" },
          offset: { type: "number" }
        },
        required: ["users", "total"]
      } } }
    } }
  } }
}, async (ctx) => {
  const session = ctx.context.session;
  if (!hasPermission({
    userId: ctx.context.session.user.id,
    role: session.user.role,
    options: opts,
    permissions: { user: ["list"] }
  })) throw new APIError$1("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_LIST_USERS });
  const where = [];
  if (ctx.query?.searchValue) where.push({
    field: ctx.query.searchField || "email",
    operator: ctx.query.searchOperator || "contains",
    value: ctx.query.searchValue
  });
  if (ctx.query?.filterValue) where.push({
    field: ctx.query.filterField || "email",
    operator: ctx.query.filterOperator || "eq",
    value: ctx.query.filterValue
  });
  try {
    const users = await ctx.context.internalAdapter.listUsers(Number(ctx.query?.limit) || void 0, Number(ctx.query?.offset) || void 0, ctx.query?.sortBy ? {
      field: ctx.query.sortBy,
      direction: ctx.query.sortDirection || "asc"
    } : void 0, where.length ? where : void 0);
    const total = await ctx.context.internalAdapter.countTotalUsers(where.length ? where : void 0);
    return ctx.json({
      users: users.map((user) => parseUserOutput(ctx.context.options, user)),
      total,
      limit: Number(ctx.query?.limit) || void 0,
      offset: Number(ctx.query?.offset) || void 0
    });
  } catch {
    return ctx.json({
      users: [],
      total: 0
    });
  }
});
const listUserSessionsBodySchema = z.object({ userId: z.coerce.string().meta({ description: "The user id" }) });
const listUserSessions = (opts) => createAuthEndpoint("/admin/list-user-sessions", {
  method: "POST",
  use: [adminMiddleware],
  body: listUserSessionsBodySchema,
  metadata: { openapi: {
    operationId: "listUserSessions",
    summary: "List user sessions",
    description: "List user sessions",
    responses: { 200: {
      description: "List of user sessions",
      content: { "application/json": { schema: {
        type: "object",
        properties: { sessions: {
          type: "array",
          items: { $ref: "#/components/schemas/Session" }
        } }
      } } }
    } }
  } }
}, async (ctx) => {
  const session = ctx.context.session;
  if (!hasPermission({
    userId: ctx.context.session.user.id,
    role: session.user.role,
    options: opts,
    permissions: { session: ["list"] }
  })) throw new APIError$1("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_LIST_USERS_SESSIONS });
  const sessions = await ctx.context.internalAdapter.listSessions(ctx.body.userId);
  return ctx.json({ sessions: sessions.map((s2) => parseSessionOutput(ctx.context.options, s2)) });
});
const unbanUserBodySchema = z.object({ userId: z.coerce.string().meta({ description: "The user id" }) });
const unbanUser = (opts) => createAuthEndpoint("/admin/unban-user", {
  method: "POST",
  body: unbanUserBodySchema,
  use: [adminMiddleware],
  metadata: { openapi: {
    operationId: "unbanUser",
    summary: "Unban a user",
    description: "Unban a user",
    responses: { 200: {
      description: "User unbanned",
      content: { "application/json": { schema: {
        type: "object",
        properties: { user: { $ref: "#/components/schemas/User" } }
      } } }
    } }
  } }
}, async (ctx) => {
  const session = ctx.context.session;
  if (!hasPermission({
    userId: ctx.context.session.user.id,
    role: session.user.role,
    options: opts,
    permissions: { user: ["ban"] }
  })) throw new APIError$1("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_BAN_USERS });
  const user = await ctx.context.internalAdapter.updateUser(ctx.body.userId, {
    banned: false,
    banExpires: null,
    banReason: null,
    updatedAt: /* @__PURE__ */ new Date()
  });
  return ctx.json({ user: parseUserOutput(ctx.context.options, user) });
});
const banUserBodySchema = z.object({
  userId: z.coerce.string().meta({ description: "The user id" }),
  banReason: z.string().meta({ description: "The reason for the ban" }).optional(),
  banExpiresIn: z.number().meta({ description: "The number of seconds until the ban expires" }).optional()
});
const banUser = (opts) => createAuthEndpoint("/admin/ban-user", {
  method: "POST",
  body: banUserBodySchema,
  use: [adminMiddleware],
  metadata: { openapi: {
    operationId: "banUser",
    summary: "Ban a user",
    description: "Ban a user",
    responses: { 200: {
      description: "User banned",
      content: { "application/json": { schema: {
        type: "object",
        properties: { user: { $ref: "#/components/schemas/User" } }
      } } }
    } }
  } }
}, async (ctx) => {
  const session = ctx.context.session;
  if (!hasPermission({
    userId: ctx.context.session.user.id,
    role: session.user.role,
    options: opts,
    permissions: { user: ["ban"] }
  })) throw new APIError$1("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_BAN_USERS });
  if (!await ctx.context.internalAdapter.findUserById(ctx.body.userId)) throw new APIError$1("NOT_FOUND", { message: BASE_ERROR_CODES.USER_NOT_FOUND });
  if (ctx.body.userId === ctx.context.session.user.id) throw new APIError$1("BAD_REQUEST", { message: ADMIN_ERROR_CODES.YOU_CANNOT_BAN_YOURSELF });
  const user = await ctx.context.internalAdapter.updateUser(ctx.body.userId, {
    banned: true,
    banReason: ctx.body.banReason || opts?.defaultBanReason || "No reason",
    banExpires: ctx.body.banExpiresIn ? getDate(ctx.body.banExpiresIn, "sec") : opts?.defaultBanExpiresIn ? getDate(opts.defaultBanExpiresIn, "sec") : void 0,
    updatedAt: /* @__PURE__ */ new Date()
  });
  await ctx.context.internalAdapter.deleteSessions(ctx.body.userId);
  return ctx.json({ user: parseUserOutput(ctx.context.options, user) });
});
const impersonateUserBodySchema = z.object({ userId: z.coerce.string().meta({ description: "The user id" }) });
const impersonateUser = (opts) => createAuthEndpoint("/admin/impersonate-user", {
  method: "POST",
  body: impersonateUserBodySchema,
  use: [adminMiddleware],
  metadata: { openapi: {
    operationId: "impersonateUser",
    summary: "Impersonate a user",
    description: "Impersonate a user",
    responses: { 200: {
      description: "Impersonation session created",
      content: { "application/json": { schema: {
        type: "object",
        properties: {
          session: { $ref: "#/components/schemas/Session" },
          user: { $ref: "#/components/schemas/User" }
        }
      } } }
    } }
  } }
}, async (ctx) => {
  if (!hasPermission({
    userId: ctx.context.session.user.id,
    role: ctx.context.session.user.role,
    options: opts,
    permissions: { user: ["impersonate"] }
  })) throw new APIError$1("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_IMPERSONATE_USERS });
  const targetUser = await ctx.context.internalAdapter.findUserById(ctx.body.userId);
  if (!targetUser) throw new APIError$1("NOT_FOUND", { message: "User not found" });
  const adminRoles = (Array.isArray(opts.adminRoles) ? opts.adminRoles : opts.adminRoles?.split(",") || []).map((role2) => role2.trim());
  const targetUserRole = (targetUser.role || opts.defaultRole || "user").split(",");
  if (opts.allowImpersonatingAdmins !== true && (targetUserRole.some((role2) => adminRoles.includes(role2)) || opts.adminUserIds?.includes(targetUser.id))) throw new APIError$1("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_CANNOT_IMPERSONATE_ADMINS });
  const session = await ctx.context.internalAdapter.createSession(targetUser.id, true, {
    impersonatedBy: ctx.context.session.user.id,
    expiresAt: opts?.impersonationSessionDuration ? getDate(opts.impersonationSessionDuration, "sec") : getDate(3600, "sec")
  }, true);
  if (!session) throw new APIError$1("INTERNAL_SERVER_ERROR", { message: ADMIN_ERROR_CODES.FAILED_TO_CREATE_USER });
  const authCookies = ctx.context.authCookies;
  deleteSessionCookie(ctx);
  const dontRememberMeCookie = await ctx.getSignedCookie(ctx.context.authCookies.dontRememberToken.name, ctx.context.secret);
  const adminCookieProp = ctx.context.createAuthCookie("admin_session");
  await ctx.setSignedCookie(adminCookieProp.name, `${ctx.context.session.session.token}:${dontRememberMeCookie || ""}`, ctx.context.secret, authCookies.sessionToken.attributes);
  await setSessionCookie(ctx, {
    session,
    user: targetUser
  }, true);
  return ctx.json({
    session,
    user: parseUserOutput(ctx.context.options, targetUser)
  });
});
const stopImpersonating = () => createAuthEndpoint("/admin/stop-impersonating", {
  method: "POST",
  requireHeaders: true
}, async (ctx) => {
  const session = await getSessionFromCtx(ctx);
  if (!session) throw new APIError$1("UNAUTHORIZED");
  if (!session.session.impersonatedBy) throw new APIError$1("BAD_REQUEST", { message: "You are not impersonating anyone" });
  const user = await ctx.context.internalAdapter.findUserById(session.session.impersonatedBy);
  if (!user) throw new APIError$1("INTERNAL_SERVER_ERROR", { message: "Failed to find user" });
  const adminSessionCookie = ctx.context.createAuthCookie("admin_session");
  const adminCookie = await ctx.getSignedCookie(adminSessionCookie.name, ctx.context.secret);
  if (!adminCookie) throw new APIError$1("INTERNAL_SERVER_ERROR", { message: "Failed to find admin session" });
  const [adminSessionToken, dontRememberMeCookie] = adminCookie?.split(":");
  const adminSession = await ctx.context.internalAdapter.findSession(adminSessionToken);
  if (!adminSession || adminSession.session.userId !== user.id) throw new APIError$1("INTERNAL_SERVER_ERROR", { message: "Failed to find admin session" });
  await ctx.context.internalAdapter.deleteSession(session.session.token);
  await setSessionCookie(ctx, adminSession, !!dontRememberMeCookie);
  expireCookie(ctx, adminSessionCookie);
  return ctx.json({
    session: parseSessionOutput(ctx.context.options, adminSession.session),
    user: parseUserOutput(ctx.context.options, adminSession.user)
  });
});
const revokeUserSessionBodySchema = z.object({ sessionToken: z.string().meta({ description: "The session token" }) });
const revokeUserSession = (opts) => createAuthEndpoint("/admin/revoke-user-session", {
  method: "POST",
  body: revokeUserSessionBodySchema,
  use: [adminMiddleware],
  metadata: { openapi: {
    operationId: "revokeUserSession",
    summary: "Revoke a user session",
    description: "Revoke a user session",
    responses: { 200: {
      description: "Session revoked",
      content: { "application/json": { schema: {
        type: "object",
        properties: { success: { type: "boolean" } }
      } } }
    } }
  } }
}, async (ctx) => {
  const session = ctx.context.session;
  if (!hasPermission({
    userId: ctx.context.session.user.id,
    role: session.user.role,
    options: opts,
    permissions: { session: ["revoke"] }
  })) throw new APIError$1("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_REVOKE_USERS_SESSIONS });
  await ctx.context.internalAdapter.deleteSession(ctx.body.sessionToken);
  return ctx.json({ success: true });
});
const revokeUserSessionsBodySchema = z.object({ userId: z.coerce.string().meta({ description: "The user id" }) });
const revokeUserSessions = (opts) => createAuthEndpoint("/admin/revoke-user-sessions", {
  method: "POST",
  body: revokeUserSessionsBodySchema,
  use: [adminMiddleware],
  metadata: { openapi: {
    operationId: "revokeUserSessions",
    summary: "Revoke all user sessions",
    description: "Revoke all user sessions",
    responses: { 200: {
      description: "Sessions revoked",
      content: { "application/json": { schema: {
        type: "object",
        properties: { success: { type: "boolean" } }
      } } }
    } }
  } }
}, async (ctx) => {
  const session = ctx.context.session;
  if (!hasPermission({
    userId: ctx.context.session.user.id,
    role: session.user.role,
    options: opts,
    permissions: { session: ["revoke"] }
  })) throw new APIError$1("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_REVOKE_USERS_SESSIONS });
  await ctx.context.internalAdapter.deleteSessions(ctx.body.userId);
  return ctx.json({ success: true });
});
const removeUserBodySchema = z.object({ userId: z.coerce.string().meta({ description: "The user id" }) });
const removeUser = (opts) => createAuthEndpoint("/admin/remove-user", {
  method: "POST",
  body: removeUserBodySchema,
  use: [adminMiddleware],
  metadata: { openapi: {
    operationId: "removeUser",
    summary: "Remove a user",
    description: "Delete a user and all their sessions and accounts. Cannot be undone.",
    responses: { 200: {
      description: "User removed",
      content: { "application/json": { schema: {
        type: "object",
        properties: { success: { type: "boolean" } }
      } } }
    } }
  } }
}, async (ctx) => {
  const session = ctx.context.session;
  if (!hasPermission({
    userId: ctx.context.session.user.id,
    role: session.user.role,
    options: opts,
    permissions: { user: ["delete"] }
  })) throw new APIError$1("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_DELETE_USERS });
  if (ctx.body.userId === ctx.context.session.user.id) throw new APIError$1("BAD_REQUEST", { message: ADMIN_ERROR_CODES.YOU_CANNOT_REMOVE_YOURSELF });
  if (!await ctx.context.internalAdapter.findUserById(ctx.body.userId)) throw new APIError$1("NOT_FOUND", { message: "User not found" });
  await ctx.context.internalAdapter.deleteUser(ctx.body.userId);
  return ctx.json({ success: true });
});
const setUserPasswordBodySchema = z.object({
  newPassword: z.string().nonempty("newPassword cannot be empty").meta({ description: "The new password" }),
  userId: z.coerce.string().nonempty("userId cannot be empty").meta({ description: "The user id" })
});
const setUserPassword = (opts) => createAuthEndpoint("/admin/set-user-password", {
  method: "POST",
  body: setUserPasswordBodySchema,
  use: [adminMiddleware],
  metadata: { openapi: {
    operationId: "setUserPassword",
    summary: "Set a user's password",
    description: "Set a user's password",
    responses: { 200: {
      description: "Password set",
      content: { "application/json": { schema: {
        type: "object",
        properties: { status: { type: "boolean" } }
      } } }
    } }
  } }
}, async (ctx) => {
  if (!hasPermission({
    userId: ctx.context.session.user.id,
    role: ctx.context.session.user.role,
    options: opts,
    permissions: { user: ["set-password"] }
  })) throw new APIError$1("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_SET_USERS_PASSWORD });
  const { newPassword, userId } = ctx.body;
  const minPasswordLength = ctx.context.password.config.minPasswordLength;
  if (newPassword.length < minPasswordLength) {
    ctx.context.logger.error("Password is too short");
    throw new APIError$1("BAD_REQUEST", { message: BASE_ERROR_CODES.PASSWORD_TOO_SHORT });
  }
  const maxPasswordLength = ctx.context.password.config.maxPasswordLength;
  if (newPassword.length > maxPasswordLength) {
    ctx.context.logger.error("Password is too long");
    throw new APIError$1("BAD_REQUEST", { message: BASE_ERROR_CODES.PASSWORD_TOO_LONG });
  }
  const hashedPassword = await ctx.context.password.hash(newPassword);
  await ctx.context.internalAdapter.updatePassword(userId, hashedPassword);
  return ctx.json({ status: true });
});
const userHasPermissionBodySchema = z.object({
  userId: z.coerce.string().optional().meta({ description: `The user id. Eg: "user-id"` }),
  role: z.string().optional().meta({ description: `The role to check permission for. Eg: "admin"` })
}).and(z.union([z.object({
  permission: z.record(z.string(), z.array(z.string())),
  permissions: z.undefined()
}), z.object({
  permission: z.undefined(),
  permissions: z.record(z.string(), z.array(z.string()))
})]));
const userHasPermission = (opts) => {
  return createAuthEndpoint("/admin/has-permission", {
    method: "POST",
    body: userHasPermissionBodySchema,
    metadata: {
      openapi: {
        description: "Check if the user has permission",
        requestBody: { content: { "application/json": { schema: {
          type: "object",
          properties: {
            permission: {
              type: "object",
              description: "The permission to check",
              deprecated: true
            },
            permissions: {
              type: "object",
              description: "The permission to check"
            }
          },
          required: ["permissions"]
        } } } },
        responses: { "200": {
          description: "Success",
          content: { "application/json": { schema: {
            type: "object",
            properties: {
              error: { type: "string" },
              success: { type: "boolean" }
            },
            required: ["success"]
          } } }
        } }
      },
      $Infer: { body: {} }
    }
  }, async (ctx) => {
    if (!ctx.body?.permission && !ctx.body?.permissions) throw new APIError$1("BAD_REQUEST", { message: "invalid permission check. no permission(s) were passed." });
    const session = await getSessionFromCtx(ctx);
    if (!session && (ctx.request || ctx.headers)) throw new APIError$1("UNAUTHORIZED");
    if (!session && !ctx.body.userId && !ctx.body.role) throw new APIError$1("BAD_REQUEST", { message: "user id or role is required" });
    const user = session?.user || (ctx.body.role ? {
      id: ctx.body.userId || "",
      role: ctx.body.role
    } : null) || (ctx.body.userId ? await ctx.context.internalAdapter.findUserById(ctx.body.userId) : null);
    if (!user) throw new APIError$1("BAD_REQUEST", { message: "user not found" });
    const result2 = hasPermission({
      userId: user.id,
      role: user.role,
      options: opts,
      permissions: ctx.body.permissions ?? ctx.body.permission
    });
    return ctx.json({
      error: null,
      success: result2
    });
  });
};
const schema = {
  user: { fields: {
    role: {
      type: "string",
      required: false,
      input: false
    },
    banned: {
      type: "boolean",
      defaultValue: false,
      required: false,
      input: false
    },
    banReason: {
      type: "string",
      required: false,
      input: false
    },
    banExpires: {
      type: "date",
      required: false,
      input: false
    }
  } },
  session: { fields: { impersonatedBy: {
    type: "string",
    required: false
  } } }
};
const admin = (options) => {
  const opts = {
    ...{},
    defaultRole: "user",
    adminRoles: ["admin"],
    bannedUserMessage: "You have been banned from this application. Please contact support if you believe this is an error."
  };
  return {
    id: "admin",
    init() {
      return { options: { databaseHooks: {
        user: { create: { async before(user) {
          return { data: {
            role: "user",
            ...user
          } };
        } } },
        session: { create: { async before(session, ctx) {
          if (!ctx) return;
          const user = await ctx.context.internalAdapter.findUserById(session.userId);
          if (user.banned) {
            if (user.banExpires && new Date(user.banExpires).getTime() < Date.now()) {
              await ctx.context.internalAdapter.updateUser(session.userId, {
                banned: false,
                banReason: null,
                banExpires: null
              });
              return;
            }
            if (ctx && (ctx.path.startsWith("/callback") || ctx.path.startsWith("/oauth2/callback"))) {
              const redirectURI = ctx.context.options.onAPIError?.errorURL || `${ctx.context.baseURL}/error`;
              throw ctx.redirect(`${redirectURI}?error=banned&error_description=${opts.bannedUserMessage}`);
            }
            throw new APIError$1("FORBIDDEN", {
              message: opts.bannedUserMessage,
              code: "BANNED_USER"
            });
          }
        } } }
      } } };
    },
    hooks: { after: [{
      matcher(context) {
        return context.path === "/list-sessions";
      },
      handler: createAuthMiddleware(async (ctx) => {
        const response = await getEndpointResponse(ctx);
        if (!response) return;
        const newJson = response.filter((session) => {
          return !session.impersonatedBy;
        });
        return ctx.json(newJson);
      })
    }] },
    endpoints: {
      setRole: setRole(opts),
      getUser: getUser(opts),
      createUser: createUser(opts),
      adminUpdateUser: adminUpdateUser(opts),
      listUsers: listUsers(opts),
      listUserSessions: listUserSessions(opts),
      unbanUser: unbanUser(opts),
      banUser: banUser(opts),
      impersonateUser: impersonateUser(opts),
      stopImpersonating: stopImpersonating(),
      revokeUserSession: revokeUserSession(opts),
      revokeUserSessions: revokeUserSessions(opts),
      removeUser: removeUser(opts),
      setUserPassword: setUserPassword(opts),
      userHasPermission: userHasPermission(opts)
    },
    $ERROR_CODES: ADMIN_ERROR_CODES,
    schema: mergeSchema(schema, opts.schema),
    options
  };
};
function parseDoubleStringifiedMetadata(metadata) {
  if (metadata == null) return null;
  if (typeof metadata === "object") return metadata;
  return safeJSONParse(metadata);
}
function needsMetadataMigration(metadata) {
  return metadata != null && typeof metadata === "string";
}
async function batchMigrateLegacyMetadata(ctx, apiKeys, opts) {
  if (opts.storage !== "database" && !opts.fallbackToDatabase) return;
  const keysToMigrate = apiKeys.filter((key) => needsMetadataMigration(key.metadata));
  if (keysToMigrate.length === 0) return;
  const migrationPromises = keysToMigrate.map(async (apiKey2) => {
    const parsed = parseDoubleStringifiedMetadata(apiKey2.metadata);
    try {
      await ctx.context.adapter.update({
        model: "apikey",
        where: [{
          field: "id",
          value: apiKey2.id
        }],
        update: { metadata: parsed }
      });
    } catch (error2) {
      ctx.context.logger.warn(`Failed to migrate double-stringified metadata for API key ${apiKey2.id}:`, error2);
    }
  });
  await Promise.all(migrationPromises);
}
async function migrateDoubleStringifiedMetadata(ctx, apiKey2, opts) {
  const parsed = parseDoubleStringifiedMetadata(apiKey2.metadata);
  if (needsMetadataMigration(apiKey2.metadata) && (opts.storage === "database" || opts.fallbackToDatabase)) try {
    await ctx.context.adapter.update({
      model: "apikey",
      where: [{
        field: "id",
        value: apiKey2.id
      }],
      update: { metadata: parsed }
    });
  } catch (error2) {
    ctx.context.logger.warn(`Failed to migrate double-stringified metadata for API key ${apiKey2.id}:`, error2);
  }
  return parsed;
}
function getStorageKeyByHashedKey(hashedKey) {
  return `api-key:${hashedKey}`;
}
function getStorageKeyById(id) {
  return `api-key:by-id:${id}`;
}
function getStorageKeyByUserId(userId) {
  return `api-key:by-user:${userId}`;
}
function serializeApiKey(apiKey2) {
  return JSON.stringify({
    ...apiKey2,
    createdAt: apiKey2.createdAt.toISOString(),
    updatedAt: apiKey2.updatedAt.toISOString(),
    expiresAt: apiKey2.expiresAt?.toISOString() ?? null,
    lastRefillAt: apiKey2.lastRefillAt?.toISOString() ?? null,
    lastRequest: apiKey2.lastRequest?.toISOString() ?? null
  });
}
function deserializeApiKey(data) {
  if (!data || typeof data !== "string") return null;
  try {
    const parsed = JSON.parse(data);
    return {
      ...parsed,
      createdAt: new Date(parsed.createdAt),
      updatedAt: new Date(parsed.updatedAt),
      expiresAt: parsed.expiresAt ? new Date(parsed.expiresAt) : null,
      lastRefillAt: parsed.lastRefillAt ? new Date(parsed.lastRefillAt) : null,
      lastRequest: parsed.lastRequest ? new Date(parsed.lastRequest) : null
    };
  } catch {
    return null;
  }
}
function getStorageInstance(ctx, opts) {
  if (opts.customStorage) return opts.customStorage;
  return ctx.context.secondaryStorage || null;
}
function calculateTTL(apiKey2) {
  if (apiKey2.expiresAt) {
    const now2 = Date.now();
    const expiresAt = new Date(apiKey2.expiresAt).getTime();
    const ttlSeconds = Math.floor((expiresAt - now2) / 1e3);
    if (ttlSeconds > 0) return ttlSeconds;
  }
}
async function getApiKeyFromStorage(ctx, hashedKey, storage) {
  const key = getStorageKeyByHashedKey(hashedKey);
  return deserializeApiKey(await storage.get(key));
}
async function getApiKeyByIdFromStorage(ctx, id, storage) {
  const key = getStorageKeyById(id);
  return deserializeApiKey(await storage.get(key));
}
async function setApiKeyInStorage(ctx, apiKey2, storage, ttl) {
  const serialized = serializeApiKey(apiKey2);
  const hashedKey = apiKey2.key;
  const id = apiKey2.id;
  await storage.set(getStorageKeyByHashedKey(hashedKey), serialized, ttl);
  await storage.set(getStorageKeyById(id), serialized, ttl);
  const userKey = getStorageKeyByUserId(apiKey2.userId);
  const userListData = await storage.get(userKey);
  let userIds = [];
  if (userListData && typeof userListData === "string") try {
    userIds = JSON.parse(userListData);
  } catch {
    userIds = [];
  }
  else if (Array.isArray(userListData)) userIds = userListData;
  if (!userIds.includes(id)) {
    userIds.push(id);
    await storage.set(userKey, JSON.stringify(userIds));
  }
}
async function deleteApiKeyFromStorage(ctx, apiKey2, storage) {
  const hashedKey = apiKey2.key;
  const id = apiKey2.id;
  const userId = apiKey2.userId;
  await storage.delete(getStorageKeyByHashedKey(hashedKey));
  await storage.delete(getStorageKeyById(id));
  const userKey = getStorageKeyByUserId(userId);
  const userListData = await storage.get(userKey);
  let userIds = [];
  if (userListData && typeof userListData === "string") try {
    userIds = JSON.parse(userListData);
  } catch {
    userIds = [];
  }
  else if (Array.isArray(userListData)) userIds = userListData;
  const filteredIds = userIds.filter((keyId) => keyId !== id);
  if (filteredIds.length === 0) await storage.delete(userKey);
  else await storage.set(userKey, JSON.stringify(filteredIds));
}
async function getApiKey$1(ctx, hashedKey, opts) {
  const storage = getStorageInstance(ctx, opts);
  if (opts.storage === "database") return await ctx.context.adapter.findOne({
    model: "apikey",
    where: [{
      field: "key",
      value: hashedKey
    }]
  });
  if (opts.storage === "secondary-storage" && opts.fallbackToDatabase) {
    if (storage) {
      const cached = await getApiKeyFromStorage(ctx, hashedKey, storage);
      if (cached) return cached;
    }
    const dbKey = await ctx.context.adapter.findOne({
      model: "apikey",
      where: [{
        field: "key",
        value: hashedKey
      }]
    });
    if (dbKey && storage) await setApiKeyInStorage(ctx, dbKey, storage, calculateTTL(dbKey));
    return dbKey;
  }
  if (opts.storage === "secondary-storage") {
    if (!storage) return null;
    return await getApiKeyFromStorage(ctx, hashedKey, storage);
  }
  return await ctx.context.adapter.findOne({
    model: "apikey",
    where: [{
      field: "key",
      value: hashedKey
    }]
  });
}
async function getApiKeyById(ctx, id, opts) {
  const storage = getStorageInstance(ctx, opts);
  if (opts.storage === "database") return await ctx.context.adapter.findOne({
    model: "apikey",
    where: [{
      field: "id",
      value: id
    }]
  });
  if (opts.storage === "secondary-storage" && opts.fallbackToDatabase) {
    if (storage) {
      const cached = await getApiKeyByIdFromStorage(ctx, id, storage);
      if (cached) return cached;
    }
    const dbKey = await ctx.context.adapter.findOne({
      model: "apikey",
      where: [{
        field: "id",
        value: id
      }]
    });
    if (dbKey && storage) await setApiKeyInStorage(ctx, dbKey, storage, calculateTTL(dbKey));
    return dbKey;
  }
  if (opts.storage === "secondary-storage") {
    if (!storage) return null;
    return await getApiKeyByIdFromStorage(ctx, id, storage);
  }
  return await ctx.context.adapter.findOne({
    model: "apikey",
    where: [{
      field: "id",
      value: id
    }]
  });
}
async function setApiKey(ctx, apiKey2, opts) {
  const storage = getStorageInstance(ctx, opts);
  const ttl = calculateTTL(apiKey2);
  if (opts.storage === "database") return;
  if (opts.storage === "secondary-storage") {
    if (!storage) throw new Error("Secondary storage is required when storage mode is 'secondary-storage'");
    await setApiKeyInStorage(ctx, apiKey2, storage, ttl);
    return;
  }
}
async function deleteApiKey(ctx, apiKey2, opts) {
  const storage = getStorageInstance(ctx, opts);
  if (opts.storage === "database") return;
  if (opts.storage === "secondary-storage") {
    if (!storage) throw new Error("Secondary storage is required when storage mode is 'secondary-storage'");
    await deleteApiKeyFromStorage(ctx, apiKey2, storage);
    return;
  }
}
async function listApiKeys(ctx, userId, opts) {
  const storage = getStorageInstance(ctx, opts);
  if (opts.storage === "database") return await ctx.context.adapter.findMany({
    model: "apikey",
    where: [{
      field: "userId",
      value: userId
    }]
  });
  if (opts.storage === "secondary-storage" && opts.fallbackToDatabase) {
    const userKey = getStorageKeyByUserId(userId);
    if (storage) {
      const userListData = await storage.get(userKey);
      let userIds = [];
      if (userListData && typeof userListData === "string") try {
        userIds = JSON.parse(userListData);
      } catch {
        userIds = [];
      }
      else if (Array.isArray(userListData)) userIds = userListData;
      if (userIds.length > 0) {
        const apiKeys = [];
        for (const id of userIds) {
          const apiKey2 = await getApiKeyByIdFromStorage(ctx, id, storage);
          if (apiKey2) apiKeys.push(apiKey2);
        }
        return apiKeys;
      }
    }
    const dbKeys = await ctx.context.adapter.findMany({
      model: "apikey",
      where: [{
        field: "userId",
        value: userId
      }]
    });
    if (storage && dbKeys.length > 0) {
      const userIds = [];
      for (const apiKey2 of dbKeys) {
        await setApiKeyInStorage(ctx, apiKey2, storage, calculateTTL(apiKey2));
        userIds.push(apiKey2.id);
      }
      await storage.set(userKey, JSON.stringify(userIds));
    }
    return dbKeys;
  }
  if (opts.storage === "secondary-storage") {
    if (!storage) return [];
    const userKey = getStorageKeyByUserId(userId);
    const userListData = await storage.get(userKey);
    let userIds = [];
    if (userListData && typeof userListData === "string") try {
      userIds = JSON.parse(userListData);
    } catch {
      return [];
    }
    else if (Array.isArray(userListData)) userIds = userListData;
    else return [];
    const apiKeys = [];
    for (const id of userIds) {
      const apiKey2 = await getApiKeyByIdFromStorage(ctx, id, storage);
      if (apiKey2) apiKeys.push(apiKey2);
    }
    return apiKeys;
  }
  return await ctx.context.adapter.findMany({
    model: "apikey",
    where: [{
      field: "userId",
      value: userId
    }]
  });
}
function isRateLimited(apiKey2, opts) {
  const now2 = /* @__PURE__ */ new Date();
  const lastRequest = apiKey2.lastRequest;
  const rateLimitTimeWindow = apiKey2.rateLimitTimeWindow;
  const rateLimitMax = apiKey2.rateLimitMax;
  let requestCount = apiKey2.requestCount;
  if (opts.rateLimit.enabled === false) return {
    success: true,
    message: null,
    update: { lastRequest: now2 },
    tryAgainIn: null
  };
  if (apiKey2.rateLimitEnabled === false) return {
    success: true,
    message: null,
    update: { lastRequest: now2 },
    tryAgainIn: null
  };
  if (rateLimitTimeWindow === null || rateLimitMax === null) return {
    success: true,
    message: null,
    update: null,
    tryAgainIn: null
  };
  if (lastRequest === null) return {
    success: true,
    message: null,
    update: {
      lastRequest: now2,
      requestCount: 1
    },
    tryAgainIn: null
  };
  const timeSinceLastRequest = now2.getTime() - new Date(lastRequest).getTime();
  if (timeSinceLastRequest > rateLimitTimeWindow) return {
    success: true,
    message: null,
    update: {
      lastRequest: now2,
      requestCount: 1
    },
    tryAgainIn: null
  };
  if (requestCount >= rateLimitMax) return {
    success: false,
    message: ERROR_CODES.RATE_LIMIT_EXCEEDED,
    update: null,
    tryAgainIn: Math.ceil(rateLimitTimeWindow - timeSinceLastRequest)
  };
  requestCount++;
  return {
    success: true,
    message: null,
    tryAgainIn: null,
    update: {
      lastRequest: now2,
      requestCount
    }
  };
}
async function validateApiKey({ hashedKey, ctx, opts, schema: schema2, permissions }) {
  const apiKey2 = await getApiKey$1(ctx, hashedKey, opts);
  if (!apiKey2) throw new APIError$1("UNAUTHORIZED", { message: ERROR_CODES.INVALID_API_KEY });
  if (apiKey2.enabled === false) throw new APIError$1("UNAUTHORIZED", {
    message: ERROR_CODES.KEY_DISABLED,
    code: "KEY_DISABLED"
  });
  if (apiKey2.expiresAt) {
    if (Date.now() > new Date(apiKey2.expiresAt).getTime()) {
      const deleteExpiredKey = async () => {
        if (opts.storage === "secondary-storage" && opts.fallbackToDatabase) {
          await deleteApiKey(ctx, apiKey2, opts);
          await ctx.context.adapter.delete({
            model: API_KEY_TABLE_NAME,
            where: [{
              field: "id",
              value: apiKey2.id
            }]
          });
        } else if (opts.storage === "secondary-storage") await deleteApiKey(ctx, apiKey2, opts);
        else await ctx.context.adapter.delete({
          model: API_KEY_TABLE_NAME,
          where: [{
            field: "id",
            value: apiKey2.id
          }]
        });
      };
      if (opts.deferUpdates) ctx.context.runInBackground(deleteExpiredKey().catch((error2) => {
        ctx.context.logger.error("Deferred update failed:", error2);
      }));
      else await deleteExpiredKey();
      throw new APIError$1("UNAUTHORIZED", {
        message: ERROR_CODES.KEY_EXPIRED,
        code: "KEY_EXPIRED"
      });
    }
  }
  if (permissions) {
    const apiKeyPermissions = apiKey2.permissions ? safeJSONParse(apiKey2.permissions) : null;
    if (!apiKeyPermissions) throw new APIError$1("UNAUTHORIZED", {
      message: ERROR_CODES.KEY_NOT_FOUND,
      code: "KEY_NOT_FOUND"
    });
    if (!role(apiKeyPermissions).authorize(permissions).success) throw new APIError$1("UNAUTHORIZED", {
      message: ERROR_CODES.KEY_NOT_FOUND,
      code: "KEY_NOT_FOUND"
    });
  }
  let remaining = apiKey2.remaining;
  let lastRefillAt = apiKey2.lastRefillAt;
  if (apiKey2.remaining === 0 && apiKey2.refillAmount === null) {
    const deleteExhaustedKey = async () => {
      if (opts.storage === "secondary-storage" && opts.fallbackToDatabase) {
        await deleteApiKey(ctx, apiKey2, opts);
        await ctx.context.adapter.delete({
          model: API_KEY_TABLE_NAME,
          where: [{
            field: "id",
            value: apiKey2.id
          }]
        });
      } else if (opts.storage === "secondary-storage") await deleteApiKey(ctx, apiKey2, opts);
      else await ctx.context.adapter.delete({
        model: API_KEY_TABLE_NAME,
        where: [{
          field: "id",
          value: apiKey2.id
        }]
      });
    };
    if (opts.deferUpdates) ctx.context.runInBackground(deleteExhaustedKey().catch((error2) => {
      ctx.context.logger.error("Deferred update failed:", error2);
    }));
    else await deleteExhaustedKey();
    throw new APIError$1("TOO_MANY_REQUESTS", {
      message: ERROR_CODES.USAGE_EXCEEDED,
      code: "USAGE_EXCEEDED"
    });
  } else if (remaining !== null) {
    const now2 = Date.now();
    const refillInterval = apiKey2.refillInterval;
    const refillAmount = apiKey2.refillAmount;
    const lastTime = new Date(lastRefillAt ?? apiKey2.createdAt).getTime();
    if (refillInterval && refillAmount) {
      if (now2 - lastTime > refillInterval) {
        remaining = refillAmount;
        lastRefillAt = /* @__PURE__ */ new Date();
      }
    }
    if (remaining === 0) throw new APIError$1("TOO_MANY_REQUESTS", {
      message: ERROR_CODES.USAGE_EXCEEDED,
      code: "USAGE_EXCEEDED"
    });
    else remaining--;
  }
  const { message: message2, success, update, tryAgainIn } = isRateLimited(apiKey2, opts);
  if (success === false) throw new APIError$1("UNAUTHORIZED", {
    message: message2 ?? void 0,
    code: "RATE_LIMITED",
    details: { tryAgainIn }
  });
  const updated = {
    ...apiKey2,
    ...update,
    remaining,
    lastRefillAt,
    updatedAt: /* @__PURE__ */ new Date()
  };
  const performUpdate = async () => {
    if (opts.storage === "database") return ctx.context.adapter.update({
      model: API_KEY_TABLE_NAME,
      where: [{
        field: "id",
        value: apiKey2.id
      }],
      update: {
        ...updated,
        id: void 0
      }
    });
    else if (opts.storage === "secondary-storage" && opts.fallbackToDatabase) {
      const dbUpdated = await ctx.context.adapter.update({
        model: API_KEY_TABLE_NAME,
        where: [{
          field: "id",
          value: apiKey2.id
        }],
        update: {
          ...updated,
          id: void 0
        }
      });
      if (dbUpdated) await setApiKey(ctx, dbUpdated, opts);
      return dbUpdated;
    } else {
      await setApiKey(ctx, updated, opts);
      return updated;
    }
  };
  let newApiKey = null;
  if (opts.deferUpdates) {
    ctx.context.runInBackground(performUpdate().catch((error2) => {
      ctx.context.logger.error("Failed to update API key:", error2);
    }));
    newApiKey = updated;
  } else {
    newApiKey = await performUpdate();
    if (!newApiKey) throw new APIError$1("INTERNAL_SERVER_ERROR", {
      message: ERROR_CODES.FAILED_TO_UPDATE_API_KEY,
      code: "INTERNAL_SERVER_ERROR"
    });
  }
  return newApiKey;
}
const verifyApiKeyBodySchema = z.object({
  key: z.string().meta({ description: "The key to verify" }),
  permissions: z.record(z.string(), z.array(z.string())).meta({ description: "The permissions to verify." }).optional()
});
function verifyApiKey({ opts, schema: schema2, deleteAllExpiredApiKeys: deleteAllExpiredApiKeys2 }) {
  return createAuthEndpoint({
    method: "POST",
    body: verifyApiKeyBodySchema
  }, async (ctx) => {
    const { key } = ctx.body;
    if (opts.customAPIKeyValidator) {
      if (!await opts.customAPIKeyValidator({
        ctx,
        key
      })) return ctx.json({
        valid: false,
        error: {
          message: ERROR_CODES.INVALID_API_KEY,
          code: "KEY_NOT_FOUND"
        },
        key: null
      });
    }
    const hashed = opts.disableKeyHashing ? key : await defaultKeyHasher(key);
    let apiKey2 = null;
    try {
      apiKey2 = await validateApiKey({
        hashedKey: hashed,
        permissions: ctx.body.permissions,
        ctx,
        opts,
        schema: schema2
      });
      if (opts.deferUpdates) ctx.context.runInBackground(deleteAllExpiredApiKeys2(ctx.context).catch((err2) => {
        ctx.context.logger.error("Failed to delete expired API keys:", err2);
      }));
    } catch (error2) {
      ctx.context.logger.error("Failed to validate API key:", error2);
      if (error2 instanceof APIError$1) return ctx.json({
        valid: false,
        error: {
          message: error2.body?.message,
          code: error2.body?.code
        },
        key: null
      });
      return ctx.json({
        valid: false,
        error: {
          message: ERROR_CODES.INVALID_API_KEY,
          code: "INVALID_API_KEY"
        },
        key: null
      });
    }
    const { key: _, ...returningApiKey } = apiKey2 ?? {
      key: 1,
      permissions: void 0
    };
    let migratedMetadata = null;
    if (apiKey2) migratedMetadata = await migrateDoubleStringifiedMetadata(ctx, apiKey2, opts);
    returningApiKey.permissions = returningApiKey.permissions ? safeJSONParse(returningApiKey.permissions) : null;
    return ctx.json({
      valid: true,
      error: null,
      key: apiKey2 === null ? null : {
        ...returningApiKey,
        metadata: migratedMetadata
      }
    });
  });
}
const createApiKeyBodySchema = z.object({
  name: z.string().meta({ description: "Name of the Api Key" }).optional(),
  expiresIn: z.number().meta({ description: "Expiration time of the Api Key in seconds" }).min(1).optional().nullable().default(null),
  userId: z.coerce.string().meta({ description: 'User Id of the user that the Api Key belongs to. server-only. Eg: "user-id"' }).optional(),
  prefix: z.string().meta({ description: "Prefix of the Api Key" }).regex(/^[a-zA-Z0-9_-]+$/, { message: "Invalid prefix format, must be alphanumeric and contain only underscores and hyphens." }).optional(),
  remaining: z.number().meta({ description: "Remaining number of requests. Server side only" }).min(0).optional().nullable().default(null),
  metadata: z.any().optional(),
  refillAmount: z.number().meta({ description: "Amount to refill the remaining count of the Api Key. server-only. Eg: 100" }).min(1).optional(),
  refillInterval: z.number().meta({ description: "Interval to refill the Api Key in milliseconds. server-only. Eg: 1000" }).optional(),
  rateLimitTimeWindow: z.number().meta({ description: "The duration in milliseconds where each request is counted. Once the `maxRequests` is reached, the request will be rejected until the `timeWindow` has passed, at which point the `timeWindow` will be reset. server-only. Eg: 1000" }).optional(),
  rateLimitMax: z.number().meta({ description: "Maximum amount of requests allowed within a window. Once the `maxRequests` is reached, the request will be rejected until the `timeWindow` has passed, at which point the `timeWindow` will be reset. server-only. Eg: 100" }).optional(),
  rateLimitEnabled: z.boolean().meta({ description: "Whether the key has rate limiting enabled. server-only. Eg: true" }).optional(),
  permissions: z.record(z.string(), z.array(z.string())).meta({ description: "Permissions of the Api Key." }).optional()
});
function createApiKey({ keyGenerator, opts, schema: schema2, deleteAllExpiredApiKeys: deleteAllExpiredApiKeys2 }) {
  return createAuthEndpoint("/api-key/create", {
    method: "POST",
    body: createApiKeyBodySchema,
    metadata: { openapi: {
      description: "Create a new API key for a user",
      responses: { "200": {
        description: "API key created successfully",
        content: { "application/json": { schema: {
          type: "object",
          properties: {
            id: {
              type: "string",
              description: "Unique identifier of the API key"
            },
            createdAt: {
              type: "string",
              format: "date-time",
              description: "Creation timestamp"
            },
            updatedAt: {
              type: "string",
              format: "date-time",
              description: "Last update timestamp"
            },
            name: {
              type: "string",
              nullable: true,
              description: "Name of the API key"
            },
            prefix: {
              type: "string",
              nullable: true,
              description: "Prefix of the API key"
            },
            start: {
              type: "string",
              nullable: true,
              description: "Starting characters of the key (if configured)"
            },
            key: {
              type: "string",
              description: "The full API key (only returned on creation)"
            },
            enabled: {
              type: "boolean",
              description: "Whether the key is enabled"
            },
            expiresAt: {
              type: "string",
              format: "date-time",
              nullable: true,
              description: "Expiration timestamp"
            },
            userId: {
              type: "string",
              description: "ID of the user owning the key"
            },
            lastRefillAt: {
              type: "string",
              format: "date-time",
              nullable: true,
              description: "Last refill timestamp"
            },
            lastRequest: {
              type: "string",
              format: "date-time",
              nullable: true,
              description: "Last request timestamp"
            },
            metadata: {
              type: "object",
              nullable: true,
              additionalProperties: true,
              description: "Metadata associated with the key"
            },
            rateLimitMax: {
              type: "number",
              nullable: true,
              description: "Maximum requests in time window"
            },
            rateLimitTimeWindow: {
              type: "number",
              nullable: true,
              description: "Rate limit time window in milliseconds"
            },
            remaining: {
              type: "number",
              nullable: true,
              description: "Remaining requests"
            },
            refillAmount: {
              type: "number",
              nullable: true,
              description: "Amount to refill"
            },
            refillInterval: {
              type: "number",
              nullable: true,
              description: "Refill interval in milliseconds"
            },
            rateLimitEnabled: {
              type: "boolean",
              description: "Whether rate limiting is enabled"
            },
            requestCount: {
              type: "number",
              description: "Current request count in window"
            },
            permissions: {
              type: "object",
              nullable: true,
              additionalProperties: {
                type: "array",
                items: { type: "string" }
              },
              description: "Permissions associated with the key"
            }
          },
          required: [
            "id",
            "createdAt",
            "updatedAt",
            "key",
            "enabled",
            "userId",
            "rateLimitEnabled",
            "requestCount"
          ]
        } } }
      } }
    } }
  }, async (ctx) => {
    const { name: name2, expiresIn, prefix, remaining, metadata, refillAmount, refillInterval, permissions, rateLimitMax, rateLimitTimeWindow, rateLimitEnabled } = ctx.body;
    const session = await getSessionFromCtx(ctx);
    const authRequired = ctx.request || ctx.headers;
    const user = authRequired && !session ? null : session?.user || { id: ctx.body.userId };
    if (!user?.id) throw new APIError$1("UNAUTHORIZED", { message: ERROR_CODES.UNAUTHORIZED_SESSION });
    if (session && ctx.body.userId && session?.user.id !== ctx.body.userId) throw new APIError$1("UNAUTHORIZED", { message: ERROR_CODES.UNAUTHORIZED_SESSION });
    if (authRequired) {
      if (refillAmount !== void 0 || refillInterval !== void 0 || rateLimitMax !== void 0 || rateLimitTimeWindow !== void 0 || rateLimitEnabled !== void 0 || permissions !== void 0 || remaining !== null) throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.SERVER_ONLY_PROPERTY });
    }
    if (metadata) {
      if (opts.enableMetadata === false) throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.METADATA_DISABLED });
      if (typeof metadata !== "object") throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.INVALID_METADATA_TYPE });
    }
    if (refillAmount && !refillInterval) throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.REFILL_AMOUNT_AND_INTERVAL_REQUIRED });
    if (refillInterval && !refillAmount) throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.REFILL_INTERVAL_AND_AMOUNT_REQUIRED });
    if (expiresIn) {
      if (opts.keyExpiration.disableCustomExpiresTime === true) throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.KEY_DISABLED_EXPIRATION });
      const expiresIn_in_days = expiresIn / (3600 * 24);
      if (opts.keyExpiration.minExpiresIn > expiresIn_in_days) throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.EXPIRES_IN_IS_TOO_SMALL });
      else if (opts.keyExpiration.maxExpiresIn < expiresIn_in_days) throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.EXPIRES_IN_IS_TOO_LARGE });
    }
    if (prefix) {
      if (prefix.length < opts.minimumPrefixLength) throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.INVALID_PREFIX_LENGTH });
      if (prefix.length > opts.maximumPrefixLength) throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.INVALID_PREFIX_LENGTH });
    }
    if (name2) {
      if (name2.length < opts.minimumNameLength) throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.INVALID_NAME_LENGTH });
      if (name2.length > opts.maximumNameLength) throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.INVALID_NAME_LENGTH });
    } else if (opts.requireName) throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.NAME_REQUIRED });
    deleteAllExpiredApiKeys2(ctx.context);
    const key = await keyGenerator({
      length: opts.defaultKeyLength,
      prefix: prefix || opts.defaultPrefix
    });
    const hashed = opts.disableKeyHashing ? key : await defaultKeyHasher(key);
    let start = null;
    if (opts.startingCharactersConfig.shouldStore) start = key.substring(0, opts.startingCharactersConfig.charactersLength);
    const defaultPermissions = opts.permissions?.defaultPermissions ? typeof opts.permissions.defaultPermissions === "function" ? await opts.permissions.defaultPermissions(user.id, ctx) : opts.permissions.defaultPermissions : void 0;
    const permissionsToApply = permissions ? JSON.stringify(permissions) : defaultPermissions ? JSON.stringify(defaultPermissions) : void 0;
    const data = {
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date(),
      name: name2 ?? null,
      prefix: prefix ?? opts.defaultPrefix ?? null,
      start,
      key: hashed,
      enabled: true,
      expiresAt: expiresIn ? getDate(expiresIn, "sec") : opts.keyExpiration.defaultExpiresIn ? getDate(opts.keyExpiration.defaultExpiresIn, "sec") : null,
      userId: user.id,
      lastRefillAt: null,
      lastRequest: null,
      metadata: null,
      rateLimitMax: rateLimitMax ?? opts.rateLimit.maxRequests ?? null,
      rateLimitTimeWindow: rateLimitTimeWindow ?? opts.rateLimit.timeWindow ?? null,
      remaining: remaining === null ? remaining : remaining ?? refillAmount ?? null,
      refillAmount: refillAmount ?? null,
      refillInterval: refillInterval ?? null,
      rateLimitEnabled: rateLimitEnabled === void 0 ? opts.rateLimit.enabled ?? true : rateLimitEnabled,
      requestCount: 0,
      permissions: permissionsToApply
    };
    if (metadata) data.metadata = metadata;
    let apiKey2;
    if (opts.storage === "secondary-storage" && opts.fallbackToDatabase) {
      apiKey2 = await ctx.context.adapter.create({
        model: API_KEY_TABLE_NAME,
        data
      });
      await setApiKey(ctx, apiKey2, opts);
    } else if (opts.storage === "secondary-storage") {
      const id = ctx.context.generateId({ model: API_KEY_TABLE_NAME }) || generateId$1();
      apiKey2 = {
        ...data,
        id
      };
      await setApiKey(ctx, apiKey2, opts);
    } else apiKey2 = await ctx.context.adapter.create({
      model: API_KEY_TABLE_NAME,
      data
    });
    return ctx.json({
      ...apiKey2,
      key,
      metadata: metadata ?? null,
      permissions: apiKey2.permissions ? safeJSONParse(apiKey2.permissions) : null
    });
  });
}
function deleteAllExpiredApiKeysEndpoint({ deleteAllExpiredApiKeys: deleteAllExpiredApiKeys2 }) {
  return createAuthEndpoint({ method: "POST" }, async (ctx) => {
    try {
      await deleteAllExpiredApiKeys2(ctx.context, true);
    } catch (error2) {
      ctx.context.logger.error("[API KEY PLUGIN] Failed to delete expired API keys:", error2);
      return ctx.json({
        success: false,
        error: error2
      });
    }
    return ctx.json({
      success: true,
      error: null
    });
  });
}
const deleteApiKeyBodySchema = z.object({ keyId: z.string().meta({ description: "The id of the Api Key" }) });
function deleteApiKey$1({ opts, schema: schema2, deleteAllExpiredApiKeys: deleteAllExpiredApiKeys2 }) {
  return createAuthEndpoint("/api-key/delete", {
    method: "POST",
    body: deleteApiKeyBodySchema,
    use: [sessionMiddleware],
    metadata: { openapi: {
      description: "Delete an existing API key",
      requestBody: { content: { "application/json": { schema: {
        type: "object",
        properties: { keyId: {
          type: "string",
          description: "The id of the API key to delete"
        } },
        required: ["keyId"]
      } } } },
      responses: { "200": {
        description: "API key deleted successfully",
        content: { "application/json": { schema: {
          type: "object",
          properties: { success: {
            type: "boolean",
            description: "Indicates if the API key was successfully deleted"
          } },
          required: ["success"]
        } } }
      } }
    } }
  }, async (ctx) => {
    const { keyId } = ctx.body;
    const session = ctx.context.session;
    if (session.user.banned === true) throw new APIError$1("UNAUTHORIZED", { message: ERROR_CODES.USER_BANNED });
    let apiKey2 = null;
    apiKey2 = await getApiKeyById(ctx, keyId, opts);
    if (!apiKey2 || apiKey2.userId !== session.user.id) throw new APIError$1("NOT_FOUND", { message: ERROR_CODES.KEY_NOT_FOUND });
    try {
      if (opts.storage === "secondary-storage" && opts.fallbackToDatabase) {
        await deleteApiKey(ctx, apiKey2, opts);
        await ctx.context.adapter.delete({
          model: API_KEY_TABLE_NAME,
          where: [{
            field: "id",
            value: apiKey2.id
          }]
        });
      } else if (opts.storage === "database") await ctx.context.adapter.delete({
        model: API_KEY_TABLE_NAME,
        where: [{
          field: "id",
          value: apiKey2.id
        }]
      });
      else await deleteApiKey(ctx, apiKey2, opts);
    } catch (error2) {
      throw new APIError$1("INTERNAL_SERVER_ERROR", { message: error2?.message });
    }
    deleteAllExpiredApiKeys2(ctx.context);
    return ctx.json({ success: true });
  });
}
const getApiKeyQuerySchema = z.object({ id: z.string().meta({ description: "The id of the Api Key" }) });
function getApiKey({ opts, schema: schema2, deleteAllExpiredApiKeys: deleteAllExpiredApiKeys2 }) {
  return createAuthEndpoint("/api-key/get", {
    method: "GET",
    query: getApiKeyQuerySchema,
    use: [sessionMiddleware],
    metadata: { openapi: {
      description: "Retrieve an existing API key by ID",
      responses: { "200": {
        description: "API key retrieved successfully",
        content: { "application/json": { schema: {
          type: "object",
          properties: {
            id: {
              type: "string",
              description: "ID"
            },
            name: {
              type: "string",
              nullable: true,
              description: "The name of the key"
            },
            start: {
              type: "string",
              nullable: true,
              description: "Shows the first few characters of the API key, including the prefix. This allows you to show those few characters in the UI to make it easier for users to identify the API key."
            },
            prefix: {
              type: "string",
              nullable: true,
              description: "The API Key prefix. Stored as plain text."
            },
            userId: {
              type: "string",
              description: "The owner of the user id"
            },
            refillInterval: {
              type: "number",
              nullable: true,
              description: "The interval in milliseconds between refills of the `remaining` count. Example: 3600000 // refill every hour (3600000ms = 1h)"
            },
            refillAmount: {
              type: "number",
              nullable: true,
              description: "The amount to refill"
            },
            lastRefillAt: {
              type: "string",
              format: "date-time",
              nullable: true,
              description: "The last refill date"
            },
            enabled: {
              type: "boolean",
              description: "Sets if key is enabled or disabled",
              default: true
            },
            rateLimitEnabled: {
              type: "boolean",
              description: "Whether the key has rate limiting enabled"
            },
            rateLimitTimeWindow: {
              type: "number",
              nullable: true,
              description: "The duration in milliseconds"
            },
            rateLimitMax: {
              type: "number",
              nullable: true,
              description: "Maximum amount of requests allowed within a window"
            },
            requestCount: {
              type: "number",
              description: "The number of requests made within the rate limit time window"
            },
            remaining: {
              type: "number",
              nullable: true,
              description: "Remaining requests (every time api key is used this should updated and should be updated on refill as well)"
            },
            lastRequest: {
              type: "string",
              format: "date-time",
              nullable: true,
              description: "When last request occurred"
            },
            expiresAt: {
              type: "string",
              format: "date-time",
              nullable: true,
              description: "Expiry date of a key"
            },
            createdAt: {
              type: "string",
              format: "date-time",
              description: "created at"
            },
            updatedAt: {
              type: "string",
              format: "date-time",
              description: "updated at"
            },
            metadata: {
              type: "object",
              nullable: true,
              additionalProperties: true,
              description: "Extra metadata about the apiKey"
            },
            permissions: {
              type: "string",
              nullable: true,
              description: "Permissions for the api key (stored as JSON string)"
            }
          },
          required: [
            "id",
            "userId",
            "enabled",
            "rateLimitEnabled",
            "requestCount",
            "createdAt",
            "updatedAt"
          ]
        } } }
      } }
    } }
  }, async (ctx) => {
    const { id } = ctx.query;
    const session = ctx.context.session;
    let apiKey2 = null;
    apiKey2 = await getApiKeyById(ctx, id, opts);
    if (apiKey2 && apiKey2.userId !== session.user.id) apiKey2 = null;
    if (!apiKey2) throw new APIError$1("NOT_FOUND", { message: ERROR_CODES.KEY_NOT_FOUND });
    deleteAllExpiredApiKeys2(ctx.context);
    const metadata = await migrateDoubleStringifiedMetadata(ctx, apiKey2, opts);
    const { key: _key, ...returningApiKey } = apiKey2;
    return ctx.json({
      ...returningApiKey,
      metadata,
      permissions: returningApiKey.permissions ? safeJSONParse(returningApiKey.permissions) : null
    });
  });
}
function listApiKeys$1({ opts, schema: schema2, deleteAllExpiredApiKeys: deleteAllExpiredApiKeys2 }) {
  return createAuthEndpoint("/api-key/list", {
    method: "GET",
    use: [sessionMiddleware],
    metadata: { openapi: {
      description: "List all API keys for the authenticated user",
      responses: { "200": {
        description: "API keys retrieved successfully",
        content: { "application/json": { schema: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: {
                type: "string",
                description: "ID"
              },
              name: {
                type: "string",
                nullable: true,
                description: "The name of the key"
              },
              start: {
                type: "string",
                nullable: true,
                description: "Shows the first few characters of the API key, including the prefix. This allows you to show those few characters in the UI to make it easier for users to identify the API key."
              },
              prefix: {
                type: "string",
                nullable: true,
                description: "The API Key prefix. Stored as plain text."
              },
              userId: {
                type: "string",
                description: "The owner of the user id"
              },
              refillInterval: {
                type: "number",
                nullable: true,
                description: "The interval in milliseconds between refills of the `remaining` count. Example: 3600000 // refill every hour (3600000ms = 1h)"
              },
              refillAmount: {
                type: "number",
                nullable: true,
                description: "The amount to refill"
              },
              lastRefillAt: {
                type: "string",
                format: "date-time",
                nullable: true,
                description: "The last refill date"
              },
              enabled: {
                type: "boolean",
                description: "Sets if key is enabled or disabled",
                default: true
              },
              rateLimitEnabled: {
                type: "boolean",
                description: "Whether the key has rate limiting enabled"
              },
              rateLimitTimeWindow: {
                type: "number",
                nullable: true,
                description: "The duration in milliseconds"
              },
              rateLimitMax: {
                type: "number",
                nullable: true,
                description: "Maximum amount of requests allowed within a window"
              },
              requestCount: {
                type: "number",
                description: "The number of requests made within the rate limit time window"
              },
              remaining: {
                type: "number",
                nullable: true,
                description: "Remaining requests (every time api key is used this should updated and should be updated on refill as well)"
              },
              lastRequest: {
                type: "string",
                format: "date-time",
                nullable: true,
                description: "When last request occurred"
              },
              expiresAt: {
                type: "string",
                format: "date-time",
                nullable: true,
                description: "Expiry date of a key"
              },
              createdAt: {
                type: "string",
                format: "date-time",
                description: "created at"
              },
              updatedAt: {
                type: "string",
                format: "date-time",
                description: "updated at"
              },
              metadata: {
                type: "object",
                nullable: true,
                additionalProperties: true,
                description: "Extra metadata about the apiKey"
              },
              permissions: {
                type: "string",
                nullable: true,
                description: "Permissions for the api key (stored as JSON string)"
              }
            },
            required: [
              "id",
              "userId",
              "enabled",
              "rateLimitEnabled",
              "requestCount",
              "createdAt",
              "updatedAt"
            ]
          }
        } } }
      } }
    } }
  }, async (ctx) => {
    const session = ctx.context.session;
    const apiKeys = await listApiKeys(ctx, session.user.id, opts);
    deleteAllExpiredApiKeys2(ctx.context);
    const returningApiKeys = apiKeys.map((apiKey2) => {
      const { key: _key, ...rest } = apiKey2;
      return {
        ...rest,
        metadata: parseDoubleStringifiedMetadata(apiKey2.metadata),
        permissions: rest.permissions ? safeJSONParse(rest.permissions) : null
      };
    });
    await ctx.context.runInBackgroundOrAwait(batchMigrateLegacyMetadata(ctx, apiKeys, opts));
    return ctx.json(returningApiKeys);
  });
}
const updateApiKeyBodySchema = z.object({
  keyId: z.string().meta({ description: "The id of the Api Key" }),
  userId: z.coerce.string().meta({ description: 'The id of the user which the api key belongs to. server-only. Eg: "some-user-id"' }).optional(),
  name: z.string().meta({ description: "The name of the key" }).optional(),
  enabled: z.boolean().meta({ description: "Whether the Api Key is enabled or not" }).optional(),
  remaining: z.number().meta({ description: "The number of remaining requests" }).min(1).optional(),
  refillAmount: z.number().meta({ description: "The refill amount" }).optional(),
  refillInterval: z.number().meta({ description: "The refill interval" }).optional(),
  metadata: z.any().optional(),
  expiresIn: z.number().meta({ description: "Expiration time of the Api Key in seconds" }).min(1).optional().nullable(),
  rateLimitEnabled: z.boolean().meta({ description: "Whether the key has rate limiting enabled." }).optional(),
  rateLimitTimeWindow: z.number().meta({ description: "The duration in milliseconds where each request is counted. server-only. Eg: 1000" }).optional(),
  rateLimitMax: z.number().meta({ description: "Maximum amount of requests allowed within a window. Once the `maxRequests` is reached, the request will be rejected until the `timeWindow` has passed, at which point the `timeWindow` will be reset. server-only. Eg: 100" }).optional(),
  permissions: z.record(z.string(), z.array(z.string())).meta({ description: "Update the permissions on the API Key. server-only." }).optional().nullable()
});
function updateApiKey({ opts, schema: schema2, deleteAllExpiredApiKeys: deleteAllExpiredApiKeys2 }) {
  return createAuthEndpoint("/api-key/update", {
    method: "POST",
    body: updateApiKeyBodySchema,
    metadata: { openapi: {
      description: "Update an existing API key by ID",
      responses: { "200": {
        description: "API key updated successfully",
        content: { "application/json": { schema: {
          type: "object",
          properties: {
            id: {
              type: "string",
              description: "ID"
            },
            name: {
              type: "string",
              nullable: true,
              description: "The name of the key"
            },
            start: {
              type: "string",
              nullable: true,
              description: "Shows the first few characters of the API key, including the prefix. This allows you to show those few characters in the UI to make it easier for users to identify the API key."
            },
            prefix: {
              type: "string",
              nullable: true,
              description: "The API Key prefix. Stored as plain text."
            },
            userId: {
              type: "string",
              description: "The owner of the user id"
            },
            refillInterval: {
              type: "number",
              nullable: true,
              description: "The interval in milliseconds between refills of the `remaining` count. Example: 3600000 // refill every hour (3600000ms = 1h)"
            },
            refillAmount: {
              type: "number",
              nullable: true,
              description: "The amount to refill"
            },
            lastRefillAt: {
              type: "string",
              format: "date-time",
              nullable: true,
              description: "The last refill date"
            },
            enabled: {
              type: "boolean",
              description: "Sets if key is enabled or disabled",
              default: true
            },
            rateLimitEnabled: {
              type: "boolean",
              description: "Whether the key has rate limiting enabled"
            },
            rateLimitTimeWindow: {
              type: "number",
              nullable: true,
              description: "The duration in milliseconds"
            },
            rateLimitMax: {
              type: "number",
              nullable: true,
              description: "Maximum amount of requests allowed within a window"
            },
            requestCount: {
              type: "number",
              description: "The number of requests made within the rate limit time window"
            },
            remaining: {
              type: "number",
              nullable: true,
              description: "Remaining requests (every time api key is used this should updated and should be updated on refill as well)"
            },
            lastRequest: {
              type: "string",
              format: "date-time",
              nullable: true,
              description: "When last request occurred"
            },
            expiresAt: {
              type: "string",
              format: "date-time",
              nullable: true,
              description: "Expiry date of a key"
            },
            createdAt: {
              type: "string",
              format: "date-time",
              description: "created at"
            },
            updatedAt: {
              type: "string",
              format: "date-time",
              description: "updated at"
            },
            metadata: {
              type: "object",
              nullable: true,
              additionalProperties: true,
              description: "Extra metadata about the apiKey"
            },
            permissions: {
              type: "string",
              nullable: true,
              description: "Permissions for the api key (stored as JSON string)"
            }
          },
          required: [
            "id",
            "userId",
            "enabled",
            "rateLimitEnabled",
            "requestCount",
            "createdAt",
            "updatedAt"
          ]
        } } }
      } }
    } }
  }, async (ctx) => {
    const { keyId, expiresIn, enabled, metadata, refillAmount, refillInterval, remaining, name: name2, permissions, rateLimitEnabled, rateLimitTimeWindow, rateLimitMax } = ctx.body;
    const session = await getSessionFromCtx(ctx);
    const authRequired = ctx.request || ctx.headers;
    const user = authRequired && !session ? null : session?.user || { id: ctx.body.userId };
    if (!user?.id) throw new APIError$1("UNAUTHORIZED", { message: ERROR_CODES.UNAUTHORIZED_SESSION });
    if (session && ctx.body.userId && session?.user.id !== ctx.body.userId) throw new APIError$1("UNAUTHORIZED", { message: ERROR_CODES.UNAUTHORIZED_SESSION });
    if (authRequired) {
      if (refillAmount !== void 0 || refillInterval !== void 0 || rateLimitMax !== void 0 || rateLimitTimeWindow !== void 0 || rateLimitEnabled !== void 0 || remaining !== void 0 || permissions !== void 0) throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.SERVER_ONLY_PROPERTY });
    }
    let apiKey2 = null;
    apiKey2 = await getApiKeyById(ctx, keyId, opts);
    if (apiKey2 && apiKey2.userId !== user.id) apiKey2 = null;
    if (!apiKey2) throw new APIError$1("NOT_FOUND", { message: ERROR_CODES.KEY_NOT_FOUND });
    const newValues = {};
    if (name2 !== void 0) {
      if (name2.length < opts.minimumNameLength) throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.INVALID_NAME_LENGTH });
      else if (name2.length > opts.maximumNameLength) throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.INVALID_NAME_LENGTH });
      newValues.name = name2;
    }
    if (enabled !== void 0) newValues.enabled = enabled;
    if (expiresIn !== void 0) {
      if (opts.keyExpiration.disableCustomExpiresTime === true) throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.KEY_DISABLED_EXPIRATION });
      if (expiresIn !== null) {
        const expiresIn_in_days = expiresIn / (3600 * 24);
        if (expiresIn_in_days < opts.keyExpiration.minExpiresIn) throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.EXPIRES_IN_IS_TOO_SMALL });
        else if (expiresIn_in_days > opts.keyExpiration.maxExpiresIn) throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.EXPIRES_IN_IS_TOO_LARGE });
      }
      newValues.expiresAt = expiresIn ? getDate(expiresIn, "sec") : null;
    }
    if (metadata !== void 0 && opts.enableMetadata === true) {
      if (typeof metadata !== "object") throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.INVALID_METADATA_TYPE });
      newValues.metadata = metadata;
    }
    if (remaining !== void 0) newValues.remaining = remaining;
    if (refillAmount !== void 0 || refillInterval !== void 0) {
      if (refillAmount !== void 0 && refillInterval === void 0) throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.REFILL_AMOUNT_AND_INTERVAL_REQUIRED });
      else if (refillInterval !== void 0 && refillAmount === void 0) throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.REFILL_INTERVAL_AND_AMOUNT_REQUIRED });
      newValues.refillAmount = refillAmount;
      newValues.refillInterval = refillInterval;
    }
    if (rateLimitEnabled !== void 0) newValues.rateLimitEnabled = rateLimitEnabled;
    if (rateLimitTimeWindow !== void 0) newValues.rateLimitTimeWindow = rateLimitTimeWindow;
    if (rateLimitMax !== void 0) newValues.rateLimitMax = rateLimitMax;
    if (permissions !== void 0) newValues.permissions = JSON.stringify(permissions);
    if (Object.keys(newValues).length === 0) throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.NO_VALUES_TO_UPDATE });
    let newApiKey = apiKey2;
    try {
      if (opts.storage === "secondary-storage" && opts.fallbackToDatabase) {
        const dbUpdated = await ctx.context.adapter.update({
          model: API_KEY_TABLE_NAME,
          where: [{
            field: "id",
            value: apiKey2.id
          }],
          update: newValues
        });
        if (dbUpdated) {
          await setApiKey(ctx, dbUpdated, opts);
          newApiKey = dbUpdated;
        }
      } else if (opts.storage === "database") {
        const result2 = await ctx.context.adapter.update({
          model: API_KEY_TABLE_NAME,
          where: [{
            field: "id",
            value: apiKey2.id
          }],
          update: newValues
        });
        if (result2) newApiKey = result2;
      } else {
        const updated = {
          ...apiKey2,
          ...newValues,
          updatedAt: /* @__PURE__ */ new Date()
        };
        await setApiKey(ctx, updated, opts);
        newApiKey = updated;
      }
    } catch (error2) {
      throw new APIError$1("INTERNAL_SERVER_ERROR", { message: error2?.message });
    }
    deleteAllExpiredApiKeys2(ctx.context);
    const migratedMetadata = await migrateDoubleStringifiedMetadata(ctx, newApiKey, opts);
    const { key: _key, ...returningApiKey } = newApiKey;
    return ctx.json({
      ...returningApiKey,
      metadata: migratedMetadata,
      permissions: returningApiKey.permissions ? safeJSONParse(returningApiKey.permissions) : null
    });
  });
}
let lastChecked = null;
async function deleteAllExpiredApiKeys(ctx, byPassLastCheckTime = false) {
  if (lastChecked && !byPassLastCheckTime) {
    if ((/* @__PURE__ */ new Date()).getTime() - lastChecked.getTime() < 1e4) return;
  }
  lastChecked = /* @__PURE__ */ new Date();
  await ctx.adapter.deleteMany({
    model: API_KEY_TABLE_NAME,
    where: [{
      field: "expiresAt",
      operator: "lt",
      value: /* @__PURE__ */ new Date()
    }, {
      field: "expiresAt",
      operator: "ne",
      value: null
    }]
  }).catch((error2) => {
    ctx.logger.error(`Failed to delete expired API keys:`, error2);
  });
}
function createApiKeyRoutes({ keyGenerator, opts, schema: schema2 }) {
  return {
    createApiKey: createApiKey({
      keyGenerator,
      opts,
      schema: schema2,
      deleteAllExpiredApiKeys
    }),
    verifyApiKey: verifyApiKey({
      opts,
      schema: schema2,
      deleteAllExpiredApiKeys
    }),
    getApiKey: getApiKey({
      opts,
      schema: schema2,
      deleteAllExpiredApiKeys
    }),
    updateApiKey: updateApiKey({
      opts,
      schema: schema2,
      deleteAllExpiredApiKeys
    }),
    deleteApiKey: deleteApiKey$1({
      opts,
      schema: schema2,
      deleteAllExpiredApiKeys
    }),
    listApiKeys: listApiKeys$1({
      opts,
      schema: schema2,
      deleteAllExpiredApiKeys
    }),
    deleteAllExpiredApiKeys: deleteAllExpiredApiKeysEndpoint({ deleteAllExpiredApiKeys })
  };
}
const PROTO_POLLUTION_PATTERNS = {
  proto: /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/,
  constructor: /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/,
  protoShort: /"__proto__"\s*:/,
  constructorShort: /"constructor"\s*:/
};
const JSON_SIGNATURE = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
const SPECIAL_VALUES = {
  true: true,
  false: false,
  null: null,
  undefined: void 0,
  nan: NaN,
  infinity: Number.POSITIVE_INFINITY,
  "-infinity": Number.NEGATIVE_INFINITY
};
const ISO_DATE_REGEX = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(?:\.(\d{1,7}))?(?:Z|([+-])(\d{2}):(\d{2}))$/;
function isValidDate(date2) {
  return date2 instanceof Date && !isNaN(date2.getTime());
}
function parseISODate(value) {
  const match2 = ISO_DATE_REGEX.exec(value);
  if (!match2) return null;
  const [, year2, month, day2, hour2, minute2, second, ms2, offsetSign, offsetHour, offsetMinute] = match2;
  const date2 = new Date(Date.UTC(parseInt(year2, 10), parseInt(month, 10) - 1, parseInt(day2, 10), parseInt(hour2, 10), parseInt(minute2, 10), parseInt(second, 10), ms2 ? parseInt(ms2.padEnd(3, "0"), 10) : 0));
  if (offsetSign) {
    const offset2 = (parseInt(offsetHour, 10) * 60 + parseInt(offsetMinute, 10)) * (offsetSign === "+" ? -1 : 1);
    date2.setUTCMinutes(date2.getUTCMinutes() + offset2);
  }
  return isValidDate(date2) ? date2 : null;
}
function betterJSONParse(value, options = {}) {
  const { strict = false, warnings = false, reviver, parseDates = true } = options;
  if (typeof value !== "string") return value;
  const trimmed = value.trim();
  if (trimmed.length > 0 && trimmed[0] === '"' && trimmed.endsWith('"') && !trimmed.slice(1, -1).includes('"')) return trimmed.slice(1, -1);
  const lowerValue = trimmed.toLowerCase();
  if (lowerValue.length <= 9 && lowerValue in SPECIAL_VALUES) return SPECIAL_VALUES[lowerValue];
  if (!JSON_SIGNATURE.test(trimmed)) {
    if (strict) throw new SyntaxError("[better-json] Invalid JSON");
    return value;
  }
  if (Object.entries(PROTO_POLLUTION_PATTERNS).some(([key, pattern]) => {
    const matches = pattern.test(trimmed);
    if (matches && warnings) console.warn(`[better-json] Detected potential prototype pollution attempt using ${key} pattern`);
    return matches;
  }) && strict) throw new Error("[better-json] Potential prototype pollution attempt detected");
  try {
    const secureReviver = (key, value$1) => {
      if (key === "__proto__" || key === "constructor" && value$1 && typeof value$1 === "object" && "prototype" in value$1) {
        if (warnings) console.warn(`[better-json] Dropping "${key}" key to prevent prototype pollution`);
        return;
      }
      if (parseDates && typeof value$1 === "string") {
        const date2 = parseISODate(value$1);
        if (date2) return date2;
      }
      return reviver ? reviver(key, value$1) : value$1;
    };
    return JSON.parse(trimmed, secureReviver);
  } catch (error2) {
    if (strict) throw error2;
    return value;
  }
}
function parseJSON(value, options = { strict: true }) {
  return betterJSONParse(value, options);
}
const apiKeySchema = ({ timeWindow, rateLimitMax }) => ({ apikey: { fields: {
  name: {
    type: "string",
    required: false,
    input: false
  },
  start: {
    type: "string",
    required: false,
    input: false
  },
  prefix: {
    type: "string",
    required: false,
    input: false
  },
  key: {
    type: "string",
    required: true,
    input: false,
    index: true
  },
  userId: {
    type: "string",
    references: {
      model: "user",
      field: "id",
      onDelete: "cascade"
    },
    required: true,
    input: false,
    index: true
  },
  refillInterval: {
    type: "number",
    required: false,
    input: false
  },
  refillAmount: {
    type: "number",
    required: false,
    input: false
  },
  lastRefillAt: {
    type: "date",
    required: false,
    input: false
  },
  enabled: {
    type: "boolean",
    required: false,
    input: false,
    defaultValue: true
  },
  rateLimitEnabled: {
    type: "boolean",
    required: false,
    input: false,
    defaultValue: true
  },
  rateLimitTimeWindow: {
    type: "number",
    required: false,
    input: false,
    defaultValue: timeWindow
  },
  rateLimitMax: {
    type: "number",
    required: false,
    input: false,
    defaultValue: rateLimitMax
  },
  requestCount: {
    type: "number",
    required: false,
    input: false,
    defaultValue: 0
  },
  remaining: {
    type: "number",
    required: false,
    input: false
  },
  lastRequest: {
    type: "date",
    required: false,
    input: false
  },
  expiresAt: {
    type: "date",
    required: false,
    input: false
  },
  createdAt: {
    type: "date",
    required: true,
    input: false
  },
  updatedAt: {
    type: "date",
    required: true,
    input: false
  },
  permissions: {
    type: "string",
    required: false,
    input: false
  },
  metadata: {
    type: "string",
    required: false,
    input: true,
    transform: {
      input(value) {
        return JSON.stringify(value);
      },
      output(value) {
        if (!value) return null;
        return parseJSON(value);
      }
    }
  }
} } });
const defaultKeyHasher = async (key) => {
  const hash = await createHash("SHA-256").digest(new TextEncoder().encode(key));
  return base64Url.encode(new Uint8Array(hash), { padding: false });
};
const ERROR_CODES = defineErrorCodes({
  INVALID_METADATA_TYPE: "metadata must be an object or undefined",
  REFILL_AMOUNT_AND_INTERVAL_REQUIRED: "refillAmount is required when refillInterval is provided",
  REFILL_INTERVAL_AND_AMOUNT_REQUIRED: "refillInterval is required when refillAmount is provided",
  USER_BANNED: "User is banned",
  UNAUTHORIZED_SESSION: "Unauthorized or invalid session",
  KEY_NOT_FOUND: "API Key not found",
  KEY_DISABLED: "API Key is disabled",
  KEY_EXPIRED: "API Key has expired",
  USAGE_EXCEEDED: "API Key has reached its usage limit",
  KEY_NOT_RECOVERABLE: "API Key is not recoverable",
  EXPIRES_IN_IS_TOO_SMALL: "The expiresIn is smaller than the predefined minimum value.",
  EXPIRES_IN_IS_TOO_LARGE: "The expiresIn is larger than the predefined maximum value.",
  INVALID_REMAINING: "The remaining count is either too large or too small.",
  INVALID_PREFIX_LENGTH: "The prefix length is either too large or too small.",
  INVALID_NAME_LENGTH: "The name length is either too large or too small.",
  METADATA_DISABLED: "Metadata is disabled.",
  RATE_LIMIT_EXCEEDED: "Rate limit exceeded.",
  NO_VALUES_TO_UPDATE: "No values to update.",
  KEY_DISABLED_EXPIRATION: "Custom key expiration values are disabled.",
  INVALID_API_KEY: "Invalid API key.",
  INVALID_USER_ID_FROM_API_KEY: "The user id from the API key is invalid.",
  INVALID_API_KEY_GETTER_RETURN_TYPE: "API Key getter returned an invalid key type. Expected string.",
  SERVER_ONLY_PROPERTY: "The property you're trying to set can only be set from the server auth instance only.",
  FAILED_TO_UPDATE_API_KEY: "Failed to update API key",
  NAME_REQUIRED: "API Key name is required."
});
const API_KEY_TABLE_NAME = "apikey";
const apiKey = (options) => {
  const opts = {
    ...options,
    apiKeyHeaders: "x-api-key",
    defaultKeyLength: 64,
    maximumPrefixLength: 32,
    minimumPrefixLength: 1,
    maximumNameLength: 32,
    minimumNameLength: 1,
    enableMetadata: false,
    disableKeyHashing: false,
    requireName: false,
    storage: "database",
    rateLimit: {
      enabled: true,
      timeWindow: 1e3 * 60 * 60 * 24,
      maxRequests: 10
    },
    keyExpiration: {
      defaultExpiresIn: null,
      disableCustomExpiresTime: false,
      maxExpiresIn: 365,
      minExpiresIn: 1
    },
    startingCharactersConfig: {
      shouldStore: true,
      charactersLength: 6
    },
    enableSessionForAPIKeys: false,
    fallbackToDatabase: false,
    customStorage: options?.customStorage,
    deferUpdates: false
  };
  const schema2 = mergeSchema(apiKeySchema({
    rateLimitMax: opts.rateLimit.maxRequests,
    timeWindow: opts.rateLimit.timeWindow
  }), opts.schema);
  const getter = opts.customAPIKeyGetter || ((ctx) => {
    if (Array.isArray(opts.apiKeyHeaders)) for (const header of opts.apiKeyHeaders) {
      const value = ctx.headers?.get(header);
      if (value) return value;
    }
    else return ctx.headers?.get(opts.apiKeyHeaders);
  });
  const routes = createApiKeyRoutes({
    keyGenerator: opts.customKeyGenerator || (async (options$1) => {
      const key = generateRandomString(options$1.length, "a-z", "A-Z");
      return `${options$1.prefix || ""}${key}`;
    }),
    opts,
    schema: schema2
  });
  return {
    id: "api-key",
    $ERROR_CODES: ERROR_CODES,
    hooks: { before: [{
      matcher: (ctx) => !!getter(ctx) && opts.enableSessionForAPIKeys,
      handler: createAuthMiddleware(async (ctx) => {
        const key = getter(ctx);
        if (typeof key !== "string") throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.INVALID_API_KEY_GETTER_RETURN_TYPE });
        if (key.length < opts.defaultKeyLength) throw new APIError$1("FORBIDDEN", { message: ERROR_CODES.INVALID_API_KEY });
        if (opts.customAPIKeyValidator) {
          if (!await opts.customAPIKeyValidator({
            ctx,
            key
          })) throw new APIError$1("FORBIDDEN", { message: ERROR_CODES.INVALID_API_KEY });
        }
        const apiKey$1 = await validateApiKey({
          hashedKey: opts.disableKeyHashing ? key : await defaultKeyHasher(key),
          ctx,
          opts,
          schema: schema2
        });
        const cleanupTask = deleteAllExpiredApiKeys(ctx.context).catch((err2) => {
          ctx.context.logger.error("Failed to delete expired API keys:", err2);
        });
        if (opts.deferUpdates) ctx.context.runInBackground(cleanupTask);
        const user = await ctx.context.internalAdapter.findUserById(apiKey$1.userId);
        if (!user) throw new APIError$1("UNAUTHORIZED", { message: ERROR_CODES.INVALID_USER_ID_FROM_API_KEY });
        const session = {
          user,
          session: {
            id: apiKey$1.id,
            token: key,
            userId: apiKey$1.userId,
            userAgent: ctx.request?.headers.get("user-agent") ?? null,
            ipAddress: ctx.request ? getIp(ctx.request, ctx.context.options) : null,
            createdAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date(),
            expiresAt: apiKey$1.expiresAt || getDate(ctx.context.options.session?.expiresIn || 3600 * 24 * 7, "ms")
          }
        };
        ctx.context.session = session;
        if (ctx.path === "/get-session") return session;
        else return { context: ctx };
      })
    }] },
    endpoints: {
      createApiKey: routes.createApiKey,
      verifyApiKey: routes.verifyApiKey,
      getApiKey: routes.getApiKey,
      updateApiKey: routes.updateApiKey,
      deleteApiKey: routes.deleteApiKey,
      listApiKeys: routes.listApiKeys,
      deleteAllExpiredApiKeys: routes.deleteAllExpiredApiKeys
    },
    schema: schema2,
    options
  };
};
const bearer = (options) => {
  return {
    id: "bearer",
    hooks: {
      before: [{
        matcher(context) {
          return Boolean(context.request?.headers.get("authorization") || context.headers?.get("authorization"));
        },
        handler: createAuthMiddleware(async (c2) => {
          const token2 = c2.request?.headers.get("authorization")?.replace("Bearer ", "") || c2.headers?.get("Authorization")?.replace("Bearer ", "");
          if (!token2) return;
          let signedToken = "";
          if (token2.includes(".")) signedToken = token2.replace("=", "");
          else {
            signedToken = (await serializeSignedCookie$1("", token2, c2.context.secret)).replace("=", "");
          }
          try {
            const decodedToken = decodeURIComponent(signedToken);
            if (!await createHMAC("SHA-256", "base64urlnopad").verify(c2.context.secret, decodedToken.split(".")[0], decodedToken.split(".")[1])) return;
          } catch {
            return;
          }
          const existingHeaders = c2.request?.headers || c2.headers;
          const headers = new Headers({ ...Object.fromEntries(existingHeaders?.entries()) });
          headers.append("cookie", `${c2.context.authCookies.sessionToken.name}=${signedToken}`);
          return { context: { headers } };
        })
      }],
      after: [{
        matcher(context) {
          return true;
        },
        handler: createAuthMiddleware(async (ctx) => {
          const setCookie = ctx.context.responseHeaders?.get("set-cookie");
          if (!setCookie) return;
          const parsedCookies = parseSetCookieHeader(setCookie);
          const cookieName = ctx.context.authCookies.sessionToken.name;
          const sessionCookie = parsedCookies.get(cookieName);
          if (!sessionCookie || !sessionCookie.value || sessionCookie["max-age"] === 0) return;
          const token2 = sessionCookie.value;
          const exposedHeaders = ctx.context.responseHeaders?.get("access-control-expose-headers") || "";
          const headersSet = new Set(exposedHeaders.split(",").map((header) => header.trim()).filter(Boolean));
          headersSet.add("set-auth-token");
          ctx.setHeader("set-auth-token", token2);
          ctx.setHeader("Access-Control-Expose-Headers", Array.from(headersSet).join(", "));
        })
      }]
    },
    options
  };
};
z.optional(z.object({
  disableCookieCache: z.boolean().meta({ description: "Disable cookie cache and fetch session from database" }).or(z.string().transform((v) => v === "true")).optional(),
  disableRefresh: z.boolean().meta({ description: "Disable session refresh. Useful for checking session status, without updating the session" }).optional()
}));
const DEVICE_AUTHORIZATION_ERROR_CODES = defineErrorCodes({
  INVALID_DEVICE_CODE: "Invalid device code",
  EXPIRED_DEVICE_CODE: "Device code has expired",
  EXPIRED_USER_CODE: "User code has expired",
  AUTHORIZATION_PENDING: "Authorization pending",
  ACCESS_DENIED: "Access denied",
  INVALID_USER_CODE: "Invalid user code",
  DEVICE_CODE_ALREADY_PROCESSED: "Device code already processed",
  POLLING_TOO_FREQUENTLY: "Polling too frequently",
  USER_NOT_FOUND: "User not found",
  FAILED_TO_CREATE_SESSION: "Failed to create session",
  INVALID_DEVICE_CODE_STATUS: "Invalid device code status",
  AUTHENTICATION_REQUIRED: "Authentication required"
});
z.object({
  client_id: z.string().meta({ description: "The client ID of the application" }),
  scope: z.string().meta({ description: "Space-separated list of scopes" }).optional()
});
z.object({
  error: z.enum(["invalid_request", "invalid_client"]).meta({ description: "Error code" }),
  error_description: z.string().meta({ description: "Detailed error description" })
});
z.object({
  grant_type: z.literal("urn:ietf:params:oauth:grant-type:device_code").meta({ description: "The grant type for device flow" }),
  device_code: z.string().meta({ description: "The device verification code" }),
  client_id: z.string().meta({ description: "The client ID of the application" })
});
z.object({
  error: z.enum([
    "authorization_pending",
    "slow_down",
    "expired_token",
    "access_denied",
    "invalid_request",
    "invalid_grant"
  ]).meta({ description: "Error code" }),
  error_description: z.string().meta({ description: "Detailed error description" })
});
createAuthEndpoint("/device", {
  method: "GET",
  query: z.object({ user_code: z.string().meta({ description: "The user code to verify" }) }),
  error: z.object({
    error: z.enum(["invalid_request"]).meta({ description: "Error code" }),
    error_description: z.string().meta({ description: "Detailed error description" })
  }),
  metadata: { openapi: {
    description: "Verify user code and get device authorization status",
    responses: { 200: {
      description: "Device authorization status",
      content: { "application/json": { schema: {
        type: "object",
        properties: {
          user_code: {
            type: "string",
            description: "The user code to verify"
          },
          status: {
            type: "string",
            enum: [
              "pending",
              "approved",
              "denied"
            ],
            description: "Current status of the device authorization"
          }
        }
      } } }
    } }
  } }
}, async (ctx) => {
  const { user_code } = ctx.query;
  const cleanUserCode = user_code.replace(/-/g, "");
  const deviceCodeRecord = await ctx.context.adapter.findOne({
    model: "deviceCode",
    where: [{
      field: "userCode",
      value: cleanUserCode
    }]
  });
  if (!deviceCodeRecord) throw new APIError$1("BAD_REQUEST", {
    error: "invalid_request",
    error_description: DEVICE_AUTHORIZATION_ERROR_CODES.INVALID_USER_CODE
  });
  if (deviceCodeRecord.expiresAt < /* @__PURE__ */ new Date()) throw new APIError$1("BAD_REQUEST", {
    error: "expired_token",
    error_description: DEVICE_AUTHORIZATION_ERROR_CODES.EXPIRED_USER_CODE
  });
  return ctx.json({
    user_code,
    status: deviceCodeRecord.status
  });
});
createAuthEndpoint("/device/approve", {
  method: "POST",
  body: z.object({ userCode: z.string().meta({ description: "The user code to approve" }) }),
  error: z.object({
    error: z.enum([
      "invalid_request",
      "expired_token",
      "device_code_already_processed",
      "unauthorized",
      "access_denied"
    ]).meta({ description: "Error code" }),
    error_description: z.string().meta({ description: "Detailed error description" })
  }),
  requireHeaders: true,
  metadata: { openapi: {
    description: "Approve device authorization",
    responses: { 200: {
      description: "Success",
      content: { "application/json": { schema: {
        type: "object",
        properties: { success: { type: "boolean" } }
      } } }
    } }
  } }
}, async (ctx) => {
  const session = await getSessionFromCtx(ctx);
  if (!session) throw new APIError$1("UNAUTHORIZED", {
    error: "unauthorized",
    error_description: DEVICE_AUTHORIZATION_ERROR_CODES.AUTHENTICATION_REQUIRED
  });
  const { userCode } = ctx.body;
  const cleanUserCode = userCode.replace(/-/g, "");
  const deviceCodeRecord = await ctx.context.adapter.findOne({
    model: "deviceCode",
    where: [{
      field: "userCode",
      value: cleanUserCode
    }]
  });
  if (!deviceCodeRecord) throw new APIError$1("BAD_REQUEST", {
    error: "invalid_request",
    error_description: DEVICE_AUTHORIZATION_ERROR_CODES.INVALID_USER_CODE
  });
  if (deviceCodeRecord.expiresAt < /* @__PURE__ */ new Date()) throw new APIError$1("BAD_REQUEST", {
    error: "expired_token",
    error_description: DEVICE_AUTHORIZATION_ERROR_CODES.EXPIRED_USER_CODE
  });
  if (deviceCodeRecord.status !== "pending") throw new APIError$1("BAD_REQUEST", {
    error: "invalid_request",
    error_description: DEVICE_AUTHORIZATION_ERROR_CODES.DEVICE_CODE_ALREADY_PROCESSED
  });
  if (deviceCodeRecord.userId && deviceCodeRecord.userId !== session.user.id) throw new APIError$1("FORBIDDEN", {
    error: "access_denied",
    error_description: "You are not authorized to approve this device authorization"
  });
  await ctx.context.adapter.update({
    model: "deviceCode",
    where: [{
      field: "id",
      value: deviceCodeRecord.id
    }],
    update: {
      status: "approved",
      userId: session.user.id
    }
  });
  return ctx.json({ success: true });
});
createAuthEndpoint("/device/deny", {
  method: "POST",
  body: z.object({ userCode: z.string().meta({ description: "The user code to deny" }) }),
  error: z.object({
    error: z.enum([
      "invalid_request",
      "expired_token",
      "unauthorized",
      "access_denied"
    ]).meta({ description: "Error code" }),
    error_description: z.string().meta({ description: "Detailed error description" })
  }),
  requireHeaders: true,
  metadata: { openapi: {
    description: "Deny device authorization",
    responses: { 200: {
      description: "Success",
      content: { "application/json": { schema: {
        type: "object",
        properties: { success: { type: "boolean" } }
      } } }
    } }
  } }
}, async (ctx) => {
  const session = await getSessionFromCtx(ctx);
  if (!session) throw new APIError$1("UNAUTHORIZED", {
    error: "unauthorized",
    error_description: DEVICE_AUTHORIZATION_ERROR_CODES.AUTHENTICATION_REQUIRED
  });
  const { userCode } = ctx.body;
  const cleanUserCode = userCode.replace(/-/g, "");
  const deviceCodeRecord = await ctx.context.adapter.findOne({
    model: "deviceCode",
    where: [{
      field: "userCode",
      value: cleanUserCode
    }]
  });
  if (!deviceCodeRecord) throw new APIError$1("BAD_REQUEST", {
    error: "invalid_request",
    error_description: DEVICE_AUTHORIZATION_ERROR_CODES.INVALID_USER_CODE
  });
  if (deviceCodeRecord.expiresAt < /* @__PURE__ */ new Date()) throw new APIError$1("BAD_REQUEST", {
    error: "expired_token",
    error_description: DEVICE_AUTHORIZATION_ERROR_CODES.EXPIRED_USER_CODE
  });
  if (deviceCodeRecord.status !== "pending") throw new APIError$1("BAD_REQUEST", {
    error: "invalid_request",
    error_description: DEVICE_AUTHORIZATION_ERROR_CODES.DEVICE_CODE_ALREADY_PROCESSED
  });
  if (deviceCodeRecord.userId && deviceCodeRecord.userId !== session.user.id) throw new APIError$1("FORBIDDEN", {
    error: "access_denied",
    error_description: "You are not authorized to deny this device authorization"
  });
  await ctx.context.adapter.update({
    model: "deviceCode",
    where: [{
      field: "id",
      value: deviceCodeRecord.id
    }],
    update: {
      status: "denied",
      userId: deviceCodeRecord.userId || session.user.id
    }
  });
  return ctx.json({ success: true });
});
z.object({
  id: z.string(),
  deviceCode: z.string(),
  userCode: z.string(),
  userId: z.string().optional(),
  expiresAt: z.date(),
  status: z.string(),
  lastPolledAt: z.date().optional(),
  pollingInterval: z.number().optional(),
  clientId: z.string().optional(),
  scope: z.string().optional()
});
const timeStringSchema = z.custom((val) => {
  if (typeof val !== "string") return false;
  try {
    ms(val);
    return true;
  } catch {
    return false;
  }
}, { message: "Invalid time string format. Use formats like '30m', '5s', '1h', etc." });
z.object({
  expiresIn: timeStringSchema.default("30m").describe("Time in seconds until the device code expires. Use formats like '30m', '5s', '1h', etc."),
  interval: timeStringSchema.default("5s").describe("Time in seconds between polling attempts. Use formats like '30m', '5s', '1h', etc."),
  deviceCodeLength: z.number().int().positive().default(40).describe("Length of the device code to be generated. Default is 40 characters."),
  userCodeLength: z.number().int().positive().default(8).describe("Length of the user code to be generated. Default is 8 characters."),
  generateDeviceCode: z.custom((val) => typeof val === "function", { message: "generateDeviceCode must be a function that returns a string or a promise that resolves to a string." }).optional().describe("Function to generate a device code. If not provided, a default random string generator will be used."),
  generateUserCode: z.custom((val) => typeof val === "function", { message: "generateUserCode must be a function that returns a string or a promise that resolves to a string." }).optional().describe("Function to generate a user code. If not provided, a default random string generator will be used."),
  validateClient: z.custom((val) => typeof val === "function", { message: "validateClient must be a function that returns a boolean or a promise that resolves to a boolean." }).optional().describe("Function to validate the client ID. If not provided, no validation will be performed."),
  onDeviceAuthRequest: z.custom((val) => typeof val === "function", { message: "onDeviceAuthRequest must be a function that returns void or a promise that resolves to void." }).optional().describe("Function to handle device authorization requests. If not provided, no additional actions will be taken."),
  verificationUri: z.string().optional().describe("The URI where users verify their device code. Can be an absolute URL (https://example.com/device) or relative path (/custom-path). This will be returned as verification_uri in the device code response. If not provided, defaults to /device."),
  schema: z.custom(() => true)
});
const types = [
  "email-verification",
  "sign-in",
  "forget-password"
];
z.object({
  email: z.string({}).meta({ description: "Email address to send the OTP" }),
  type: z.enum(types).meta({ description: "Type of the OTP" })
});
z.object({
  email: z.string({}).meta({ description: "Email address to send the OTP" }),
  type: z.enum(types).meta({
    required: true,
    description: "Type of the OTP"
  })
});
z.object({
  email: z.string({}).meta({ description: "Email address the OTP was sent to" }),
  type: z.enum(types).meta({
    required: true,
    description: "Type of the OTP"
  })
});
z.object({
  email: z.string().meta({ description: "Email address the OTP was sent to" }),
  type: z.enum(types).meta({
    required: true,
    description: "Type of the OTP"
  }),
  otp: z.string().meta({
    required: true,
    description: "OTP to verify"
  })
});
z.object({
  email: z.string({}).meta({ description: "Email address to verify" }),
  otp: z.string().meta({
    required: true,
    description: "OTP to verify"
  })
});
z.object({
  email: z.string({}).meta({ description: "Email address to sign in" }),
  otp: z.string().meta({
    required: true,
    description: "OTP sent to the email"
  })
});
z.object({ email: z.string().meta({ description: "Email address to send the OTP" }) });
z.object({ email: z.string().meta({ description: "Email address to send the OTP" }) });
z.object({
  email: z.string().meta({ description: "Email address to reset the password" }),
  otp: z.string().meta({ description: "OTP sent to the email" }),
  password: z.string().meta({ description: "New password" })
});
z.object({
  providerId: z.string().meta({ description: "The provider ID for the OAuth provider" }),
  callbackURL: z.string().meta({ description: "The URL to redirect to after sign in" }).optional(),
  errorCallbackURL: z.string().meta({ description: "The URL to redirect to if an error occurs" }).optional(),
  newUserCallbackURL: z.string().meta({ description: 'The URL to redirect to after login if the user is new. Eg: "/welcome"' }).optional(),
  disableRedirect: z.boolean().meta({ description: "Disable redirect" }).optional(),
  scopes: z.array(z.string()).meta({ description: "Scopes to be passed to the provider authorization request." }).optional(),
  requestSignUp: z.boolean().meta({ description: "Explicitly request sign-up. Useful when disableImplicitSignUp is true for this provider. Eg: false" }).optional(),
  additionalData: z.record(z.string(), z.any()).optional()
});
z.object({
  code: z.string().meta({ description: "The OAuth2 code" }).optional(),
  error: z.string().meta({ description: "The error message, if any" }).optional(),
  error_description: z.string().meta({ description: "The error description, if any" }).optional(),
  state: z.string().meta({ description: "The state parameter from the OAuth2 request" }).optional()
});
z.object({
  providerId: z.string(),
  callbackURL: z.string(),
  scopes: z.array(z.string()).meta({ description: "Additional scopes to request when linking the account" }).optional(),
  errorCallbackURL: z.string().meta({ description: "The URL to redirect to if there is an error during the link process" }).optional()
});
z.object({
  payload: z.record(z.string(), z.any()),
  overrideOptions: z.record(z.string(), z.any()).optional()
});
z.object({
  token: z.string(),
  issuer: z.string().optional()
});
z.object({
  email: z.email().meta({ description: "Email address to send the magic link" }),
  name: z.string().meta({ description: 'User display name. Only used if the user is registering for the first time. Eg: "my-name"' }).optional(),
  callbackURL: z.string().meta({ description: "URL to redirect after magic link verification" }).optional(),
  newUserCallbackURL: z.string().meta({ description: "URL to redirect after new user signup. Only used if the user is registering for the first time." }).optional(),
  errorCallbackURL: z.string().meta({ description: "URL to redirect after error." }).optional()
});
z.object({
  token: z.string().meta({ description: "Verification token" }),
  callbackURL: z.string().meta({ description: 'URL to redirect after magic link verification, if not provided the user will be redirected to the root URL. Eg: "/dashboard"' }).optional(),
  errorCallbackURL: z.string().meta({ description: "URL to redirect after error." }).optional(),
  newUserCallbackURL: z.string().meta({ description: "URL to redirect after new user signup. Only used if the user is registering for the first time." }).optional()
});
z.object({
  clientId: z.string(),
  clientSecret: z.string().optional(),
  type: z.enum([
    "web",
    "native",
    "user-agent-based",
    "public"
  ]),
  name: z.string(),
  icon: z.string().optional(),
  metadata: z.string().optional(),
  disabled: z.boolean().optional().default(false),
  redirectUrls: z.string(),
  userId: z.string().optional(),
  createdAt: z.date(),
  updatedAt: z.date()
});
z.object({
  accept: z.boolean(),
  consent_code: z.string().optional().nullish()
});
z.record(z.any(), z.any());
z.object({
  redirect_uris: z.array(z.string()).meta({ description: 'A list of redirect URIs. Eg: ["https://client.example.com/callback"]' }),
  token_endpoint_auth_method: z.enum([
    "none",
    "client_secret_basic",
    "client_secret_post"
  ]).meta({ description: 'The authentication method for the token endpoint. Eg: "client_secret_basic"' }).default("client_secret_basic").optional(),
  grant_types: z.array(z.enum([
    "authorization_code",
    "implicit",
    "password",
    "client_credentials",
    "refresh_token",
    "urn:ietf:params:oauth:grant-type:jwt-bearer",
    "urn:ietf:params:oauth:grant-type:saml2-bearer"
  ])).meta({ description: 'The grant types supported by the application. Eg: ["authorization_code"]' }).default(["authorization_code"]).optional(),
  response_types: z.array(z.enum(["code", "token"])).meta({ description: 'The response types supported by the application. Eg: ["code"]' }).default(["code"]).optional(),
  client_name: z.string().meta({ description: 'The name of the application. Eg: "My App"' }).optional(),
  client_uri: z.string().meta({ description: 'The URI of the application. Eg: "https://client.example.com"' }).optional(),
  logo_uri: z.string().meta({ description: 'The URI of the application logo. Eg: "https://client.example.com/logo.png"' }).optional(),
  scope: z.string().meta({ description: 'The scopes supported by the application. Separated by spaces. Eg: "profile email"' }).optional(),
  contacts: z.array(z.string()).meta({ description: 'The contact information for the application. Eg: ["admin@example.com"]' }).optional(),
  tos_uri: z.string().meta({ description: 'The URI of the application terms of service. Eg: "https://client.example.com/tos"' }).optional(),
  policy_uri: z.string().meta({ description: 'The URI of the application privacy policy. Eg: "https://client.example.com/policy"' }).optional(),
  jwks_uri: z.string().meta({ description: 'The URI of the application JWKS. Eg: "https://client.example.com/jwks"' }).optional(),
  jwks: z.record(z.any(), z.any()).meta({ description: 'The JWKS of the application. Eg: {"keys": [{"kty": "RSA", "alg": "RS256", "use": "sig", "n": "...", "e": "..."}]}' }).optional(),
  metadata: z.record(z.any(), z.any()).meta({ description: 'The metadata of the application. Eg: {"key": "value"}' }).optional(),
  software_id: z.string().meta({ description: 'The software ID of the application. Eg: "my-software"' }).optional(),
  software_version: z.string().meta({ description: 'The software version of the application. Eg: "1.0.0"' }).optional(),
  software_statement: z.string().meta({ description: "The software statement of the application." }).optional()
});
z.object({
  redirect_uris: z.array(z.string()),
  token_endpoint_auth_method: z.enum([
    "none",
    "client_secret_basic",
    "client_secret_post"
  ]).default("client_secret_basic").optional(),
  grant_types: z.array(z.enum([
    "authorization_code",
    "implicit",
    "password",
    "client_credentials",
    "refresh_token",
    "urn:ietf:params:oauth:grant-type:jwt-bearer",
    "urn:ietf:params:oauth:grant-type:saml2-bearer"
  ])).default(["authorization_code"]).optional(),
  response_types: z.array(z.enum(["code", "token"])).default(["code"]).optional(),
  client_name: z.string().optional(),
  client_uri: z.string().optional(),
  logo_uri: z.string().optional(),
  scope: z.string().optional(),
  contacts: z.array(z.string()).optional(),
  tos_uri: z.string().optional(),
  policy_uri: z.string().optional(),
  jwks_uri: z.string().optional(),
  jwks: z.record(z.string(), z.any()).optional(),
  metadata: z.record(z.any(), z.any()).optional(),
  software_id: z.string().optional(),
  software_version: z.string().optional(),
  software_statement: z.string().optional()
});
z.record(z.any(), z.any());
z.object({ sessionToken: z.string().meta({ description: "The session token to set as active" }) });
z.object({ sessionToken: z.string().meta({ description: "The session token to revoke" }) });
z.object({
  callbackURL: z.string().meta({ description: "The URL to redirect to after the proxy" }),
  cookies: z.string().meta({ description: "The cookies to set after the proxy" })
});
z.object({ idToken: z.string().meta({ description: "Google ID token, which the client obtains from the One Tap API" }) });
z.object({ token: z.string().meta({ description: 'The token to verify. Eg: "some-token"' }) });
createAuthMiddleware(async () => {
  return {};
});
createAuthMiddleware({ use: [sessionMiddleware] }, async (ctx) => {
  return { session: ctx.context.session };
});
z.object({
  organizationId: z.string().optional().meta({ description: "The id of the organization to create the role in. If not provided, the user's active organization will be used." }),
  role: z.string().meta({ description: "The name of the role to create" }),
  permission: z.record(z.string(), z.array(z.string())).meta({ description: "The permission to assign to the role" })
});
z.object({ organizationId: z.string().optional().meta({ description: "The id of the organization to create the role in. If not provided, the user's active organization will be used." }) }).and(z.union([z.object({ roleName: z.string().nonempty().meta({ description: "The name of the role to delete" }) }), z.object({ roleId: z.string().nonempty().meta({ description: "The id of the role to delete" }) })]));
z.object({ organizationId: z.string().optional().meta({ description: "The id of the organization to list roles for. If not provided, the user's active organization will be used." }) }).optional();
z.object({ organizationId: z.string().optional().meta({ description: "The id of the organization to read a role for. If not provided, the user's active organization will be used." }) }).and(z.union([z.object({ roleName: z.string().nonempty().meta({ description: "The name of the role to read" }) }), z.object({ roleId: z.string().nonempty().meta({ description: "The id of the role to read" }) })])).optional();
z.union([z.object({ roleName: z.string().nonempty().meta({ description: "The name of the role to update" }) }), z.object({ roleId: z.string().nonempty().meta({ description: "The id of the role to update" }) })]);
z.object({
  email: z.string().meta({ description: "The email address of the user to invite" }),
  role: z.union([z.string().meta({ description: "The role to assign to the user" }), z.array(z.string().meta({ description: "The roles to assign to the user" }))]).meta({ description: 'The role(s) to assign to the user. It can be `admin`, `member`, owner. Eg: "member"' }),
  organizationId: z.string().meta({ description: "The organization ID to invite the user to" }).optional(),
  resend: z.boolean().meta({ description: "Resend the invitation email, if the user is already invited. Eg: true" }).optional(),
  teamId: z.union([z.string().meta({ description: "The team ID to invite the user to" }).optional(), z.array(z.string()).meta({ description: "The team IDs to invite the user to" }).optional()])
});
z.object({ invitationId: z.string().meta({ description: "The ID of the invitation to accept" }) });
z.object({ invitationId: z.string().meta({ description: "The ID of the invitation to reject" }) });
z.object({ invitationId: z.string().meta({ description: "The ID of the invitation to cancel" }) });
z.object({ id: z.string().meta({ description: "The ID of the invitation to get" }) });
z.object({ organizationId: z.string().meta({ description: "The ID of the organization to list invitations for" }).optional() }).optional();
z.object({
  userId: z.coerce.string().meta({ description: 'The user Id which represents the user to be added as a member. If `null` is provided, then it\'s expected to provide session headers. Eg: "user-id"' }),
  role: z.union([z.string(), z.array(z.string())]).meta({ description: 'The role(s) to assign to the new member. Eg: ["admin", "sale"]' }),
  organizationId: z.string().meta({ description: `An optional organization ID to pass. If not provided, will default to the user's active organization. Eg: "org-id"` }).optional(),
  teamId: z.string().meta({ description: 'An optional team ID to add the member to. Eg: "team-id"' }).optional()
});
z.object({
  memberIdOrEmail: z.string().meta({ description: "The ID or email of the member to remove" }),
  organizationId: z.string().meta({ description: 'The ID of the organization to remove the member from. If not provided, the active organization will be used. Eg: "org-id"' }).optional()
});
z.object({
  role: z.union([z.string(), z.array(z.string())]).meta({ description: 'The new role to be applied. This can be a string or array of strings representing the roles. Eg: ["admin", "sale"]' }),
  memberId: z.string().meta({ description: 'The member id to apply the role update to. Eg: "member-id"' }),
  organizationId: z.string().meta({ description: 'An optional organization ID which the member is a part of to apply the role update. If not provided, you must provide session headers to get the active organization. Eg: "organization-id"' }).optional()
});
z.object({ organizationId: z.string().meta({ description: 'The organization Id for the member to leave. Eg: "organization-id"' }) });
z.object({
  userId: z.string().meta({ description: "The user ID to get the role for. If not provided, will default to the current user's" }).optional(),
  organizationId: z.string().meta({ description: `The organization ID to list members for. If not provided, will default to the user's active organization. Eg: "organization-id"` }).optional(),
  organizationSlug: z.string().meta({ description: `The organization slug to list members for. If not provided, will default to the user's active organization. Eg: "organization-slug"` }).optional()
}).optional();
z.object({
  name: z.string().min(1).meta({ description: "The name of the organization" }),
  slug: z.string().min(1).meta({ description: "The slug of the organization" }),
  userId: z.coerce.string().meta({ description: 'The user id of the organization creator. If not provided, the current user will be used. Should only be used by admins or when called by the server. server-only. Eg: "user-id"' }).optional(),
  logo: z.string().meta({ description: "The logo of the organization" }).optional(),
  metadata: z.record(z.string(), z.any()).meta({ description: "The metadata of the organization" }).optional(),
  keepCurrentActiveOrganization: z.boolean().meta({ description: "Whether to keep the current active organization active after creating a new one. Eg: true" }).optional()
});
z.object({ slug: z.string().meta({ description: 'The organization slug to check. Eg: "my-org"' }) });
z.object({
  name: z.string().min(1).meta({ description: "The name of the organization" }).optional(),
  slug: z.string().min(1).meta({ description: "The slug of the organization" }).optional(),
  logo: z.string().meta({ description: "The logo of the organization" }).optional(),
  metadata: z.record(z.string(), z.any()).meta({ description: "The metadata of the organization" }).optional()
});
z.object({ organizationId: z.string().meta({ description: "The organization id to delete" }) });
z.optional(z.object({
  organizationId: z.string().meta({ description: "The organization id to get" }).optional(),
  organizationSlug: z.string().meta({ description: "The organization slug to get" }).optional(),
  membersLimit: z.number().or(z.string().transform((val) => parseInt(val))).meta({ description: "The limit of members to get. By default, it uses the membershipLimit option which defaults to 100." }).optional()
}));
z.object({
  organizationId: z.string().meta({ description: 'The organization id to set as active. It can be null to unset the active organization. Eg: "org-id"' }).nullable().optional(),
  organizationSlug: z.string().meta({ description: 'The organization slug to set as active. It can be null to unset the active organization if organizationId is not provided. Eg: "org-slug"' }).optional()
});
const roleSchema = z.string();
const invitationStatus = z.enum([
  "pending",
  "accepted",
  "rejected",
  "canceled"
]).default("pending");
z.object({
  id: z.string().default(generateId$1),
  name: z.string(),
  slug: z.string(),
  logo: z.string().nullish().optional(),
  metadata: z.record(z.string(), z.unknown()).or(z.string().transform((v) => JSON.parse(v))).optional(),
  createdAt: z.date()
});
z.object({
  id: z.string().default(generateId$1),
  organizationId: z.string(),
  userId: z.coerce.string(),
  role: roleSchema,
  createdAt: z.date().default(() => /* @__PURE__ */ new Date())
});
z.object({
  id: z.string().default(generateId$1),
  organizationId: z.string(),
  email: z.string(),
  role: roleSchema,
  status: invitationStatus,
  teamId: z.string().nullish(),
  inviterId: z.string(),
  expiresAt: z.date(),
  createdAt: z.date().default(() => /* @__PURE__ */ new Date())
});
z.object({
  id: z.string().default(generateId$1),
  name: z.string().min(1),
  organizationId: z.string(),
  createdAt: z.date(),
  updatedAt: z.date().optional()
});
z.object({
  id: z.string().default(generateId$1),
  teamId: z.string(),
  userId: z.string(),
  createdAt: z.date().default(() => /* @__PURE__ */ new Date())
});
z.object({
  id: z.string().default(generateId$1),
  organizationId: z.string(),
  role: z.string(),
  permission: z.record(z.string(), z.array(z.string())),
  createdAt: z.date().default(() => /* @__PURE__ */ new Date()),
  updatedAt: z.date().optional()
});
const defaultRoles = [
  "admin",
  "member",
  "owner"
];
z.union([z.enum(defaultRoles), z.array(z.enum(defaultRoles))]);
z.object({
  name: z.string().meta({ description: 'The name of the team. Eg: "my-team"' }),
  organizationId: z.string().meta({ description: 'The organization ID which the team will be created in. Defaults to the active organization. Eg: "organization-id"' }).optional()
});
z.object({
  teamId: z.string().meta({ description: `The team ID of the team to remove. Eg: "team-id"` }),
  organizationId: z.string().meta({ description: `The organization ID which the team falls under. If not provided, it will default to the user's active organization. Eg: "organization-id"` }).optional()
});
z.optional(z.object({ organizationId: z.string().meta({ description: `The organization ID which the teams are under to list. Defaults to the users active organization. Eg: "organization-id"` }).optional() }));
z.object({ teamId: z.string().meta({ description: "The team id to set as active. It can be null to unset the active team" }).nullable().optional() });
z.optional(z.object({ teamId: z.string().optional().meta({ description: "The team whose members we should return. If this is not provided the members of the current active team get returned." }) }));
z.object({
  teamId: z.string().meta({ description: "The team the user should be a member of." }),
  userId: z.coerce.string().meta({ description: "The user Id which represents the user to be added as a member." })
});
z.object({
  teamId: z.string().meta({ description: "The team the user should be removed from." }),
  userId: z.coerce.string().meta({ description: "The user which should be removed from the team." })
});
z.object({ organizationId: z.string().optional() }).and(z.union([z.object({
  permission: z.record(z.string(), z.array(z.string())),
  permissions: z.undefined()
}), z.object({
  permission: z.undefined(),
  permissions: z.record(z.string(), z.array(z.string()))
})]));
z.object({
  phoneNumber: z.string().meta({ description: 'Phone number to sign in. Eg: "+1234567890"' }),
  password: z.string().meta({ description: "Password to use for sign in." }),
  rememberMe: z.boolean().meta({ description: "Remember the session. Eg: true" }).optional()
});
z.object({ phoneNumber: z.string().meta({ description: 'Phone number to send OTP. Eg: "+1234567890"' }) });
z.object({
  phoneNumber: z.string().meta({ description: 'Phone number to verify. Eg: "+1234567890"' }),
  code: z.string().meta({ description: 'OTP code. Eg: "123456"' }),
  disableSession: z.boolean().meta({ description: "Disable session creation after verification. Eg: false" }).optional(),
  updatePhoneNumber: z.boolean().meta({ description: "Check if there is a session and update the phone number. Eg: true" }).optional()
});
z.object({ phoneNumber: z.string() });
z.object({
  otp: z.string().meta({ description: 'The one time password to reset the password. Eg: "123456"' }),
  phoneNumber: z.string().meta({ description: 'The phone number to the account which intends to reset the password for. Eg: "+1234567890"' }),
  newPassword: z.string().meta({ description: `The new password. Eg: "new-and-secure-password"` })
});
z.object({
  walletAddress: z.string().regex(/^0[xX][a-fA-F0-9]{40}$/i).length(42),
  chainId: z.number().int().positive().max(2147483647).optional().default(1)
});
z.object({
  code: z.string().meta({ description: `A backup code to verify. Eg: "123456"` }),
  disableSession: z.boolean().meta({ description: "If true, the session cookie will not be set." }).optional(),
  trustDevice: z.boolean().meta({ description: "If true, the device will be trusted for 30 days. It'll be refreshed on every sign in request within this time. Eg: true" }).optional()
});
z.object({ userId: z.coerce.string().meta({ description: `The user ID to view all backup codes. Eg: "user-id"` }) });
z.object({ password: z.string().meta({ description: "The users password." }) });
z.object({
  code: z.string().meta({ description: 'The otp code to verify. Eg: "012345"' }),
  trustDevice: z.boolean().optional().meta({ description: "If true, the device will be trusted for 30 days. It'll be refreshed on every sign in request within this time. Eg: true" })
});
z.object({ trustDevice: z.boolean().optional().meta({ description: "If true, the device will be trusted for 30 days. It'll be refreshed on every sign in request within this time. Eg: true" }) }).optional();
z.object({ secret: z.string().meta({ description: "The secret to generate the TOTP code" }) });
z.object({ password: z.string().meta({ description: "User password" }) });
z.object({
  code: z.string().meta({ description: 'The otp code to verify. Eg: "012345"' }),
  trustDevice: z.boolean().meta({ description: "If true, the device will be trusted for 30 days. It'll be refreshed on every sign in request within this time. Eg: true" }).optional()
});
z.object({
  password: z.string().meta({ description: "User password" }),
  issuer: z.string().meta({ description: "Custom issuer for the TOTP URI" }).optional()
});
z.object({ password: z.string().meta({ description: "User password" }) });
z.object({
  username: z.string().meta({ description: "The username of the user" }),
  password: z.string().meta({ description: "The password of the user" }),
  rememberMe: z.boolean().meta({ description: "Remember the user session" }).optional(),
  callbackURL: z.string().meta({ description: "The URL to redirect to after email verification" }).optional()
});
z.object({ username: z.string().meta({ description: "The username to check" }) });
const coreBuilder = QuestpieBuilder.empty("questpie-core").fields(defaultFields);
const usersCollection = coreBuilder.collection("user").options({ timestamps: true }).fields((f) => ({
  name: f.text({ required: true, maxLength: 255 }),
  email: f.email({ required: true, maxLength: 255, unique: true }),
  emailVerified: f.boolean({ required: true }),
  image: f.url({ maxLength: 500 }),
  role: f.text({ maxLength: 50 }),
  // Optional: Better Auth role handling
  banned: f.boolean({ default: false }),
  // Optional: Better Auth ban handling
  banReason: f.text({ maxLength: 255 }),
  banExpires: f.datetime()
})).title(({ f }) => f.name);
const sessionsCollection = coreBuilder.collection("session").options({ timestamps: true }).fields((f) => ({
  userId: f.text({ required: true, maxLength: 255 }),
  token: f.text({ required: true, maxLength: 255, unique: true }),
  expiresAt: f.datetime({ required: true }),
  ipAddress: f.text({ maxLength: 45 }),
  userAgent: f.text({ maxLength: 500 }),
  impersonatedBy: f.text({ maxLength: 255 })
})).title(({ f }) => f.token);
const accountsCollection = coreBuilder.collection("account").options({ timestamps: true }).fields((f) => ({
  userId: f.text({ required: true, maxLength: 255 }),
  accountId: f.text({ required: true, maxLength: 255 }),
  providerId: f.text({ required: true, maxLength: 255 }),
  accessToken: f.text({ maxLength: 500 }),
  refreshToken: f.text({ maxLength: 500 }),
  accessTokenExpiresAt: f.datetime(),
  refreshTokenExpiresAt: f.datetime(),
  scope: f.text({ maxLength: 255 }),
  idToken: f.text({ maxLength: 500 }),
  password: f.text({ maxLength: 255 })
  // Optional: if using credential account here
})).title(({ f }) => f.providerId);
const verificationsCollection = coreBuilder.collection("verification").options({ timestamps: true }).fields((f) => ({
  identifier: f.text({ required: true, maxLength: 255 }),
  value: f.text({ required: true, maxLength: 255 }),
  expiresAt: f.datetime({ required: true })
})).title(({ f }) => f.identifier);
const apiKeysCollection = coreBuilder.collection("apikey").options({ timestamps: true }).fields((f) => ({
  name: f.text({ maxLength: 255 }),
  start: f.text({ maxLength: 255 }),
  prefix: f.text({ maxLength: 255 }),
  key: f.text({ required: true, maxLength: 500, unique: true }),
  userId: f.text({ required: true, maxLength: 255 }),
  refillInterval: f.number(),
  refillAmount: f.number(),
  lastRefillAt: f.datetime(),
  enabled: f.boolean({ default: true }),
  rateLimitEnabled: f.boolean({ default: true }),
  rateLimitTimeWindow: f.number(),
  rateLimitMax: f.number(),
  requestCount: f.number({ default: 0 }),
  remaining: f.number(),
  lastRequest: f.datetime(),
  expiresAt: f.datetime(),
  permissions: f.textarea(),
  // Larger text for JSON permissions
  metadata: f.textarea()
  // Larger text for JSON metadata
})).title(({ f }) => f.key);
const coreAuthOptions = auth({
  baseURL: process.env.BETTER_AUTH_URL,
  secret: process.env.BETTER_AUTH_SECRET,
  advanced: {
    useSecureCookies: process.env.NODE_ENV === "production"
  },
  plugins: [admin(), apiKey(), bearer()],
  emailAndPassword: {
    enabled: true,
    requireEmailVerification: true
  }
});
const assetsCollection = coreBuilder.collection("assets").options({
  timestamps: true
}).fields((f) => ({
  // Image dimensions (optional)
  width: f.number(),
  height: f.number(),
  // Descriptive metadata
  alt: f.text({ maxLength: 500 }),
  caption: f.textarea()
})).upload({
  visibility: "public"
}).hooks({
  afterDelete: async ({ data, app }) => {
    const cms2 = app;
    const record = data;
    if (!cms2?.storage || !record?.key) return;
    try {
      await cms2.storage.use().delete(record.key);
    } catch (error2) {
      cms2.logger?.warn?.("Failed to delete asset file from storage", {
        key: record.key,
        error: error2 instanceof Error ? error2.message : String(error2)
      });
    }
  }
}).title(({ f }) => f.filename);
const coreBackendMessages = {
  en: {
    // General errors
    "error.notFound": "Resource not found",
    "error.notFound.withId": "{{resource}} with ID {{id}} not found",
    "error.forbidden": "Access forbidden",
    "error.unauthorized": "Unauthorized",
    "error.validation": "Validation failed",
    "error.internal": "Internal server error",
    "error.badRequest": "Bad request",
    "error.conflict": "Resource conflict",
    "error.notImplemented": "Not implemented",
    "error.timeout": "Request timeout",
    // CRUD errors
    "crud.create.forbidden": "You don't have permission to create this resource",
    "crud.read.forbidden": "You don't have permission to read this resource",
    "crud.update.forbidden": "You don't have permission to update this resource",
    "crud.delete.forbidden": "You don't have permission to delete this resource",
    "crud.notFound": "{{resource}} not found",
    // Validation errors
    "validation.required": "{{field}} is required",
    "validation.invalidType": "{{field}} must be a {{expected}}",
    "validation.string.tooSmall": "{{field}} must be at least {{min}} characters",
    "validation.string.tooBig": "{{field}} must be at most {{max}} characters",
    "validation.string.email": "{{field}} must be a valid email",
    "validation.string.url": "{{field}} must be a valid URL",
    "validation.string.uuid": "{{field}} must be a valid UUID",
    "validation.string.regex": "{{field}} has invalid format",
    "validation.number.tooSmall": "{{field}} must be at least {{min}}",
    "validation.number.tooBig": "{{field}} must be at most {{max}}",
    "validation.number.notInteger": "{{field}} must be an integer",
    "validation.number.notPositive": "{{field}} must be positive",
    "validation.number.notNegative": "{{field}} must be negative",
    "validation.array.tooSmall": "{{field}} must have at least {{min}} items",
    "validation.array.tooBig": "{{field}} must have at most {{max}} items",
    "validation.date.invalid": "{{field}} must be a valid date",
    "validation.date.tooEarly": "{{field}} must be after {{min}}",
    "validation.date.tooLate": "{{field}} must be before {{max}}",
    // Auth errors
    "auth.invalidCredentials": "Invalid credentials",
    "auth.sessionExpired": "Session expired",
    "auth.tokenInvalid": "Invalid token",
    "auth.tokenExpired": "Token expired",
    "auth.accountLocked": "Account locked",
    "auth.emailNotVerified": "Email not verified",
    "auth.userNotFound": "User not found",
    "auth.userAlreadyExists": "User already exists",
    // Upload errors
    "upload.tooLarge": "File too large (max {{max}})",
    "upload.invalidType": "Invalid file type. Allowed: {{allowed}}",
    "upload.failed": "Upload failed",
    // Hook errors
    "hook.beforeCreate.failed": "Pre-create validation failed",
    "hook.afterCreate.failed": "Post-create processing failed",
    "hook.beforeUpdate.failed": "Pre-update validation failed",
    "hook.afterUpdate.failed": "Post-update processing failed",
    "hook.beforeDelete.failed": "Pre-delete validation failed",
    "hook.afterDelete.failed": "Post-delete processing failed",
    "hook.validate.failed": "Validation hook failed",
    // Access errors
    "access.denied": "Access denied",
    "access.fieldDenied": "Access to field {{field}} denied",
    "access.operationDenied": "Operation {{operation}} not allowed",
    // Database constraint errors
    "error.database.uniqueViolation": "{{field}} already exists",
    "error.database.foreignKeyViolation": "Referenced {{resource}} does not exist",
    "error.database.notNullViolation": "{{field}} cannot be null",
    "error.database.checkViolation": "{{field}} violates check constraint"
  }
};
const starterBase = QuestpieBuilder.empty("questpie-starter");
const realtimeCleanupJob = starterBase.job({
  name: "questpie.realtime.cleanup",
  schema: z$1.object({}),
  options: {
    cron: "0 * * * *"
  },
  handler: async ({ app }) => {
    await app.realtime.cleanupOutbox(true);
  }
});
const starterModule = starterBase.collections({
  assets: assetsCollection,
  user: usersCollection,
  session: sessionsCollection
}).collections({
  account: accountsCollection,
  verification: verificationsCollection,
  apikey: apiKeysCollection
}).jobs({
  realtimeCleanup: realtimeCleanupJob
}).auth(coreAuthOptions).messages(coreBackendMessages);
function rpc() {
  const typedFn2 = fn.typed();
  return {
    fn: typedFn2,
    router(router2) {
      return router2;
    }
  };
}
function config(config2) {
  return config2;
}
const baseBuilder = questpie({ name: "questpie" }).fields(defaultFields);
const callableQ = createCallableBuilder(baseBuilder);
const q = Object.assign(callableQ, {
  /**
   * Starter module - opt-in "batteries included" module
   * Includes auth collections and assets with file upload support
   * @example q({ name: "app" }).use(q.starter).build({...})
   */
  starter: starterModule,
  /**
   * Define CLI configuration (questpie.config.ts)
   * @example export default q.config({ app: cms, cli: { migrations: { directory: "./migrations" } } })
   */
  config,
  /**
   * Create standalone RPC contract builder.
   */
  rpc
});
function introspectBlock(blockDef) {
  const state = blockDef.state;
  return {
    name: state.name ?? blockDef.name,
    admin: state.admin,
    allowChildren: state.allowChildren,
    maxChildren: state.maxChildren,
    hasPrefetch: typeof state.prefetch === "function",
    fields: blockDef.getFieldMetadata()
  };
}
function introspectBlocks(blocks2) {
  if (!blocks2) {
    return {};
  }
  const schemas = {};
  for (const [name2, blockDef] of Object.entries(blocks2)) {
    schemas[name2] = introspectBlock(blockDef);
  }
  return schemas;
}
function getBlocksOperators() {
  return {
    column: {
      // Check if any block of a specific type exists
      hasBlockType: (col, value) => sql$1`EXISTS (
					SELECT 1 FROM jsonb_array_elements(${col}->'_tree') AS block
					WHERE block->>'type' = ${value}
				)`,
      // Count blocks at root level
      blockCount: (col, value) => {
        const { op, count: count2 } = value;
        const operator2 = op === "gte" ? ">=" : op === "lte" ? "<=" : "=";
        return sql$1`jsonb_array_length(${col}->'_tree') ${sql$1.raw(operator2)} ${count2}`;
      },
      // Check if document is empty (no blocks)
      isEmpty: (col) => sql$1`(
					${col} IS NULL 
					OR ${col}->'_tree' IS NULL
					OR jsonb_array_length(${col}->'_tree') = 0
				)`,
      isNotEmpty: (col) => sql$1`(
					${col} IS NOT NULL 
					AND ${col}->'_tree' IS NOT NULL
					AND jsonb_array_length(${col}->'_tree') > 0
				)`,
      isNull: (col) => isNull$2(col),
      isNotNull: (col) => isNotNull$1(col)
    },
    jsonb: {
      hasBlockType: (col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`EXISTS (
					SELECT 1 FROM jsonb_array_elements(${col}#>'{${sql$1.raw(path)},_tree}') AS block
					WHERE block->>'type' = ${value}
				)`;
      },
      isEmpty: (col, _value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(
					${col}#>'{${sql$1.raw(path)}}' IS NULL 
					OR ${col}#>'{${sql$1.raw(path)},_tree}' IS NULL
					OR jsonb_array_length(${col}#>'{${sql$1.raw(path)},_tree}') = 0
				)`;
      },
      isNotEmpty: (col, _value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(
					${col}#>'{${sql$1.raw(path)}}' IS NOT NULL 
					AND ${col}#>'{${sql$1.raw(path)},_tree}' IS NOT NULL
					AND jsonb_array_length(${col}#>'{${sql$1.raw(path)},_tree}') > 0
				)`;
      },
      isNull: (col, _value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`${col}#>'{${sql$1.raw(path)}}' IS NULL`;
      },
      isNotNull: (col, _value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`${col}#>'{${sql$1.raw(path)}}' IS NOT NULL`;
      }
    }
  };
}
const blocksField = defineField()({
  type: "blocks",
  _value: void 0,
  toColumn(_name, config2) {
    let column = jsonb();
    if (config2.required && config2.nullable !== true) {
      column = column.notNull();
    }
    if (config2.default !== void 0) {
      const defaultValue = typeof config2.default === "function" ? config2.default() : config2.default;
      column = column.default(defaultValue);
    }
    return column;
  },
  toZodSchema(config2) {
    const blockNodeSchema = z$1.lazy(
      () => z$1.object({
        id: z$1.string(),
        type: z$1.string(),
        children: z$1.array(blockNodeSchema).default([])
      })
    );
    let docSchema = z$1.object({
      _tree: z$1.array(blockNodeSchema),
      _values: z$1.record(z$1.string(), z$1.record(z$1.string(), z$1.any()))
    });
    if (config2.minBlocks !== void 0 || config2.maxBlocks !== void 0) {
      docSchema = docSchema.refine(
        (doc) => {
          const count2 = doc._tree.length;
          if (config2.minBlocks !== void 0 && count2 < config2.minBlocks) {
            return false;
          }
          if (config2.maxBlocks !== void 0 && count2 > config2.maxBlocks) {
            return false;
          }
          return true;
        },
        {
          message: config2.minBlocks !== void 0 && config2.maxBlocks !== void 0 ? `Must have between ${config2.minBlocks} and ${config2.maxBlocks} blocks` : config2.minBlocks !== void 0 ? `Must have at least ${config2.minBlocks} blocks` : `Must have at most ${config2.maxBlocks} blocks`
        }
      );
    }
    if (config2._blockDefinitions && Object.keys(config2._blockDefinitions).length > 0) {
      const blockDefs = config2._blockDefinitions;
      docSchema = docSchema.superRefine((doc, ctx) => {
        const allNodes = [];
        const collectNodes = (nodes) => {
          for (const node of nodes) {
            allNodes.push(node);
            if (node.children.length > 0) {
              collectNodes(node.children);
            }
          }
        };
        collectNodes(doc._tree);
        for (const node of allNodes) {
          const blockDef = blockDefs[node.type];
          if (!blockDef?.state.fields) continue;
          const blockValues = doc._values[node.id] || {};
          for (const [fieldName, fieldDef] of Object.entries(
            blockDef.state.fields
          )) {
            if (fieldDef && typeof fieldDef === "object" && "toZodSchema" in fieldDef && typeof fieldDef.toZodSchema === "function") {
              const fieldSchema = fieldDef.toZodSchema();
              const result2 = fieldSchema.safeParse(blockValues[fieldName]);
              if (!result2.success) {
                for (const issue of result2.error.issues) {
                  ctx.addIssue({
                    ...issue,
                    path: ["_values", node.id, fieldName, ...issue.path],
                    message: `Block "${node.type}" field "${fieldName}": ${issue.message}`
                  });
                }
              }
            }
          }
        }
      });
    }
    if (!config2.required && config2.nullable !== false) {
      return docSchema.nullish();
    }
    return docSchema;
  },
  getOperators() {
    return getBlocksOperators();
  },
  getMetadata(config2) {
    return {
      type: "blocks",
      label: config2.label,
      description: config2.description,
      required: config2.required ?? false,
      localized: config2.localized ?? false,
      readOnly: config2.input === false,
      writeOnly: config2.output === false,
      meta: config2.meta,
      // Blocks specific
      allowedBlocks: config2.allowedBlocks,
      minBlocks: config2.minBlocks,
      maxBlocks: config2.maxBlocks,
      allowNesting: config2.allowNesting ?? true,
      maxDepth: config2.maxDepth ?? 3,
      placeholder: config2.placeholder
    };
  }
});
function getRichTextOperators() {
  return {
    column: {
      // Full-text search in document content
      contains: (col, value) => {
        return sql$1`EXISTS (
					SELECT 1 FROM jsonb_array_elements_text(
						jsonb_path_query_array(${col}, '$..text')
					) AS t
					WHERE t ILIKE ${"%" + value + "%"}
				)`;
      },
      // Check if document is empty (no content or only whitespace)
      isEmpty: (col) => sql$1`(
					${col} IS NULL 
					OR ${col} = '{"type":"doc"}'::jsonb 
					OR ${col} = '{"type":"doc","content":[]}'::jsonb
					OR NOT EXISTS (
						SELECT 1 FROM jsonb_array_elements_text(
							jsonb_path_query_array(${col}, '$..text')
						) AS t
						WHERE length(trim(t)) > 0
					)
				)`,
      isNotEmpty: (col) => sql$1`(
					${col} IS NOT NULL 
					AND ${col} != '{"type":"doc"}'::jsonb 
					AND ${col} != '{"type":"doc","content":[]}'::jsonb
					AND EXISTS (
						SELECT 1 FROM jsonb_array_elements_text(
							jsonb_path_query_array(${col}, '$..text')
						) AS t
						WHERE length(trim(t)) > 0
					)
				)`,
      isNull: (col) => isNull$2(col),
      isNotNull: (col) => isNotNull$1(col)
    },
    jsonb: {
      contains: (col, value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`EXISTS (
					SELECT 1 FROM jsonb_array_elements_text(
						jsonb_path_query_array(${col}#>'{${sql$1.raw(path)}}', '$..text')
					) AS t
					WHERE t ILIKE ${"%" + value + "%"}
				)`;
      },
      isEmpty: (col, _value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(
					${col}#>'{${sql$1.raw(path)}}' IS NULL 
					OR ${col}#>'{${sql$1.raw(path)}}' = '{"type":"doc"}'::jsonb
				)`;
      },
      isNotEmpty: (col, _value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`(
					${col}#>'{${sql$1.raw(path)}}' IS NOT NULL 
					AND ${col}#>'{${sql$1.raw(path)}}' != '{"type":"doc"}'::jsonb
				)`;
      },
      isNull: (col, _value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`${col}#>'{${sql$1.raw(path)}}' IS NULL`;
      },
      isNotNull: (col, _value, ctx) => {
        const path = ctx.jsonbPath?.join(",") ?? "";
        return sql$1`${col}#>'{${sql$1.raw(path)}}' IS NOT NULL`;
      }
    }
  };
}
const DEFAULT_FEATURES = [
  "bold",
  "italic",
  "link",
  "heading",
  "bulletList",
  "orderedList"
];
const DEFAULT_HEADING_LEVELS = [1, 2, 3];
const richTextField = defineField()(
  {
    type: "richText",
    _value: void 0,
    toColumn(_name, config2) {
      let column = jsonb();
      if (config2.required && config2.nullable !== true) {
        column = column.notNull();
      }
      if (config2.default !== void 0) {
        const defaultValue = typeof config2.default === "function" ? config2.default() : config2.default;
        column = column.default(defaultValue);
      }
      return column;
    },
    toZodSchema(config2) {
      const nodeSchema = z$1.lazy(
        () => z$1.object({
          type: z$1.string(),
          attrs: z$1.record(z$1.string(), z$1.any()).optional(),
          content: z$1.array(nodeSchema).optional(),
          marks: z$1.array(
            z$1.object({
              type: z$1.string(),
              attrs: z$1.record(z$1.string(), z$1.any()).optional()
            })
          ).optional(),
          text: z$1.string().optional()
        })
      );
      const docSchema = z$1.object({
        type: z$1.literal("doc"),
        content: z$1.array(nodeSchema).optional()
      });
      if (!config2.required && config2.nullable !== false) {
        return docSchema.nullish();
      }
      return docSchema;
    },
    getOperators() {
      return getRichTextOperators();
    },
    getMetadata(config2) {
      return {
        type: "richText",
        label: config2.label,
        description: config2.description,
        required: config2.required ?? false,
        localized: config2.localized ?? false,
        readOnly: config2.input === false,
        writeOnly: config2.output === false,
        meta: config2.meta,
        // Rich text specific
        maxCharacters: config2.maxCharacters,
        minCharacters: config2.minCharacters,
        features: config2.features ?? DEFAULT_FEATURES,
        headingLevels: config2.headingLevels ?? DEFAULT_HEADING_LEVELS,
        placeholder: config2.placeholder,
        allowImages: config2.allowImages,
        imageCollection: config2.imageCollection
      };
    }
  }
);
const adminFields = {
  richText: richTextField,
  blocks: blocksField
};
const adminPreferencesCollection = q.collection("admin_preferences").fields((f) => ({
  // User who owns this preference
  userId: f.text({ required: true, maxLength: 255, label: "User ID" }),
  // Preference key (e.g., "viewState:posts")
  key: f.text({ required: true, maxLength: 255, label: "Key" }),
  // Preference value (JSON)
  value: f.json({ required: true, label: "Value" })
})).options({
  timestamps: true
}).indexes(({ table }) => [
  // Unique constraint on userId + key
  // Type assertion needed due to Drizzle ORM duplicate dependency resolution
  uniqueIndex("admin_preferences_user_key_idx").on(
    table.userId,
    table.key
  )
]);
const locksCollection = q.collection("admin_locks").fields((f) => ({
  // Resource type: "collection" or "global"
  resourceType: f.select({
    required: true,
    options: [
      { value: "collection", label: "Collection" },
      { value: "global", label: "Global" }
    ],
    label: "Resource Type"
  }),
  // Resource name (collection slug or global slug)
  resource: f.text({
    required: true,
    maxLength: 255,
    label: "Resource"
  }),
  // Document ID being locked
  resourceId: f.text({
    required: true,
    maxLength: 255,
    label: "Resource ID"
  }),
  // User who holds the lock (relation to user collection)
  user: f.relation({
    to: "user",
    required: true,
    label: "User"
  }),
  // Browser session ID (unique per tab, allows same user to edit in multiple tabs)
  sessionId: f.text({
    required: true,
    maxLength: 64,
    label: "Session ID"
  }),
  // Lock expiration time (refreshed by heartbeat)
  expiresAt: f.date({
    required: true,
    label: "Expires At"
  })
})).options({
  timestamps: true
});
const savedViewsCollection = q.collection("admin_saved_views").fields((f) => ({
  // User who owns this saved view
  userId: f.text({ required: true, maxLength: 255, label: "User ID" }),
  // Target collection for this view
  collectionName: f.text({
    required: true,
    maxLength: 255,
    label: "Collection Name"
  }),
  // Display name for the view
  name: f.text({ required: true, maxLength: 255, label: "Name" }),
  // View configuration (filters, sort, columns)
  configuration: f.json({
    required: true,
    label: "Configuration"
  }),
  // Whether this is the default view for the user/collection
  isDefault: f.boolean({ default: false, label: "Is Default" })
})).options({
  timestamps: true
});
function getApp$4(ctx) {
  return ctx.app;
}
async function hasReadAccess(readRule, ctx) {
  if (readRule === void 0 || readRule === true) return true;
  if (readRule === false) return false;
  try {
    const result2 = await executeAccessRule(readRule, {
      cms: ctx.app,
      db: ctx.db,
      session: ctx.session,
      locale: ctx.locale
    });
    return result2 !== false;
  } catch {
    return true;
  }
}
function extractCollectionsMeta(cms2) {
  const result2 = {};
  const collections = cms2.getCollections();
  for (const [name2, collection] of Object.entries(collections)) {
    const admin2 = collection.state?.admin;
    if (admin2) {
      result2[name2] = {
        label: admin2.label,
        description: admin2.description,
        icon: admin2.icon,
        hidden: admin2.hidden,
        group: admin2.group,
        order: admin2.order
      };
    } else {
      result2[name2] = {};
    }
  }
  return result2;
}
function extractGlobalsMeta(cms2) {
  const result2 = {};
  const globals = cms2.getGlobals();
  for (const [name2, global2] of Object.entries(globals)) {
    const admin2 = global2.state?.admin;
    if (admin2) {
      result2[name2] = {
        label: admin2.label,
        description: admin2.description,
        icon: admin2.icon,
        hidden: admin2.hidden,
        group: admin2.group,
        order: admin2.order
      };
    } else {
      result2[name2] = {};
    }
  }
  return result2;
}
function buildAutoSidebar(collectionsMeta, globalsMeta) {
  const ungrouped = [];
  const grouped = {};
  for (const [name2, meta2] of Object.entries(collectionsMeta)) {
    if (meta2.hidden) continue;
    if (meta2.group) {
      if (!grouped[meta2.group]) grouped[meta2.group] = [];
      grouped[meta2.group].push({ name: name2, meta: meta2 });
    } else {
      ungrouped.push({ name: name2, meta: meta2 });
    }
  }
  const sortByOrder = (a, b) => (a.meta.order ?? 0) - (b.meta.order ?? 0);
  ungrouped.sort(sortByOrder);
  for (const items of Object.values(grouped)) {
    items.sort(sortByOrder);
  }
  const sections2 = [];
  if (ungrouped.length > 0) {
    sections2.push({
      id: "content",
      title: { en: "Content" },
      items: ungrouped.map(({ name: name2, meta: meta2 }) => ({
        type: "collection",
        collection: name2,
        label: meta2.label,
        icon: meta2.icon
      }))
    });
  }
  const sortedGroupNames = Object.keys(grouped).sort();
  for (const groupName of sortedGroupNames) {
    const items = grouped[groupName];
    sections2.push({
      id: `group:${groupName}`,
      title: { en: groupName.charAt(0).toUpperCase() + groupName.slice(1) },
      items: items.map(({ name: name2, meta: meta2 }) => ({
        type: "collection",
        collection: name2,
        label: meta2.label,
        icon: meta2.icon
      }))
    });
  }
  const visibleGlobals = Object.entries(globalsMeta).filter(
    ([, meta2]) => !meta2.hidden
  );
  if (visibleGlobals.length > 0) {
    visibleGlobals.sort(([, a], [, b]) => (a.order ?? 0) - (b.order ?? 0));
    sections2.push({
      id: "globals",
      title: { en: "Globals" },
      items: visibleGlobals.map(([name2, meta2]) => ({
        type: "global",
        global: name2,
        label: meta2.label,
        icon: meta2.icon
      }))
    });
  }
  return { sections: sections2 };
}
function filterSidebarConfig(config2, accessibleCollections, accessibleGlobals) {
  return {
    sections: config2.sections.map((s2) => ({
      ...s2,
      items: (s2.items ?? []).filter((item) => {
        if (item.type === "collection")
          return accessibleCollections.has(item.collection);
        if (item.type === "global")
          return accessibleGlobals.has(item.global);
        return true;
      })
    })).filter(
      (s2) => (s2.items?.length ?? 0) > 0 || (s2.sections?.length ?? 0) > 0
    )
  };
}
function collectSidebarReferences(config2) {
  const collections = /* @__PURE__ */ new Set();
  const globals = /* @__PURE__ */ new Set();
  function collectFromSection(section) {
    for (const item of section.items ?? []) {
      if (item.type === "collection") collections.add(item.collection);
      else if (item.type === "global") globals.add(item.global);
    }
    for (const subSection of section.sections ?? []) {
      collectFromSection(subSection);
    }
  }
  for (const section of config2.sections) {
    collectFromSection(section);
  }
  return { collections, globals };
}
function assignWidgetIds(items) {
  let counter = 0;
  function walk(items2) {
    for (const item of items2) {
      if (item.type === "section") {
        walk(item.items || []);
      } else if (item.type === "tabs") {
        for (const tab of item.tabs || []) {
          walk(tab.items || []);
        }
      } else {
        if (!item.id) {
          item.id = `__auto_${item.type}_${counter++}`;
        }
      }
    }
  }
  walk(items);
}
async function processDashboardItems(items, accessibleCollections, accessCtx) {
  const result2 = [];
  for (const item of items) {
    if (item.type === "section") {
      const filtered = await processDashboardItems(
        item.items || [],
        accessibleCollections,
        accessCtx
      );
      if (filtered.length > 0) {
        result2.push({ ...item, items: filtered });
      }
      continue;
    }
    if (item.type === "tabs") {
      const tabs = [];
      for (const tab of item.tabs || []) {
        const filtered = await processDashboardItems(
          tab.items || [],
          accessibleCollections,
          accessCtx
        );
        tabs.push({ ...tab, items: filtered });
      }
      result2.push({ ...item, tabs });
      continue;
    }
    const widget = item;
    if (widget.access !== void 0) {
      const widgetAccessResult = typeof widget.access === "function" ? await widget.access({
        cms: accessCtx.app,
        db: accessCtx.db,
        session: accessCtx.session,
        locale: accessCtx.locale
      }) : widget.access;
      if (widgetAccessResult === false) continue;
    }
    if (widget.collection && !accessibleCollections.has(widget.collection)) {
      continue;
    }
    if (widget.type === "quickActions") {
      const actions = (widget.actions || []).filter((action) => {
        if (action.action?.type === "create") {
          return accessibleCollections.has(action.action.collection);
        }
        return true;
      });
      const { fetchFn: fetchFn2, access: access2, ...serializable2 } = widget;
      result2.push({ ...serializable2, actions });
      continue;
    }
    const { fetchFn, access, filterFn, ...serializable } = widget;
    if (fetchFn) {
      serializable.hasFetchFn = true;
    }
    result2.push(serializable);
  }
  return result2;
}
const getAdminConfigSchema = z$1.object({}).optional();
const getAdminConfigOutputSchema = z$1.object({
  dashboard: z$1.unknown().optional(),
  sidebar: z$1.unknown().optional(),
  branding: z$1.unknown().optional(),
  blocks: z$1.record(z$1.string(), z$1.unknown()).optional(),
  collections: z$1.record(z$1.string(), z$1.unknown()).optional(),
  globals: z$1.record(z$1.string(), z$1.unknown()).optional(),
  uploads: z$1.object({
    collections: z$1.array(z$1.string()),
    defaultCollection: z$1.string().optional()
  }).optional()
});
const getAdminConfig = fn({
  type: "query",
  schema: getAdminConfigSchema,
  outputSchema: getAdminConfigOutputSchema,
  handler: async (ctx) => {
    const cms2 = getApp$4(ctx);
    const state = cms2.state || {};
    const collections = cms2.getCollections();
    const globals = cms2.getGlobals();
    const accessCtx = {
      app: cms2,
      session: ctx.session,
      db: ctx.db,
      locale: ctx.locale
    };
    const accessibleCollections = /* @__PURE__ */ new Set();
    for (const [name2, col] of Object.entries(collections)) {
      if (await hasReadAccess(col.state?.access?.read, accessCtx)) {
        accessibleCollections.add(name2);
      }
    }
    const accessibleGlobals = /* @__PURE__ */ new Set();
    for (const [name2, g] of Object.entries(globals)) {
      if (await hasReadAccess(g.state?.access?.read, accessCtx)) {
        accessibleGlobals.add(name2);
      }
    }
    const allCollectionsMeta = extractCollectionsMeta(cms2);
    const allGlobalsMeta = extractGlobalsMeta(cms2);
    const filteredCollectionsMeta = Object.fromEntries(
      Object.entries(allCollectionsMeta).filter(
        ([n2]) => accessibleCollections.has(n2)
      )
    );
    const filteredGlobalsMeta = Object.fromEntries(
      Object.entries(allGlobalsMeta).filter(([n2]) => accessibleGlobals.has(n2))
    );
    const response = {};
    const uploadCollections = Object.entries(collections).filter(
      ([name2, collection]) => accessibleCollections.has(name2) && Boolean(collection?.state?.upload)
    ).map(([name2]) => name2);
    response.uploads = {
      collections: uploadCollections,
      defaultCollection: uploadCollections.length === 1 ? uploadCollections[0] : void 0
    };
    if (state.branding) {
      response.branding = state.branding;
    }
    if (state.dashboard) {
      const dashboard = state.dashboard;
      if (dashboard.items) {
        assignWidgetIds(dashboard.items);
      }
      response.dashboard = {
        ...dashboard,
        items: dashboard.items ? await processDashboardItems(
          dashboard.items,
          accessibleCollections,
          accessCtx
        ) : void 0
      };
    }
    if (state.sidebar) {
      const filteredSidebar = filterSidebarConfig(
        state.sidebar,
        accessibleCollections,
        accessibleGlobals
      );
      const referenced = collectSidebarReferences(state.sidebar);
      const unlistedCollectionsMeta = Object.fromEntries(
        Object.entries(filteredCollectionsMeta).filter(
          ([name2, meta2]) => !referenced.collections.has(name2) && !meta2.hidden
        )
      );
      const unlistedGlobalsMeta = Object.fromEntries(
        Object.entries(filteredGlobalsMeta).filter(
          ([name2, meta2]) => !referenced.globals.has(name2) && !meta2.hidden
        )
      );
      const unlistedSidebar = buildAutoSidebar(
        unlistedCollectionsMeta,
        unlistedGlobalsMeta
      );
      response.sidebar = {
        sections: [...filteredSidebar.sections, ...unlistedSidebar.sections]
      };
    } else {
      response.sidebar = buildAutoSidebar(
        filteredCollectionsMeta,
        filteredGlobalsMeta
      );
    }
    if (state.blocks && Object.keys(state.blocks).length > 0) {
      response.blocks = introspectBlocks(state.blocks);
    }
    response.collections = filteredCollectionsMeta;
    response.globals = filteredGlobalsMeta;
    return response;
  }
});
const adminConfigFunctions = {
  getAdminConfig
};
function getActionsConfig(app, collectionSlug) {
  const state = app.state;
  const collection = state.collections?.[collectionSlug];
  if (!collection) {
    return null;
  }
  const collectionState = collection.state || collection;
  const actionsConfig = collectionState.adminActions;
  if (!actionsConfig) {
    return {
      builtin: ["create", "save", "delete", "deleteMany"],
      custom: []
    };
  }
  const customWithoutHandlers = (actionsConfig.custom || []).map((action) => {
    const { handler: handler2, ...rest } = action;
    return rest;
  });
  return {
    builtin: actionsConfig.builtin || [
      "create",
      "save",
      "delete",
      "deleteMany"
    ],
    custom: customWithoutHandlers
  };
}
async function executeAction(app, request, session) {
  const {
    collection: collectionSlug,
    actionId,
    itemId,
    itemIds,
    data,
    locale
  } = request;
  const state = app.state;
  const collection = state.collections?.[collectionSlug];
  if (!collection) {
    return {
      success: false,
      error: `Collection "${collectionSlug}" not found`
    };
  }
  const collectionState = collection.state || collection;
  const actionsConfig = collectionState.adminActions;
  const builtinActions = actionsConfig?.builtin || [
    "create",
    "save",
    "delete",
    "deleteMany",
    "duplicate"
  ];
  if (builtinActions.includes(actionId)) {
    return executeBuiltinAction(app, {
      collectionSlug,
      actionId,
      itemId,
      itemIds,
      data
    });
  }
  const customAction = actionsConfig?.custom?.find((a) => a.id === actionId);
  if (!customAction) {
    return {
      success: false,
      error: `Action "${actionId}" not found on collection "${collectionSlug}"`
    };
  }
  if (customAction.form) {
    const validationError = validateActionFormData(
      customAction.form.fields,
      data || {}
    );
    if (validationError) {
      return {
        success: false,
        result: {
          type: "error",
          toast: { message: validationError }
        }
      };
    }
  }
  try {
    const context = {
      data: data || {},
      itemId,
      itemIds,
      app,
      db: app.db,
      session,
      locale
    };
    const result2 = await customAction.handler(context);
    return {
      success: result2.type === "success" || result2.type === "redirect",
      result: result2
    };
  } catch (error2) {
    console.error(`Action "${actionId}" failed:`, error2);
    return {
      success: false,
      result: {
        type: "error",
        toast: {
          message: error2 instanceof Error ? error2.message : "Action execution failed"
        }
      }
    };
  }
}
async function executeBuiltinAction(app, params) {
  const { collectionSlug, actionId, itemId, itemIds, data } = params;
  try {
    switch (actionId) {
      case "create": {
        const result2 = await app.create(collectionSlug, data || {});
        return {
          success: true,
          result: {
            type: "success",
            toast: { message: "Item created successfully" },
            effects: {
              invalidate: [collectionSlug],
              redirect: `/admin/collections/${collectionSlug}/${result2.id}`
            }
          }
        };
      }
      case "save": {
        if (!itemId) {
          return {
            success: false,
            result: {
              type: "error",
              toast: { message: "Item ID is required for save action" }
            }
          };
        }
        await app.update(collectionSlug, itemId, data || {});
        return {
          success: true,
          result: {
            type: "success",
            toast: { message: "Item saved successfully" },
            effects: { invalidate: [collectionSlug] }
          }
        };
      }
      case "delete": {
        if (!itemId) {
          return {
            success: false,
            result: {
              type: "error",
              toast: { message: "Item ID is required for delete action" }
            }
          };
        }
        await app.delete(collectionSlug, itemId);
        return {
          success: true,
          result: {
            type: "success",
            toast: { message: "Item deleted successfully" },
            effects: {
              invalidate: [collectionSlug],
              redirect: `/admin/collections/${collectionSlug}`
            }
          }
        };
      }
      case "deleteMany": {
        if (!itemIds || itemIds.length === 0) {
          return {
            success: false,
            result: {
              type: "error",
              toast: {
                message: "Item IDs are required for bulk delete action"
              }
            }
          };
        }
        await Promise.all(
          itemIds.map((id) => app.delete(collectionSlug, id))
        );
        return {
          success: true,
          result: {
            type: "success",
            toast: { message: `${itemIds.length} items deleted successfully` },
            effects: { invalidate: [collectionSlug] }
          }
        };
      }
      case "duplicate": {
        if (!itemId) {
          return {
            success: false,
            result: {
              type: "error",
              toast: { message: "Item ID is required for duplicate action" }
            }
          };
        }
        const original = await app.findById(collectionSlug, itemId);
        if (!original) {
          return {
            success: false,
            result: {
              type: "error",
              toast: { message: "Item not found" }
            }
          };
        }
        const { id, createdAt, updatedAt, ...duplicateData } = original;
        const duplicated = await app.create(
          collectionSlug,
          duplicateData
        );
        return {
          success: true,
          result: {
            type: "success",
            toast: { message: "Item duplicated successfully" },
            effects: {
              invalidate: [collectionSlug],
              redirect: `/admin/collections/${collectionSlug}/${duplicated.id}`
            }
          }
        };
      }
      default:
        return {
          success: false,
          result: {
            type: "error",
            toast: { message: `Unknown built-in action: ${actionId}` }
          }
        };
    }
  } catch (error2) {
    console.error(`Built-in action "${actionId}" failed:`, error2);
    return {
      success: false,
      result: {
        type: "error",
        toast: {
          message: error2 instanceof Error ? error2.message : "Action execution failed"
        }
      }
    };
  }
}
function isFieldDefinition(field) {
  return typeof field.getMetadata === "function";
}
function isFieldRequired(field) {
  if (isFieldDefinition(field)) {
    return !!field.state?.required;
  }
  return !!field.required;
}
function validateActionFormData(fields2, data) {
  for (const [fieldName, fieldConfig] of Object.entries(fields2)) {
    if (isFieldRequired(fieldConfig) && !data[fieldName]) {
      return `Field "${fieldName}" is required`;
    }
  }
  return null;
}
const executeActionRequestSchema = z$1.object({
  collection: z$1.string(),
  actionId: z$1.string(),
  itemId: z$1.string().optional(),
  itemIds: z$1.array(z$1.string()).optional(),
  data: z$1.record(z$1.string(), z$1.unknown()).optional(),
  locale: z$1.string().optional()
});
const executeActionResponseSchema = z$1.object({
  success: z$1.boolean(),
  result: z$1.unknown().optional(),
  error: z$1.string().optional()
});
const getActionsConfigRequestSchema = z$1.object({
  collection: z$1.string()
});
const getActionsConfigResponseSchema = z$1.object({
  builtin: z$1.array(z$1.string()),
  custom: z$1.array(z$1.unknown())
}).nullable();
const executeActionFn = fn({
  type: "mutation",
  schema: executeActionRequestSchema,
  outputSchema: executeActionResponseSchema,
  handler: async (ctx) => {
    const app = ctx.app;
    const session = ctx.session;
    return executeAction(app, ctx.input, session);
  }
});
const getActionsConfigFn = fn({
  type: "query",
  schema: getActionsConfigRequestSchema,
  outputSchema: getActionsConfigResponseSchema,
  handler: (ctx) => {
    const app = ctx.app;
    return getActionsConfig(app, ctx.input.collection);
  }
});
const actionFunctions = {
  executeAction: executeActionFn,
  getActionsConfig: getActionsConfigFn
};
function getApp$3(ctx) {
  return ctx.app;
}
const getContentLocalesSchema = z$1.object({}).optional();
const getContentLocalesOutputSchema = z$1.object({
  locales: z$1.array(
    z$1.object({
      code: z$1.string(),
      label: z$1.string().optional(),
      fallback: z$1.boolean().optional(),
      flagCountryCode: z$1.string().optional()
    })
  ),
  defaultLocale: z$1.string(),
  fallbacks: z$1.record(z$1.string(), z$1.string()).optional()
});
const getContentLocales = fn({
  type: "query",
  schema: getContentLocalesSchema,
  outputSchema: getContentLocalesOutputSchema,
  handler: async (ctx) => {
    const cms2 = getApp$3(ctx);
    const localeConfig = cms2.config.locale;
    if (!localeConfig) {
      return {
        locales: [{ code: "en", label: "English", fallback: true }],
        defaultLocale: "en"
      };
    }
    const locales = typeof localeConfig.locales === "function" ? await localeConfig.locales() : localeConfig.locales;
    return {
      locales: locales.map(
        (l2) => ({
          code: l2.code,
          label: l2.label,
          fallback: l2.fallback,
          flagCountryCode: l2.flagCountryCode
        })
      ),
      defaultLocale: localeConfig.defaultLocale,
      fallbacks: localeConfig.fallbacks
    };
  }
});
const localeFunctions = {
  getContentLocales
};
const DRAFT_MODE_COOKIE = "__draft_mode";
function createDraftModeCookie(enabled, maxAge = 3600) {
  if (enabled) {
    return `${DRAFT_MODE_COOKIE}=true; Path=/; Max-Age=${maxAge}; SameSite=Lax; HttpOnly`;
  }
  return `${DRAFT_MODE_COOKIE}=; Path=/; Max-Age=0; SameSite=Lax; HttpOnly`;
}
function getPreviewSecret() {
  const secret = process.env.PREVIEW_SECRET || process.env.SECRET || "dev-preview-secret";
  if (process.env.NODE_ENV === "production" && secret === "dev-preview-secret") {
    console.warn(
      "[preview] Using default secret in production. Set PREVIEW_SECRET or SECRET env var."
    );
  }
  return secret;
}
function base64UrlEncode(input) {
  const buffer = Buffer.isBuffer(input) ? input : Buffer.from(input);
  return buffer.toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
}
function base64UrlDecode(input) {
  let base642 = input.replace(/-/g, "+").replace(/_/g, "/");
  const padding = base642.length % 4;
  if (padding) {
    base642 += "=".repeat(4 - padding);
  }
  return Buffer.from(base642, "base64").toString("utf8");
}
const mintPreviewTokenSchema = z$1.object({
  path: z$1.string().min(1, "Path is required"),
  ttlMs: z$1.number().positive().optional()
});
const mintPreviewTokenOutputSchema = z$1.object({
  token: z$1.string(),
  expiresAt: z$1.number()
});
const verifyPreviewTokenSchema = z$1.object({
  token: z$1.string()
});
const verifyPreviewTokenOutputSchema = z$1.object({
  valid: z$1.boolean(),
  path: z$1.string().optional(),
  error: z$1.string().optional()
});
const DEFAULT_TTL_MS = 60 * 60 * 1e3;
function createPreviewFunctions(secret) {
  const signPayload = (payload) => {
    const signature = createHmac("sha256", secret).update(payload).digest();
    return base64UrlEncode(signature);
  };
  const mintPreviewToken = fn({
    type: "mutation",
    schema: mintPreviewTokenSchema,
    outputSchema: mintPreviewTokenOutputSchema,
    handler: async ({ input, session }) => {
      if (!session) {
        throw new Error("Unauthorized: Admin session required");
      }
      const { path, ttlMs = DEFAULT_TTL_MS } = input;
      const expiresAt = Date.now() + ttlMs;
      const payload = { path, exp: expiresAt };
      const payloadString = JSON.stringify(payload);
      const encodedPayload = base64UrlEncode(payloadString);
      const signature = signPayload(encodedPayload);
      return {
        token: `${encodedPayload}.${signature}`,
        expiresAt
      };
    }
  });
  const verifyPreviewToken2 = fn({
    type: "query",
    schema: verifyPreviewTokenSchema,
    outputSchema: verifyPreviewTokenOutputSchema,
    handler: async ({ input }) => {
      const { token: token2 } = input;
      const [encodedPayload, signature] = token2.split(".");
      if (!encodedPayload || !signature) {
        return { valid: false, error: "Invalid token format" };
      }
      const expectedSignature = signPayload(encodedPayload);
      const signatureBuffer = Uint8Array.from(Buffer.from(signature));
      const expectedBuffer = Uint8Array.from(Buffer.from(expectedSignature));
      if (signatureBuffer.length !== expectedBuffer.length) {
        return { valid: false, error: "Invalid signature" };
      }
      if (!timingSafeEqual$1(signatureBuffer, expectedBuffer)) {
        return { valid: false, error: "Invalid signature" };
      }
      try {
        const payload = JSON.parse(
          base64UrlDecode(encodedPayload)
        );
        if (!payload?.exp || typeof payload.exp !== "number") {
          return { valid: false, error: "Invalid payload" };
        }
        if (payload.exp < Date.now()) {
          return { valid: false, error: "Token expired" };
        }
        if (!payload.path || typeof payload.path !== "string") {
          return { valid: false, error: "Invalid path" };
        }
        return { valid: true, path: payload.path };
      } catch {
        return { valid: false, error: "Invalid payload" };
      }
    }
  });
  return {
    mintPreviewToken,
    verifyPreviewToken: verifyPreviewToken2
  };
}
function verifyPreviewTokenDirect(token2, secret) {
  const [encodedPayload, signature] = token2.split(".");
  if (!encodedPayload || !signature) return null;
  const expectedSignature = base64UrlEncode(
    createHmac("sha256", secret).update(encodedPayload).digest()
  );
  const signatureBuffer = Uint8Array.from(Buffer.from(signature));
  const expectedBuffer = Uint8Array.from(Buffer.from(expectedSignature));
  if (signatureBuffer.length !== expectedBuffer.length) return null;
  if (!timingSafeEqual$1(signatureBuffer, expectedBuffer)) return null;
  try {
    const payload = JSON.parse(
      base64UrlDecode(encodedPayload)
    );
    if (!payload?.exp || typeof payload.exp !== "number") return null;
    if (payload.exp < Date.now()) return null;
    if (!payload.path || typeof payload.path !== "string") return null;
    return payload;
  } catch {
    return null;
  }
}
function createPreviewTokenVerifier(secret) {
  const resolvedSecret = secret ?? getPreviewSecret();
  return (token2) => {
    return verifyPreviewTokenDirect(token2, resolvedSecret);
  };
}
const previewFunctions = createPreviewFunctions(getPreviewSecret());
function getApp$2(ctx) {
  return ctx.app;
}
function buildReactiveContext(formData, siblingData, prevData, prevSiblingData, serverCtx) {
  return {
    data: formData,
    sibling: siblingData || {},
    prev: {
      data: prevData || formData,
      sibling: prevSiblingData || siblingData || {}
    },
    ctx: serverCtx
  };
}
function buildOptionsContext(formData, siblingData, search, page, limit, serverCtx) {
  return {
    data: formData,
    sibling: siblingData || {},
    search,
    page,
    limit,
    ctx: serverCtx
  };
}
function getCollection(cms2, collectionName) {
  const collections = cms2.getCollections();
  const collection = collections[collectionName];
  if (!collection) {
    throw new Error(`Collection '${collectionName}' not found`);
  }
  return collection;
}
function getFieldDefinition(cms2, collectionName, fieldPath) {
  const collection = getCollection(cms2, collectionName);
  const fieldDefinitions = collection.state.fieldDefinitions || {};
  const parts = fieldPath.split(".");
  let currentDefs = fieldDefinitions;
  let fieldDef = null;
  for (let i = 0; i < parts.length; i++) {
    const part = parts[i];
    if (/^\d+$/.test(part)) {
      continue;
    }
    if (currentDefs[part]) {
      fieldDef = currentDefs[part];
      if (fieldDef.getNestedFields) {
        currentDefs = fieldDef.getNestedFields();
      } else if (fieldDef.state?.config?.of) {
        const ofField = fieldDef.state.config.of;
        if (ofField?.getNestedFields) {
          currentDefs = ofField.getNestedFields();
        }
      }
    } else {
      throw new Error(`Field '${part}' not found in path '${fieldPath}'`);
    }
  }
  if (!fieldDef) {
    throw new Error(
      `Field '${fieldPath}' not found in collection '${collectionName}'`
    );
  }
  return fieldDef;
}
function normalizeFieldPath(fieldPath) {
  return fieldPath.split(".").filter((part) => !/^\d+$/.test(part)).join(".");
}
function getFieldPathCandidates(fieldPath) {
  const normalized = normalizeFieldPath(fieldPath);
  const candidates = /* @__PURE__ */ new Set([normalized]);
  const parts = normalized.split(".");
  if (parts.length > 1) {
    const leaf = parts[parts.length - 1];
    if (leaf) {
      candidates.add(leaf);
    }
  }
  return candidates;
}
function findReactiveFieldEntryInLayoutItems(items, fieldCandidates) {
  if (!Array.isArray(items)) {
    return null;
  }
  for (const item of items) {
    if (!item || typeof item !== "object") {
      continue;
    }
    const entry = item;
    if (typeof entry.field === "string" && fieldCandidates.has(entry.field)) {
      return entry;
    }
    if (entry.type === "section") {
      const found = findReactiveFieldEntryInLayoutItems(
        entry.fields,
        fieldCandidates
      );
      if (found) {
        return found;
      }
      continue;
    }
    if (entry.type === "tabs") {
      const found = findReactiveFieldEntryInTabs(entry.tabs, fieldCandidates);
      if (found) {
        return found;
      }
    }
  }
  return null;
}
function findReactiveFieldEntryInSections(sections2, fieldCandidates) {
  if (!Array.isArray(sections2)) {
    return null;
  }
  for (const section of sections2) {
    if (!section || typeof section !== "object") {
      continue;
    }
    const sectionConfig = section;
    const found = findReactiveFieldEntryInLayoutItems(
      sectionConfig.fields,
      fieldCandidates
    );
    if (found) {
      return found;
    }
  }
  return null;
}
function findReactiveFieldEntryInTabs(tabs, fieldCandidates) {
  if (!Array.isArray(tabs)) {
    return null;
  }
  for (const tab of tabs) {
    if (!tab || typeof tab !== "object") {
      continue;
    }
    const tabConfig = tab;
    const fromFields = findReactiveFieldEntryInLayoutItems(
      tabConfig.fields,
      fieldCandidates
    );
    if (fromFields) {
      return fromFields;
    }
    const fromSections = findReactiveFieldEntryInSections(
      tabConfig.sections,
      fieldCandidates
    );
    if (fromSections) {
      return fromSections;
    }
  }
  return null;
}
function findReactiveFieldEntry(formConfig, fieldPath) {
  if (!formConfig || typeof formConfig !== "object") {
    return null;
  }
  const fieldCandidates = getFieldPathCandidates(fieldPath);
  const form = formConfig;
  const fromFields = findReactiveFieldEntryInLayoutItems(
    form.fields,
    fieldCandidates
  );
  if (fromFields) {
    return fromFields;
  }
  const fromSections = findReactiveFieldEntryInSections(
    form.sections,
    fieldCandidates
  );
  if (fromSections) {
    return fromSections;
  }
  const fromTabs = findReactiveFieldEntryInTabs(form.tabs, fieldCandidates);
  if (fromTabs) {
    return fromTabs;
  }
  if (form.sidebar && typeof form.sidebar === "object") {
    const sidebar2 = form.sidebar;
    return findReactiveFieldEntryInLayoutItems(sidebar2.fields, fieldCandidates);
  }
  return null;
}
function getReactiveHandler(cms2, collectionName, fieldPath, handlerType) {
  const collection = getCollection(cms2, collectionName);
  const formConfig = collection.state.adminForm;
  const fieldEntry = findReactiveFieldEntry(formConfig, fieldPath);
  if (!fieldEntry) {
    return null;
  }
  const handlerConfig = fieldEntry[handlerType];
  if (!handlerConfig || typeof handlerConfig === "boolean") {
    return null;
  }
  if (typeof handlerConfig === "function") {
    return handlerConfig;
  }
  if (typeof handlerConfig === "object" && handlerConfig !== null && "handler" in handlerConfig && typeof handlerConfig.handler === "function") {
    return handlerConfig.handler;
  }
  return null;
}
function getOptionsHandler(fieldDef) {
  const config2 = fieldDef.state?.config;
  const options = config2?.options;
  if (!options) return null;
  if (typeof options === "object" && "handler" in options) {
    return options.handler;
  }
  return null;
}
const reactiveRequestSchema = z$1.object({
  /** Field path (supports nested paths like "items.0.variant") */
  field: z$1.string(),
  /** Type of reactive operation */
  type: z$1.enum(["hidden", "readOnly", "disabled", "compute"]),
  /** Current form data */
  formData: z$1.record(z$1.string(), z$1.unknown()),
  /** Sibling data (for array items) */
  siblingData: z$1.record(z$1.string(), z$1.unknown()).nullable().optional(),
  /** Previous form data (for change detection) */
  prevData: z$1.record(z$1.string(), z$1.unknown()).nullable().optional(),
  /** Previous sibling data */
  prevSiblingData: z$1.record(z$1.string(), z$1.unknown()).nullable().optional()
});
const batchReactiveInputSchema = z$1.object({
  /** Collection name */
  collection: z$1.string(),
  /** Array of reactive requests */
  requests: z$1.array(reactiveRequestSchema)
});
const reactiveResultSchema = z$1.object({
  /** Field path */
  field: z$1.string(),
  /** Type of reactive operation */
  type: z$1.enum(["hidden", "readOnly", "disabled", "compute"]),
  /** Computed value */
  value: z$1.unknown(),
  /** Error message if handler failed */
  error: z$1.string().optional()
});
const batchReactiveOutputSchema = z$1.object({
  results: z$1.array(reactiveResultSchema)
});
const optionsInputSchema = z$1.object({
  /** Collection name */
  collection: z$1.string(),
  /** Field path */
  field: z$1.string(),
  /** Current form data */
  formData: z$1.record(z$1.string(), z$1.unknown()),
  /** Sibling data (for array items) */
  siblingData: z$1.record(z$1.string(), z$1.unknown()).nullable().optional(),
  /** Search query */
  search: z$1.string().default(""),
  /** Page number (0-based) */
  page: z$1.number().int().min(0).default(0),
  /** Items per page */
  limit: z$1.number().int().min(1).max(100).default(20)
});
const optionsOutputSchema = z$1.object({
  options: z$1.array(
    z$1.object({
      value: z$1.union([z$1.string(), z$1.number()]),
      label: z$1.union([z$1.string(), z$1.record(z$1.string(), z$1.string())])
    })
  ),
  hasMore: z$1.boolean().optional(),
  total: z$1.number().optional()
});
const batchReactive = fn({
  type: "query",
  schema: batchReactiveInputSchema,
  outputSchema: batchReactiveOutputSchema,
  handler: async (ctx) => {
    const cms2 = getApp$2(ctx);
    const { collection: collectionName, requests } = ctx.input;
    const serverCtx = {
      db: ctx.db,
      user: ctx.session?.user ?? null,
      req: new Request("http://localhost"),
      // Placeholder - not used in handlers
      locale: ctx.locale ?? "en"
    };
    const results = [];
    for (const request of requests) {
      const { field, type: type2, formData, siblingData, prevData, prevSiblingData } = request;
      try {
        getFieldDefinition(cms2, collectionName, field);
        const handler2 = getReactiveHandler(cms2, collectionName, field, type2);
        if (!handler2) {
          results.push({
            field,
            type: type2,
            value: void 0,
            error: `No ${type2} handler found for field '${field}'`
          });
          continue;
        }
        const reactiveCtx = buildReactiveContext(
          formData,
          siblingData,
          prevData,
          prevSiblingData,
          serverCtx
        );
        const value = await handler2(reactiveCtx);
        results.push({
          field,
          type: type2,
          value
        });
      } catch (error2) {
        results.push({
          field,
          type: type2,
          value: void 0,
          error: error2 instanceof Error ? error2.message : String(error2)
        });
      }
    }
    return { results };
  }
});
const fieldOptions = fn({
  type: "query",
  schema: optionsInputSchema,
  outputSchema: optionsOutputSchema,
  handler: async (ctx) => {
    const cms2 = getApp$2(ctx);
    const {
      collection: collectionName,
      field,
      formData,
      siblingData,
      search,
      page,
      limit
    } = ctx.input;
    const serverCtx = {
      db: ctx.db,
      user: ctx.session?.user ?? null,
      req: new Request("http://localhost"),
      // Placeholder - not used in handlers
      locale: ctx.locale ?? "en"
    };
    try {
      const fieldDef = getFieldDefinition(cms2, collectionName, field);
      const handler2 = getOptionsHandler(fieldDef);
      if (!handler2) {
        const config2 = fieldDef.state?.config;
        if (Array.isArray(config2?.options)) {
          let options = config2.options;
          if (search) {
            const searchLower = search.toLowerCase();
            options = options.filter((opt) => {
              const label = typeof opt.label === "string" ? opt.label : Object.values(opt.label).join(" ");
              return label.toLowerCase().includes(searchLower);
            });
          }
          const start = page * limit;
          const paginatedOptions = options.slice(start, start + limit);
          return {
            options: paginatedOptions,
            hasMore: start + limit < options.length,
            total: options.length
          };
        }
        return {
          options: [],
          hasMore: false
        };
      }
      const optionsCtx = buildOptionsContext(
        formData,
        siblingData,
        search,
        page,
        limit,
        serverCtx
      );
      const result2 = await handler2(optionsCtx);
      return {
        options: result2.options || [],
        hasMore: result2.hasMore,
        total: result2.total
      };
    } catch (error2) {
      console.error(
        `Error fetching options for ${collectionName}.${field}:`,
        error2
      );
      return {
        options: [],
        hasMore: false
      };
    }
  }
});
const reactiveFunctions = {
  batchReactive,
  fieldOptions
};
function getApp$1(ctx) {
  return ctx.app;
}
const isSetupRequiredSchema = z$1.object({});
const isSetupRequiredOutputSchema = z$1.object({
  required: z$1.boolean()
});
const createFirstAdminSchema = z$1.object({
  email: z$1.string().email("Invalid email address"),
  password: z$1.string().min(8, "Password must be at least 8 characters"),
  name: z$1.string().min(2, "Name must be at least 2 characters")
});
const createFirstAdminOutputSchema = z$1.object({
  success: z$1.boolean(),
  user: z$1.object({
    id: z$1.string(),
    email: z$1.string(),
    name: z$1.string()
  }).optional(),
  error: z$1.string().optional()
});
const isSetupRequired = fn({
  type: "query",
  schema: isSetupRequiredSchema,
  outputSchema: isSetupRequiredOutputSchema,
  handler: async (ctx) => {
    const app = getApp$1(ctx);
    const userCollection = app.getCollectionConfig("user");
    const result2 = await app.db.select({ count: sql$1`count(*)::int` }).from(userCollection.table);
    return { required: result2[0].count === 0 };
  }
});
const createFirstAdmin = fn({
  type: "mutation",
  schema: createFirstAdminSchema,
  outputSchema: createFirstAdminOutputSchema,
  handler: async (ctx) => {
    const app = getApp$1(ctx);
    const input = ctx.input;
    const userCollection = app.getCollectionConfig("user");
    const checkResult = await app.db.select({ count: sql$1`count(*)::int` }).from(userCollection.table);
    if (checkResult[0].count > 0) {
      return {
        success: false,
        error: "Setup already completed - users exist in the system"
      };
    }
    try {
      const signUpResult = await app.auth.api.signUpEmail({
        body: {
          email: input.email,
          password: input.password,
          name: input.name
        }
      });
      if (!signUpResult.user) {
        return {
          success: false,
          error: "Failed to create user account"
        };
      }
      await app.db.update(userCollection.table).set({
        role: "admin",
        emailVerified: true
      }).where(eq(userCollection.table.id, signUpResult.user.id));
      return {
        success: true,
        user: {
          id: signUpResult.user.id,
          email: signUpResult.user.email,
          name: signUpResult.user.name
        }
      };
    } catch (error2) {
      return {
        success: false,
        error: error2 instanceof Error ? error2.message : "An unexpected error occurred"
      };
    }
  }
});
const setupFunctions = {
  isSetupRequired,
  createFirstAdmin
};
const cs = {
  // Common
  "common.save": "Uloit",
  "common.cancel": "Zruit",
  "common.delete": "Smazat",
  "common.edit": "Upravit",
  "common.create": "Vytvoit",
  "common.add": "Pidat",
  "common.remove": "Odstranit",
  "common.close": "Zavt",
  "common.form": "Formul",
  "common.search": "Vyhledat",
  "common.filter": "Filtr",
  "common.refresh": "Obnovit",
  "common.loading": "Natn...",
  "common.confirm": "Potvrdit",
  "common.back": "Zpt",
  "common.next": "Dal",
  "common.previous": "Pedchoz",
  "common.actions": "Akce",
  "common.more": "Vce",
  "common.yes": "Ano",
  "common.no": "Ne",
  "common.ok": "OK",
  "common.apply": "Pout",
  "common.reset": "Resetovat",
  "common.clear": "Vymazat",
  "common.selectAll": "Vybrat ve",
  "common.deselectAll": "Zruit vbr",
  "common.duplicate": "Duplikovat",
  "common.copy": "Koprovat",
  "common.paste": "Vloit",
  "common.upload": "Nahrt",
  "common.download": "Sthnout",
  "common.preview": "Nhled",
  "common.view": "Zobrazit",
  "common.open": "Otevt",
  "common.retry": "Opakovat",
  "common.submit": "Odeslat",
  // Navigation
  "nav.dashboard": "Dashboard",
  "nav.collections": "Kolekce",
  "nav.globals": "Globly",
  "nav.media": "Mdia",
  "nav.settings": "Nastaven",
  "nav.logout": "Odhlsit se",
  "nav.home": "Dom",
  "nav.back": "Zpt",
  // Dashboard
  "dashboard.title": "Dashboard",
  "dashboard.welcome": "Vtejte zpt",
  "dashboard.recentActivity": "Nedvn aktivita",
  "dashboard.quickActions": "Rychl akce",
  // Collections
  "collection.create": "Vytvoit {{name}}",
  "collection.edit": "Upravit {{name}}",
  "collection.delete": "Smazat {{name}}",
  "collection.deleteConfirm": "Opravdu chcete smazat {{name}}?",
  "collection.noItems": "Nenalezeny dn {{name}}",
  "collection.createFirst": "Vytvote svj prvn {{name}}",
  "collection.itemCount": {
    one: "{{count}} poloka",
    other: "{{count}} poloek"
  },
  "collection.bulkDelete": "Smazat vybran",
  "collection.bulkDeleteConfirm": "Opravdu chcete smazat {{count}} poloek?",
  "collection.bulkDeleteSuccess": {
    one: "spn smazna {{count}} poloka",
    other: "spn smazno {{count}} poloek"
  },
  "collection.bulkDeleteError": "Nepodailo se smazat poloky",
  "collection.bulkDeletePartial": {
    one: "Smazna {{success}} poloka, {{failed}} selhalo",
    other: "Smazno {{success}} poloek, {{failed}} selhalo"
  },
  "collection.bulkActionFailed": "Hromadn akce selhala",
  "collection.selected": "Vybrno {{count}}",
  "collection.selectOnPage": "Ve na tto strnce",
  "collection.selectAllMatching": "Ve vyhovujc filtru ({{count}})",
  "collection.clearSelection": "Zruit vbr",
  "collection.list": "Seznam {{name}}",
  "collection.new": "Nov {{name}}",
  "collection.duplicateSuccess": "{{name}} spn duplikovn",
  "collection.duplicateError": "Nepodailo se duplikovat {{name}}",
  // Relations
  "relation.select": "Vybrat {{name}}",
  "relation.clear": "Vymazat vbr",
  "relation.search": "Hledat {{name}}...",
  "relation.noResults": "Nenalezeny dn {{name}}",
  "relation.loading": "Natn...",
  "relation.createNew": "Vytvoit nov {{name}}",
  "relation.selected": "Vybrno {{count}}",
  "relation.removeItem": "Odstranit {{name}}",
  "relation.addItem": "Pidat {{name}}",
  "relation.noneSelected": "Nen vybrn dn {{name}}",
  "relation.noRelated": "Nenalezeny dn souvisejc poloky",
  "relation.saveFirst": "Nejprve ulote tuto poloku pro zobrazen souvisejcch poloek.",
  // Arrays
  "array.empty": "Zatm nejsou pidny dn {{name}}",
  "array.addItem": "Pidat {{name}}",
  // Blocks
  "blocks.addAbove": "Pidat nad",
  "blocks.addBelow": "Pidat pod",
  "blocks.addChild": "Pidat podzen blok",
  // Forms
  "form.id": "ID",
  "form.created": "Vytvoeno",
  "form.updated": "Aktualizovno",
  "form.required": "Toto pole je povinn",
  "form.invalid": "Neplatn hodnota",
  "form.saveChanges": "Uloit zmny",
  "form.unsavedChanges": "Mte neuloen zmny",
  "form.discardChanges": "Zahodit zmny",
  "form.discardConfirm": "Opravdu chcete zahodit zmny? Tuto akci nelze vrtit zpt.",
  "form.fieldRequired": "{{field}} je povinn",
  "form.fieldInvalid": "{{field}} je neplatn",
  "form.maxLength": "Maximln {{max}} znak",
  "form.minLength": "Minimln {{min}} znak",
  "form.maxValue": "Maximln {{max}}",
  "form.minValue": "Minimln {{min}}",
  "form.pattern": "Neplatn formt",
  "form.email": "Neplatn e-mailov adresa",
  "form.url": "Neplatn URL",
  "form.createSuccess": "{{name}} spn vytvoen",
  "form.createError": "Nepodailo se vytvoit {{name}}",
  "form.updateSuccess": "{{name}} spn aktualizovn",
  "form.updateError": "Nepodailo se aktualizovat {{name}}",
  "form.deleteSuccess": "{{name}} spn smazn",
  "form.deleteError": "Nepodailo se smazat {{name}}",
  // Auth
  "auth.login": "Pihlsit se",
  "auth.logout": "Odhlsit se",
  "auth.email": "E-mail",
  "auth.password": "Heslo",
  "auth.forgotPassword": "Zapomenut heslo?",
  "auth.resetPassword": "Resetovat heslo",
  "auth.signIn": "Pihlsit se",
  "auth.signOut": "Odhlsit se",
  "auth.signUp": "Registrovat se",
  "auth.rememberMe": "Zapamatovat si m",
  "auth.invalidCredentials": "Neplatn e-mail nebo heslo",
  "auth.sessionExpired": "Vae relace vyprela. Prosm pihlaste se znovu.",
  "auth.emailPlaceholder": "vy@priklad.cz",
  "auth.passwordPlaceholder": "Zadejte heslo",
  "auth.signingIn": "Pihlaovn...",
  "auth.creatingAdmin": "Vytven administrtora...",
  "auth.name": "Jmno",
  "auth.namePlaceholder": "Vae jmno",
  "auth.confirmPassword": "Potvrdit heslo",
  "auth.confirmPasswordPlaceholder": "Potvrte heslo",
  "auth.acceptInvite": "Pijmout pozvnku",
  "auth.acceptingInvite": "Pijmn pozvnky...",
  "auth.dontHaveAccount": "Nemte et?",
  "auth.alreadyHaveAccount": "Mte ji et?",
  "auth.emailRequired": "E-mail je povinn",
  "auth.passwordRequired": "Heslo je povinn",
  "auth.passwordMinLength": "Heslo mus mt alespo {{min}} znak",
  "auth.nameRequired": "Jmno je povinn",
  "auth.nameMinLength": "Jmno mus mt alespo {{min}} znak",
  "auth.invalidEmail": "Neplatn e-mailov adresa",
  "auth.passwordMismatch": "Hesla se neshoduj",
  "auth.newPassword": "Nov heslo",
  "auth.newPasswordPlaceholder": "Zadejte nov heslo",
  "auth.sendResetLink": "Odeslat odkaz pro reset",
  "auth.sendingResetLink": "Odesln...",
  "auth.resetLinkSent": "Odkaz pro reset hesla byl odesln na v e-mail",
  "auth.resettingPassword": "Resetovn hesla...",
  "auth.createFirstAdmin": "Vytvoit prvnho administrtora",
  "auth.setupTitle": "Nastaven",
  "auth.setupDescription": "Vytvote svj prvn administrtorsk et.",
  "auth.profile": "Profil",
  "auth.myAccount": "Mj et",
  "auth.logoutFailed": "Odhlen se nezdailo. Zkuste to prosm znovu.",
  // Errors
  "error.notFound": "Nenalezeno",
  "error.serverError": "Chyba serveru",
  "error.networkError": "Chyba st. Zkontrolujte pipojen.",
  "error.unauthorized": "Nemte oprvnn k tto akci",
  "error.forbidden": "Pstup zamtnut",
  "error.validation": "Validace selhala",
  "error.unknown": "Dolo k neznm chyb",
  "error.timeout": "Vyprel as poadavku. Zkuste to znovu.",
  "error.conflict": "Nastala kolize. Obnovte strnku a zkuste to znovu.",
  // Table
  "table.rowsPerPage": "dk na strnku",
  "table.of": "z",
  "table.noResults": "dn vsledky",
  "table.selectAll": "Vybrat ve",
  "table.selectRow": "Vybrat dek",
  "table.showing": "Zobrazeno {{from}} a {{to}} z {{total}}",
  "table.page": "Strana {{page}}",
  "table.firstPage": "Prvn strana",
  "table.lastPage": "Posledn strana",
  "table.nextPage": "Dal strana",
  "table.previousPage": "Pedchoz strana",
  "table.sortAsc": "Seadit vzestupn",
  "table.sortDesc": "Seadit sestupn",
  "table.columns": "Sloupce",
  "table.hideColumn": "Skrt sloupec",
  "table.showColumn": "Zobrazit sloupec",
  // Upload
  "upload.dropzone": "Pethnte soubory sem nebo kliknte pro nahrn",
  "upload.browse": "Prochzet soubory",
  "upload.uploading": "Nahrvn...",
  "upload.complete": "Nahrn dokoneno",
  "upload.error": "Nahrn selhalo",
  "upload.maxSize": "Soubor mus bt men ne {{size}}",
  "upload.invalidType": "Neplatn typ souboru. Povoleno: {{types}}",
  "upload.remove": "Odstranit soubor",
  "upload.replace": "Nahradit soubor",
  "upload.preview": "Nhled",
  "upload.noFile": "Nen vybrn dn soubor",
  "upload.dragDrop": "Pethnte soubory sem",
  // Editor
  "editor.bold": "Tun",
  "editor.italic": "Kurzva",
  "editor.underline": "Podtren",
  "editor.strikethrough": "Pekrtnut",
  "editor.heading": "Nadpis {{level}}",
  "editor.link": "Vloit odkaz",
  "editor.image": "Vloit obrzek",
  "editor.list": "Seznam",
  "editor.orderedList": "slovan seznam",
  "editor.unorderedList": "Odrkov seznam",
  "editor.quote": "Citace",
  "editor.code": "Kd",
  "editor.codeBlock": "Blok kdu",
  "editor.table": "Vloit tabulku",
  "editor.undo": "Zpt",
  "editor.redo": "Znovu",
  "editor.alignLeft": "Zarovnat vlevo",
  "editor.alignCenter": "Zarovnat na sted",
  "editor.alignRight": "Zarovnat vpravo",
  "editor.alignJustify": "Zarovnat do bloku",
  "editor.horizontalRule": "Horizontln ra",
  "editor.addRowBefore": "Pidat dek ped",
  "editor.addRowAfter": "Pidat dek za",
  "editor.addColumnBefore": "Pidat sloupec ped",
  "editor.addColumnAfter": "Pidat sloupec za",
  "editor.deleteRow": "Smazat dek",
  "editor.deleteColumn": "Smazat sloupec",
  "editor.deleteTable": "Smazat tabulku",
  "editor.toggleHeaderRow": "Pepnout hlaviku dku",
  "editor.toggleHeaderColumn": "Pepnout hlaviku sloupce",
  "editor.mergeCells": "Slouit buky",
  "editor.splitCell": "Rozdlit buku",
  "editor.insertUrl": "Vloit URL",
  "editor.altText": "Alternativn text (voliteln)",
  "editor.uploadFile": "Nahrt soubor",
  "editor.chooseFile": "Vybrat soubor",
  "editor.uploading": "Nahrvn...",
  "editor.browseLibrary": "Prochzet knihovnu",
  // Toasts
  "toast.success": "spch",
  "toast.error": "Chyba",
  "toast.warning": "Varovn",
  "toast.info": "Informace",
  "toast.saving": "Ukldn...",
  "toast.saveFailed": "Nepodailo se uloit zmny",
  "toast.saveSuccess": "Zmny spn uloeny",
  "toast.creating": "Vytven...",
  "toast.createSuccess": "spn vytvoeno",
  "toast.createFailed": "Nepodailo se vytvoit",
  "toast.deleting": "Mazn...",
  "toast.deleteFailed": "Nepodailo se smazat",
  "toast.deleteSuccess": "spn smazno",
  "toast.loadFailed": "Nepodailo se nast data",
  "toast.uploadFailed": "Nepodailo se nahrt soubor",
  "toast.uploadSuccess": "Soubor spn nahrn",
  "toast.copySuccess": "Zkoprovno do schrnky",
  "toast.copyFailed": "Nepodailo se zkoprovat do schrnky",
  "toast.idCopied": "ID zkoprovno do schrnky",
  "toast.validationFailed": "Validace selhala",
  "toast.validationDescription": "Zkontrolujte formul na chyby",
  "toast.created": "{{name}} vytvoen",
  "toast.updated": "{{name}} aktualizovn",
  "toast.resourceSaveFailed": "Nepodailo se uloit {{name}}",
  "toast.editComingSoon": "Funkce prav brzy dostupn",
  "toast.maxFilesWarning": "Mete pidat jen {{remaining}} dal soubor(y) (max {{max}})",
  "toast.settingsSaveFailed": "Nepodailo se uloit nastaven",
  "toast.actionSuccess": "Akce spn dokonena",
  "toast.actionFailed": "Akce selhala",
  "toast.localeChangedUnsaved": "Jazyk obsahu zmnn",
  "toast.localeChangedUnsavedDescription": "Vae neuloen zmny byly nahrazeny obsahem v novm jazyce.",
  // Confirm
  "confirm.delete": "Opravdu chcete smazat? Tuto akci nelze vrtit zpt.",
  "confirm.discard": "Opravdu chcete zahodit zmny? Tuto akci nelze vrtit zpt.",
  "confirm.unsavedChanges": "Mte neuloen zmny. Opravdu chcete odejt?",
  "confirm.action": "Opravdu chcete pokraovat?",
  "confirm.irreversible": "Tuto akci nelze vrtit zpt.",
  "confirm.localeChange": "Zahodit neuloen zmny?",
  "confirm.localeChangeDescription": "Mte neuloen zmny. Pepnut jazyka zahod zmny a nate obsah v novm jazyce.",
  "confirm.localeChangeStay": "Zstat",
  "confirm.localeChangeDiscard": "Zahodit a pepnout",
  // Status
  "status.draft": "Koncept",
  "status.published": "Publikovno",
  "status.archived": "Archivovno",
  "status.pending": "ek",
  "status.active": "Aktivn",
  "status.inactive": "Neaktivn",
  // Dates
  "date.today": "Dnes",
  "date.yesterday": "Vera",
  "date.tomorrow": "Ztra",
  "date.selectDate": "Vybrat datum",
  "date.selectTime": "Vybrat as",
  "date.clear": "Vymazat datum",
  // Accessibility
  "a11y.openMenu": "Otevt menu",
  "a11y.closeMenu": "Zavt menu",
  "a11y.expand": "Rozbalit",
  "a11y.collapse": "Sbalit",
  "a11y.loading": "Natn",
  "a11y.required": "Povinn",
  "a11y.optional": "Voliteln",
  "a11y.selected": "Vybrno",
  "a11y.notSelected": "Nen vybrno",
  // Locale
  "locale.language": "Jazyk",
  "locale.switchLanguage": "Pepnout jazyk",
  "locale.contentLanguage": "Jazyk obsahu",
  "locale.uiLanguage": "Jazyk rozhran",
  // ===========================================
  // Default Collections
  // ===========================================
  // Users Collection
  "defaults.users.label": "Uivatel",
  "defaults.users.description": "Spravovat uivatele a jejich role",
  "defaults.users.fields.name.label": "Jmno",
  "defaults.users.fields.name.placeholder": "Zadejte jmno uivatele",
  "defaults.users.fields.email.label": "E-mail",
  "defaults.users.fields.email.description": "E-mailov adresa (jen pro ten)",
  "defaults.users.fields.role.label": "Role",
  "defaults.users.fields.role.options.admin": "Administrtor",
  "defaults.users.fields.role.options.user": "Uivatel",
  "defaults.users.fields.emailVerified.label": "E-mail oven",
  "defaults.users.fields.emailVerified.description": "Zda uivatel ovil svou e-mailovou adresu",
  "defaults.users.fields.banned.label": "Blokovn",
  "defaults.users.fields.banned.description": "Zabrnit uivateli pstup do systmu",
  "defaults.users.fields.banReason.label": "Dvod blokace",
  "defaults.users.fields.banReason.placeholder": "Zadejte dvod blokace...",
  "defaults.users.sections.basicInfo": "Zkladn informace",
  "defaults.users.sections.permissions": "Oprvnn",
  "defaults.users.sections.accessControl": "zen pstupu",
  "defaults.users.actions.createUser.label": "Vytvoit uivatele",
  "defaults.users.actions.createUser.title": "Vytvoit uivatele",
  "defaults.users.actions.createUser.description": "Vytvoit nov uivatelsk et s pihlaovacmi daji.",
  "defaults.users.actions.createUser.fields.password.label": "Heslo",
  "defaults.users.actions.createUser.fields.password.placeholder": "Zadejte heslo",
  "defaults.users.actions.createUser.submit": "Vytvoit uivatele",
  "defaults.users.actions.createUser.success": "Uivatel {{email}} spn vytvoen. Sdlejte pihlaovac daje s uivatelem.",
  "defaults.users.actions.createUser.errorNoAuth": "Auth klient nen nakonfigurovn. Nelze vytvoit uivatele.",
  "defaults.users.actions.resetPassword.label": "Resetovat heslo",
  "defaults.users.actions.resetPassword.title": "Resetovat heslo",
  "defaults.users.actions.resetPassword.description": "Nastavit nov heslo pro tohoto uivatele.",
  "defaults.users.actions.resetPassword.fields.newPassword.label": "Nov heslo",
  "defaults.users.actions.resetPassword.fields.newPassword.placeholder": "Zadejte nov heslo",
  "defaults.users.actions.resetPassword.fields.confirmPassword.label": "Potvrdit heslo",
  "defaults.users.actions.resetPassword.fields.confirmPassword.placeholder": "Potvrte nov heslo",
  "defaults.users.actions.resetPassword.submit": "Resetovat heslo",
  "defaults.users.actions.resetPassword.success": "Heslo spn resetovno!",
  "defaults.users.actions.resetPassword.errorMismatch": "Hesla se neshoduj",
  "defaults.users.actions.delete.label": "Smazat uivatele",
  // Assets Collection
  "defaults.assets.label": "Mdia",
  "defaults.assets.description": "Spravovat nahran soubory a obrzky",
  "defaults.assets.fields.preview.label": "Nhled",
  "defaults.assets.fields.filename.label": "Nzev souboru",
  "defaults.assets.fields.filename.description": "Pvodn nzev nahranho souboru",
  "defaults.assets.fields.mimeType.label": "Typ",
  "defaults.assets.fields.mimeType.description": "MIME typ souboru",
  "defaults.assets.fields.size.label": "Velikost (bajty)",
  "defaults.assets.fields.size.description": "Velikost souboru v bajtech",
  "defaults.assets.fields.alt.label": "Alternativn text",
  "defaults.assets.fields.alt.placeholder": "Popite obrzek pro pstupnost",
  "defaults.assets.fields.alt.description": "Alternativn text pro teky obrazovky",
  "defaults.assets.fields.caption.label": "Popisek",
  "defaults.assets.fields.caption.placeholder": "Pidejte popisek...",
  "defaults.assets.fields.visibility.label": "Viditelnost",
  "defaults.assets.fields.visibility.options.public": "Veejn",
  "defaults.assets.fields.visibility.options.private": "Soukrom",
  "defaults.assets.fields.visibility.description": "Veejn soubory jsou dostupn bez autentizace. Soukrom soubory vyaduj podepsanou URL.",
  "defaults.assets.sections.fileInfo": "Informace o souboru",
  "defaults.assets.sections.metadata": "Metadata",
  "defaults.assets.sections.metadata.description": "Pidejte popisn informace pro pstupnost a SEO",
  "defaults.assets.actions.upload.label": "Nahrt soubory",
  // Default Sidebar
  "defaults.sidebar.administration": "Administrace",
  // View Options (Filter Builder)
  "viewOptions.title": "Monosti zobrazen",
  "viewOptions.columns": "Sloupce",
  "viewOptions.filters": "Filtry",
  "viewOptions.savedViews": "Uloen zobrazen",
  "viewOptions.apply": "Pout",
  "viewOptions.reset": "Resetovat",
  // Saved Views Tab
  "viewOptions.saveCurrentConfig": "Uloit aktuln konfiguraci",
  "viewOptions.viewNamePlaceholder": "Nzev zobrazen...",
  "viewOptions.saveDescription": "Ulo aktuln sloupce, filtry a azen.",
  "viewOptions.noChangesToSave": "dn filtry nebo zmny sloupc k uloen.",
  "viewOptions.noSavedViews": "Zatm dn uloen zobrazen.",
  "viewOptions.filtersCount": {
    one: "{{count}} filtr",
    other: "{{count}} filtr"
  },
  "viewOptions.columnsCount": {
    one: "{{count}} sloupec",
    other: "{{count}} sloupc"
  },
  "viewOptions.defaultView": "Vchoz",
  // Columns Tab
  "viewOptions.columnsDragHint": "Pethnte pro zmnu poad, pepnte pro zobrazen/skryt sloupc.",
  "viewOptions.noFieldsAvailable": "dn dostupn pole.",
  // Filters Tab
  "viewOptions.filtersDescription": "Zte vsledky vlastnmi pravidly.",
  "viewOptions.filterNumber": "Filtr #{{number}}",
  "viewOptions.selectField": "Vybrat pole",
  "viewOptions.selectOperator": "Vybrat opertor",
  "viewOptions.valuePlaceholder": "Hodnota...",
  "viewOptions.noActiveFilters": "dn aktivn filtry.",
  "viewOptions.addFilter": "Pidat filtr",
  "viewOptions.clearAll": "Vymazat ve",
  "viewOptions.activeFilters": {
    one: "{{count}} aktivn filtr",
    other: "{{count}} aktivnch filtr"
  },
  "viewOptions.clearFilters": "Vymazat filtry",
  // Filter Operators
  "filter.contains": "Obsahuje",
  "filter.notContains": "Neobsahuje",
  "filter.equals": "Rovn se",
  "filter.notEquals": "Nerovn se",
  "filter.startsWith": "Zan na",
  "filter.endsWith": "Kon na",
  "filter.greaterThan": "Vt ne",
  "filter.greaterThanOrEqual": "Vt ne nebo rovno",
  "filter.lessThan": "Men ne",
  "filter.lessThanOrEqual": "Men ne nebo rovno",
  "filter.in": "Je nkter z",
  "filter.notIn": "Nen dn z",
  "filter.some": "M njak",
  "filter.every": "M vechny",
  "filter.none": "Nem dn",
  "filter.isEmpty": "Je przdn",
  "filter.isNotEmpty": "Nen przdn",
  // Preview
  "preview.show": "Nhled",
  "preview.hide": "Skrt nhled",
  "preview.title": "Nhled",
  "preview.livePreview": "iv nhled",
  "preview.fullscreen": "Cel obrazovka",
  "preview.close": "Zavt nhled",
  "preview.loading": "Natn nhledu...",
  // Autosave
  "autosave.saving": "Ukldn...",
  "autosave.saved": "Uloeno",
  "autosave.unsavedChanges": "Neuloen zmny",
  "autosave.justNow": "prv te",
  "autosave.secondsAgo": {
    one: "{{count}}s zptky",
    other: "{{count}}s zptky"
  },
  "autosave.minutesAgo": {
    one: "{{count}}m zptky",
    other: "{{count}}m zptky"
  },
  "autosave.hoursAgo": { one: "{{count}}h zptky", other: "{{count}}h zptky" },
  // Global Search
  "globalSearch.placeholder": "Hledat kolekce, globly, akce, zznamy...",
  "globalSearch.collections": "Kolekce",
  "globalSearch.globals": "Globly",
  "globalSearch.quickActions": "Rychl akce",
  "globalSearch.records": "Zznamy",
  "globalSearch.createNew": "Vytvoit nov {{name}}",
  "globalSearch.noResults": "Nenalezeny dn vsledky",
  "globalSearch.searching": "Hledn...",
  "globalSearch.navigate": "pro navigaci",
  "globalSearch.select": "pro vbr",
  // Collection Search
  "collectionSearch.placeholder": "Hledat zznamy...",
  "collectionSearch.noResults": "Nenalezeny dn odpovdajc zznamy",
  "collectionSearch.searching": "Hledn..."
};
const de = {
  // Common
  "common.save": "Speichern",
  "common.cancel": "Abbrechen",
  "common.delete": "Lschen",
  "common.edit": "Bearbeiten",
  "common.create": "Erstellen",
  "common.add": "Hinzufgen",
  "common.remove": "Entfernen",
  "common.close": "Schlieen",
  "common.form": "Formular",
  "common.search": "Suchen",
  "common.filter": "Filter",
  "common.refresh": "Aktualisieren",
  "common.loading": "Laden...",
  "common.confirm": "Besttigen",
  "common.back": "Zurck",
  "common.next": "Weiter",
  "common.previous": "Zurck",
  "common.actions": "Aktionen",
  "common.more": "Mehr",
  "common.yes": "Ja",
  "common.no": "Nein",
  "common.ok": "OK",
  "common.apply": "Anwenden",
  "common.reset": "Zurcksetzen",
  "common.clear": "Lschen",
  "common.selectAll": "Alle auswhlen",
  "common.deselectAll": "Auswahl aufheben",
  "common.duplicate": "Duplizieren",
  "common.copy": "Kopieren",
  "common.paste": "Einfgen",
  "common.upload": "Hochladen",
  "common.download": "Herunterladen",
  "common.preview": "Vorschau",
  "common.view": "Ansicht",
  "common.open": "ffnen",
  "common.retry": "Wiederholen",
  "common.submit": "Absenden",
  // Navigation
  "nav.dashboard": "Dashboard",
  "nav.collections": "Sammlungen",
  "nav.globals": "Globals",
  "nav.media": "Medien",
  "nav.settings": "Einstellungen",
  "nav.logout": "Abmelden",
  "nav.home": "Startseite",
  "nav.back": "Zurck",
  // Dashboard
  "dashboard.title": "Dashboard",
  "dashboard.welcome": "Willkommen zurck",
  "dashboard.recentActivity": "Letzte Aktivitt",
  "dashboard.quickActions": "Schnellaktionen",
  // Collections
  "collection.create": "{{name}} erstellen",
  "collection.edit": "{{name}} bearbeiten",
  "collection.delete": "{{name}} lschen",
  "collection.deleteConfirm": "Mchten Sie {{name}} wirklich lschen?",
  "collection.noItems": "Keine {{name}} gefunden",
  "collection.createFirst": "Erstellen Sie Ihr erstes {{name}}",
  "collection.itemCount": {
    one: "{{count}} Element",
    other: "{{count}} Elemente"
  },
  "collection.bulkDelete": "Ausgewhlte lschen",
  "collection.bulkDeleteConfirm": "Mchten Sie {{count}} Elemente wirklich lschen?",
  "collection.bulkDeleteSuccess": {
    one: "{{count}} Element erfolgreich gelscht",
    other: "{{count}} Elemente erfolgreich gelscht"
  },
  "collection.bulkDeleteError": "Fehler beim Lschen der Elemente",
  "collection.bulkDeletePartial": {
    one: "{{success}} Element gelscht, {{failed}} fehlgeschlagen",
    other: "{{success}} Elemente gelscht, {{failed}} fehlgeschlagen"
  },
  "collection.bulkActionFailed": "Massenaktion fehlgeschlagen",
  "collection.selected": "{{count}} ausgewhlt",
  "collection.selectOnPage": "Alle auf dieser Seite",
  "collection.selectAllMatching": "Alle passenden ({{count}})",
  "collection.clearSelection": "Auswahl aufheben",
  "collection.list": "{{name}} Liste",
  "collection.new": "Neues {{name}}",
  "collection.duplicateSuccess": "{{name}} erfolgreich dupliziert",
  "collection.duplicateError": "Fehler beim Duplizieren von {{name}}",
  // Relations
  "relation.select": "{{name}} auswhlen",
  "relation.clear": "Auswahl lschen",
  "relation.search": "{{name}} suchen...",
  "relation.noResults": "Keine {{name}} gefunden",
  "relation.loading": "Laden...",
  "relation.createNew": "Neues {{name}} erstellen",
  "relation.selected": "{{count}} ausgewhlt",
  "relation.removeItem": "{{name}} entfernen",
  "relation.addItem": "{{name}} hinzufgen",
  "relation.noneSelected": "Kein {{name}} ausgewhlt",
  "relation.noRelated": "Keine verwandten Elemente gefunden",
  "relation.saveFirst": "Speichern Sie dieses Element zuerst, um verwandte Elemente zu sehen.",
  // Arrays
  "array.empty": "Noch keine {{name}} hinzugefgt",
  "array.addItem": "{{name}} hinzufgen",
  // Blocks
  "blocks.addAbove": "Darber hinzufgen",
  "blocks.addBelow": "Darunter hinzufgen",
  "blocks.addChild": "Untergeordneten Block hinzufgen",
  // Forms
  "form.id": "ID",
  "form.created": "Erstellt",
  "form.updated": "Aktualisiert",
  "form.required": "Dieses Feld ist erforderlich",
  "form.invalid": "Ungltiger Wert",
  "form.saveChanges": "nderungen speichern",
  "form.unsavedChanges": "Sie haben ungespeicherte nderungen",
  "form.discardChanges": "nderungen verwerfen",
  "form.discardConfirm": "Mchten Sie die nderungen wirklich verwerfen? Diese Aktion kann nicht rckgngig gemacht werden.",
  "form.fieldRequired": "{{field}} ist erforderlich",
  "form.fieldInvalid": "{{field}} ist ungltig",
  "form.maxLength": "Maximal {{max}} Zeichen",
  "form.minLength": "Mindestens {{min}} Zeichen",
  "form.maxValue": "Maximal {{max}}",
  "form.minValue": "Mindestens {{min}}",
  "form.pattern": "Ungltiges Format",
  "form.email": "Ungltige E-Mail-Adresse",
  "form.url": "Ungltige URL",
  "form.createSuccess": "{{name}} erfolgreich erstellt",
  "form.createError": "Fehler beim Erstellen von {{name}}",
  "form.updateSuccess": "{{name}} erfolgreich aktualisiert",
  "form.updateError": "Fehler beim Aktualisieren von {{name}}",
  "form.deleteSuccess": "{{name}} erfolgreich gelscht",
  "form.deleteError": "Fehler beim Lschen von {{name}}",
  // Auth
  "auth.login": "Anmelden",
  "auth.logout": "Abmelden",
  "auth.email": "E-Mail",
  "auth.password": "Passwort",
  "auth.forgotPassword": "Passwort vergessen?",
  "auth.resetPassword": "Passwort zurcksetzen",
  "auth.signIn": "Anmelden",
  "auth.signOut": "Abmelden",
  "auth.signUp": "Registrieren",
  "auth.rememberMe": "Angemeldet bleiben",
  "auth.invalidCredentials": "Ungltige E-Mail oder Passwort",
  "auth.sessionExpired": "Ihre Sitzung ist abgelaufen. Bitte melden Sie sich erneut an.",
  "auth.emailPlaceholder": "sie@beispiel.de",
  "auth.passwordPlaceholder": "Passwort eingeben",
  "auth.signingIn": "Anmeldung...",
  "auth.creatingAdmin": "Administrator wird erstellt...",
  "auth.name": "Name",
  "auth.namePlaceholder": "Ihr Name",
  "auth.confirmPassword": "Passwort besttigen",
  "auth.confirmPasswordPlaceholder": "Passwort besttigen",
  "auth.acceptInvite": "Einladung annehmen",
  "auth.acceptingInvite": "Einladung wird angenommen...",
  "auth.dontHaveAccount": "Noch kein Konto?",
  "auth.alreadyHaveAccount": "Bereits ein Konto?",
  "auth.emailRequired": "E-Mail ist erforderlich",
  "auth.passwordRequired": "Passwort ist erforderlich",
  "auth.passwordMinLength": "Passwort muss mindestens {{min}} Zeichen haben",
  "auth.nameRequired": "Name ist erforderlich",
  "auth.nameMinLength": "Name muss mindestens {{min}} Zeichen haben",
  "auth.invalidEmail": "Ungltige E-Mail-Adresse",
  "auth.passwordMismatch": "Passwrter stimmen nicht berein",
  "auth.newPassword": "Neues Passwort",
  "auth.newPasswordPlaceholder": "Neues Passwort eingeben",
  "auth.sendResetLink": "Reset-Link senden",
  "auth.sendingResetLink": "Wird gesendet...",
  "auth.resetLinkSent": "Passwort-Reset-Link wurde an Ihre E-Mail gesendet",
  "auth.resettingPassword": "Passwort wird zurckgesetzt...",
  "auth.createFirstAdmin": "Ersten Administrator erstellen",
  "auth.setupTitle": "Einrichtung",
  "auth.setupDescription": "Erstellen Sie Ihr erstes Administratorkonto.",
  "auth.profile": "Profil",
  "auth.myAccount": "Mein Konto",
  "auth.logoutFailed": "Abmeldung fehlgeschlagen. Bitte versuchen Sie es erneut.",
  // Errors
  "error.notFound": "Nicht gefunden",
  "error.serverError": "Serverfehler",
  "error.networkError": "Netzwerkfehler. Bitte berprfen Sie Ihre Verbindung.",
  "error.unauthorized": "Sie sind nicht berechtigt, diese Aktion auszufhren",
  "error.forbidden": "Zugriff verweigert",
  "error.validation": "Validierung fehlgeschlagen",
  "error.unknown": "Ein unbekannter Fehler ist aufgetreten",
  "error.timeout": "Zeitberschreitung der Anfrage. Bitte versuchen Sie es erneut.",
  "error.conflict": "Ein Konflikt ist aufgetreten. Bitte aktualisieren Sie und versuchen Sie es erneut.",
  // Table
  "table.rowsPerPage": "Zeilen pro Seite",
  "table.of": "von",
  "table.noResults": "Keine Ergebnisse",
  "table.selectAll": "Alle auswhlen",
  "table.selectRow": "Zeile auswhlen",
  "table.showing": "Zeige {{from}} bis {{to}} von {{total}}",
  "table.page": "Seite {{page}}",
  "table.firstPage": "Erste Seite",
  "table.lastPage": "Letzte Seite",
  "table.nextPage": "Nchste Seite",
  "table.previousPage": "Vorherige Seite",
  "table.sortAsc": "Aufsteigend sortieren",
  "table.sortDesc": "Absteigend sortieren",
  "table.columns": "Spalten",
  "table.hideColumn": "Spalte ausblenden",
  "table.showColumn": "Spalte anzeigen",
  // Upload
  "upload.dropzone": "Dateien hier ablegen oder klicken zum Hochladen",
  "upload.browse": "Dateien durchsuchen",
  "upload.uploading": "Wird hochgeladen...",
  "upload.complete": "Hochladen abgeschlossen",
  "upload.error": "Hochladen fehlgeschlagen",
  "upload.maxSize": "Datei muss kleiner als {{size}} sein",
  "upload.invalidType": "Ungltiger Dateityp. Erlaubt: {{types}}",
  "upload.remove": "Datei entfernen",
  "upload.replace": "Datei ersetzen",
  "upload.preview": "Vorschau",
  "upload.noFile": "Keine Datei ausgewhlt",
  "upload.dragDrop": "Dateien hier ablegen",
  // Editor
  "editor.bold": "Fett",
  "editor.italic": "Kursiv",
  "editor.underline": "Unterstrichen",
  "editor.strikethrough": "Durchgestrichen",
  "editor.heading": "berschrift {{level}}",
  "editor.link": "Link einfgen",
  "editor.image": "Bild einfgen",
  "editor.list": "Liste",
  "editor.orderedList": "Nummerierte Liste",
  "editor.unorderedList": "Aufzhlungsliste",
  "editor.quote": "Zitat",
  "editor.code": "Code",
  "editor.codeBlock": "Code-Block",
  "editor.table": "Tabelle einfgen",
  "editor.undo": "Rckgngig",
  "editor.redo": "Wiederherstellen",
  "editor.alignLeft": "Linksbndig",
  "editor.alignCenter": "Zentriert",
  "editor.alignRight": "Rechtsbndig",
  "editor.alignJustify": "Blocksatz",
  "editor.horizontalRule": "Horizontale Linie",
  "editor.addRowBefore": "Zeile davor einfgen",
  "editor.addRowAfter": "Zeile danach einfgen",
  "editor.addColumnBefore": "Spalte davor einfgen",
  "editor.addColumnAfter": "Spalte danach einfgen",
  "editor.deleteRow": "Zeile lschen",
  "editor.deleteColumn": "Spalte lschen",
  "editor.deleteTable": "Tabelle lschen",
  "editor.toggleHeaderRow": "Kopfzeile umschalten",
  "editor.toggleHeaderColumn": "Kopfspalte umschalten",
  "editor.mergeCells": "Zellen zusammenfhren",
  "editor.splitCell": "Zelle teilen",
  "editor.insertUrl": "URL einfgen",
  "editor.altText": "Alternativtext (optional)",
  "editor.uploadFile": "Datei hochladen",
  "editor.chooseFile": "Datei auswhlen",
  "editor.uploading": "Wird hochgeladen...",
  "editor.browseLibrary": "Bibliothek durchsuchen",
  // Toasts
  "toast.success": "Erfolg",
  "toast.error": "Fehler",
  "toast.warning": "Warnung",
  "toast.info": "Info",
  "toast.saving": "Wird gespeichert...",
  "toast.saveFailed": "Fehler beim Speichern der nderungen",
  "toast.saveSuccess": "nderungen erfolgreich gespeichert",
  "toast.creating": "Wird erstellt...",
  "toast.createSuccess": "Erfolgreich erstellt",
  "toast.createFailed": "Fehler beim Erstellen",
  "toast.deleting": "Wird gelscht...",
  "toast.deleteFailed": "Fehler beim Lschen",
  "toast.deleteSuccess": "Erfolgreich gelscht",
  "toast.loadFailed": "Fehler beim Laden der Daten",
  "toast.uploadFailed": "Fehler beim Hochladen der Datei",
  "toast.uploadSuccess": "Datei erfolgreich hochgeladen",
  "toast.copySuccess": "In Zwischenablage kopiert",
  "toast.copyFailed": "Fehler beim Kopieren in die Zwischenablage",
  "toast.idCopied": "ID in Zwischenablage kopiert",
  "toast.validationFailed": "Validierung fehlgeschlagen",
  "toast.validationDescription": "Bitte berprfen Sie das Formular auf Fehler",
  "toast.created": "{{name}} erstellt",
  "toast.updated": "{{name}} aktualisiert",
  "toast.resourceSaveFailed": "Fehler beim Speichern von {{name}}",
  "toast.editComingSoon": "Bearbeitungsfunktion demnchst verfgbar",
  "toast.maxFilesWarning": "Nur noch {{remaining}} Datei(en) knnen hinzugefgt werden (max {{max}})",
  "toast.settingsSaveFailed": "Fehler beim Speichern der Einstellungen",
  "toast.actionSuccess": "Aktion erfolgreich abgeschlossen",
  "toast.actionFailed": "Aktion fehlgeschlagen",
  "toast.localeChangedUnsaved": "Inhaltssprache gendert",
  "toast.localeChangedUnsavedDescription": "Ihre ungespeicherten nderungen wurden durch den Inhalt in der neuen Sprache ersetzt.",
  // Confirm
  "confirm.delete": "Mchten Sie dies wirklich lschen? Diese Aktion kann nicht rckgngig gemacht werden.",
  "confirm.discard": "Mchten Sie die nderungen wirklich verwerfen? Diese Aktion kann nicht rckgngig gemacht werden.",
  "confirm.unsavedChanges": "Sie haben ungespeicherte nderungen. Mchten Sie wirklich verlassen?",
  "confirm.action": "Mchten Sie wirklich fortfahren?",
  "confirm.irreversible": "Diese Aktion kann nicht rckgngig gemacht werden.",
  "confirm.localeChange": "Ungespeicherte nderungen verwerfen?",
  "confirm.localeChangeDescription": "Sie haben ungespeicherte nderungen. Das Wechseln der Inhaltssprache verwirft Ihre nderungen und ldt den Inhalt in der neuen Sprache.",
  "confirm.localeChangeStay": "Bleiben",
  "confirm.localeChangeDiscard": "Verwerfen & wechseln",
  // Status
  "status.draft": "Entwurf",
  "status.published": "Verffentlicht",
  "status.archived": "Archiviert",
  "status.pending": "Ausstehend",
  "status.active": "Aktiv",
  "status.inactive": "Inaktiv",
  // Dates
  "date.today": "Heute",
  "date.yesterday": "Gestern",
  "date.tomorrow": "Morgen",
  "date.selectDate": "Datum auswhlen",
  "date.selectTime": "Zeit auswhlen",
  "date.clear": "Datum lschen",
  // Accessibility
  "a11y.openMenu": "Men ffnen",
  "a11y.closeMenu": "Men schlieen",
  "a11y.expand": "Erweitern",
  "a11y.collapse": "Zusammenklappen",
  "a11y.loading": "Laden",
  "a11y.required": "Erforderlich",
  "a11y.optional": "Optional",
  "a11y.selected": "Ausgewhlt",
  "a11y.notSelected": "Nicht ausgewhlt",
  // Locale
  "locale.language": "Sprache",
  "locale.switchLanguage": "Sprache wechseln",
  "locale.contentLanguage": "Inhaltssprache",
  "locale.uiLanguage": "Oberflchensprache",
  // ===========================================
  // Default Collections
  // ===========================================
  // Users Collection
  "defaults.users.label": "Benutzer",
  "defaults.users.description": "Admin-Benutzer und deren Rollen verwalten",
  "defaults.users.fields.name.label": "Name",
  "defaults.users.fields.name.placeholder": "Benutzernamen eingeben",
  "defaults.users.fields.email.label": "E-Mail",
  "defaults.users.fields.email.description": "E-Mail-Adresse (schreibgeschtzt)",
  "defaults.users.fields.role.label": "Rolle",
  "defaults.users.fields.role.options.admin": "Administrator",
  "defaults.users.fields.role.options.user": "Benutzer",
  "defaults.users.fields.emailVerified.label": "E-Mail verifiziert",
  "defaults.users.fields.emailVerified.description": "Ob der Benutzer seine E-Mail-Adresse verifiziert hat",
  "defaults.users.fields.banned.label": "Gesperrt",
  "defaults.users.fields.banned.description": "Benutzer den Zugriff auf das System verweigern",
  "defaults.users.fields.banReason.label": "Sperrgrund",
  "defaults.users.fields.banReason.placeholder": "Grund fr die Sperre eingeben...",
  "defaults.users.sections.basicInfo": "Grundinformationen",
  "defaults.users.sections.permissions": "Berechtigungen",
  "defaults.users.sections.accessControl": "Zugriffskontrolle",
  "defaults.users.actions.createUser.label": "Benutzer erstellen",
  "defaults.users.actions.createUser.title": "Benutzer erstellen",
  "defaults.users.actions.createUser.description": "Neues Benutzerkonto mit Anmeldedaten erstellen.",
  "defaults.users.actions.createUser.fields.password.label": "Passwort",
  "defaults.users.actions.createUser.fields.password.placeholder": "Passwort eingeben",
  "defaults.users.actions.createUser.submit": "Benutzer erstellen",
  "defaults.users.actions.createUser.success": "Benutzer {{email}} erfolgreich erstellt. Teilen Sie die Anmeldedaten mit dem Benutzer.",
  "defaults.users.actions.createUser.errorNoAuth": "Auth-Client nicht konfiguriert. Benutzer kann nicht erstellt werden.",
  "defaults.users.actions.resetPassword.label": "Passwort zurcksetzen",
  "defaults.users.actions.resetPassword.title": "Passwort zurcksetzen",
  "defaults.users.actions.resetPassword.description": "Neues Passwort fr diesen Benutzer festlegen.",
  "defaults.users.actions.resetPassword.fields.newPassword.label": "Neues Passwort",
  "defaults.users.actions.resetPassword.fields.newPassword.placeholder": "Neues Passwort eingeben",
  "defaults.users.actions.resetPassword.fields.confirmPassword.label": "Passwort besttigen",
  "defaults.users.actions.resetPassword.fields.confirmPassword.placeholder": "Neues Passwort besttigen",
  "defaults.users.actions.resetPassword.submit": "Passwort zurcksetzen",
  "defaults.users.actions.resetPassword.success": "Passwort erfolgreich zurckgesetzt!",
  "defaults.users.actions.resetPassword.errorMismatch": "Passwrter stimmen nicht berein",
  "defaults.users.actions.delete.label": "Benutzer lschen",
  // Assets Collection
  "defaults.assets.label": "Medien",
  "defaults.assets.description": "Hochgeladene Dateien und Bilder verwalten",
  "defaults.assets.fields.preview.label": "Vorschau",
  "defaults.assets.fields.filename.label": "Dateiname",
  "defaults.assets.fields.filename.description": "Originaler Dateiname der hochgeladenen Datei",
  "defaults.assets.fields.mimeType.label": "Typ",
  "defaults.assets.fields.mimeType.description": "MIME-Typ der Datei",
  "defaults.assets.fields.size.label": "Gre (Bytes)",
  "defaults.assets.fields.size.description": "Dateigre in Bytes",
  "defaults.assets.fields.alt.label": "Alternativtext",
  "defaults.assets.fields.alt.placeholder": "Bild fr Barrierefreiheit beschreiben",
  "defaults.assets.fields.alt.description": "Alternativtext fr Screenreader",
  "defaults.assets.fields.caption.label": "Untertitel",
  "defaults.assets.fields.caption.placeholder": "Untertitel hinzufgen...",
  "defaults.assets.fields.visibility.label": "Sichtbarkeit",
  "defaults.assets.fields.visibility.options.public": "ffentlich",
  "defaults.assets.fields.visibility.options.private": "Privat",
  "defaults.assets.fields.visibility.description": "ffentliche Dateien sind ohne Authentifizierung zugnglich. Private Dateien erfordern eine signierte URL.",
  "defaults.assets.sections.fileInfo": "Dateiinformationen",
  "defaults.assets.sections.metadata": "Metadaten",
  "defaults.assets.sections.metadata.description": "Beschreibende Informationen fr Barrierefreiheit und SEO hinzufgen",
  "defaults.assets.actions.upload.label": "Dateien hochladen",
  // Default Sidebar
  "defaults.sidebar.administration": "Administration",
  // View Options (Filter Builder)
  "viewOptions.title": "Ansichtsoptionen",
  "viewOptions.columns": "Spalten",
  "viewOptions.filters": "Filter",
  "viewOptions.savedViews": "Gespeicherte Ansichten",
  "viewOptions.apply": "Anwenden",
  "viewOptions.reset": "Zurcksetzen",
  // Saved Views Tab
  "viewOptions.saveCurrentConfig": "Aktuelle Konfiguration speichern",
  "viewOptions.viewNamePlaceholder": "Ansichtsname...",
  "viewOptions.saveDescription": "Speichert aktuelle Spalten, Filter und Sortierung.",
  "viewOptions.noChangesToSave": "Keine Filter oder Spaltennderungen zum Speichern.",
  "viewOptions.noSavedViews": "Noch keine gespeicherten Ansichten.",
  "viewOptions.filtersCount": {
    one: "{{count}} Filter",
    other: "{{count}} Filter"
  },
  "viewOptions.columnsCount": {
    one: "{{count}} Spalte",
    other: "{{count}} Spalten"
  },
  "viewOptions.defaultView": "Standard",
  // Columns Tab
  "viewOptions.columnsDragHint": "Ziehen zum Neuanordnen, umschalten zum Ein-/Ausblenden von Spalten.",
  "viewOptions.noFieldsAvailable": "Keine Felder verfgbar.",
  // Filters Tab
  "viewOptions.filtersDescription": "Ergebnisse mit benutzerdefinierten Regeln eingrenzen.",
  "viewOptions.filterNumber": "Filter #{{number}}",
  "viewOptions.selectField": "Feld auswhlen",
  "viewOptions.selectOperator": "Operator auswhlen",
  "viewOptions.valuePlaceholder": "Wert...",
  "viewOptions.noActiveFilters": "Keine aktiven Filter.",
  "viewOptions.addFilter": "Filter hinzufgen",
  "viewOptions.clearAll": "Alle lschen",
  "viewOptions.activeFilters": {
    one: "{{count}} aktiver Filter",
    other: "{{count}} aktive Filter"
  },
  "viewOptions.clearFilters": "Filter lschen",
  // Filter Operators
  "filter.contains": "Enthlt",
  "filter.notContains": "Enthlt nicht",
  "filter.equals": "Gleich",
  "filter.notEquals": "Ungleich",
  "filter.startsWith": "Beginnt mit",
  "filter.endsWith": "Endet mit",
  "filter.greaterThan": "Grer als",
  "filter.greaterThanOrEqual": "Grer oder gleich",
  "filter.lessThan": "Kleiner als",
  "filter.lessThanOrEqual": "Kleiner oder gleich",
  "filter.in": "Ist eines von",
  "filter.notIn": "Ist keines von",
  "filter.some": "Hat irgendeines",
  "filter.every": "Hat alle",
  "filter.none": "Hat keines",
  "filter.isEmpty": "Ist leer",
  "filter.isNotEmpty": "Ist nicht leer",
  // Preview
  "preview.show": "Vorschau",
  "preview.hide": "Vorschau ausblenden",
  "preview.title": "Vorschau",
  "preview.livePreview": "Live-Vorschau",
  "preview.fullscreen": "Vollbild",
  "preview.close": "Vorschau schlieen",
  "preview.loading": "Vorschau wird geladen...",
  // Autosave
  "autosave.saving": "Wird gespeichert...",
  "autosave.saved": "Gespeichert",
  "autosave.unsavedChanges": "Ungespeicherte nderungen",
  "autosave.justNow": "gerade eben",
  "autosave.secondsAgo": { one: "vor {{count}}s", other: "vor {{count}}s" },
  "autosave.minutesAgo": { one: "vor {{count}}m", other: "vor {{count}}m" },
  "autosave.hoursAgo": { one: "vor {{count}}h", other: "vor {{count}}h" },
  // Global Search
  "globalSearch.placeholder": "Sammlungen, Globals, Aktionen, Datenstze durchsuchen...",
  "globalSearch.collections": "Sammlungen",
  "globalSearch.globals": "Globals",
  "globalSearch.quickActions": "Schnellaktionen",
  "globalSearch.records": "Datenstze",
  "globalSearch.createNew": "Neues {{name}} erstellen",
  "globalSearch.noResults": "Keine Ergebnisse gefunden",
  "globalSearch.searching": "Suche luft...",
  "globalSearch.navigate": "zur Navigation",
  "globalSearch.select": "zur Auswahl",
  // Collection Search
  "collectionSearch.placeholder": "Datenstze durchsuchen...",
  "collectionSearch.noResults": "Keine passenden Datenstze gefunden",
  "collectionSearch.searching": "Suche luft..."
};
const en = {
  // Common
  "common.save": "Save",
  "common.cancel": "Cancel",
  "common.delete": "Delete",
  "common.edit": "Edit",
  "common.create": "Create",
  "common.add": "Add",
  "common.remove": "Remove",
  "common.close": "Close",
  "common.form": "Form",
  "common.search": "Search",
  "common.filter": "Filter",
  "common.refresh": "Refresh",
  "common.loading": "Loading...",
  "common.confirm": "Confirm",
  "common.back": "Back",
  "common.next": "Next",
  "common.previous": "Previous",
  "common.actions": "Actions",
  "common.more": "More",
  "common.yes": "Yes",
  "common.no": "No",
  "common.ok": "OK",
  "common.apply": "Apply",
  "common.reset": "Reset",
  "common.clear": "Clear",
  "common.selectAll": "Select all",
  "common.deselectAll": "Deselect all",
  "common.duplicate": "Duplicate",
  "common.copy": "Copy",
  "common.paste": "Paste",
  "common.upload": "Upload",
  "common.download": "Download",
  "common.preview": "Preview",
  "common.view": "View",
  "common.open": "Open",
  "common.retry": "Retry",
  "common.submit": "Submit",
  // Navigation
  "nav.dashboard": "Dashboard",
  "nav.collections": "Collections",
  "nav.globals": "Globals",
  "nav.media": "Media",
  "nav.settings": "Settings",
  "nav.logout": "Log out",
  "nav.home": "Home",
  "nav.back": "Back",
  // Dashboard
  "dashboard.title": "Dashboard",
  "dashboard.welcome": "Welcome back",
  "dashboard.recentActivity": "Recent Activity",
  "dashboard.quickActions": "Quick Actions",
  // Collections
  "collection.create": "Create {{name}}",
  "collection.edit": "Edit {{name}}",
  "collection.delete": "Delete {{name}}",
  "collection.deleteConfirm": "Are you sure you want to delete this {{name}}?",
  "collection.noItems": "No {{name}} found",
  "collection.createFirst": "Create your first {{name}}",
  "collection.itemCount": { one: "{{count}} item", other: "{{count}} items" },
  "collection.bulkDelete": "Delete selected",
  "collection.bulkDeleteConfirm": "Are you sure you want to delete {{count}} items?",
  "collection.bulkDeleteSuccess": {
    one: "Successfully deleted {{count}} item",
    other: "Successfully deleted {{count}} items"
  },
  "collection.bulkDeleteError": "Failed to delete items",
  "collection.bulkDeletePartial": {
    one: "Deleted {{success}} item, {{failed}} failed",
    other: "Deleted {{success}} items, {{failed}} failed"
  },
  "collection.bulkActionFailed": "Bulk action failed",
  "collection.selected": "{{count}} selected",
  "collection.selectOnPage": "All on this page",
  "collection.selectAllMatching": "All matching filter ({{count}})",
  "collection.clearSelection": "Clear selection",
  "collection.list": "{{name}} list",
  "collection.new": "New {{name}}",
  "collection.duplicateSuccess": "{{name}} duplicated successfully",
  "collection.duplicateError": "Failed to duplicate {{name}}",
  // Relations
  "relation.select": "Select {{name}}",
  "relation.clear": "Clear selection",
  "relation.search": "Search {{name}}...",
  "relation.noResults": "No {{name}} found",
  "relation.loading": "Loading...",
  "relation.createNew": "Create new {{name}}",
  "relation.selected": "{{count}} selected",
  "relation.removeItem": "Remove {{name}}",
  "relation.addItem": "Add {{name}}",
  "relation.noneSelected": "No {{name}} selected",
  "relation.noRelated": "No related items found",
  "relation.saveFirst": "Save this item first to see related items.",
  // Arrays
  "array.empty": "No {{name}} added yet",
  "array.addItem": "Add {{name}}",
  // Blocks
  "blocks.addAbove": "Add above",
  "blocks.addBelow": "Add below",
  "blocks.addChild": "Add child block",
  // Forms
  "form.id": "ID",
  "form.created": "Created",
  "form.updated": "Updated",
  "form.required": "This field is required",
  "form.invalid": "Invalid value",
  "form.saveChanges": "Save changes",
  "form.unsavedChanges": "You have unsaved changes",
  "form.discardChanges": "Discard changes",
  "form.discardConfirm": "Are you sure you want to discard your changes? This action cannot be undone.",
  "form.fieldRequired": "{{field}} is required",
  "form.fieldInvalid": "{{field}} is invalid",
  "form.maxLength": "Must be at most {{max}} characters",
  "form.minLength": "Must be at least {{min}} characters",
  "form.maxValue": "Must be at most {{max}}",
  "form.minValue": "Must be at least {{min}}",
  "form.pattern": "Invalid format",
  "form.email": "Invalid email address",
  "form.url": "Invalid URL",
  "form.createSuccess": "{{name}} created successfully",
  "form.createError": "Failed to create {{name}}",
  "form.updateSuccess": "{{name}} updated successfully",
  "form.updateError": "Failed to update {{name}}",
  "form.deleteSuccess": "{{name}} deleted successfully",
  "form.deleteError": "Failed to delete {{name}}",
  // Auth
  "auth.login": "Log in",
  "auth.logout": "Log out",
  "auth.email": "Email",
  "auth.password": "Password",
  "auth.forgotPassword": "Forgot password?",
  "auth.resetPassword": "Reset password",
  "auth.signIn": "Sign in",
  "auth.signOut": "Sign out",
  "auth.signUp": "Sign up",
  "auth.rememberMe": "Remember me",
  "auth.invalidCredentials": "Invalid email or password",
  "auth.sessionExpired": "Your session has expired. Please log in again.",
  "auth.emailPlaceholder": "you@example.com",
  "auth.passwordPlaceholder": "Enter your password",
  "auth.signingIn": "Signing in...",
  "auth.creatingAdmin": "Creating admin...",
  "auth.name": "Name",
  "auth.namePlaceholder": "Your name",
  "auth.confirmPassword": "Confirm password",
  "auth.confirmPasswordPlaceholder": "Confirm your password",
  "auth.acceptInvite": "Accept invite",
  "auth.acceptingInvite": "Accepting invite...",
  "auth.dontHaveAccount": "Don't have an account?",
  "auth.alreadyHaveAccount": "Already have an account?",
  "auth.emailRequired": "Email is required",
  "auth.passwordRequired": "Password is required",
  "auth.passwordMinLength": "Password must be at least {{min}} characters",
  "auth.nameRequired": "Name is required",
  "auth.nameMinLength": "Name must be at least {{min}} characters",
  "auth.invalidEmail": "Invalid email address",
  "auth.passwordMismatch": "Passwords do not match",
  "auth.newPassword": "New password",
  "auth.newPasswordPlaceholder": "Enter new password",
  "auth.sendResetLink": "Send reset link",
  "auth.sendingResetLink": "Sending...",
  "auth.resetLinkSent": "Password reset link sent to your email",
  "auth.resettingPassword": "Resetting password...",
  "auth.createFirstAdmin": "Create first admin",
  "auth.setupTitle": "Setup",
  "auth.setupDescription": "Create your first admin account to get started.",
  "auth.profile": "Profile",
  "auth.myAccount": "My account",
  "auth.logoutFailed": "Failed to log out. Please try again.",
  // Errors
  "error.notFound": "Not found",
  "error.serverError": "Server error",
  "error.networkError": "Network error. Please check your connection.",
  "error.unauthorized": "You are not authorized to perform this action",
  "error.forbidden": "Access denied",
  "error.validation": "Validation failed",
  "error.unknown": "An unknown error occurred",
  "error.timeout": "Request timed out. Please try again.",
  "error.conflict": "A conflict occurred. Please refresh and try again.",
  // Table
  "table.rowsPerPage": "Rows per page",
  "table.of": "of",
  "table.noResults": "No results",
  "table.selectAll": "Select all",
  "table.selectRow": "Select row",
  "table.showing": "Showing {{from}} to {{to}} of {{total}}",
  "table.page": "Page {{page}}",
  "table.firstPage": "First page",
  "table.lastPage": "Last page",
  "table.nextPage": "Next page",
  "table.previousPage": "Previous page",
  "table.sortAsc": "Sort ascending",
  "table.sortDesc": "Sort descending",
  "table.columns": "Columns",
  "table.hideColumn": "Hide column",
  "table.showColumn": "Show column",
  // Upload
  "upload.dropzone": "Drop files here or click to upload",
  "upload.browse": "Browse files",
  "upload.uploading": "Uploading...",
  "upload.complete": "Upload complete",
  "upload.error": "Upload failed",
  "upload.maxSize": "File must be smaller than {{size}}",
  "upload.invalidType": "Invalid file type. Allowed: {{types}}",
  "upload.remove": "Remove file",
  "upload.replace": "Replace file",
  "upload.preview": "Preview",
  "upload.noFile": "No file selected",
  "upload.dragDrop": "Drag and drop files here",
  "upload.bulkTitle": "Upload Files",
  "upload.bulkDescription": "Add multiple files to your media library",
  "upload.bulkHint": "Upload multiple files at once",
  "upload.bulkSuccess": {
    one: "{{count}} file uploaded successfully",
    other: "{{count}} files uploaded successfully"
  },
  "upload.bulkError": {
    one: "{{count}} file failed to upload",
    other: "{{count}} files failed to upload"
  },
  "upload.waitForComplete": "Please wait for uploads to complete",
  "upload.filesCount": { one: "{{count}} file", other: "{{count}} files" },
  "upload.uploadedCount": {
    one: "{{count}} uploaded",
    other: "{{count}} uploaded"
  },
  "upload.failedCount": { one: "{{count}} failed", other: "{{count}} failed" },
  "upload.browseLibrary": "Browse Library",
  // Editor
  "editor.bold": "Bold",
  "editor.italic": "Italic",
  "editor.underline": "Underline",
  "editor.strikethrough": "Strikethrough",
  "editor.heading": "Heading {{level}}",
  "editor.link": "Insert link",
  "editor.image": "Insert image",
  "editor.list": "List",
  "editor.orderedList": "Numbered list",
  "editor.unorderedList": "Bullet list",
  "editor.quote": "Quote",
  "editor.code": "Code",
  "editor.codeBlock": "Code block",
  "editor.table": "Insert table",
  "editor.undo": "Undo",
  "editor.redo": "Redo",
  "editor.alignLeft": "Align left",
  "editor.alignCenter": "Align center",
  "editor.alignRight": "Align right",
  "editor.alignJustify": "Justify",
  "editor.horizontalRule": "Horizontal rule",
  "editor.addRowBefore": "Add row before",
  "editor.addRowAfter": "Add row after",
  "editor.addColumnBefore": "Add column before",
  "editor.addColumnAfter": "Add column after",
  "editor.deleteRow": "Delete row",
  "editor.deleteColumn": "Delete column",
  "editor.deleteTable": "Delete table",
  "editor.toggleHeaderRow": "Toggle header row",
  "editor.toggleHeaderColumn": "Toggle header column",
  "editor.mergeCells": "Merge cells",
  "editor.splitCell": "Split cell",
  "editor.insertUrl": "Insert URL",
  "editor.altText": "Alt text (optional)",
  "editor.uploadFile": "Upload file",
  "editor.chooseFile": "Choose file",
  "editor.uploading": "Uploading...",
  "editor.browseLibrary": "Browse library",
  // Toasts
  "toast.success": "Success",
  "toast.error": "Error",
  "toast.warning": "Warning",
  "toast.info": "Info",
  "toast.saving": "Saving...",
  "toast.saveFailed": "Failed to save changes",
  "toast.saveSuccess": "Changes saved successfully",
  "toast.creating": "Creating...",
  "toast.createSuccess": "Created successfully",
  "toast.createFailed": "Failed to create",
  "toast.deleting": "Deleting...",
  "toast.deleteFailed": "Failed to delete",
  "toast.deleteSuccess": "Deleted successfully",
  "toast.loadFailed": "Failed to load data",
  "toast.uploadFailed": "Failed to upload file",
  "toast.uploadSuccess": "File uploaded successfully",
  "toast.copySuccess": "Copied to clipboard",
  "toast.copyFailed": "Failed to copy to clipboard",
  "toast.idCopied": "ID copied to clipboard",
  "toast.validationFailed": "Validation failed",
  "toast.validationDescription": "Please check the form for errors",
  "toast.created": "{{name}} created",
  "toast.updated": "{{name}} updated",
  "toast.resourceSaveFailed": "Failed to save {{name}}",
  "toast.editComingSoon": "Edit functionality coming soon",
  "toast.maxFilesWarning": "Only {{remaining}} more file(s) can be added (max {{max}})",
  "toast.settingsSaveFailed": "Failed to save settings",
  "toast.actionSuccess": "Action completed successfully",
  "toast.actionFailed": "Action failed",
  "toast.localeChangedUnsaved": "Content language changed",
  "toast.localeChangedUnsavedDescription": "Your unsaved changes were replaced with content from the new language.",
  // Confirm
  "confirm.delete": "Are you sure you want to delete this? This action cannot be undone.",
  "confirm.discard": "Are you sure you want to discard your changes? This action cannot be undone.",
  "confirm.unsavedChanges": "You have unsaved changes. Are you sure you want to leave?",
  "confirm.action": "Are you sure you want to continue?",
  "confirm.irreversible": "This action cannot be undone.",
  "confirm.localeChange": "Discard unsaved changes?",
  "confirm.localeChangeDescription": "You have unsaved changes. Switching content language will discard your changes and load the content in the new language.",
  "confirm.localeChangeStay": "Stay",
  "confirm.localeChangeDiscard": "Discard & switch",
  // Status
  "status.draft": "Draft",
  "status.published": "Published",
  "status.archived": "Archived",
  "status.pending": "Pending",
  "status.active": "Active",
  "status.inactive": "Inactive",
  // Dates
  "date.today": "Today",
  "date.yesterday": "Yesterday",
  "date.tomorrow": "Tomorrow",
  "date.selectDate": "Select date",
  "date.selectTime": "Select time",
  "date.clear": "Clear date",
  // Accessibility
  "a11y.openMenu": "Open menu",
  "a11y.closeMenu": "Close menu",
  "a11y.expand": "Expand",
  "a11y.collapse": "Collapse",
  "a11y.loading": "Loading",
  "a11y.required": "Required",
  "a11y.optional": "Optional",
  "a11y.selected": "Selected",
  "a11y.notSelected": "Not selected",
  // Locale
  "locale.language": "Language",
  "locale.switchLanguage": "Switch language",
  "locale.contentLanguage": "Content language",
  "locale.uiLanguage": "Interface language",
  // ===========================================
  // Default Collections
  // ===========================================
  // Users Collection
  "defaults.users.label": "Users",
  "defaults.users.description": "Manage admin users and their roles",
  "defaults.users.fields.name.label": "Name",
  "defaults.users.fields.name.placeholder": "Enter user name",
  "defaults.users.fields.email.label": "Email",
  "defaults.users.fields.email.description": "Email address (read-only)",
  "defaults.users.fields.role.label": "Role",
  "defaults.users.fields.role.options.admin": "Admin",
  "defaults.users.fields.role.options.user": "User",
  "defaults.users.fields.emailVerified.label": "Email Verified",
  "defaults.users.fields.emailVerified.description": "Whether the user has verified their email address",
  "defaults.users.fields.banned.label": "Banned",
  "defaults.users.fields.banned.description": "Prevent user from accessing the system",
  "defaults.users.fields.banReason.label": "Ban Reason",
  "defaults.users.fields.banReason.placeholder": "Enter reason for banning...",
  "defaults.users.sections.basicInfo": "Basic Information",
  "defaults.users.sections.permissions": "Permissions",
  "defaults.users.sections.accessControl": "Access Control",
  "defaults.users.actions.createUser.label": "Create User",
  "defaults.users.actions.createUser.title": "Create User",
  "defaults.users.actions.createUser.description": "Create a new user account with login credentials.",
  "defaults.users.actions.createUser.fields.password.label": "Password",
  "defaults.users.actions.createUser.fields.password.placeholder": "Enter password",
  "defaults.users.actions.createUser.submit": "Create User",
  "defaults.users.actions.createUser.success": "User {{email}} created successfully. Share the credentials with the user.",
  "defaults.users.actions.createUser.errorNoAuth": "Auth client not configured. Cannot create user.",
  "defaults.users.actions.resetPassword.label": "Reset Password",
  "defaults.users.actions.resetPassword.title": "Reset Password",
  "defaults.users.actions.resetPassword.description": "Set a new password for this user.",
  "defaults.users.actions.resetPassword.fields.newPassword.label": "New Password",
  "defaults.users.actions.resetPassword.fields.newPassword.placeholder": "Enter new password",
  "defaults.users.actions.resetPassword.fields.confirmPassword.label": "Confirm Password",
  "defaults.users.actions.resetPassword.fields.confirmPassword.placeholder": "Confirm new password",
  "defaults.users.actions.resetPassword.submit": "Reset Password",
  "defaults.users.actions.resetPassword.success": "Password reset successfully!",
  "defaults.users.actions.resetPassword.errorMismatch": "Passwords do not match",
  "defaults.users.actions.delete.label": "Delete User",
  // Assets Collection
  "defaults.assets.label": "Media",
  "defaults.assets.description": "Manage uploaded files and images",
  "defaults.assets.fields.preview.label": "Preview",
  "defaults.assets.fields.filename.label": "Filename",
  "defaults.assets.fields.filename.description": "Original filename of the uploaded file",
  "defaults.assets.fields.mimeType.label": "Type",
  "defaults.assets.fields.mimeType.description": "MIME type of the file",
  "defaults.assets.fields.size.label": "Size (bytes)",
  "defaults.assets.fields.size.description": "File size in bytes",
  "defaults.assets.fields.alt.label": "Alt Text",
  "defaults.assets.fields.alt.placeholder": "Describe the image for accessibility",
  "defaults.assets.fields.alt.description": "Alternative text for screen readers",
  "defaults.assets.fields.caption.label": "Caption",
  "defaults.assets.fields.caption.placeholder": "Add a caption...",
  "defaults.assets.fields.visibility.label": "Visibility",
  "defaults.assets.fields.visibility.options.public": "Public",
  "defaults.assets.fields.visibility.options.private": "Private",
  "defaults.assets.fields.visibility.description": "Public files are accessible without authentication. Private files require a signed URL.",
  "defaults.assets.sections.fileInfo": "File Information",
  "defaults.assets.sections.metadata": "Metadata",
  "defaults.assets.sections.metadata.description": "Add descriptive information for accessibility and SEO",
  "defaults.assets.actions.upload.label": "Upload Files",
  // Default Sidebar
  "defaults.sidebar.administration": "Administration",
  // View Options (Filter Builder)
  "viewOptions.title": "View Options",
  "viewOptions.columns": "Columns",
  "viewOptions.filters": "Filters",
  "viewOptions.savedViews": "Saved Views",
  "viewOptions.apply": "Apply",
  "viewOptions.reset": "Reset",
  // Saved Views Tab
  "viewOptions.saveCurrentConfig": "Save Current Configuration",
  "viewOptions.viewNamePlaceholder": "View Name...",
  "viewOptions.saveDescription": "Saves current columns, filters, and sort order.",
  "viewOptions.noChangesToSave": "No filters or column changes to save.",
  "viewOptions.noSavedViews": "No saved views yet.",
  "viewOptions.filtersCount": {
    one: "{{count}} filter",
    other: "{{count}} filters"
  },
  "viewOptions.columnsCount": { one: "{{count}} col", other: "{{count}} cols" },
  "viewOptions.defaultView": "Default",
  // Columns Tab
  "viewOptions.columnsDragHint": "Drag to reorder, toggle to show/hide columns.",
  "viewOptions.noFieldsAvailable": "No fields available.",
  // Filters Tab
  "viewOptions.filtersDescription": "Narrow down your results with custom rules.",
  "viewOptions.filterNumber": "Filter #{{number}}",
  "viewOptions.selectField": "Select field",
  "viewOptions.selectOperator": "Select operator",
  "viewOptions.valuePlaceholder": "Value...",
  "viewOptions.noActiveFilters": "No active filters.",
  "viewOptions.addFilter": "Add Filter",
  "viewOptions.clearAll": "Clear All",
  "viewOptions.activeFilters": {
    one: "{{count}} filter active",
    other: "{{count}} filters active"
  },
  "viewOptions.clearFilters": "Clear filters",
  // Filter Operators
  "filter.contains": "Contains",
  "filter.notContains": "Does not contain",
  "filter.equals": "Equals",
  "filter.notEquals": "Does not equal",
  "filter.startsWith": "Starts with",
  "filter.endsWith": "Ends with",
  "filter.greaterThan": "Greater than",
  "filter.greaterThanOrEqual": "Greater than or equal",
  "filter.lessThan": "Less than",
  "filter.lessThanOrEqual": "Less than or equal",
  "filter.in": "Is any of",
  "filter.notIn": "Is none of",
  "filter.some": "Has any",
  "filter.every": "Has all",
  "filter.none": "Has none",
  "filter.isEmpty": "Is empty",
  "filter.isNotEmpty": "Is not empty",
  // Preview
  "preview.show": "Preview",
  "preview.hide": "Hide Preview",
  "preview.title": "Preview",
  "preview.livePreview": "Live Preview",
  "preview.fullscreen": "Fullscreen",
  "preview.close": "Close preview",
  "preview.loading": "Loading preview...",
  // Autosave
  "autosave.saving": "Saving...",
  "autosave.saved": "Saved",
  "autosave.unsavedChanges": "Unsaved changes",
  "autosave.justNow": "just now",
  "autosave.secondsAgo": { one: "{{count}}s ago", other: "{{count}}s ago" },
  "autosave.minutesAgo": { one: "{{count}}m ago", other: "{{count}}m ago" },
  "autosave.hoursAgo": { one: "{{count}}h ago", other: "{{count}}h ago" },
  // Global Search
  "globalSearch.placeholder": "Search collections, globals, actions, records...",
  "globalSearch.collections": "Collections",
  "globalSearch.globals": "Globals",
  "globalSearch.quickActions": "Quick Actions",
  "globalSearch.records": "Records",
  "globalSearch.createNew": "Create new {{name}}",
  "globalSearch.noResults": "No results found",
  "globalSearch.searching": "Searching...",
  "globalSearch.navigate": "to navigate",
  "globalSearch.select": "to select",
  // Collection Search
  "collectionSearch.placeholder": "Search records...",
  "collectionSearch.noResults": "No matching records found",
  "collectionSearch.searching": "Searching...",
  // Document Locking
  "lock.blockedTitle": "{{name}} is currently editing",
  "lock.blockedDescription": "This document is locked. You can view it but cannot make changes until the lock expires.",
  "lock.openElsewhere": "You have this document open in another tab. Changes will sync automatically.",
  "lock.cannotSave": "Cannot save - document is locked by another user"
};
const es = {
  // Common
  "common.save": "Guardar",
  "common.cancel": "Cancelar",
  "common.delete": "Eliminar",
  "common.edit": "Editar",
  "common.create": "Crear",
  "common.add": "Aadir",
  "common.remove": "Eliminar",
  "common.close": "Cerrar",
  "common.form": "Formulario",
  "common.search": "Buscar",
  "common.filter": "Filtrar",
  "common.refresh": "Actualizar",
  "common.loading": "Cargando...",
  "common.confirm": "Confirmar",
  "common.back": "Atrs",
  "common.next": "Siguiente",
  "common.previous": "Anterior",
  "common.actions": "Acciones",
  "common.more": "Ms",
  "common.yes": "S",
  "common.no": "No",
  "common.ok": "OK",
  "common.apply": "Aplicar",
  "common.reset": "Restablecer",
  "common.clear": "Limpiar",
  "common.selectAll": "Seleccionar todo",
  "common.deselectAll": "Deseleccionar todo",
  "common.duplicate": "Duplicar",
  "common.copy": "Copiar",
  "common.paste": "Pegar",
  "common.upload": "Subir",
  "common.download": "Descargar",
  "common.preview": "Vista previa",
  "common.view": "Ver",
  "common.open": "Abrir",
  "common.retry": "Reintentar",
  "common.submit": "Enviar",
  // Navigation
  "nav.dashboard": "Panel",
  "nav.collections": "Colecciones",
  "nav.globals": "Globales",
  "nav.media": "Medios",
  "nav.settings": "Configuracin",
  "nav.logout": "Cerrar sesin",
  "nav.home": "Inicio",
  "nav.back": "Atrs",
  // Dashboard
  "dashboard.title": "Panel",
  "dashboard.welcome": "Bienvenido de nuevo",
  "dashboard.recentActivity": "Actividad reciente",
  "dashboard.quickActions": "Acciones rpidas",
  // Collections
  "collection.create": "Crear {{name}}",
  "collection.edit": "Editar {{name}}",
  "collection.delete": "Eliminar {{name}}",
  "collection.deleteConfirm": "Est seguro de que desea eliminar {{name}}?",
  "collection.noItems": "No se encontraron {{name}}",
  "collection.createFirst": "Cree su primer {{name}}",
  "collection.itemCount": {
    one: "{{count}} elemento",
    other: "{{count}} elementos"
  },
  "collection.bulkDelete": "Eliminar seleccionados",
  "collection.bulkDeleteConfirm": "Est seguro de que desea eliminar {{count}} elementos?",
  "collection.bulkDeleteSuccess": {
    one: "{{count}} elemento eliminado correctamente",
    other: "{{count}} elementos eliminados correctamente"
  },
  "collection.bulkDeleteError": "Error al eliminar elementos",
  "collection.bulkDeletePartial": {
    one: "{{success}} elemento eliminado, {{failed}} fallido",
    other: "{{success}} elementos eliminados, {{failed}} fallidos"
  },
  "collection.bulkActionFailed": "Accin masiva fallida",
  "collection.selected": "{{count}} seleccionados",
  "collection.selectOnPage": "Todos en esta pgina",
  "collection.selectAllMatching": "Todos los que coinciden ({{count}})",
  "collection.clearSelection": "Limpiar seleccin",
  "collection.list": "Lista de {{name}}",
  "collection.new": "Nuevo {{name}}",
  "collection.duplicateSuccess": "{{name}} duplicado correctamente",
  "collection.duplicateError": "Error al duplicar {{name}}",
  // Relations
  "relation.select": "Seleccionar {{name}}",
  "relation.clear": "Limpiar seleccin",
  "relation.search": "Buscar {{name}}...",
  "relation.noResults": "No se encontraron {{name}}",
  "relation.loading": "Cargando...",
  "relation.createNew": "Crear nuevo {{name}}",
  "relation.selected": "{{count}} seleccionados",
  "relation.removeItem": "Eliminar {{name}}",
  "relation.addItem": "Aadir {{name}}",
  "relation.noneSelected": "Ningn {{name}} seleccionado",
  "relation.noRelated": "No se encontraron elementos relacionados",
  "relation.saveFirst": "Guarde este elemento primero para ver los elementos relacionados.",
  // Arrays
  "array.empty": "An no se han aadido {{name}}",
  "array.addItem": "Aadir {{name}}",
  // Blocks
  "blocks.addAbove": "Aadir arriba",
  "blocks.addBelow": "Aadir abajo",
  "blocks.addChild": "Aadir bloque hijo",
  // Forms
  "form.id": "ID",
  "form.created": "Creado",
  "form.updated": "Actualizado",
  "form.required": "Este campo es obligatorio",
  "form.invalid": "Valor invlido",
  "form.saveChanges": "Guardar cambios",
  "form.unsavedChanges": "Tiene cambios sin guardar",
  "form.discardChanges": "Descartar cambios",
  "form.discardConfirm": "Est seguro de que desea descartar los cambios? Esta accin no se puede deshacer.",
  "form.fieldRequired": "{{field}} es obligatorio",
  "form.fieldInvalid": "{{field}} es invlido",
  "form.maxLength": "Mximo {{max}} caracteres",
  "form.minLength": "Mnimo {{min}} caracteres",
  "form.maxValue": "Mximo {{max}}",
  "form.minValue": "Mnimo {{min}}",
  "form.pattern": "Formato invlido",
  "form.email": "Correo electrnico invlido",
  "form.url": "URL invlida",
  "form.createSuccess": "{{name}} creado correctamente",
  "form.createError": "Error al crear {{name}}",
  "form.updateSuccess": "{{name}} actualizado correctamente",
  "form.updateError": "Error al actualizar {{name}}",
  "form.deleteSuccess": "{{name}} eliminado correctamente",
  "form.deleteError": "Error al eliminar {{name}}",
  // Auth
  "auth.login": "Iniciar sesin",
  "auth.logout": "Cerrar sesin",
  "auth.email": "Correo electrnico",
  "auth.password": "Contrasea",
  "auth.forgotPassword": "Olvid su contrasea?",
  "auth.resetPassword": "Restablecer contrasea",
  "auth.signIn": "Iniciar sesin",
  "auth.signOut": "Cerrar sesin",
  "auth.signUp": "Registrarse",
  "auth.rememberMe": "Recordarme",
  "auth.invalidCredentials": "Correo electrnico o contrasea invlidos",
  "auth.sessionExpired": "Su sesin ha expirado. Por favor, inicie sesin nuevamente.",
  "auth.emailPlaceholder": "usted@ejemplo.com",
  "auth.passwordPlaceholder": "Ingrese su contrasea",
  "auth.signingIn": "Iniciando sesin...",
  "auth.creatingAdmin": "Creando administrador...",
  "auth.name": "Nombre",
  "auth.namePlaceholder": "Su nombre",
  "auth.confirmPassword": "Confirmar contrasea",
  "auth.confirmPasswordPlaceholder": "Confirme su contrasea",
  "auth.acceptInvite": "Aceptar invitacin",
  "auth.acceptingInvite": "Aceptando invitacin...",
  "auth.dontHaveAccount": "No tiene una cuenta?",
  "auth.alreadyHaveAccount": "Ya tiene una cuenta?",
  "auth.emailRequired": "El correo electrnico es obligatorio",
  "auth.passwordRequired": "La contrasea es obligatoria",
  "auth.passwordMinLength": "La contrasea debe tener al menos {{min}} caracteres",
  "auth.nameRequired": "El nombre es obligatorio",
  "auth.nameMinLength": "El nombre debe tener al menos {{min}} caracteres",
  "auth.invalidEmail": "Correo electrnico invlido",
  "auth.passwordMismatch": "Las contraseas no coinciden",
  "auth.newPassword": "Nueva contrasea",
  "auth.newPasswordPlaceholder": "Ingrese nueva contrasea",
  "auth.sendResetLink": "Enviar enlace de restablecimiento",
  "auth.sendingResetLink": "Enviando...",
  "auth.resetLinkSent": "Enlace de restablecimiento de contrasea enviado a su correo",
  "auth.resettingPassword": "Restableciendo contrasea...",
  "auth.createFirstAdmin": "Crear primer administrador",
  "auth.setupTitle": "Configuracin",
  "auth.setupDescription": "Cree su primera cuenta de administrador para comenzar.",
  "auth.profile": "Perfil",
  "auth.myAccount": "Mi cuenta",
  "auth.logoutFailed": "Error al cerrar sesin. Por favor, intente nuevamente.",
  // Errors
  "error.notFound": "No encontrado",
  "error.serverError": "Error del servidor",
  "error.networkError": "Error de red. Por favor, verifique su conexin.",
  "error.unauthorized": "No est autorizado para realizar esta accin",
  "error.forbidden": "Acceso denegado",
  "error.validation": "Validacin fallida",
  "error.unknown": "Ocurri un error desconocido",
  "error.timeout": "Tiempo de espera agotado. Por favor, intente nuevamente.",
  "error.conflict": "Ocurri un conflicto. Por favor, actualice e intente nuevamente.",
  // Table
  "table.rowsPerPage": "Filas por pgina",
  "table.of": "de",
  "table.noResults": "Sin resultados",
  "table.selectAll": "Seleccionar todo",
  "table.selectRow": "Seleccionar fila",
  "table.showing": "Mostrando {{from}} a {{to}} de {{total}}",
  "table.page": "Pgina {{page}}",
  "table.firstPage": "Primera pgina",
  "table.lastPage": "ltima pgina",
  "table.nextPage": "Siguiente pgina",
  "table.previousPage": "Pgina anterior",
  "table.sortAsc": "Ordenar ascendente",
  "table.sortDesc": "Ordenar descendente",
  "table.columns": "Columnas",
  "table.hideColumn": "Ocultar columna",
  "table.showColumn": "Mostrar columna",
  // Upload
  "upload.dropzone": "Arrastre archivos aqu o haga clic para subir",
  "upload.browse": "Explorar archivos",
  "upload.uploading": "Subiendo...",
  "upload.complete": "Carga completa",
  "upload.error": "Error al cargar",
  "upload.maxSize": "El archivo debe ser menor que {{size}}",
  "upload.invalidType": "Tipo de archivo invlido. Permitidos: {{types}}",
  "upload.remove": "Eliminar archivo",
  "upload.replace": "Reemplazar archivo",
  "upload.preview": "Vista previa",
  "upload.noFile": "Ningn archivo seleccionado",
  "upload.dragDrop": "Arrastre y suelte archivos aqu",
  // Editor
  "editor.bold": "Negrita",
  "editor.italic": "Cursiva",
  "editor.underline": "Subrayado",
  "editor.strikethrough": "Tachado",
  "editor.heading": "Encabezado {{level}}",
  "editor.link": "Insertar enlace",
  "editor.image": "Insertar imagen",
  "editor.list": "Lista",
  "editor.orderedList": "Lista numerada",
  "editor.unorderedList": "Lista con vietas",
  "editor.quote": "Cita",
  "editor.code": "Cdigo",
  "editor.codeBlock": "Bloque de cdigo",
  "editor.table": "Insertar tabla",
  "editor.undo": "Deshacer",
  "editor.redo": "Rehacer",
  "editor.alignLeft": "Alinear a la izquierda",
  "editor.alignCenter": "Centrar",
  "editor.alignRight": "Alinear a la derecha",
  "editor.alignJustify": "Justificar",
  "editor.horizontalRule": "Regla horizontal",
  "editor.addRowBefore": "Aadir fila antes",
  "editor.addRowAfter": "Aadir fila despus",
  "editor.addColumnBefore": "Aadir columna antes",
  "editor.addColumnAfter": "Aadir columna despus",
  "editor.deleteRow": "Eliminar fila",
  "editor.deleteColumn": "Eliminar columna",
  "editor.deleteTable": "Eliminar tabla",
  "editor.toggleHeaderRow": "Alternar fila de encabezado",
  "editor.toggleHeaderColumn": "Alternar columna de encabezado",
  "editor.mergeCells": "Combinar celdas",
  "editor.splitCell": "Dividir celda",
  "editor.insertUrl": "Insertar URL",
  "editor.altText": "Texto alternativo (opcional)",
  "editor.uploadFile": "Subir archivo",
  "editor.chooseFile": "Elegir archivo",
  "editor.uploading": "Subiendo...",
  "editor.browseLibrary": "Explorar biblioteca",
  // Toasts
  "toast.success": "xito",
  "toast.error": "Error",
  "toast.warning": "Advertencia",
  "toast.info": "Informacin",
  "toast.saving": "Guardando...",
  "toast.saveFailed": "Error al guardar cambios",
  "toast.saveSuccess": "Cambios guardados correctamente",
  "toast.creating": "Creando...",
  "toast.createSuccess": "Creado correctamente",
  "toast.createFailed": "Error al crear",
  "toast.deleting": "Eliminando...",
  "toast.deleteFailed": "Error al eliminar",
  "toast.deleteSuccess": "Eliminado correctamente",
  "toast.loadFailed": "Error al cargar datos",
  "toast.uploadFailed": "Error al subir archivo",
  "toast.uploadSuccess": "Archivo subido correctamente",
  "toast.copySuccess": "Copiado al portapapeles",
  "toast.copyFailed": "Error al copiar al portapapeles",
  "toast.idCopied": "ID copiado al portapapeles",
  "toast.validationFailed": "Validacin fallida",
  "toast.validationDescription": "Por favor, verifique el formulario en busca de errores",
  "toast.created": "{{name}} creado",
  "toast.updated": "{{name}} actualizado",
  "toast.resourceSaveFailed": "Error al guardar {{name}}",
  "toast.editComingSoon": "Funcin de edicin prximamente disponible",
  "toast.maxFilesWarning": "Solo puede aadir {{remaining}} archivo(s) ms (mx {{max}})",
  "toast.settingsSaveFailed": "Error al guardar configuracin",
  "toast.actionSuccess": "Accin completada correctamente",
  "toast.actionFailed": "Accin fallida",
  "toast.localeChangedUnsaved": "Idioma de contenido cambiado",
  "toast.localeChangedUnsavedDescription": "Sus cambios sin guardar fueron reemplazados por el contenido en el nuevo idioma.",
  // Confirm
  "confirm.delete": "Est seguro de que desea eliminar esto? Esta accin no se puede deshacer.",
  "confirm.discard": "Est seguro de que desea descartar los cambios? Esta accin no se puede deshacer.",
  "confirm.unsavedChanges": "Tiene cambios sin guardar. Est seguro de que desea salir?",
  "confirm.action": "Est seguro de que desea continuar?",
  "confirm.irreversible": "Esta accin no se puede deshacer.",
  "confirm.localeChange": "Descartar cambios sin guardar?",
  "confirm.localeChangeDescription": "Tiene cambios sin guardar. Cambiar el idioma de contenido descartar sus cambios y cargar el contenido en el nuevo idioma.",
  "confirm.localeChangeStay": "Quedarse",
  "confirm.localeChangeDiscard": "Descartar y cambiar",
  // Status
  "status.draft": "Borrador",
  "status.published": "Publicado",
  "status.archived": "Archivado",
  "status.pending": "Pendiente",
  "status.active": "Activo",
  "status.inactive": "Inactivo",
  // Dates
  "date.today": "Hoy",
  "date.yesterday": "Ayer",
  "date.tomorrow": "Maana",
  "date.selectDate": "Seleccionar fecha",
  "date.selectTime": "Seleccionar hora",
  "date.clear": "Limpiar fecha",
  // Accessibility
  "a11y.openMenu": "Abrir men",
  "a11y.closeMenu": "Cerrar men",
  "a11y.expand": "Expandir",
  "a11y.collapse": "Colapsar",
  "a11y.loading": "Cargando",
  "a11y.required": "Requerido",
  "a11y.optional": "Opcional",
  "a11y.selected": "Seleccionado",
  "a11y.notSelected": "No seleccionado",
  // Locale
  "locale.language": "Idioma",
  "locale.switchLanguage": "Cambiar idioma",
  "locale.contentLanguage": "Idioma de contenido",
  "locale.uiLanguage": "Idioma de interfaz",
  // ===========================================
  // Default Collections
  // ===========================================
  // Users Collection
  "defaults.users.label": "Usuarios",
  "defaults.users.description": "Gestionar usuarios administradores y sus roles",
  "defaults.users.fields.name.label": "Nombre",
  "defaults.users.fields.name.placeholder": "Ingrese nombre de usuario",
  "defaults.users.fields.email.label": "Correo electrnico",
  "defaults.users.fields.email.description": "Direccin de correo (solo lectura)",
  "defaults.users.fields.role.label": "Rol",
  "defaults.users.fields.role.options.admin": "Administrador",
  "defaults.users.fields.role.options.user": "Usuario",
  "defaults.users.fields.emailVerified.label": "Correo verificado",
  "defaults.users.fields.emailVerified.description": "Si el usuario ha verificado su direccin de correo",
  "defaults.users.fields.banned.label": "Bloqueado",
  "defaults.users.fields.banned.description": "Evitar que el usuario acceda al sistema",
  "defaults.users.fields.banReason.label": "Motivo de bloqueo",
  "defaults.users.fields.banReason.placeholder": "Ingrese motivo del bloqueo...",
  "defaults.users.sections.basicInfo": "Informacin bsica",
  "defaults.users.sections.permissions": "Permisos",
  "defaults.users.sections.accessControl": "Control de acceso",
  "defaults.users.actions.createUser.label": "Crear usuario",
  "defaults.users.actions.createUser.title": "Crear usuario",
  "defaults.users.actions.createUser.description": "Crear una nueva cuenta de usuario con credenciales de inicio de sesin.",
  "defaults.users.actions.createUser.fields.password.label": "Contrasea",
  "defaults.users.actions.createUser.fields.password.placeholder": "Ingrese contrasea",
  "defaults.users.actions.createUser.submit": "Crear usuario",
  "defaults.users.actions.createUser.success": "Usuario {{email}} creado correctamente. Comparta las credenciales con el usuario.",
  "defaults.users.actions.createUser.errorNoAuth": "Cliente de autenticacin no configurado. No se puede crear usuario.",
  "defaults.users.actions.resetPassword.label": "Restablecer contrasea",
  "defaults.users.actions.resetPassword.title": "Restablecer contrasea",
  "defaults.users.actions.resetPassword.description": "Establecer una nueva contrasea para este usuario.",
  "defaults.users.actions.resetPassword.fields.newPassword.label": "Nueva contrasea",
  "defaults.users.actions.resetPassword.fields.newPassword.placeholder": "Ingrese nueva contrasea",
  "defaults.users.actions.resetPassword.fields.confirmPassword.label": "Confirmar contrasea",
  "defaults.users.actions.resetPassword.fields.confirmPassword.placeholder": "Confirme nueva contrasea",
  "defaults.users.actions.resetPassword.submit": "Restablecer contrasea",
  "defaults.users.actions.resetPassword.success": "Contrasea restablecida correctamente!",
  "defaults.users.actions.resetPassword.errorMismatch": "Las contraseas no coinciden",
  "defaults.users.actions.delete.label": "Eliminar usuario",
  // Assets Collection
  "defaults.assets.label": "Medios",
  "defaults.assets.description": "Gestionar archivos e imgenes subidos",
  "defaults.assets.fields.preview.label": "Vista previa",
  "defaults.assets.fields.filename.label": "Nombre de archivo",
  "defaults.assets.fields.filename.description": "Nombre original del archivo subido",
  "defaults.assets.fields.mimeType.label": "Tipo",
  "defaults.assets.fields.mimeType.description": "Tipo MIME del archivo",
  "defaults.assets.fields.size.label": "Tamao (bytes)",
  "defaults.assets.fields.size.description": "Tamao del archivo en bytes",
  "defaults.assets.fields.alt.label": "Texto alternativo",
  "defaults.assets.fields.alt.placeholder": "Describa la imagen para accesibilidad",
  "defaults.assets.fields.alt.description": "Texto alternativo para lectores de pantalla",
  "defaults.assets.fields.caption.label": "Leyenda",
  "defaults.assets.fields.caption.placeholder": "Aadir una leyenda...",
  "defaults.assets.fields.visibility.label": "Visibilidad",
  "defaults.assets.fields.visibility.options.public": "Pblico",
  "defaults.assets.fields.visibility.options.private": "Privado",
  "defaults.assets.fields.visibility.description": "Los archivos pblicos son accesibles sin autenticacin. Los archivos privados requieren una URL firmada.",
  "defaults.assets.sections.fileInfo": "Informacin del archivo",
  "defaults.assets.sections.metadata": "Metadatos",
  "defaults.assets.sections.metadata.description": "Aada informacin descriptiva para accesibilidad y SEO",
  "defaults.assets.actions.upload.label": "Subir archivos",
  // Default Sidebar
  "defaults.sidebar.administration": "Administracin",
  // View Options (Filter Builder)
  "viewOptions.title": "Opciones de vista",
  "viewOptions.columns": "Columnas",
  "viewOptions.filters": "Filtros",
  "viewOptions.savedViews": "Vistas guardadas",
  "viewOptions.apply": "Aplicar",
  "viewOptions.reset": "Restablecer",
  // Saved Views Tab
  "viewOptions.saveCurrentConfig": "Guardar configuracin actual",
  "viewOptions.viewNamePlaceholder": "Nombre de vista...",
  "viewOptions.saveDescription": "Guarda las columnas, filtros y orden actual.",
  "viewOptions.noChangesToSave": "No hay filtros o cambios de columnas para guardar.",
  "viewOptions.noSavedViews": "An no hay vistas guardadas.",
  "viewOptions.filtersCount": {
    one: "{{count}} filtro",
    other: "{{count}} filtros"
  },
  "viewOptions.columnsCount": { one: "{{count}} col", other: "{{count}} cols" },
  "viewOptions.defaultView": "Predeterminado",
  // Columns Tab
  "viewOptions.columnsDragHint": "Arrastre para reordenar, active/desactive para mostrar/ocultar columnas.",
  "viewOptions.noFieldsAvailable": "No hay campos disponibles.",
  // Filters Tab
  "viewOptions.filtersDescription": "Reduzca sus resultados con reglas personalizadas.",
  "viewOptions.filterNumber": "Filtro #{{number}}",
  "viewOptions.selectField": "Seleccionar campo",
  "viewOptions.selectOperator": "Seleccionar operador",
  "viewOptions.valuePlaceholder": "Valor...",
  "viewOptions.noActiveFilters": "No hay filtros activos.",
  "viewOptions.addFilter": "Aadir filtro",
  "viewOptions.clearAll": "Limpiar todo",
  "viewOptions.activeFilters": {
    one: "{{count}} filtro activo",
    other: "{{count}} filtros activos"
  },
  "viewOptions.clearFilters": "Limpiar filtros",
  // Filter Operators
  "filter.contains": "Contiene",
  "filter.notContains": "No contiene",
  "filter.equals": "Igual a",
  "filter.notEquals": "No igual a",
  "filter.startsWith": "Comienza con",
  "filter.endsWith": "Termina con",
  "filter.greaterThan": "Mayor que",
  "filter.greaterThanOrEqual": "Mayor o igual que",
  "filter.lessThan": "Menor que",
  "filter.lessThanOrEqual": "Menor o igual que",
  "filter.in": "Es cualquiera de",
  "filter.notIn": "No es ninguno de",
  "filter.some": "Tiene alguno",
  "filter.every": "Tiene todos",
  "filter.none": "No tiene ninguno",
  "filter.isEmpty": "Est vaco",
  "filter.isNotEmpty": "No est vaco",
  // Preview
  "preview.show": "Vista previa",
  "preview.hide": "Ocultar vista previa",
  "preview.title": "Vista previa",
  "preview.livePreview": "Vista previa en vivo",
  "preview.fullscreen": "Pantalla completa",
  "preview.close": "Cerrar vista previa",
  "preview.loading": "Cargando vista previa...",
  // Autosave
  "autosave.saving": "Guardando...",
  "autosave.saved": "Guardado",
  "autosave.unsavedChanges": "Cambios sin guardar",
  "autosave.justNow": "ahora mismo",
  "autosave.secondsAgo": { one: "hace {{count}}s", other: "hace {{count}}s" },
  "autosave.minutesAgo": { one: "hace {{count}}m", other: "hace {{count}}m" },
  "autosave.hoursAgo": { one: "hace {{count}}h", other: "hace {{count}}h" },
  // Global Search
  "globalSearch.placeholder": "Buscar colecciones, globales, acciones, registros...",
  "globalSearch.collections": "Colecciones",
  "globalSearch.globals": "Globales",
  "globalSearch.quickActions": "Acciones rpidas",
  "globalSearch.records": "Registros",
  "globalSearch.createNew": "Crear nuevo {{name}}",
  "globalSearch.noResults": "No se encontraron resultados",
  "globalSearch.searching": "Buscando...",
  "globalSearch.navigate": "para navegar",
  "globalSearch.select": "para seleccionar",
  // Collection Search
  "collectionSearch.placeholder": "Buscar registros...",
  "collectionSearch.noResults": "No se encontraron registros coincidentes",
  "collectionSearch.searching": "Buscando..."
};
const fr = {
  // Common
  "common.save": "Enregistrer",
  "common.cancel": "Annuler",
  "common.delete": "Supprimer",
  "common.edit": "Modifier",
  "common.create": "Crer",
  "common.add": "Ajouter",
  "common.remove": "Supprimer",
  "common.close": "Fermer",
  "common.form": "Formulaire",
  "common.search": "Rechercher",
  "common.filter": "Filtrer",
  "common.refresh": "Actualiser",
  "common.loading": "Chargement...",
  "common.confirm": "Confirmer",
  "common.back": "Retour",
  "common.next": "Suivant",
  "common.previous": "Prcdent",
  "common.actions": "Actions",
  "common.more": "Plus",
  "common.yes": "Oui",
  "common.no": "Non",
  "common.ok": "OK",
  "common.apply": "Appliquer",
  "common.reset": "Rinitialiser",
  "common.clear": "Effacer",
  "common.selectAll": "Tout slectionner",
  "common.deselectAll": "Tout dslectionner",
  "common.duplicate": "Dupliquer",
  "common.copy": "Copier",
  "common.paste": "Coller",
  "common.upload": "Tlverser",
  "common.download": "Tlcharger",
  "common.preview": "Aperu",
  "common.view": "Voir",
  "common.open": "Ouvrir",
  "common.retry": "Ressayer",
  "common.submit": "Soumettre",
  // Navigation
  "nav.dashboard": "Tableau de bord",
  "nav.collections": "Collections",
  "nav.globals": "Globales",
  "nav.media": "Mdias",
  "nav.settings": "Paramtres",
  "nav.logout": "Se dconnecter",
  "nav.home": "Accueil",
  "nav.back": "Retour",
  // Dashboard
  "dashboard.title": "Tableau de bord",
  "dashboard.welcome": "Bon retour",
  "dashboard.recentActivity": "Activit rcente",
  "dashboard.quickActions": "Actions rapides",
  // Collections
  "collection.create": "Crer {{name}}",
  "collection.edit": "Modifier {{name}}",
  "collection.delete": "Supprimer {{name}}",
  "collection.deleteConfirm": "tes-vous sr de vouloir supprimer {{name}} ?",
  "collection.noItems": "Aucun {{name}} trouv",
  "collection.createFirst": "Crez votre premier {{name}}",
  "collection.itemCount": {
    one: "{{count}} lment",
    other: "{{count}} lments"
  },
  "collection.bulkDelete": "Supprimer la slection",
  "collection.bulkDeleteConfirm": "tes-vous sr de vouloir supprimer {{count}} lments ?",
  "collection.bulkDeleteSuccess": {
    one: "{{count}} lment supprim avec succs",
    other: "{{count}} lments supprims avec succs"
  },
  "collection.bulkDeleteError": "chec de la suppression des lments",
  "collection.bulkDeletePartial": {
    one: "{{success}} lment supprim, {{failed}} chec",
    other: "{{success}} lments supprims, {{failed}} checs"
  },
  "collection.bulkActionFailed": "Action groupe choue",
  "collection.selected": "{{count}} slectionn(s)",
  "collection.selectOnPage": "Tous sur cette page",
  "collection.selectAllMatching": "Tous correspondant ({{count}})",
  "collection.clearSelection": "Effacer la slection",
  "collection.list": "Liste {{name}}",
  "collection.new": "Nouveau {{name}}",
  "collection.duplicateSuccess": "{{name}} dupliqu avec succs",
  "collection.duplicateError": "chec de la duplication de {{name}}",
  // Relations
  "relation.select": "Slectionner {{name}}",
  "relation.clear": "Effacer la slection",
  "relation.search": "Rechercher {{name}}...",
  "relation.noResults": "Aucun {{name}} trouv",
  "relation.loading": "Chargement...",
  "relation.createNew": "Crer nouveau {{name}}",
  "relation.selected": "{{count}} slectionn(s)",
  "relation.removeItem": "Supprimer {{name}}",
  "relation.addItem": "Ajouter {{name}}",
  "relation.noneSelected": "Aucun {{name}} slectionn",
  "relation.noRelated": "Aucun lment li trouv",
  "relation.saveFirst": "Enregistrez d'abord cet lment pour voir les lments lis.",
  // Arrays
  "array.empty": "Aucun {{name}} ajout pour le moment",
  "array.addItem": "Ajouter {{name}}",
  // Blocks
  "blocks.addAbove": "Ajouter au-dessus",
  "blocks.addBelow": "Ajouter en-dessous",
  "blocks.addChild": "Ajouter bloc enfant",
  // Forms
  "form.id": "ID",
  "form.created": "Cr",
  "form.updated": "Mis  jour",
  "form.required": "Ce champ est obligatoire",
  "form.invalid": "Valeur invalide",
  "form.saveChanges": "Enregistrer les modifications",
  "form.unsavedChanges": "Vous avez des modifications non enregistres",
  "form.discardChanges": "Abandonner les modifications",
  "form.discardConfirm": "tes-vous sr de vouloir abandonner les modifications ? Cette action est irrversible.",
  "form.fieldRequired": "{{field}} est obligatoire",
  "form.fieldInvalid": "{{field}} est invalide",
  "form.maxLength": "Maximum {{max}} caractres",
  "form.minLength": "Minimum {{min}} caractres",
  "form.maxValue": "Maximum {{max}}",
  "form.minValue": "Minimum {{min}}",
  "form.pattern": "Format invalide",
  "form.email": "Adresse e-mail invalide",
  "form.url": "URL invalide",
  "form.createSuccess": "{{name}} cr avec succs",
  "form.createError": "chec de la cration de {{name}}",
  "form.updateSuccess": "{{name}} mis  jour avec succs",
  "form.updateError": "chec de la mise  jour de {{name}}",
  "form.deleteSuccess": "{{name}} supprim avec succs",
  "form.deleteError": "chec de la suppression de {{name}}",
  // Auth
  "auth.login": "Se connecter",
  "auth.logout": "Se dconnecter",
  "auth.email": "E-mail",
  "auth.password": "Mot de passe",
  "auth.forgotPassword": "Mot de passe oubli ?",
  "auth.resetPassword": "Rinitialiser le mot de passe",
  "auth.signIn": "Se connecter",
  "auth.signOut": "Se dconnecter",
  "auth.signUp": "S'inscrire",
  "auth.rememberMe": "Se souvenir de moi",
  "auth.invalidCredentials": "E-mail ou mot de passe invalide",
  "auth.sessionExpired": "Votre session a expir. Veuillez vous reconnecter.",
  "auth.emailPlaceholder": "vous@exemple.fr",
  "auth.passwordPlaceholder": "Entrez votre mot de passe",
  "auth.signingIn": "Connexion en cours...",
  "auth.creatingAdmin": "Cration de l'administrateur...",
  "auth.name": "Nom",
  "auth.namePlaceholder": "Votre nom",
  "auth.confirmPassword": "Confirmer le mot de passe",
  "auth.confirmPasswordPlaceholder": "Confirmez votre mot de passe",
  "auth.acceptInvite": "Accepter l'invitation",
  "auth.acceptingInvite": "Acceptation de l'invitation...",
  "auth.dontHaveAccount": "Vous n'avez pas de compte ?",
  "auth.alreadyHaveAccount": "Vous avez dj un compte ?",
  "auth.emailRequired": "L'e-mail est obligatoire",
  "auth.passwordRequired": "Le mot de passe est obligatoire",
  "auth.passwordMinLength": "Le mot de passe doit avoir au moins {{min}} caractres",
  "auth.nameRequired": "Le nom est obligatoire",
  "auth.nameMinLength": "Le nom doit avoir au moins {{min}} caractres",
  "auth.invalidEmail": "Adresse e-mail invalide",
  "auth.passwordMismatch": "Les mots de passe ne correspondent pas",
  "auth.newPassword": "Nouveau mot de passe",
  "auth.newPasswordPlaceholder": "Entrez nouveau mot de passe",
  "auth.sendResetLink": "Envoyer le lien de rinitialisation",
  "auth.sendingResetLink": "Envoi en cours...",
  "auth.resetLinkSent": "Lien de rinitialisation envoy  votre e-mail",
  "auth.resettingPassword": "Rinitialisation du mot de passe...",
  "auth.createFirstAdmin": "Crer le premier administrateur",
  "auth.setupTitle": "Configuration",
  "auth.setupDescription": "Crez votre premier compte administrateur pour commencer.",
  "auth.profile": "Profil",
  "auth.myAccount": "Mon compte",
  "auth.logoutFailed": "chec de la dconnexion. Veuillez ressayer.",
  // Errors
  "error.notFound": "Non trouv",
  "error.serverError": "Erreur serveur",
  "error.networkError": "Erreur rseau. Veuillez vrifier votre connexion.",
  "error.unauthorized": "Vous n'tes pas autoris  effectuer cette action",
  "error.forbidden": "Accs refus",
  "error.validation": "Validation choue",
  "error.unknown": "Une erreur inconnue s'est produite",
  "error.timeout": "Dlai de demande dpass. Veuillez ressayer.",
  "error.conflict": "Un conflit s'est produit. Veuillez actualiser et ressayer.",
  // Table
  "table.rowsPerPage": "Lignes par page",
  "table.of": "sur",
  "table.noResults": "Aucun rsultat",
  "table.selectAll": "Tout slectionner",
  "table.selectRow": "Slectionner la ligne",
  "table.showing": "Affichage de {{from}}  {{to}} sur {{total}}",
  "table.page": "Page {{page}}",
  "table.firstPage": "Premire page",
  "table.lastPage": "Dernire page",
  "table.nextPage": "Page suivante",
  "table.previousPage": "Page prcdente",
  "table.sortAsc": "Trier croissant",
  "table.sortDesc": "Trier dcroissant",
  "table.columns": "Colonnes",
  "table.hideColumn": "Masquer colonne",
  "table.showColumn": "Afficher colonne",
  // Upload
  "upload.dropzone": "Dposez les fichiers ici ou cliquez pour tlverser",
  "upload.browse": "Parcourir les fichiers",
  "upload.uploading": "Tlversement...",
  "upload.complete": "Tlversement termin",
  "upload.error": "chec du tlversement",
  "upload.maxSize": "Le fichier doit tre plus petit que {{size}}",
  "upload.invalidType": "Type de fichier invalide. Autoriss : {{types}}",
  "upload.remove": "Supprimer fichier",
  "upload.replace": "Remplacer fichier",
  "upload.preview": "Aperu",
  "upload.noFile": "Aucun fichier slectionn",
  "upload.dragDrop": "Glissez-dposez les fichiers ici",
  // Editor
  "editor.bold": "Gras",
  "editor.italic": "Italique",
  "editor.underline": "Soulign",
  "editor.strikethrough": "Barr",
  "editor.heading": "Titre {{level}}",
  "editor.link": "Insrer lien",
  "editor.image": "Insrer image",
  "editor.list": "Liste",
  "editor.orderedList": "Liste numrote",
  "editor.unorderedList": "Liste  puces",
  "editor.quote": "Citation",
  "editor.code": "Code",
  "editor.codeBlock": "Bloc de code",
  "editor.table": "Insrer tableau",
  "editor.undo": "Annuler",
  "editor.redo": "Rtablir",
  "editor.alignLeft": "Aligner  gauche",
  "editor.alignCenter": "Centrer",
  "editor.alignRight": "Aligner  droite",
  "editor.alignJustify": "Justifier",
  "editor.horizontalRule": "Ligne horizontale",
  "editor.addRowBefore": "Ajouter ligne avant",
  "editor.addRowAfter": "Ajouter ligne aprs",
  "editor.addColumnBefore": "Ajouter colonne avant",
  "editor.addColumnAfter": "Ajouter colonne aprs",
  "editor.deleteRow": "Supprimer ligne",
  "editor.deleteColumn": "Supprimer colonne",
  "editor.deleteTable": "Supprimer tableau",
  "editor.toggleHeaderRow": "Basculer ligne d'en-tte",
  "editor.toggleHeaderColumn": "Basculer colonne d'en-tte",
  "editor.mergeCells": "Fusionner cellules",
  "editor.splitCell": "Diviser cellule",
  "editor.insertUrl": "Insrer URL",
  "editor.altText": "Texte alternatif (optionnel)",
  "editor.uploadFile": "Tlverser fichier",
  "editor.chooseFile": "Choisir fichier",
  "editor.uploading": "Tlversement...",
  "editor.browseLibrary": "Parcourir la bibliothque",
  // Toasts
  "toast.success": "Succs",
  "toast.error": "Erreur",
  "toast.warning": "Avertissement",
  "toast.info": "Information",
  "toast.saving": "Enregistrement...",
  "toast.saveFailed": "chec de l'enregistrement des modifications",
  "toast.saveSuccess": "Modifications enregistres avec succs",
  "toast.creating": "Cration...",
  "toast.createSuccess": "Cr avec succs",
  "toast.createFailed": "chec de la cration",
  "toast.deleting": "Suppression...",
  "toast.deleteFailed": "chec de la suppression",
  "toast.deleteSuccess": "Supprim avec succs",
  "toast.loadFailed": "chec du chargement des donnes",
  "toast.uploadFailed": "chec du tlversement du fichier",
  "toast.uploadSuccess": "Fichier tlvers avec succs",
  "toast.copySuccess": "Copi dans le presse-papiers",
  "toast.copyFailed": "chec de la copie dans le presse-papiers",
  "toast.idCopied": "ID copi dans le presse-papiers",
  "toast.validationFailed": "Validation choue",
  "toast.validationDescription": "Veuillez vrifier le formulaire pour les erreurs",
  "toast.created": "{{name}} cr",
  "toast.updated": "{{name}} mis  jour",
  "toast.resourceSaveFailed": "chec de l'enregistrement de {{name}}",
  "toast.editComingSoon": "Fonction de modification bientt disponible",
  "toast.maxFilesWarning": "Seulement {{remaining}} fichier(s) supplmentaire(s) peuvent tre ajouts (max {{max}})",
  "toast.settingsSaveFailed": "chec de l'enregistrement des paramtres",
  "toast.actionSuccess": "Action termine avec succs",
  "toast.actionFailed": "Action choue",
  "toast.localeChangedUnsaved": "Langue du contenu modifie",
  "toast.localeChangedUnsavedDescription": "Vos modifications non enregistres ont t remplaces par le contenu dans la nouvelle langue.",
  // Confirm
  "confirm.delete": "tes-vous sr de vouloir supprimer ceci ? Cette action est irrversible.",
  "confirm.discard": "tes-vous sr de vouloir abandonner les modifications ? Cette action est irrversible.",
  "confirm.unsavedChanges": "Vous avez des modifications non enregistres. tes-vous sr de vouloir quitter ?",
  "confirm.action": "tes-vous sr de vouloir continuer ?",
  "confirm.irreversible": "Cette action est irrversible.",
  "confirm.localeChange": "Abandonner les modifications non enregistres ?",
  "confirm.localeChangeDescription": "Vous avez des modifications non enregistres. Changer la langue du contenu abandonnera vos modifications et chargera le contenu dans la nouvelle langue.",
  "confirm.localeChangeStay": "Rester",
  "confirm.localeChangeDiscard": "Abandonner et changer",
  // Status
  "status.draft": "Brouillon",
  "status.published": "Publi",
  "status.archived": "Archiv",
  "status.pending": "En attente",
  "status.active": "Actif",
  "status.inactive": "Inactif",
  // Dates
  "date.today": "Aujourd'hui",
  "date.yesterday": "Hier",
  "date.tomorrow": "Demain",
  "date.selectDate": "Slectionner date",
  "date.selectTime": "Slectionner heure",
  "date.clear": "Effacer date",
  // Accessibility
  "a11y.openMenu": "Ouvrir menu",
  "a11y.closeMenu": "Fermer menu",
  "a11y.expand": "Dvelopper",
  "a11y.collapse": "Rduire",
  "a11y.loading": "Chargement",
  "a11y.required": "Obligatoire",
  "a11y.optional": "Optionnel",
  "a11y.selected": "Slectionn",
  "a11y.notSelected": "Non slectionn",
  // Locale
  "locale.language": "Langue",
  "locale.switchLanguage": "Changer de langue",
  "locale.contentLanguage": "Langue du contenu",
  "locale.uiLanguage": "Langue de l'interface",
  // ===========================================
  // Default Collections
  // ===========================================
  // Users Collection
  "defaults.users.label": "Utilisateurs",
  "defaults.users.description": "Grer les utilisateurs et leurs rles",
  "defaults.users.fields.name.label": "Nom",
  "defaults.users.fields.name.placeholder": "Entrez le nom de l'utilisateur",
  "defaults.users.fields.email.label": "E-mail",
  "defaults.users.fields.email.description": "Adresse e-mail (lecture seule)",
  "defaults.users.fields.role.label": "Rle",
  "defaults.users.fields.role.options.admin": "Administrateur",
  "defaults.users.fields.role.options.user": "Utilisateur",
  "defaults.users.fields.emailVerified.label": "E-mail vrifi",
  "defaults.users.fields.emailVerified.description": "Si l'utilisateur a vrifi son adresse e-mail",
  "defaults.users.fields.banned.label": "Banni",
  "defaults.users.fields.banned.description": "Empcher l'utilisateur d'accder au systme",
  "defaults.users.fields.banReason.label": "Raison du bannissement",
  "defaults.users.fields.banReason.placeholder": "Entrez la raison du bannissement...",
  "defaults.users.sections.basicInfo": "Informations de base",
  "defaults.users.sections.permissions": "Permissions",
  "defaults.users.sections.accessControl": "Contrle d'accs",
  "defaults.users.actions.createUser.label": "Crer utilisateur",
  "defaults.users.actions.createUser.title": "Crer utilisateur",
  "defaults.users.actions.createUser.description": "Crer un nouveau compte utilisateur avec identifiants de connexion.",
  "defaults.users.actions.createUser.fields.password.label": "Mot de passe",
  "defaults.users.actions.createUser.fields.password.placeholder": "Entrez le mot de passe",
  "defaults.users.actions.createUser.submit": "Crer utilisateur",
  "defaults.users.actions.createUser.success": "Utilisateur {{email}} cr avec succs. Partagez les identifiants avec l'utilisateur.",
  "defaults.users.actions.createUser.errorNoAuth": "Client d'authentification non configur. Impossible de crer l'utilisateur.",
  "defaults.users.actions.resetPassword.label": "Rinitialiser mot de passe",
  "defaults.users.actions.resetPassword.title": "Rinitialiser mot de passe",
  "defaults.users.actions.resetPassword.description": "Dfinir un nouveau mot de passe pour cet utilisateur.",
  "defaults.users.actions.resetPassword.fields.newPassword.label": "Nouveau mot de passe",
  "defaults.users.actions.resetPassword.fields.newPassword.placeholder": "Entrez nouveau mot de passe",
  "defaults.users.actions.resetPassword.fields.confirmPassword.label": "Confirmer mot de passe",
  "defaults.users.actions.resetPassword.fields.confirmPassword.placeholder": "Confirmez nouveau mot de passe",
  "defaults.users.actions.resetPassword.submit": "Rinitialiser mot de passe",
  "defaults.users.actions.resetPassword.success": "Mot de passe rinitialis avec succs !",
  "defaults.users.actions.resetPassword.errorMismatch": "Les mots de passe ne correspondent pas",
  "defaults.users.actions.delete.label": "Supprimer utilisateur",
  // Assets Collection
  "defaults.assets.label": "Mdias",
  "defaults.assets.description": "Grer les fichiers et images tlverss",
  "defaults.assets.fields.preview.label": "Aperu",
  "defaults.assets.fields.filename.label": "Nom de fichier",
  "defaults.assets.fields.filename.description": "Nom original du fichier tlvers",
  "defaults.assets.fields.mimeType.label": "Type",
  "defaults.assets.fields.mimeType.description": "Type MIME du fichier",
  "defaults.assets.fields.size.label": "Taille (octets)",
  "defaults.assets.fields.size.description": "Taille du fichier en octets",
  "defaults.assets.fields.alt.label": "Texte alternatif",
  "defaults.assets.fields.alt.placeholder": "Dcrivez l'image pour l'accessibilit",
  "defaults.assets.fields.alt.description": "Texte alternatif pour les lecteurs d'cran",
  "defaults.assets.fields.caption.label": "Lgende",
  "defaults.assets.fields.caption.placeholder": "Ajouter une lgende...",
  "defaults.assets.fields.visibility.label": "Visibilit",
  "defaults.assets.fields.visibility.options.public": "Public",
  "defaults.assets.fields.visibility.options.private": "Priv",
  "defaults.assets.fields.visibility.description": "Les fichiers publics sont accessibles sans authentification. Les fichiers privs ncessitent une URL signe.",
  "defaults.assets.sections.fileInfo": "Informations du fichier",
  "defaults.assets.sections.metadata": "Mtadonnes",
  "defaults.assets.sections.metadata.description": "Ajoutez des informations descriptives pour l'accessibilit et le SEO",
  "defaults.assets.actions.upload.label": "Tlverser fichiers",
  // Default Sidebar
  "defaults.sidebar.administration": "Administration",
  // View Options (Filter Builder)
  "viewOptions.title": "Options de vue",
  "viewOptions.columns": "Colonnes",
  "viewOptions.filters": "Filtres",
  "viewOptions.savedViews": "Vues enregistres",
  "viewOptions.apply": "Appliquer",
  "viewOptions.reset": "Rinitialiser",
  // Saved Views Tab
  "viewOptions.saveCurrentConfig": "Enregistrer la configuration actuelle",
  "viewOptions.viewNamePlaceholder": "Nom de la vue...",
  "viewOptions.saveDescription": "Enregistre les colonnes, filtres et tri actuels.",
  "viewOptions.noChangesToSave": "Aucun filtre ou changement de colonnes  enregistrer.",
  "viewOptions.noSavedViews": "Aucune vue enregistre pour le moment.",
  "viewOptions.filtersCount": {
    one: "{{count}} filtre",
    other: "{{count}} filtres"
  },
  "viewOptions.columnsCount": { one: "{{count}} col", other: "{{count}} cols" },
  "viewOptions.defaultView": "Par dfaut",
  // Columns Tab
  "viewOptions.columnsDragHint": "Glissez pour rordonner, activez/dsactivez pour afficher/masquer les colonnes.",
  "viewOptions.noFieldsAvailable": "Aucun champ disponible.",
  // Filters Tab
  "viewOptions.filtersDescription": "Affinez vos rsultats avec des rgles personnalises.",
  "viewOptions.filterNumber": "Filtre #{{number}}",
  "viewOptions.selectField": "Slectionner champ",
  "viewOptions.selectOperator": "Slectionner oprateur",
  "viewOptions.valuePlaceholder": "Valeur...",
  "viewOptions.noActiveFilters": "Aucun filtre actif.",
  "viewOptions.addFilter": "Ajouter filtre",
  "viewOptions.clearAll": "Tout effacer",
  "viewOptions.activeFilters": {
    one: "{{count}} filtre actif",
    other: "{{count}} filtres actifs"
  },
  "viewOptions.clearFilters": "Effacer filtres",
  // Filter Operators
  "filter.contains": "Contient",
  "filter.notContains": "Ne contient pas",
  "filter.equals": "gal ",
  "filter.notEquals": "Diffrent de",
  "filter.startsWith": "Commence par",
  "filter.endsWith": "Termine par",
  "filter.greaterThan": "Suprieur ",
  "filter.greaterThanOrEqual": "Suprieur ou gal ",
  "filter.lessThan": "Infrieur ",
  "filter.lessThanOrEqual": "Infrieur ou gal ",
  "filter.in": "Est l'un de",
  "filter.notIn": "N'est aucun de",
  "filter.some": "A au moins un",
  "filter.every": "A tous",
  "filter.none": "N'en a aucun",
  "filter.isEmpty": "Est vide",
  "filter.isNotEmpty": "N'est pas vide",
  // Preview
  "preview.show": "Aperu",
  "preview.hide": "Masquer aperu",
  "preview.title": "Aperu",
  "preview.livePreview": "Aperu en direct",
  "preview.fullscreen": "Plein cran",
  "preview.close": "Fermer aperu",
  "preview.loading": "Chargement de l'aperu...",
  // Autosave
  "autosave.saving": "Enregistrement...",
  "autosave.saved": "Enregistr",
  "autosave.unsavedChanges": "Modifications non enregistres",
  "autosave.justNow": " l'instant",
  "autosave.secondsAgo": {
    one: "il y a {{count}}s",
    other: "il y a {{count}}s"
  },
  "autosave.minutesAgo": {
    one: "il y a {{count}}m",
    other: "il y a {{count}}m"
  },
  "autosave.hoursAgo": { one: "il y a {{count}}h", other: "il y a {{count}}h" },
  // Global Search
  "globalSearch.placeholder": "Rechercher collections, globales, actions, enregistrements...",
  "globalSearch.collections": "Collections",
  "globalSearch.globals": "Globales",
  "globalSearch.quickActions": "Actions rapides",
  "globalSearch.records": "Enregistrements",
  "globalSearch.createNew": "Crer nouveau {{name}}",
  "globalSearch.noResults": "Aucun rsultat trouv",
  "globalSearch.searching": "Recherche en cours...",
  "globalSearch.navigate": "pour naviguer",
  "globalSearch.select": "pour slectionner",
  // Collection Search
  "collectionSearch.placeholder": "Rechercher enregistrements...",
  "collectionSearch.noResults": "Aucun enregistrement correspondant trouv",
  "collectionSearch.searching": "Recherche en cours..."
};
const pl = {
  // Common
  "common.save": "Zapisz",
  "common.cancel": "Anuluj",
  "common.delete": "Usu",
  "common.edit": "Edytuj",
  "common.create": "Utwrz",
  "common.add": "Dodaj",
  "common.remove": "Usu",
  "common.close": "Zamknij",
  "common.form": "Formularz",
  "common.search": "Szukaj",
  "common.filter": "Filtr",
  "common.refresh": "Odwie",
  "common.loading": "adowanie...",
  "common.confirm": "Potwierd",
  "common.back": "Wstecz",
  "common.next": "Dalej",
  "common.previous": "Wstecz",
  "common.actions": "Akcje",
  "common.more": "Wicej",
  "common.yes": "Tak",
  "common.no": "Nie",
  "common.ok": "OK",
  "common.apply": "Zastosuj",
  "common.reset": "Resetuj",
  "common.clear": "Wyczy",
  "common.selectAll": "Zaznacz wszystko",
  "common.deselectAll": "Odznacz wszystko",
  "common.duplicate": "Duplikuj",
  "common.copy": "Kopiuj",
  "common.paste": "Wklej",
  "common.upload": "Przelij",
  "common.download": "Pobierz",
  "common.preview": "Podgld",
  "common.view": "Widok",
  "common.open": "Otwrz",
  "common.retry": "Ponw",
  "common.submit": "Wylij",
  // Navigation
  "nav.dashboard": "Dashboard",
  "nav.collections": "Kolekcje",
  "nav.globals": "Globalne",
  "nav.media": "Media",
  "nav.settings": "Ustawienia",
  "nav.logout": "Wyloguj si",
  "nav.home": "Strona gwna",
  "nav.back": "Wstecz",
  // Dashboard
  "dashboard.title": "Dashboard",
  "dashboard.welcome": "Witaj ponownie",
  "dashboard.recentActivity": "Ostatnia aktywno",
  "dashboard.quickActions": "Szybkie akcje",
  // Collections
  "collection.create": "Utwrz {{name}}",
  "collection.edit": "Edytuj {{name}}",
  "collection.delete": "Usu {{name}}",
  "collection.deleteConfirm": "Czy na pewno chcesz usun {{name}}?",
  "collection.noItems": "Nie znaleziono {{name}}",
  "collection.createFirst": "Utwrz swj pierwszy {{name}}",
  "collection.itemCount": {
    one: "{{count}} element",
    other: "{{count}} elementw"
  },
  "collection.bulkDelete": "Usu zaznaczone",
  "collection.bulkDeleteConfirm": "Czy na pewno chcesz usun {{count}} elementw?",
  "collection.bulkDeleteSuccess": {
    one: "Pomylnie usunito {{count}} element",
    other: "Pomylnie usunito {{count}} elementw"
  },
  "collection.bulkDeleteError": "Nie udao si usun elementw",
  "collection.bulkDeletePartial": {
    one: "Usunito {{success}} element, {{failed}} nie powiodo si",
    other: "Usunito {{success}} elementw, {{failed}} nie powiodo si"
  },
  "collection.bulkActionFailed": "Akcja zbiorcza nie powioda si",
  "collection.selected": "Zaznaczono {{count}}",
  "collection.selectOnPage": "Wszystko na tej stronie",
  "collection.selectAllMatching": "Wszystko pasujce do filtra ({{count}})",
  "collection.clearSelection": "Wyczy zaznaczenie",
  "collection.list": "Lista {{name}}",
  "collection.new": "Nowy {{name}}",
  "collection.duplicateSuccess": "{{name}} pomylnie zduplikowany",
  "collection.duplicateError": "Nie udao si zduplikowa {{name}}",
  // Relations
  "relation.select": "Wybierz {{name}}",
  "relation.clear": "Wyczy zaznaczenie",
  "relation.search": "Szukaj {{name}}...",
  "relation.noResults": "Nie znaleziono {{name}}",
  "relation.loading": "adowanie...",
  "relation.createNew": "Utwrz nowy {{name}}",
  "relation.selected": "Zaznaczono {{count}}",
  "relation.removeItem": "Usu {{name}}",
  "relation.addItem": "Dodaj {{name}}",
  "relation.noneSelected": "Nie wybrano {{name}}",
  "relation.noRelated": "Nie znaleziono powizanych elementw",
  "relation.saveFirst": "Najpierw zapisz ten element, aby zobaczy powizane elementy.",
  // Arrays
  "array.empty": "Nie dodano jeszcze adnych {{name}}",
  "array.addItem": "Dodaj {{name}}",
  // Blocks
  "blocks.addAbove": "Dodaj powyej",
  "blocks.addBelow": "Dodaj poniej",
  "blocks.addChild": "Dodaj blok podrzdny",
  // Forms
  "form.id": "ID",
  "form.created": "Utworzono",
  "form.updated": "Zaktualizowano",
  "form.required": "To pole jest wymagane",
  "form.invalid": "Nieprawidowa warto",
  "form.saveChanges": "Zapisz zmiany",
  "form.unsavedChanges": "Masz niezapisane zmiany",
  "form.discardChanges": "Odrzu zmiany",
  "form.discardConfirm": "Czy na pewno chcesz odrzuci zmiany? Tej akcji nie mona cofn.",
  "form.fieldRequired": "{{field}} jest wymagane",
  "form.fieldInvalid": "{{field}} jest nieprawidowe",
  "form.maxLength": "Maksymalnie {{max}} znakw",
  "form.minLength": "Minimum {{min}} znakw",
  "form.maxValue": "Maksymalnie {{max}}",
  "form.minValue": "Minimum {{min}}",
  "form.pattern": "Nieprawidowy format",
  "form.email": "Nieprawidowy adres e-mail",
  "form.url": "Nieprawidowy URL",
  "form.createSuccess": "{{name}} pomylnie utworzony",
  "form.createError": "Nie udao si utworzy {{name}}",
  "form.updateSuccess": "{{name}} pomylnie zaktualizowany",
  "form.updateError": "Nie udao si zaktualizowa {{name}}",
  "form.deleteSuccess": "{{name}} pomylnie usunity",
  "form.deleteError": "Nie udao si usun {{name}}",
  // Auth
  "auth.login": "Zaloguj si",
  "auth.logout": "Wyloguj si",
  "auth.email": "E-mail",
  "auth.password": "Haso",
  "auth.forgotPassword": "Zapomniae hasa?",
  "auth.resetPassword": "Resetuj haso",
  "auth.signIn": "Zaloguj si",
  "auth.signOut": "Wyloguj si",
  "auth.signUp": "Zarejestruj si",
  "auth.rememberMe": "Zapamitaj mnie",
  "auth.invalidCredentials": "Nieprawidowy e-mail lub haso",
  "auth.sessionExpired": "Twoja sesja wygasa. Zaloguj si ponownie.",
  "auth.emailPlaceholder": "ty@przyklad.pl",
  "auth.passwordPlaceholder": "Wprowad haso",
  "auth.signingIn": "Logowanie...",
  "auth.creatingAdmin": "Tworzenie administratora...",
  "auth.name": "Imi",
  "auth.namePlaceholder": "Twoje imi",
  "auth.confirmPassword": "Potwierd haso",
  "auth.confirmPasswordPlaceholder": "Potwierd haso",
  "auth.acceptInvite": "Akceptuj zaproszenie",
  "auth.acceptingInvite": "Akceptowanie zaproszenia...",
  "auth.dontHaveAccount": "Nie masz konta?",
  "auth.alreadyHaveAccount": "Masz ju konto?",
  "auth.emailRequired": "E-mail jest wymagany",
  "auth.passwordRequired": "Haso jest wymagane",
  "auth.passwordMinLength": "Haso musi mie co najmniej {{min}} znakw",
  "auth.nameRequired": "Imi jest wymagane",
  "auth.nameMinLength": "Imi musi mie co najmniej {{min}} znakw",
  "auth.invalidEmail": "Nieprawidowy adres e-mail",
  "auth.passwordMismatch": "Hasa nie pasuj do siebie",
  "auth.newPassword": "Nowe haso",
  "auth.newPasswordPlaceholder": "Wprowad nowe haso",
  "auth.sendResetLink": "Wylij link resetujcy",
  "auth.sendingResetLink": "Wysyanie...",
  "auth.resetLinkSent": "Link do resetowania hasa zosta wysany na Twj e-mail",
  "auth.resettingPassword": "Resetowanie hasa...",
  "auth.createFirstAdmin": "Utwrz pierwszego administratora",
  "auth.setupTitle": "Konfiguracja",
  "auth.setupDescription": "Utwrz pierwsze konto administratora.",
  "auth.profile": "Profil",
  "auth.myAccount": "Moje konto",
  "auth.logoutFailed": "Wylogowanie nie powiodo si. Sprbuj ponownie.",
  // Errors
  "error.notFound": "Nie znaleziono",
  "error.serverError": "Bd serwera",
  "error.networkError": "Bd sieci. Sprawd poczenie.",
  "error.unauthorized": "Nie masz uprawnie do tej akcji",
  "error.forbidden": "Dostp zabroniony",
  "error.validation": "Walidacja nie powioda si",
  "error.unknown": "Wystpi nieznany bd",
  "error.timeout": "Przekroczono czas dania. Sprbuj ponownie.",
  "error.conflict": "Wystpi konflikt. Odwie stron i sprbuj ponownie.",
  // Table
  "table.rowsPerPage": "Wierszy na stron",
  "table.of": "z",
  "table.noResults": "Brak wynikw",
  "table.selectAll": "Zaznacz wszystko",
  "table.selectRow": "Zaznacz wiersz",
  "table.showing": "Pokazano {{from}} do {{to}} z {{total}}",
  "table.page": "Strona {{page}}",
  "table.firstPage": "Pierwsza strona",
  "table.lastPage": "Ostatnia strona",
  "table.nextPage": "Nastpna strona",
  "table.previousPage": "Poprzednia strona",
  "table.sortAsc": "Sortuj rosnco",
  "table.sortDesc": "Sortuj malejco",
  "table.columns": "Kolumny",
  "table.hideColumn": "Ukryj kolumn",
  "table.showColumn": "Poka kolumn",
  // Upload
  "upload.dropzone": "Upu pliki tutaj lub kliknij, aby przesa",
  "upload.browse": "Przegldaj pliki",
  "upload.uploading": "Przesyanie...",
  "upload.complete": "Przesyanie zakoczone",
  "upload.error": "Przesyanie nie powiodo si",
  "upload.maxSize": "Plik musi by mniejszy ni {{size}}",
  "upload.invalidType": "Nieprawidowy typ pliku. Dozwolone: {{types}}",
  "upload.remove": "Usu plik",
  "upload.replace": "Zastp plik",
  "upload.preview": "Podgld",
  "upload.noFile": "Nie wybrano pliku",
  "upload.dragDrop": "Przecignij i upu pliki tutaj",
  // Editor
  "editor.bold": "Pogrubienie",
  "editor.italic": "Kursywa",
  "editor.underline": "Podkrelenie",
  "editor.strikethrough": "Przekrelenie",
  "editor.heading": "Nagwek {{level}}",
  "editor.link": "Wstaw link",
  "editor.image": "Wstaw obraz",
  "editor.list": "Lista",
  "editor.orderedList": "Lista numerowana",
  "editor.unorderedList": "Lista punktowana",
  "editor.quote": "Cytat",
  "editor.code": "Kod",
  "editor.codeBlock": "Blok kodu",
  "editor.table": "Wstaw tabel",
  "editor.undo": "Cofnij",
  "editor.redo": "Ponw",
  "editor.alignLeft": "Wyrwnaj do lewej",
  "editor.alignCenter": "Wyrwnaj do rodka",
  "editor.alignRight": "Wyrwnaj do prawej",
  "editor.alignJustify": "Wyjustuj",
  "editor.horizontalRule": "Linia pozioma",
  "editor.addRowBefore": "Dodaj wiersz przed",
  "editor.addRowAfter": "Dodaj wiersz po",
  "editor.addColumnBefore": "Dodaj kolumn przed",
  "editor.addColumnAfter": "Dodaj kolumn po",
  "editor.deleteRow": "Usu wiersz",
  "editor.deleteColumn": "Usu kolumn",
  "editor.deleteTable": "Usu tabel",
  "editor.toggleHeaderRow": "Przecz nagwek wiersza",
  "editor.toggleHeaderColumn": "Przecz nagwek kolumny",
  "editor.mergeCells": "Scal komrki",
  "editor.splitCell": "Podziel komrk",
  "editor.insertUrl": "Wstaw URL",
  "editor.altText": "Tekst alternatywny (opcjonalnie)",
  "editor.uploadFile": "Przelij plik",
  "editor.chooseFile": "Wybierz plik",
  "editor.uploading": "Przesyanie...",
  "editor.browseLibrary": "Przegldaj bibliotek",
  // Toasts
  "toast.success": "Sukces",
  "toast.error": "Bd",
  "toast.warning": "Ostrzeenie",
  "toast.info": "Informacja",
  "toast.saving": "Zapisywanie...",
  "toast.saveFailed": "Nie udao si zapisa zmian",
  "toast.saveSuccess": "Zmiany zapisane pomylnie",
  "toast.creating": "Tworzenie...",
  "toast.createSuccess": "Utworzono pomylnie",
  "toast.createFailed": "Nie udao si utworzy",
  "toast.deleting": "Usuwanie...",
  "toast.deleteFailed": "Nie udao si usun",
  "toast.deleteSuccess": "Usunito pomylnie",
  "toast.loadFailed": "Nie udao si zaadowa danych",
  "toast.uploadFailed": "Nie udao si przesa pliku",
  "toast.uploadSuccess": "Plik przesany pomylnie",
  "toast.copySuccess": "Skopiowano do schowka",
  "toast.copyFailed": "Nie udao si skopiowa do schowka",
  "toast.idCopied": "ID skopiowane do schowka",
  "toast.validationFailed": "Walidacja nie powioda si",
  "toast.validationDescription": "Sprawd formularz pod ktem bdw",
  "toast.created": "{{name}} utworzony",
  "toast.updated": "{{name}} zaktualizowany",
  "toast.resourceSaveFailed": "Nie udao si zapisa {{name}}",
  "toast.editComingSoon": "Funkcja edycji wkrtce dostpna",
  "toast.maxFilesWarning": "Moesz doda tylko {{remaining}} wicej plik(w) (max {{max}})",
  "toast.settingsSaveFailed": "Nie udao si zapisa ustawie",
  "toast.actionSuccess": "Akcja zakoczona pomylnie",
  "toast.actionFailed": "Akcja nie powioda si",
  "toast.localeChangedUnsaved": "Zmieniono jzyk treci",
  "toast.localeChangedUnsavedDescription": "Twoje niezapisane zmiany zostay zastpione treci w nowym jzyku.",
  // Confirm
  "confirm.delete": "Czy na pewno chcesz usun? Tej akcji nie mona cofn.",
  "confirm.discard": "Czy na pewno chcesz odrzuci zmiany? Tej akcji nie mona cofn.",
  "confirm.unsavedChanges": "Masz niezapisane zmiany. Czy na pewno chcesz wyj?",
  "confirm.action": "Czy na pewno chcesz kontynuowa?",
  "confirm.irreversible": "Tej akcji nie mona cofn.",
  "confirm.localeChange": "Odrzuci niezapisane zmiany?",
  "confirm.localeChangeDescription": "Masz niezapisane zmiany. Przeczenie jzyka treci odrzuci zmiany i zaaduje tre w nowym jzyku.",
  "confirm.localeChangeStay": "Zosta",
  "confirm.localeChangeDiscard": "Odrzu i przecz",
  // Status
  "status.draft": "Wersja robocza",
  "status.published": "Opublikowane",
  "status.archived": "Zarchiwizowane",
  "status.pending": "Oczekujce",
  "status.active": "Aktywne",
  "status.inactive": "Nieaktywne",
  // Dates
  "date.today": "Dzisiaj",
  "date.yesterday": "Wczoraj",
  "date.tomorrow": "Jutro",
  "date.selectDate": "Wybierz dat",
  "date.selectTime": "Wybierz czas",
  "date.clear": "Wyczy dat",
  // Accessibility
  "a11y.openMenu": "Otwrz menu",
  "a11y.closeMenu": "Zamknij menu",
  "a11y.expand": "Rozwi",
  "a11y.collapse": "Zwi",
  "a11y.loading": "adowanie",
  "a11y.required": "Wymagane",
  "a11y.optional": "Opcjonalne",
  "a11y.selected": "Wybrane",
  "a11y.notSelected": "Nie wybrane",
  // Locale
  "locale.language": "Jzyk",
  "locale.switchLanguage": "Przecz jzyk",
  "locale.contentLanguage": "Jzyk treci",
  "locale.uiLanguage": "Jzyk interfejsu",
  // ===========================================
  // Default Collections
  // ===========================================
  // Users Collection
  "defaults.users.label": "Uytkownicy",
  "defaults.users.description": "Zarzdzaj uytkownikami i ich rolami",
  "defaults.users.fields.name.label": "Imi",
  "defaults.users.fields.name.placeholder": "Wprowad imi uytkownika",
  "defaults.users.fields.email.label": "E-mail",
  "defaults.users.fields.email.description": "Adres e-mail (tylko do odczytu)",
  "defaults.users.fields.role.label": "Rola",
  "defaults.users.fields.role.options.admin": "Administrator",
  "defaults.users.fields.role.options.user": "Uytkownik",
  "defaults.users.fields.emailVerified.label": "E-mail zweryfikowany",
  "defaults.users.fields.emailVerified.description": "Czy uytkownik zweryfikowa swj adres e-mail",
  "defaults.users.fields.banned.label": "Zablokowany",
  "defaults.users.fields.banned.description": "Zablokuj uytkownikowi dostp do systemu",
  "defaults.users.fields.banReason.label": "Powd blokady",
  "defaults.users.fields.banReason.placeholder": "Wprowad powd blokady...",
  "defaults.users.sections.basicInfo": "Podstawowe informacje",
  "defaults.users.sections.permissions": "Uprawnienia",
  "defaults.users.sections.accessControl": "Kontrola dostpu",
  "defaults.users.actions.createUser.label": "Utwrz uytkownika",
  "defaults.users.actions.createUser.title": "Utwrz uytkownika",
  "defaults.users.actions.createUser.description": "Utwrz nowe konto uytkownika z danymi logowania.",
  "defaults.users.actions.createUser.fields.password.label": "Haso",
  "defaults.users.actions.createUser.fields.password.placeholder": "Wprowad haso",
  "defaults.users.actions.createUser.submit": "Utwrz uytkownika",
  "defaults.users.actions.createUser.success": "Uytkownik {{email}} pomylnie utworzony. Udostpnij dane logowania uytkownikowi.",
  "defaults.users.actions.createUser.errorNoAuth": "Klient auth nie jest skonfigurowany. Nie mona utworzy uytkownika.",
  "defaults.users.actions.resetPassword.label": "Resetuj haso",
  "defaults.users.actions.resetPassword.title": "Resetuj haso",
  "defaults.users.actions.resetPassword.description": "Ustaw nowe haso dla tego uytkownika.",
  "defaults.users.actions.resetPassword.fields.newPassword.label": "Nowe haso",
  "defaults.users.actions.resetPassword.fields.newPassword.placeholder": "Wprowad nowe haso",
  "defaults.users.actions.resetPassword.fields.confirmPassword.label": "Potwierd haso",
  "defaults.users.actions.resetPassword.fields.confirmPassword.placeholder": "Potwierd nowe haso",
  "defaults.users.actions.resetPassword.submit": "Resetuj haso",
  "defaults.users.actions.resetPassword.success": "Haso pomylnie zresetowane!",
  "defaults.users.actions.resetPassword.errorMismatch": "Hasa nie pasuj do siebie",
  "defaults.users.actions.delete.label": "Usu uytkownika",
  // Assets Collection
  "defaults.assets.label": "Media",
  "defaults.assets.description": "Zarzdzaj przesanymi plikami i obrazami",
  "defaults.assets.fields.preview.label": "Podgld",
  "defaults.assets.fields.filename.label": "Nazwa pliku",
  "defaults.assets.fields.filename.description": "Oryginalna nazwa przesanego pliku",
  "defaults.assets.fields.mimeType.label": "Typ",
  "defaults.assets.fields.mimeType.description": "Typ MIME pliku",
  "defaults.assets.fields.size.label": "Rozmiar (bajty)",
  "defaults.assets.fields.size.description": "Rozmiar pliku w bajtach",
  "defaults.assets.fields.alt.label": "Tekst alternatywny",
  "defaults.assets.fields.alt.placeholder": "Opisz obraz dla uatwienia dostpu",
  "defaults.assets.fields.alt.description": "Tekst alternatywny dla czytnikw ekranu",
  "defaults.assets.fields.caption.label": "Podpis",
  "defaults.assets.fields.caption.placeholder": "Dodaj podpis...",
  "defaults.assets.fields.visibility.label": "Widoczno",
  "defaults.assets.fields.visibility.options.public": "Publiczne",
  "defaults.assets.fields.visibility.options.private": "Prywatne",
  "defaults.assets.fields.visibility.description": "Pliki publiczne s dostpne bez autoryzacji. Pliki prywatne wymagaj podpisanego URL.",
  "defaults.assets.sections.fileInfo": "Informacje o pliku",
  "defaults.assets.sections.metadata": "Metadane",
  "defaults.assets.sections.metadata.description": "Dodaj informacje opisowe dla uatwienia dostpu i SEO",
  "defaults.assets.actions.upload.label": "Przelij pliki",
  // Default Sidebar
  "defaults.sidebar.administration": "Administracja",
  // View Options (Filter Builder)
  "viewOptions.title": "Opcje widoku",
  "viewOptions.columns": "Kolumny",
  "viewOptions.filters": "Filtry",
  "viewOptions.savedViews": "Zapisane widoki",
  "viewOptions.apply": "Zastosuj",
  "viewOptions.reset": "Resetuj",
  // Saved Views Tab
  "viewOptions.saveCurrentConfig": "Zapisz aktualn konfiguracj",
  "viewOptions.viewNamePlaceholder": "Nazwa widoku...",
  "viewOptions.saveDescription": "Zapisuje aktualne kolumny, filtry i sortowanie.",
  "viewOptions.noChangesToSave": "Brak filtrw lub zmian kolumn do zapisu.",
  "viewOptions.noSavedViews": "Brak zapisanych widokw.",
  "viewOptions.filtersCount": {
    one: "{{count}} filtr",
    other: "{{count}} filtrw"
  },
  "viewOptions.columnsCount": {
    one: "{{count}} kolumna",
    other: "{{count}} kolumn"
  },
  "viewOptions.defaultView": "Domylny",
  // Columns Tab
  "viewOptions.columnsDragHint": "Przecignij, aby zmieni kolejno, przecz, aby pokaza/ukry kolumny.",
  "viewOptions.noFieldsAvailable": "Brak dostpnych pl.",
  // Filters Tab
  "viewOptions.filtersDescription": "Zaw wyniki niestandardowymi reguami.",
  "viewOptions.filterNumber": "Filtr #{{number}}",
  "viewOptions.selectField": "Wybierz pole",
  "viewOptions.selectOperator": "Wybierz operator",
  "viewOptions.valuePlaceholder": "Warto...",
  "viewOptions.noActiveFilters": "Brak aktywnych filtrw.",
  "viewOptions.addFilter": "Dodaj filtr",
  "viewOptions.clearAll": "Wyczy wszystko",
  "viewOptions.activeFilters": {
    one: "{{count}} aktywny filtr",
    other: "{{count}} aktywnych filtrw"
  },
  "viewOptions.clearFilters": "Wyczy filtry",
  // Filter Operators
  "filter.contains": "Zawiera",
  "filter.notContains": "Nie zawiera",
  "filter.equals": "Rwna si",
  "filter.notEquals": "Nie rwna si",
  "filter.startsWith": "Zaczyna si od",
  "filter.endsWith": "Koczy si na",
  "filter.greaterThan": "Wiksze ni",
  "filter.greaterThanOrEqual": "Wiksze lub rwne",
  "filter.lessThan": "Mniejsze ni",
  "filter.lessThanOrEqual": "Mniejsze lub rwne",
  "filter.in": "Jest ktrymkolwiek z",
  "filter.notIn": "Nie jest adnym z",
  "filter.some": "Ma jakiekolwiek",
  "filter.every": "Ma wszystkie",
  "filter.none": "Nie ma adnego",
  "filter.isEmpty": "Jest puste",
  "filter.isNotEmpty": "Nie jest puste",
  // Preview
  "preview.show": "Podgld",
  "preview.hide": "Ukryj podgld",
  "preview.title": "Podgld",
  "preview.livePreview": "Podgld na ywo",
  "preview.fullscreen": "Peny ekran",
  "preview.close": "Zamknij podgld",
  "preview.loading": "adowanie podgldu...",
  // Autosave
  "autosave.saving": "Zapisywanie...",
  "autosave.saved": "Zapisano",
  "autosave.unsavedChanges": "Niezapisane zmiany",
  "autosave.justNow": "przed chwil",
  "autosave.secondsAgo": { one: "{{count}}s temu", other: "{{count}}s temu" },
  "autosave.minutesAgo": { one: "{{count}}m temu", other: "{{count}}m temu" },
  "autosave.hoursAgo": { one: "{{count}}h temu", other: "{{count}}h temu" },
  // Global Search
  "globalSearch.placeholder": "Szukaj kolekcji, globali, akcji, rekordw...",
  "globalSearch.collections": "Kolekcje",
  "globalSearch.globals": "Globalne",
  "globalSearch.quickActions": "Szybkie akcje",
  "globalSearch.records": "Rekordy",
  "globalSearch.createNew": "Utwrz nowy {{name}}",
  "globalSearch.noResults": "Nie znaleziono wynikw",
  "globalSearch.searching": "Wyszukiwanie...",
  "globalSearch.navigate": "do nawigacji",
  "globalSearch.select": "do wyboru",
  // Collection Search
  "collectionSearch.placeholder": "Szukaj rekordw...",
  "collectionSearch.noResults": "Nie znaleziono pasujcych rekordw",
  "collectionSearch.searching": "Wyszukiwanie..."
};
const pt = {
  // Common
  "common.save": "Salvar",
  "common.cancel": "Cancelar",
  "common.delete": "Excluir",
  "common.edit": "Editar",
  "common.create": "Criar",
  "common.add": "Adicionar",
  "common.remove": "Remover",
  "common.close": "Fechar",
  "common.form": "Formulrio",
  "common.search": "Pesquisar",
  "common.filter": "Filtrar",
  "common.refresh": "Atualizar",
  "common.loading": "Carregando...",
  "common.confirm": "Confirmar",
  "common.back": "Voltar",
  "common.next": "Prximo",
  "common.previous": "Anterior",
  "common.actions": "Aes",
  "common.more": "Mais",
  "common.yes": "Sim",
  "common.no": "No",
  "common.ok": "OK",
  "common.apply": "Aplicar",
  "common.reset": "Redefinir",
  "common.clear": "Limpar",
  "common.selectAll": "Selecionar tudo",
  "common.deselectAll": "Desselecionar tudo",
  "common.duplicate": "Duplicar",
  "common.copy": "Copiar",
  "common.paste": "Colar",
  "common.upload": "Enviar",
  "common.download": "Baixar",
  "common.preview": "Visualizar",
  "common.view": "Ver",
  "common.open": "Abrir",
  "common.retry": "Tentar novamente",
  "common.submit": "Enviar",
  // Navigation
  "nav.dashboard": "Painel",
  "nav.collections": "Colees",
  "nav.globals": "Globais",
  "nav.media": "Mdia",
  "nav.settings": "Configuraes",
  "nav.logout": "Sair",
  "nav.home": "Incio",
  "nav.back": "Voltar",
  // Dashboard
  "dashboard.title": "Painel",
  "dashboard.welcome": "Bem-vindo de volta",
  "dashboard.recentActivity": "Atividade recente",
  "dashboard.quickActions": "Aes rpidas",
  // Collections
  "collection.create": "Criar {{name}}",
  "collection.edit": "Editar {{name}}",
  "collection.delete": "Excluir {{name}}",
  "collection.deleteConfirm": "Tem certeza de que deseja excluir {{name}}?",
  "collection.noItems": "Nenhum {{name}} encontrado",
  "collection.createFirst": "Crie seu primeiro {{name}}",
  "collection.itemCount": { one: "{{count}} item", other: "{{count}} itens" },
  "collection.bulkDelete": "Excluir selecionados",
  "collection.bulkDeleteConfirm": "Tem certeza de que deseja excluir {{count}} itens?",
  "collection.bulkDeleteSuccess": {
    one: "{{count}} item excludo com sucesso",
    other: "{{count}} itens excludos com sucesso"
  },
  "collection.bulkDeleteError": "Falha ao excluir itens",
  "collection.bulkDeletePartial": {
    one: "{{success}} item excludo, {{failed}} falhou",
    other: "{{success}} itens excludos, {{failed}} falharam"
  },
  "collection.bulkActionFailed": "Ao em massa falhou",
  "collection.selected": "{{count}} selecionado(s)",
  "collection.selectOnPage": "Todos nesta pgina",
  "collection.selectAllMatching": "Todos correspondentes ({{count}})",
  "collection.clearSelection": "Limpar seleo",
  "collection.list": "Lista de {{name}}",
  "collection.new": "Novo {{name}}",
  "collection.duplicateSuccess": "{{name}} duplicado com sucesso",
  "collection.duplicateError": "Falha ao duplicar {{name}}",
  // Relations
  "relation.select": "Selecionar {{name}}",
  "relation.clear": "Limpar seleo",
  "relation.search": "Pesquisar {{name}}...",
  "relation.noResults": "Nenhum {{name}} encontrado",
  "relation.loading": "Carregando...",
  "relation.createNew": "Criar novo {{name}}",
  "relation.selected": "{{count}} selecionado(s)",
  "relation.removeItem": "Remover {{name}}",
  "relation.addItem": "Adicionar {{name}}",
  "relation.noneSelected": "Nenhum {{name}} selecionado",
  "relation.noRelated": "Nenhum item relacionado encontrado",
  "relation.saveFirst": "Salve este item primeiro para ver os itens relacionados.",
  // Arrays
  "array.empty": "Nenhum {{name}} adicionado ainda",
  "array.addItem": "Adicionar {{name}}",
  // Blocks
  "blocks.addAbove": "Adicionar acima",
  "blocks.addBelow": "Adicionar abaixo",
  "blocks.addChild": "Adicionar bloco filho",
  // Forms
  "form.id": "ID",
  "form.created": "Criado",
  "form.updated": "Atualizado",
  "form.required": "Este campo  obrigatrio",
  "form.invalid": "Valor invlido",
  "form.saveChanges": "Salvar alteraes",
  "form.unsavedChanges": "Voc tem alteraes no salvas",
  "form.discardChanges": "Descartar alteraes",
  "form.discardConfirm": "Tem certeza de que deseja descartar as alteraes? Esta ao no pode ser desfeita.",
  "form.fieldRequired": "{{field}}  obrigatrio",
  "form.fieldInvalid": "{{field}}  invlido",
  "form.maxLength": "Mximo {{max}} caracteres",
  "form.minLength": "Mnimo {{min}} caracteres",
  "form.maxValue": "Mximo {{max}}",
  "form.minValue": "Mnimo {{min}}",
  "form.pattern": "Formato invlido",
  "form.email": "E-mail invlido",
  "form.url": "URL invlida",
  "form.createSuccess": "{{name}} criado com sucesso",
  "form.createError": "Falha ao criar {{name}}",
  "form.updateSuccess": "{{name}} atualizado com sucesso",
  "form.updateError": "Falha ao atualizar {{name}}",
  "form.deleteSuccess": "{{name}} excludo com sucesso",
  "form.deleteError": "Falha ao excluir {{name}}",
  // Auth
  "auth.login": "Entrar",
  "auth.logout": "Sair",
  "auth.email": "E-mail",
  "auth.password": "Senha",
  "auth.forgotPassword": "Esqueceu a senha?",
  "auth.resetPassword": "Redefinir senha",
  "auth.signIn": "Entrar",
  "auth.signOut": "Sair",
  "auth.signUp": "Cadastrar-se",
  "auth.rememberMe": "Lembrar-me",
  "auth.invalidCredentials": "E-mail ou senha invlidos",
  "auth.sessionExpired": "Sua sesso expirou. Por favor, entre novamente.",
  "auth.emailPlaceholder": "voce@exemplo.com",
  "auth.passwordPlaceholder": "Digite sua senha",
  "auth.signingIn": "Entrando...",
  "auth.creatingAdmin": "Criando administrador...",
  "auth.name": "Nome",
  "auth.namePlaceholder": "Seu nome",
  "auth.confirmPassword": "Confirmar senha",
  "auth.confirmPasswordPlaceholder": "Confirme sua senha",
  "auth.acceptInvite": "Aceitar convite",
  "auth.acceptingInvite": "Aceitando convite...",
  "auth.dontHaveAccount": "No tem uma conta?",
  "auth.alreadyHaveAccount": "J tem uma conta?",
  "auth.emailRequired": "E-mail  obrigatrio",
  "auth.passwordRequired": "Senha  obrigatria",
  "auth.passwordMinLength": "A senha deve ter pelo menos {{min}} caracteres",
  "auth.nameRequired": "Nome  obrigatrio",
  "auth.nameMinLength": "O nome deve ter pelo menos {{min}} caracteres",
  "auth.invalidEmail": "E-mail invlido",
  "auth.passwordMismatch": "As senhas no coincidem",
  "auth.newPassword": "Nova senha",
  "auth.newPasswordPlaceholder": "Digite nova senha",
  "auth.sendResetLink": "Enviar link de redefinio",
  "auth.sendingResetLink": "Enviando...",
  "auth.resetLinkSent": "Link de redefinio de senha enviado para seu e-mail",
  "auth.resettingPassword": "Redefinindo senha...",
  "auth.createFirstAdmin": "Criar primeiro administrador",
  "auth.setupTitle": "Configurao",
  "auth.setupDescription": "Crie sua primeira conta de administrador para comear.",
  "auth.profile": "Perfil",
  "auth.myAccount": "Minha conta",
  "auth.logoutFailed": "Falha ao sair. Por favor, tente novamente.",
  // Errors
  "error.notFound": "No encontrado",
  "error.serverError": "Erro do servidor",
  "error.networkError": "Erro de rede. Verifique sua conexo.",
  "error.unauthorized": "Voc no est autorizado a realizar esta ao",
  "error.forbidden": "Acesso negado",
  "error.validation": "Validao falhou",
  "error.unknown": "Ocorreu um erro desconhecido",
  "error.timeout": "Tempo de solicitao esgotado. Tente novamente.",
  "error.conflict": "Ocorreu um conflito. Atualize e tente novamente.",
  // Table
  "table.rowsPerPage": "Linhas por pgina",
  "table.of": "de",
  "table.noResults": "Sem resultados",
  "table.selectAll": "Selecionar tudo",
  "table.selectRow": "Selecionar linha",
  "table.showing": "Mostrando {{from}} a {{to}} de {{total}}",
  "table.page": "Pgina {{page}}",
  "table.firstPage": "Primeira pgina",
  "table.lastPage": "ltima pgina",
  "table.nextPage": "Prxima pgina",
  "table.previousPage": "Pgina anterior",
  "table.sortAsc": "Ordenar crescente",
  "table.sortDesc": "Ordenar decrescente",
  "table.columns": "Colunas",
  "table.hideColumn": "Ocultar coluna",
  "table.showColumn": "Mostrar coluna",
  // Upload
  "upload.dropzone": "Arraste arquivos aqui ou clique para enviar",
  "upload.browse": "Procurar arquivos",
  "upload.uploading": "Enviando...",
  "upload.complete": "Envio completo",
  "upload.error": "Falha no envio",
  "upload.maxSize": "O arquivo deve ser menor que {{size}}",
  "upload.invalidType": "Tipo de arquivo invlido. Permitidos: {{types}}",
  "upload.remove": "Remover arquivo",
  "upload.replace": "Substituir arquivo",
  "upload.preview": "Visualizar",
  "upload.noFile": "Nenhum arquivo selecionado",
  "upload.dragDrop": "Arraste e solte arquivos aqui",
  // Editor
  "editor.bold": "Negrito",
  "editor.italic": "Itlico",
  "editor.underline": "Sublinhado",
  "editor.strikethrough": "Tachado",
  "editor.heading": "Ttulo {{level}}",
  "editor.link": "Inserir link",
  "editor.image": "Inserir imagem",
  "editor.list": "Lista",
  "editor.orderedList": "Lista numerada",
  "editor.unorderedList": "Lista com marcadores",
  "editor.quote": "Citao",
  "editor.code": "Cdigo",
  "editor.codeBlock": "Bloco de cdigo",
  "editor.table": "Inserir tabela",
  "editor.undo": "Desfazer",
  "editor.redo": "Refazer",
  "editor.alignLeft": "Alinhar  esquerda",
  "editor.alignCenter": "Centralizar",
  "editor.alignRight": "Alinhar  direita",
  "editor.alignJustify": "Justificar",
  "editor.horizontalRule": "Linha horizontal",
  "editor.addRowBefore": "Adicionar linha antes",
  "editor.addRowAfter": "Adicionar linha depois",
  "editor.addColumnBefore": "Adicionar coluna antes",
  "editor.addColumnAfter": "Adicionar coluna depois",
  "editor.deleteRow": "Excluir linha",
  "editor.deleteColumn": "Excluir coluna",
  "editor.deleteTable": "Excluir tabela",
  "editor.toggleHeaderRow": "Alternar linha de cabealho",
  "editor.toggleHeaderColumn": "Alternar coluna de cabealho",
  "editor.mergeCells": "Mesclar clulas",
  "editor.splitCell": "Dividir clula",
  "editor.insertUrl": "Inserir URL",
  "editor.altText": "Texto alternativo (opcional)",
  "editor.uploadFile": "Enviar arquivo",
  "editor.chooseFile": "Escolher arquivo",
  "editor.uploading": "Enviando...",
  "editor.browseLibrary": "Procurar na biblioteca",
  // Toasts
  "toast.success": "Sucesso",
  "toast.error": "Erro",
  "toast.warning": "Aviso",
  "toast.info": "Informao",
  "toast.saving": "Salvando...",
  "toast.saveFailed": "Falha ao salvar alteraes",
  "toast.saveSuccess": "Alteraes salvas com sucesso",
  "toast.creating": "Criando...",
  "toast.createSuccess": "Criado com sucesso",
  "toast.createFailed": "Falha ao criar",
  "toast.deleting": "Excluindo...",
  "toast.deleteFailed": "Falha ao excluir",
  "toast.deleteSuccess": "Excludo com sucesso",
  "toast.loadFailed": "Falha ao carregar dados",
  "toast.uploadFailed": "Falha ao enviar arquivo",
  "toast.uploadSuccess": "Arquivo enviado com sucesso",
  "toast.copySuccess": "Copiado para a rea de transferncia",
  "toast.copyFailed": "Falha ao copiar para a rea de transferncia",
  "toast.idCopied": "ID copiado para a rea de transferncia",
  "toast.validationFailed": "Validao falhou",
  "toast.validationDescription": "Por favor, verifique o formulrio por erros",
  "toast.created": "{{name}} criado",
  "toast.updated": "{{name}} atualizado",
  "toast.resourceSaveFailed": "Falha ao salvar {{name}}",
  "toast.editComingSoon": "Funcionalidade de edio em breve",
  "toast.maxFilesWarning": "Apenas {{remaining}} arquivo(s) adicional(is) pode(m) ser adicionado(s) (mx {{max}})",
  "toast.settingsSaveFailed": "Falha ao salvar configuraes",
  "toast.actionSuccess": "Ao concluda com sucesso",
  "toast.actionFailed": "Ao falhou",
  "toast.localeChangedUnsaved": "Idioma do contedo alterado",
  "toast.localeChangedUnsavedDescription": "Suas alteraes no salvas foram substitudas pelo contedo no novo idioma.",
  // Confirm
  "confirm.delete": "Tem certeza de que deseja excluir isto? Esta ao no pode ser desfeita.",
  "confirm.discard": "Tem certeza de que deseja descartar as alteraes? Esta ao no pode ser desfeita.",
  "confirm.unsavedChanges": "Voc tem alteraes no salvas. Tem certeza de que deseja sair?",
  "confirm.action": "Tem certeza de que deseja continuar?",
  "confirm.irreversible": "Esta ao no pode ser desfeita.",
  "confirm.localeChange": "Descartar alteraes no salvas?",
  "confirm.localeChangeDescription": "Voc tem alteraes no salvas. Mudar o idioma do contedo descartar suas alteraes e carregar o contedo no novo idioma.",
  "confirm.localeChangeStay": "Ficar",
  "confirm.localeChangeDiscard": "Descartar e mudar",
  // Status
  "status.draft": "Rascunho",
  "status.published": "Publicado",
  "status.archived": "Arquivado",
  "status.pending": "Pendente",
  "status.active": "Ativo",
  "status.inactive": "Inativo",
  // Dates
  "date.today": "Hoje",
  "date.yesterday": "Ontem",
  "date.tomorrow": "Amanh",
  "date.selectDate": "Selecionar data",
  "date.selectTime": "Selecionar hora",
  "date.clear": "Limpar data",
  // Accessibility
  "a11y.openMenu": "Abrir menu",
  "a11y.closeMenu": "Fechar menu",
  "a11y.expand": "Expandir",
  "a11y.collapse": "Recolher",
  "a11y.loading": "Carregando",
  "a11y.required": "Obrigatrio",
  "a11y.optional": "Opcional",
  "a11y.selected": "Selecionado",
  "a11y.notSelected": "No selecionado",
  // Locale
  "locale.language": "Idioma",
  "locale.switchLanguage": "Mudar idioma",
  "locale.contentLanguage": "Idioma do contedo",
  "locale.uiLanguage": "Idioma da interface",
  // ===========================================
  // Default Collections
  // ===========================================
  // Users Collection
  "defaults.users.label": "Usurios",
  "defaults.users.description": "Gerenciar usurios administradores e suas funes",
  "defaults.users.fields.name.label": "Nome",
  "defaults.users.fields.name.placeholder": "Digite o nome do usurio",
  "defaults.users.fields.email.label": "E-mail",
  "defaults.users.fields.email.description": "Endereo de e-mail (somente leitura)",
  "defaults.users.fields.role.label": "Funo",
  "defaults.users.fields.role.options.admin": "Administrador",
  "defaults.users.fields.role.options.user": "Usurio",
  "defaults.users.fields.emailVerified.label": "E-mail verificado",
  "defaults.users.fields.emailVerified.description": "Se o usurio verificou seu endereo de e-mail",
  "defaults.users.fields.banned.label": "Banido",
  "defaults.users.fields.banned.description": "Impedir que o usurio acesse o sistema",
  "defaults.users.fields.banReason.label": "Motivo do banimento",
  "defaults.users.fields.banReason.placeholder": "Digite o motivo do banimento...",
  "defaults.users.sections.basicInfo": "Informaes bsicas",
  "defaults.users.sections.permissions": "Permisses",
  "defaults.users.sections.accessControl": "Controle de acesso",
  "defaults.users.actions.createUser.label": "Criar usurio",
  "defaults.users.actions.createUser.title": "Criar usurio",
  "defaults.users.actions.createUser.description": "Criar uma nova conta de usurio com credenciais de login.",
  "defaults.users.actions.createUser.fields.password.label": "Senha",
  "defaults.users.actions.createUser.fields.password.placeholder": "Digite a senha",
  "defaults.users.actions.createUser.submit": "Criar usurio",
  "defaults.users.actions.createUser.success": "Usurio {{email}} criado com sucesso. Compartilhe as credenciais com o usurio.",
  "defaults.users.actions.createUser.errorNoAuth": "Cliente de autenticao no configurado. No  possvel criar usurio.",
  "defaults.users.actions.resetPassword.label": "Redefinir senha",
  "defaults.users.actions.resetPassword.title": "Redefinir senha",
  "defaults.users.actions.resetPassword.description": "Definir uma nova senha para este usurio.",
  "defaults.users.actions.resetPassword.fields.newPassword.label": "Nova senha",
  "defaults.users.actions.resetPassword.fields.newPassword.placeholder": "Digite nova senha",
  "defaults.users.actions.resetPassword.fields.confirmPassword.label": "Confirmar senha",
  "defaults.users.actions.resetPassword.fields.confirmPassword.placeholder": "Confirme nova senha",
  "defaults.users.actions.resetPassword.submit": "Redefinir senha",
  "defaults.users.actions.resetPassword.success": "Senha redefinida com sucesso!",
  "defaults.users.actions.resetPassword.errorMismatch": "As senhas no coincidem",
  "defaults.users.actions.delete.label": "Excluir usurio",
  // Assets Collection
  "defaults.assets.label": "Mdia",
  "defaults.assets.description": "Gerenciar arquivos e imagens enviados",
  "defaults.assets.fields.preview.label": "Visualizao",
  "defaults.assets.fields.filename.label": "Nome do arquivo",
  "defaults.assets.fields.filename.description": "Nome original do arquivo enviado",
  "defaults.assets.fields.mimeType.label": "Tipo",
  "defaults.assets.fields.mimeType.description": "Tipo MIME do arquivo",
  "defaults.assets.fields.size.label": "Tamanho (bytes)",
  "defaults.assets.fields.size.description": "Tamanho do arquivo em bytes",
  "defaults.assets.fields.alt.label": "Texto alternativo",
  "defaults.assets.fields.alt.placeholder": "Descreva a imagem para acessibilidade",
  "defaults.assets.fields.alt.description": "Texto alternativo para leitores de tela",
  "defaults.assets.fields.caption.label": "Legenda",
  "defaults.assets.fields.caption.placeholder": "Adicionar uma legenda...",
  "defaults.assets.fields.visibility.label": "Visibilidade",
  "defaults.assets.fields.visibility.options.public": "Pblico",
  "defaults.assets.fields.visibility.options.private": "Privado",
  "defaults.assets.fields.visibility.description": "Arquivos pblicos so acessveis sem autenticao. Arquivos privados requerem uma URL assinada.",
  "defaults.assets.sections.fileInfo": "Informaes do arquivo",
  "defaults.assets.sections.metadata": "Metadados",
  "defaults.assets.sections.metadata.description": "Adicione informaes descritivas para acessibilidade e SEO",
  "defaults.assets.actions.upload.label": "Enviar arquivos",
  // Default Sidebar
  "defaults.sidebar.administration": "Administrao",
  // View Options (Filter Builder)
  "viewOptions.title": "Opes de visualizao",
  "viewOptions.columns": "Colunas",
  "viewOptions.filters": "Filtros",
  "viewOptions.savedViews": "Visualizaes salvas",
  "viewOptions.apply": "Aplicar",
  "viewOptions.reset": "Redefinir",
  // Saved Views Tab
  "viewOptions.saveCurrentConfig": "Salvar configurao atual",
  "viewOptions.viewNamePlaceholder": "Nome da visualizao...",
  "viewOptions.saveDescription": "Salva as colunas, filtros e ordem atuais.",
  "viewOptions.noChangesToSave": "Nenhum filtro ou mudana de colunas para salvar.",
  "viewOptions.noSavedViews": "Ainda no h visualizaes salvas.",
  "viewOptions.filtersCount": {
    one: "{{count}} filtro",
    other: "{{count}} filtros"
  },
  "viewOptions.columnsCount": { one: "{{count}} col", other: "{{count}} cols" },
  "viewOptions.defaultView": "Padro",
  // Columns Tab
  "viewOptions.columnsDragHint": "Arraste para reordenar, alterne para mostrar/ocultar colunas.",
  "viewOptions.noFieldsAvailable": "Nenhum campo disponvel.",
  // Filters Tab
  "viewOptions.filtersDescription": "Refine seus resultados com regras personalizadas.",
  "viewOptions.filterNumber": "Filtro #{{number}}",
  "viewOptions.selectField": "Selecionar campo",
  "viewOptions.selectOperator": "Selecionar operador",
  "viewOptions.valuePlaceholder": "Valor...",
  "viewOptions.noActiveFilters": "Nenhum filtro ativo.",
  "viewOptions.addFilter": "Adicionar filtro",
  "viewOptions.clearAll": "Limpar tudo",
  "viewOptions.activeFilters": {
    one: "{{count}} filtro ativo",
    other: "{{count}} filtros ativos"
  },
  "viewOptions.clearFilters": "Limpar filtros",
  // Filter Operators
  "filter.contains": "Contm",
  "filter.notContains": "No contm",
  "filter.equals": "Igual a",
  "filter.notEquals": "Diferente de",
  "filter.startsWith": "Comea com",
  "filter.endsWith": "Termina com",
  "filter.greaterThan": "Maior que",
  "filter.greaterThanOrEqual": "Maior ou igual a",
  "filter.lessThan": "Menor que",
  "filter.lessThanOrEqual": "Menor ou igual a",
  "filter.in": " qualquer um de",
  "filter.notIn": "No  nenhum de",
  "filter.some": "Tem algum",
  "filter.every": "Tem todos",
  "filter.none": "No tem nenhum",
  "filter.isEmpty": "Est vazio",
  "filter.isNotEmpty": "No est vazio",
  // Preview
  "preview.show": "Visualizar",
  "preview.hide": "Ocultar visualizao",
  "preview.title": "Visualizao",
  "preview.livePreview": "Visualizao ao vivo",
  "preview.fullscreen": "Tela cheia",
  "preview.close": "Fechar visualizao",
  "preview.loading": "Carregando visualizao...",
  // Autosave
  "autosave.saving": "Salvando...",
  "autosave.saved": "Salvo",
  "autosave.unsavedChanges": "Alteraes no salvas",
  "autosave.justNow": "agora mesmo",
  "autosave.secondsAgo": { one: "{{count}}s atrs", other: "{{count}}s atrs" },
  "autosave.minutesAgo": { one: "{{count}}m atrs", other: "{{count}}m atrs" },
  "autosave.hoursAgo": { one: "{{count}}h atrs", other: "{{count}}h atrs" },
  // Global Search
  "globalSearch.placeholder": "Pesquisar colees, globais, aes, registros...",
  "globalSearch.collections": "Colees",
  "globalSearch.globals": "Globais",
  "globalSearch.quickActions": "Aes rpidas",
  "globalSearch.records": "Registros",
  "globalSearch.createNew": "Criar novo {{name}}",
  "globalSearch.noResults": "Nenhum resultado encontrado",
  "globalSearch.searching": "Pesquisando...",
  "globalSearch.navigate": "para navegar",
  "globalSearch.select": "para selecionar",
  // Collection Search
  "collectionSearch.placeholder": "Pesquisar registros...",
  "collectionSearch.noResults": "Nenhum registro correspondente encontrado",
  "collectionSearch.searching": "Pesquisando..."
};
const sk = {
  // Common
  "common.save": "Uloi",
  "common.cancel": "Zrui",
  "common.delete": "Vymaza",
  "common.edit": "Upravi",
  "common.create": "Vytvori",
  "common.add": "Prida",
  "common.remove": "Odstrni",
  "common.close": "Zavrie",
  "common.form": "Formulr",
  "common.search": "Hada",
  "common.filter": "Filter",
  "common.refresh": "Obnovi",
  "common.loading": "Natava sa...",
  "common.confirm": "Potvrdi",
  "common.back": "Sp",
  "common.next": "alej",
  "common.previous": "Predchdzajce",
  "common.actions": "Akcie",
  "common.more": "Viac",
  "common.yes": "no",
  "common.no": "Nie",
  "common.ok": "OK",
  "common.apply": "Poui",
  "common.reset": "Resetova",
  "common.clear": "Vyisti",
  "common.selectAll": "Vybra vetko",
  "common.deselectAll": "Zrui vber",
  "common.duplicate": "Duplikova",
  "common.copy": "Koprova",
  "common.paste": "Prilepi",
  "common.upload": "Nahra",
  "common.download": "Stiahnu",
  "common.preview": "Nhad",
  "common.view": "Zobrazi",
  "common.open": "Otvori",
  "common.retry": "Sksi znova",
  "common.submit": "Odosla",
  // Navigation
  "nav.dashboard": "Prehad",
  "nav.collections": "Kolekcie",
  "nav.globals": "Globlne nastavenia",
  "nav.media": "Mdi",
  "nav.settings": "Nastavenia",
  "nav.logout": "Odhlsi sa",
  "nav.home": "Domov",
  "nav.back": "Sp",
  // Dashboard
  "dashboard.title": "Prehad",
  "dashboard.welcome": "Vitajte sp",
  "dashboard.recentActivity": "Posledn aktivita",
  "dashboard.quickActions": "Rchle akcie",
  // Collections
  "collection.create": "Vytvori {{name}}",
  "collection.edit": "Upravi {{name}}",
  "collection.delete": "Vymaza {{name}}",
  "collection.deleteConfirm": "Naozaj chcete vymaza tento {{name}}?",
  "collection.noItems": "iadne {{name}} sa nenali",
  "collection.createFirst": "Vytvorte svoj prv {{name}}",
  "collection.itemCount": {
    one: "{{count}} poloka",
    few: "{{count}} poloky",
    other: "{{count}} poloiek"
  },
  "collection.bulkDelete": "Vymaza vybran",
  "collection.bulkDeleteConfirm": "Naozaj chcete vymaza {{count}} poloiek?",
  "collection.bulkDeleteSuccess": {
    one: "spene vymazan {{count}} poloka",
    few: "spene vymazan {{count}} poloky",
    other: "spene vymazanch {{count}} poloiek"
  },
  "collection.bulkDeleteError": "Nepodarilo sa vymaza poloky",
  "collection.bulkDeletePartial": {
    one: "Vymazan {{success}} poloka, {{failed}} zlyhalo",
    few: "Vymazan {{success}} poloky, {{failed}} zlyhalo",
    other: "Vymazanch {{success}} poloiek, {{failed}} zlyhalo"
  },
  "collection.bulkActionFailed": "Hromadn akcia zlyhala",
  "collection.selected": "{{count}} vybranch",
  "collection.selectOnPage": "Vetky na tejto strnke",
  "collection.selectAllMatching": "Vetky zodpovedajce filtru ({{count}})",
  "collection.clearSelection": "Zrui vber",
  "collection.list": "Zoznam {{name}}",
  "collection.new": "Nov {{name}}",
  "collection.duplicateSuccess": "{{name}} spene zduplikovan",
  "collection.duplicateError": "Nepodarilo sa zduplikova {{name}}",
  // Relations
  "relation.select": "Vybra {{name}}",
  "relation.clear": "Vyisti vber",
  "relation.search": "Hada {{name}}...",
  "relation.noResults": "iadne {{name}} sa nenali",
  "relation.loading": "Natava sa...",
  "relation.createNew": "Vytvori nov {{name}}",
  "relation.selected": "{{count}} vybranch",
  "relation.removeItem": "Odstrni {{name}}",
  "relation.addItem": "Prida {{name}}",
  "relation.noneSelected": "iadne {{name}} nie s vybran",
  "relation.noRelated": "iadne svisiace poloky sa nenali",
  "relation.saveFirst": "Najprv ulote tto poloku, aby ste videli svisiace poloky.",
  // Arrays
  "array.empty": "Zatia neboli pridan iadne {{name}}",
  "array.addItem": "Prida {{name}}",
  // Blocks
  "blocks.addAbove": "Prida nad",
  "blocks.addBelow": "Prida pod",
  "blocks.addChild": "Prida vnoren blok",
  // Forms
  "form.id": "ID",
  "form.created": "Vytvoren",
  "form.updated": "Aktualizovan",
  "form.required": "Toto pole je povinn",
  "form.invalid": "Neplatn hodnota",
  "form.saveChanges": "Uloi zmeny",
  "form.unsavedChanges": "Mte neuloen zmeny",
  "form.discardChanges": "Zahodi zmeny",
  "form.discardConfirm": "Naozaj chcete zahodi vae zmeny? Tto akciu nie je mon vrti sp.",
  "form.fieldRequired": "{{field}} je povinn",
  "form.fieldInvalid": "{{field}} je neplatn",
  "form.maxLength": "Maximlne {{max}} znakov",
  "form.minLength": "Minimlne {{min}} znakov",
  "form.maxValue": "Maximlne {{max}}",
  "form.minValue": "Minimlne {{min}}",
  "form.pattern": "Neplatn formt",
  "form.email": "Neplatn e-mailov adresa",
  "form.url": "Neplatn URL adresa",
  "form.createSuccess": "{{name}} spene vytvoren",
  "form.createError": "Nepodarilo sa vytvori {{name}}",
  "form.updateSuccess": "{{name}} spene aktualizovan",
  "form.updateError": "Nepodarilo sa aktualizova {{name}}",
  "form.deleteSuccess": "{{name}} spene vymazan",
  "form.deleteError": "Nepodarilo sa vymaza {{name}}",
  // Auth
  "auth.login": "Prihlsi sa",
  "auth.logout": "Odhlsi sa",
  "auth.email": "E-mail",
  "auth.password": "Heslo",
  "auth.forgotPassword": "Zabudli ste heslo?",
  "auth.resetPassword": "Obnovi heslo",
  "auth.signIn": "Prihlsi sa",
  "auth.signOut": "Odhlsi sa",
  "auth.signUp": "Registrova sa",
  "auth.rememberMe": "Zapamta si ma",
  "auth.invalidCredentials": "Neplatn e-mail alebo heslo",
  "auth.sessionExpired": "Vaa relcia vyprala. Prosm, prihlste sa znova.",
  "auth.emailPlaceholder": "vas@email.com",
  "auth.passwordPlaceholder": "Zadajte vae heslo",
  "auth.signingIn": "Prihlasuje sa...",
  "auth.creatingAdmin": "Vytvra sa admin...",
  "auth.name": "Meno",
  "auth.namePlaceholder": "Vae meno",
  "auth.confirmPassword": "Potvrdi heslo",
  "auth.confirmPasswordPlaceholder": "Potvrte vae heslo",
  "auth.acceptInvite": "Prija pozvnku",
  "auth.acceptingInvite": "Prijma sa pozvnka...",
  "auth.dontHaveAccount": "Nemte et?",
  "auth.alreadyHaveAccount": "U mte et?",
  "auth.emailRequired": "E-mail je povinn",
  "auth.passwordRequired": "Heslo je povinn",
  "auth.passwordMinLength": "Heslo mus ma minimlne {{min}} znakov",
  "auth.nameRequired": "Meno je povinn",
  "auth.nameMinLength": "Meno mus ma minimlne {{min}} znaky",
  "auth.invalidEmail": "Neplatn e-mailov adresa",
  "auth.passwordMismatch": "Hesl sa nezhoduj",
  "auth.newPassword": "Nov heslo",
  "auth.newPasswordPlaceholder": "Zadajte nov heslo",
  "auth.sendResetLink": "Odosla odkaz na obnovenie",
  "auth.sendingResetLink": "Odosiela sa...",
  "auth.resetLinkSent": "Odkaz na obnovenie hesla bol odoslan na v e-mail",
  "auth.resettingPassword": "Obnovuje sa heslo...",
  "auth.createFirstAdmin": "Vytvori prvho administrtora",
  "auth.setupTitle": "Nastavenie",
  "auth.setupDescription": "Vytvorte v prv administrtorsk et pre zaatie.",
  "auth.profile": "Profil",
  "auth.myAccount": "Mj et",
  "auth.logoutFailed": "Odhlsenie zlyhalo. Skste to prosm znova.",
  // Errors
  "error.notFound": "Nenjden",
  "error.serverError": "Chyba servera",
  "error.networkError": "Chyba siete. Skontrolujte vae pripojenie.",
  "error.unauthorized": "Nemte oprvnenie vykona tto akciu",
  "error.forbidden": "Prstup zamietnut",
  "error.validation": "Validcia zlyhala",
  "error.unknown": "Nastala neznma chyba",
  "error.timeout": "Poiadavka vyprala. Skste to prosm znova.",
  "error.conflict": "Nastal konflikt. Obnovte strnku a skste znova.",
  // Table
  "table.rowsPerPage": "Riadkov na strnku",
  "table.of": "z",
  "table.noResults": "iadne vsledky",
  "table.selectAll": "Vybra vetko",
  "table.selectRow": "Vybra riadok",
  "table.showing": "Zobrazuje sa {{from}} a {{to}} z {{total}}",
  "table.page": "Strnka {{page}}",
  "table.firstPage": "Prv strnka",
  "table.lastPage": "Posledn strnka",
  "table.nextPage": "alia strnka",
  "table.previousPage": "Predchdzajca strnka",
  "table.sortAsc": "Zoradi vzostupne",
  "table.sortDesc": "Zoradi zostupne",
  "table.columns": "Stpce",
  "table.hideColumn": "Skry stpec",
  "table.showColumn": "Zobrazi stpec",
  // Upload
  "upload.dropzone": "Presute sbory sem alebo kliknite pre nahranie",
  "upload.browse": "Prehada sbory",
  "upload.uploading": "Nahrva sa...",
  "upload.complete": "Nahrvanie dokonen",
  "upload.error": "Nahrvanie zlyhalo",
  "upload.maxSize": "Sbor mus by men ako {{size}}",
  "upload.invalidType": "Neplatn typ sboru. Povolen: {{types}}",
  "upload.remove": "Odstrni sbor",
  "upload.replace": "Nahradi sbor",
  "upload.preview": "Nhad",
  "upload.noFile": "iadny sbor nevybran",
  "upload.dragDrop": "Presute sbory sem",
  "upload.bulkTitle": "Nahra sbory",
  "upload.bulkDescription": "Pridajte viacero sborov do vaej kninice mdi",
  "upload.bulkHint": "Nahrajte viacero sborov naraz",
  "upload.bulkSuccess": {
    one: "{{count}} sbor spene nahran",
    few: "{{count}} sbory spene nahran",
    other: "{{count}} sborov spene nahranch"
  },
  "upload.bulkError": {
    one: "{{count}} sbor sa nepodarilo nahra",
    few: "{{count}} sbory sa nepodarilo nahra",
    other: "{{count}} sborov sa nepodarilo nahra"
  },
  "upload.waitForComplete": "Pokajte prosm na dokonenie nahrvania",
  "upload.filesCount": {
    one: "{{count}} sbor",
    few: "{{count}} sbory",
    other: "{{count}} sborov"
  },
  "upload.uploadedCount": {
    one: "{{count}} nahran",
    few: "{{count}} nahran",
    other: "{{count}} nahranch"
  },
  "upload.failedCount": {
    one: "{{count}} zlyhal",
    few: "{{count}} zlyhali",
    other: "{{count}} zlyhalo"
  },
  "upload.browseLibrary": "Prehada kninicu",
  // Editor
  "editor.bold": "Tun",
  "editor.italic": "Kurzva",
  "editor.underline": "Podiarknut",
  "editor.strikethrough": "Preiarknut",
  "editor.heading": "Nadpis {{level}}",
  "editor.link": "Vloi odkaz",
  "editor.image": "Vloi obrzok",
  "editor.list": "Zoznam",
  "editor.orderedList": "slovan zoznam",
  "editor.unorderedList": "Odrkov zoznam",
  "editor.quote": "Citt",
  "editor.code": "Kd",
  "editor.codeBlock": "Blok kdu",
  "editor.table": "Vloi tabuku",
  "editor.undo": "Sp",
  "editor.redo": "Znova",
  "editor.alignLeft": "Zarovna vavo",
  "editor.alignCenter": "Zarovna na stred",
  "editor.alignRight": "Zarovna vpravo",
  "editor.alignJustify": "Do bloku",
  "editor.horizontalRule": "Vodorovn iara",
  "editor.addRowBefore": "Prida riadok pred",
  "editor.addRowAfter": "Prida riadok za",
  "editor.addColumnBefore": "Prida stpec pred",
  "editor.addColumnAfter": "Prida stpec za",
  "editor.deleteRow": "Vymaza riadok",
  "editor.deleteColumn": "Vymaza stpec",
  "editor.deleteTable": "Vymaza tabuku",
  "editor.toggleHeaderRow": "Prepn hlavikov riadok",
  "editor.toggleHeaderColumn": "Prepn hlavikov stpec",
  "editor.mergeCells": "Zli bunky",
  "editor.splitCell": "Rozdeli bunku",
  "editor.insertUrl": "Vloi URL",
  "editor.altText": "Alternatvny text (voliten)",
  "editor.uploadFile": "Nahra sbor",
  "editor.chooseFile": "Vybra sbor",
  "editor.uploading": "Nahrva sa...",
  "editor.browseLibrary": "Prehada kninicu",
  // Toasts
  "toast.success": "spech",
  "toast.error": "Chyba",
  "toast.warning": "Upozornenie",
  "toast.info": "Informcia",
  "toast.saving": "Ukladm...",
  "toast.saveFailed": "Nepodarilo sa uloi zmeny",
  "toast.saveSuccess": "Zmeny spene uloen",
  "toast.creating": "Vytvram...",
  "toast.createSuccess": "spene vytvoren",
  "toast.createFailed": "Nepodarilo sa vytvori",
  "toast.deleting": "Odstraujem...",
  "toast.deleteFailed": "Nepodarilo sa vymaza",
  "toast.deleteSuccess": "spene vymazan",
  "toast.loadFailed": "Nepodarilo sa nata dta",
  "toast.uploadFailed": "Nepodarilo sa nahra sbor",
  "toast.uploadSuccess": "Sbor spene nahran",
  "toast.copySuccess": "Skoprovan do schrnky",
  "toast.copyFailed": "Nepodarilo sa skoprova do schrnky",
  "toast.idCopied": "ID skoprovan do schrnky",
  "toast.validationFailed": "Validcia zlyhala",
  "toast.validationDescription": "Skontrolujte formulr pre chyby",
  "toast.created": "{{name}} vytvoren",
  "toast.updated": "{{name}} aktualizovan",
  "toast.resourceSaveFailed": "Nepodarilo sa uloi {{name}}",
  "toast.editComingSoon": "Funkcia prav bude oskoro dostupn",
  "toast.maxFilesWarning": "Je mon prida ete {{remaining}} sbor(ov) (max {{max}})",
  "toast.settingsSaveFailed": "Nepodarilo sa uloi nastavenia",
  "toast.actionSuccess": "Akcia spene dokonen",
  "toast.actionFailed": "Akcia zlyhala",
  "toast.localeChangedUnsaved": "Jazyk obsahu bol zmenen",
  "toast.localeChangedUnsavedDescription": "Vae neuloen zmeny boli nahraden obsahom v novom jazyku.",
  // Confirm
  "confirm.delete": "Naozaj chcete toto vymaza? Tto akciu nie je mon vrti sp.",
  "confirm.discard": "Naozaj chcete zahodi vae zmeny? Tto akciu nie je mon vrti sp.",
  "confirm.unsavedChanges": "Mte neuloen zmeny. Naozaj chcete ods?",
  "confirm.action": "Naozaj chcete pokraova?",
  "confirm.irreversible": "Tto akciu nie je mon vrti sp.",
  "confirm.localeChange": "Zahodi neuloen zmeny?",
  "confirm.localeChangeDescription": "Mte neuloen zmeny. Prepnutie jazyka obsahu zahod vae zmeny a nata obsah v novom jazyku.",
  "confirm.localeChangeStay": "Zosta",
  "confirm.localeChangeDiscard": "Zahodi a prepn",
  // Status
  "status.draft": "Koncept",
  "status.published": "Publikovan",
  "status.archived": "Archivovan",
  "status.pending": "akajce",
  "status.active": "Aktvne",
  "status.inactive": "Neaktvne",
  // Dates
  "date.today": "Dnes",
  "date.yesterday": "Vera",
  "date.tomorrow": "Zajtra",
  "date.selectDate": "Vybra dtum",
  "date.selectTime": "Vybra as",
  "date.clear": "Vyisti dtum",
  // Accessibility
  "a11y.openMenu": "Otvori menu",
  "a11y.closeMenu": "Zavrie menu",
  "a11y.expand": "Rozbali",
  "a11y.collapse": "Zbali",
  "a11y.loading": "Natava sa",
  "a11y.required": "Povinn",
  "a11y.optional": "Voliten",
  "a11y.selected": "Vybran",
  "a11y.notSelected": "Nevybran",
  // Locale
  "locale.language": "Jazyk",
  "locale.switchLanguage": "Zmeni jazyk",
  "locale.contentLanguage": "Jazyk obsahu",
  "locale.uiLanguage": "Jazyk rozhrania",
  // ===========================================
  // Default Collections
  // ===========================================
  // Users Collection
  "defaults.users.label": "Pouvatelia",
  "defaults.users.description": "Sprva administrtorov a ich rol",
  "defaults.users.fields.name.label": "Meno",
  "defaults.users.fields.name.placeholder": "Zadajte meno pouvatea",
  "defaults.users.fields.email.label": "E-mail",
  "defaults.users.fields.email.description": "E-mailov adresa (len na tanie)",
  "defaults.users.fields.role.label": "Rola",
  "defaults.users.fields.role.options.admin": "Administrtor",
  "defaults.users.fields.role.options.user": "Pouvate",
  "defaults.users.fields.emailVerified.label": "E-mail overen",
  "defaults.users.fields.emailVerified.description": "i pouvate overil svoju e-mailov adresu",
  "defaults.users.fields.banned.label": "Zablokovan",
  "defaults.users.fields.banned.description": "Zabrni pouvateovi v prstupe do systmu",
  "defaults.users.fields.banReason.label": "Dvod zablokovania",
  "defaults.users.fields.banReason.placeholder": "Zadajte dvod zablokovania...",
  "defaults.users.sections.basicInfo": "Zkladn informcie",
  "defaults.users.sections.permissions": "Oprvnenia",
  "defaults.users.sections.accessControl": "Riadenie prstupu",
  "defaults.users.actions.createUser.label": "Vytvori pouvatea",
  "defaults.users.actions.createUser.title": "Vytvori pouvatea",
  "defaults.users.actions.createUser.description": "Vytvorte nov pouvatesk et s prihlasovacmi dajmi.",
  "defaults.users.actions.createUser.fields.password.label": "Heslo",
  "defaults.users.actions.createUser.fields.password.placeholder": "Zadajte heslo",
  "defaults.users.actions.createUser.submit": "Vytvori pouvatea",
  "defaults.users.actions.createUser.success": "Pouvate {{email}} bol spene vytvoren. Zdieajte prihlasovacie daje s pouvateom.",
  "defaults.users.actions.createUser.errorNoAuth": "Auth klient nie je nakonfigurovan. Nie je mon vytvori pouvatea.",
  "defaults.users.actions.resetPassword.label": "Obnovi heslo",
  "defaults.users.actions.resetPassword.title": "Obnovi heslo",
  "defaults.users.actions.resetPassword.description": "Nastavte nov heslo pre tohto pouvatea.",
  "defaults.users.actions.resetPassword.fields.newPassword.label": "Nov heslo",
  "defaults.users.actions.resetPassword.fields.newPassword.placeholder": "Zadajte nov heslo",
  "defaults.users.actions.resetPassword.fields.confirmPassword.label": "Potvrdi heslo",
  "defaults.users.actions.resetPassword.fields.confirmPassword.placeholder": "Potvrte nov heslo",
  "defaults.users.actions.resetPassword.submit": "Obnovi heslo",
  "defaults.users.actions.resetPassword.success": "Heslo bolo spene obnoven!",
  "defaults.users.actions.resetPassword.errorMismatch": "Hesl sa nezhoduj",
  "defaults.users.actions.delete.label": "Vymaza pouvatea",
  // Assets Collection
  "defaults.assets.label": "Mdi",
  "defaults.assets.description": "Sprva nahranch sborov a obrzkov",
  "defaults.assets.fields.preview.label": "Nhad",
  "defaults.assets.fields.filename.label": "Nzov sboru",
  "defaults.assets.fields.filename.description": "Pvodn nzov nahranho sboru",
  "defaults.assets.fields.mimeType.label": "Typ",
  "defaults.assets.fields.mimeType.description": "MIME typ sboru",
  "defaults.assets.fields.size.label": "Vekos (bajty)",
  "defaults.assets.fields.size.description": "Vekos sboru v bajtoch",
  "defaults.assets.fields.alt.label": "Alternatvny text",
  "defaults.assets.fields.alt.placeholder": "Opte obrzok pre prstupnos",
  "defaults.assets.fields.alt.description": "Alternatvny text pre taky obrazovky",
  "defaults.assets.fields.caption.label": "Popisok",
  "defaults.assets.fields.caption.placeholder": "Pridajte popisok...",
  "defaults.assets.fields.visibility.label": "Viditenos",
  "defaults.assets.fields.visibility.options.public": "Verejn",
  "defaults.assets.fields.visibility.options.private": "Skromn",
  "defaults.assets.fields.visibility.description": "Verejn sbory s prstupn bez autentifikcie. Skromn sbory vyaduj podpsan URL.",
  "defaults.assets.sections.fileInfo": "Informcie o sbore",
  "defaults.assets.sections.metadata": "Metadta",
  "defaults.assets.sections.metadata.description": "Pridajte popisn informcie pre prstupnos a SEO",
  "defaults.assets.actions.upload.label": "Nahra sbory",
  // Default Sidebar
  "defaults.sidebar.administration": "Administrcia",
  // View Options (Filter Builder)
  "viewOptions.title": "Monosti zobrazenia",
  "viewOptions.columns": "Stpce",
  "viewOptions.filters": "Filtre",
  "viewOptions.savedViews": "Uloen zobrazenia",
  "viewOptions.apply": "Poui",
  "viewOptions.reset": "Obnovi",
  // Saved Views Tab
  "viewOptions.saveCurrentConfig": "Uloi aktulnu konfigurciu",
  "viewOptions.viewNamePlaceholder": "Nzov zobrazenia...",
  "viewOptions.saveDescription": "Ulo aktulne stpce, filtre a zoradenie.",
  "viewOptions.noChangesToSave": "iadne filtre ani zmeny stpcov na uloenie.",
  "viewOptions.noSavedViews": "Zatia iadne uloen zobrazenia.",
  "viewOptions.filtersCount": {
    one: "{{count}} filter",
    few: "{{count}} filtre",
    other: "{{count}} filtrov"
  },
  "viewOptions.columnsCount": {
    one: "{{count}} stpec",
    few: "{{count}} stpce",
    other: "{{count}} stpcov"
  },
  "viewOptions.defaultView": "Predvolen",
  // Columns Tab
  "viewOptions.columnsDragHint": "ahanm zmente poradie, prepnaom zobrazte/skryjete stpce.",
  "viewOptions.noFieldsAvailable": "iadne polia nie s dostupn.",
  // Filters Tab
  "viewOptions.filtersDescription": "Zte vsledky pomocou vlastnch pravidiel.",
  "viewOptions.filterNumber": "Filter #{{number}}",
  "viewOptions.selectField": "Vybra pole",
  "viewOptions.selectOperator": "Vybra opertor",
  "viewOptions.valuePlaceholder": "Hodnota...",
  "viewOptions.noActiveFilters": "iadne aktvne filtre.",
  "viewOptions.addFilter": "Prida filter",
  "viewOptions.clearAll": "Vymaza vetko",
  "viewOptions.activeFilters": {
    one: "{{count}} aktvny filter",
    few: "{{count}} aktvne filtre",
    other: "{{count}} aktvnych filtrov"
  },
  "viewOptions.clearFilters": "Vymaza filtre",
  // Filter Operators
  "filter.contains": "Obsahuje",
  "filter.notContains": "Neobsahuje",
  "filter.equals": "Rovn sa",
  "filter.notEquals": "Nerovn sa",
  "filter.startsWith": "Zana na",
  "filter.endsWith": "Kon na",
  "filter.greaterThan": "Vie ako",
  "filter.greaterThanOrEqual": "Vie alebo rovn",
  "filter.lessThan": "Menie ako",
  "filter.lessThanOrEqual": "Menie alebo rovn",
  "filter.in": "Je jeden z",
  "filter.notIn": "Nie je medzi",
  "filter.some": "M aspo jeden",
  "filter.every": "M vetky",
  "filter.none": "Nem iadny",
  "filter.isEmpty": "Je przdne",
  "filter.isNotEmpty": "Nie je przdne",
  // Preview
  "preview.show": "Nhad",
  "preview.hide": "Skry nhad",
  "preview.title": "Nhad",
  "preview.livePreview": "iv nhad",
  "preview.fullscreen": "Cel obrazovka",
  "preview.close": "Zavrie nhad",
  "preview.loading": "Natava sa nhad...",
  // Autosave
  "autosave.saving": "Uklad sa...",
  "autosave.saved": "Uloen",
  "autosave.unsavedChanges": "Neuloen zmeny",
  "autosave.justNow": "prve teraz",
  "autosave.secondsAgo": {
    one: "pred {{count}}s",
    few: "pred {{count}}s",
    other: "pred {{count}}s"
  },
  "autosave.minutesAgo": {
    one: "pred {{count}}m",
    few: "pred {{count}}m",
    other: "pred {{count}}m"
  },
  "autosave.hoursAgo": {
    one: "pred {{count}}h",
    few: "pred {{count}}h",
    other: "pred {{count}}h"
  }
};
const messages = {
  cs,
  de,
  en,
  es,
  fr,
  pl,
  pt,
  sk
};
function getAdminMessagesForLocale(locale) {
  return messages[locale] ?? messages.en ?? {};
}
function getSupportedAdminLocales() {
  return Object.keys(messages);
}
function getApp(ctx) {
  return ctx.app;
}
function getAdminLocaleConfig(cms2) {
  return cms2.state?.adminLocale;
}
const getAdminTranslationsSchema = z$1.object({
  /** Requested locale code */
  locale: z$1.string()
});
const messageValueSchema = z$1.union([
  z$1.string(),
  z$1.object({ one: z$1.string(), other: z$1.string() })
]);
const getAdminTranslationsOutputSchema = z$1.object({
  /** Actual locale returned (may differ from requested if not supported) */
  locale: z$1.string(),
  /** Messages for the locale */
  messages: z$1.record(z$1.string(), messageValueSchema),
  /** Fallback locale */
  fallbackLocale: z$1.string()
});
const getAdminLocalesSchema = z$1.object({}).optional();
const getAdminLocalesOutputSchema = z$1.object({
  /** Available UI locales */
  locales: z$1.array(z$1.string()),
  /** Default UI locale */
  defaultLocale: z$1.string()
});
const getAdminTranslations = fn({
  type: "query",
  schema: getAdminTranslationsSchema,
  outputSchema: getAdminTranslationsOutputSchema,
  handler: async (ctx) => {
    const cms2 = getApp(ctx);
    const input = ctx.input;
    const requestedLocale = input.locale;
    const adminLocaleConfig = getAdminLocaleConfig(cms2);
    const supportedLocales = adminLocaleConfig?.locales ?? getSupportedAdminLocales();
    const defaultLocale2 = adminLocaleConfig?.defaultLocale ?? "en";
    const locale = supportedLocales.includes(requestedLocale) ? requestedLocale : defaultLocale2;
    const builtInMessages = getAdminMessagesForLocale(locale);
    const fallbackMessages = locale !== defaultLocale2 ? getAdminMessagesForLocale(defaultLocale2) : {};
    const customFallbackMessages = locale !== defaultLocale2 ? cms2.config.translations?.messages?.[defaultLocale2] ?? {} : {};
    const customMessages = cms2.config.translations?.messages?.[locale] ?? {};
    const messages2 = {
      ...fallbackMessages,
      ...customFallbackMessages,
      ...builtInMessages,
      ...customMessages
    };
    return {
      locale,
      messages: messages2,
      fallbackLocale: defaultLocale2
    };
  }
});
const getAdminLocales = fn({
  type: "query",
  schema: getAdminLocalesSchema,
  outputSchema: getAdminLocalesOutputSchema,
  handler: async (ctx) => {
    const cms2 = getApp(ctx);
    const adminLocaleConfig = getAdminLocaleConfig(cms2);
    return {
      locales: adminLocaleConfig?.locales ?? getSupportedAdminLocales(),
      defaultLocale: adminLocaleConfig?.defaultLocale ?? "en"
    };
  }
});
const translationFunctions = {
  getAdminTranslations,
  getAdminLocales
};
function findWidgetById(items, id) {
  for (const item of items) {
    if (item.type === "section") {
      const found = findWidgetById(item.items || [], id);
      if (found) return found;
    } else if (item.type === "tabs") {
      for (const tab of item.tabs || []) {
        const found = findWidgetById(tab.items || [], id);
        if (found) return found;
      }
    } else if (item.id === id) {
      return item;
    }
  }
  return null;
}
const fetchWidgetDataSchema = z$1.object({
  widgetId: z$1.string()
});
const fetchWidgetData = fn({
  type: "query",
  schema: fetchWidgetDataSchema,
  outputSchema: z$1.unknown(),
  handler: async (ctx) => {
    const cms2 = ctx.app;
    const state = cms2.state || {};
    const dashboard = state.dashboard;
    if (!dashboard?.items) {
      throw new Error("No dashboard configured");
    }
    const widget = findWidgetById(dashboard.items, ctx.input.widgetId);
    if (!widget) {
      throw new Error(`Widget "${ctx.input.widgetId}" not found`);
    }
    if (!widget.fetchFn) {
      throw new Error(`Widget "${ctx.input.widgetId}" has no fetchFn`);
    }
    if (widget.access !== void 0) {
      const accessResult = typeof widget.access === "function" ? await widget.access({
        app: cms2,
        db: ctx.db,
        session: ctx.session,
        locale: ctx.locale
      }) : widget.access;
      if (accessResult === false) {
        throw new Error("Access denied");
      }
    }
    return widget.fetchFn({
      app: cms2,
      db: ctx.db,
      session: ctx.session,
      locale: ctx.locale
    });
  }
});
const widgetDataFunctions = {
  fetchWidgetData
};
const r = rpc();
const adminRpc = r.router({
  ...setupFunctions,
  ...localeFunctions,
  ...previewFunctions,
  ...adminConfigFunctions,
  ...actionFunctions,
  ...translationFunctions,
  ...widgetDataFunctions,
  ...reactiveFunctions
});
function bindCollectionToBuilder(collection, builder) {
  const rebound = new CollectionBuilder({
    ...collection.state,
    "~questpieApp": builder
  });
  if (collection._indexesFn) {
    rebound._indexesFn = collection._indexesFn;
  }
  return rebound;
}
const adminBaseBuilder = q({ name: "questpie-admin" }).use(starterModule).listViews({
  table: q.listView("table")
}).editViews({
  form: q.editView("form")
}).components({
  icon: q.component("icon"),
  badge: q.component("badge")
});
const adminModule = adminBaseBuilder.fields(adminFields).collections({
  // Override auth collections with admin UI config
  user: bindCollectionToBuilder(
    starterModule.state.collections.user,
    adminBaseBuilder
  ).admin(({ c: c2 }) => ({
    label: { key: "defaults.users.label" },
    icon: c2.icon("ph:users"),
    description: { key: "defaults.users.description" },
    group: "administration"
  })).list(
    ({ v, f, a }) => v.table({
      columns: [f.name, f.email, f.role, f.banned],
      searchable: [f.name, f.email],
      defaultSort: { field: f.name, direction: "asc" },
      actions: {
        header: { primary: [a.create] },
        bulk: [a.deleteMany]
      }
    })
  ).form(
    ({ v, f }) => v.form({
      fields: [
        {
          type: "section",
          label: { key: "defaults.users.sections.basicInfo" },
          fields: [f.name, f.email]
        },
        {
          type: "section",
          label: { key: "defaults.users.sections.permissions" },
          fields: [f.role, f.emailVerified]
        },
        {
          type: "section",
          label: { key: "defaults.users.sections.accessControl" },
          fields: [f.banned, f.banReason]
        }
      ]
    })
  ),
  assets: bindCollectionToBuilder(
    starterModule.state.collections.assets,
    adminBaseBuilder
  ).admin(({ c: c2 }) => ({
    label: { key: "defaults.assets.label" },
    icon: c2.icon("ph:image"),
    description: { key: "defaults.assets.description" },
    group: "administration"
  })),
  // Hide internal auth collections
  session: starterModule.state.collections.session.admin({ hidden: true }),
  account: starterModule.state.collections.account.admin({ hidden: true }),
  verification: starterModule.state.collections.verification.admin({
    hidden: true
  }),
  apikey: starterModule.state.collections.apikey.admin({ hidden: true }),
  // Admin-specific collections (hidden from sidebar)
  adminSavedViews: savedViewsCollection.admin({ hidden: true }),
  adminPreferences: adminPreferencesCollection.admin({ hidden: true }),
  adminLocks: locksCollection.admin({ hidden: true })
}).sidebar(
  ({ s: s2, c: c2 }) => s2.sidebar({
    sections: [
      s2.section({
        id: "administration",
        title: { key: "defaults.sidebar.administration" },
        items: [
          {
            type: "collection",
            collection: "user",
            icon: c2.icon("ph:users")
          },
          {
            type: "collection",
            collection: "assets",
            icon: c2.icon("ph:image")
          }
        ]
      })
    ]
  })
);
const verifyPreviewToken = createPreviewTokenVerifier();
const Route$5 = createFileRoute("/api/preview")({
  server: {
    handlers: {
      GET: async ({ request }) => {
        const url = new URL(request.url);
        const disable = url.searchParams.get("disable");
        if (disable === "true") {
          return new Response(null, {
            status: 302,
            headers: {
              Location: "/",
              "Set-Cookie": createDraftModeCookie(false),
              "Cache-Control": "private, no-store"
            }
          });
        }
        const token2 = url.searchParams.get("token");
        if (!token2) {
          return new Response("Missing token parameter", { status: 400 });
        }
        const payload = verifyPreviewToken(token2);
        if (!payload) {
          return new Response("Invalid or expired preview token", {
            status: 401
          });
        }
        return new Response(null, {
          status: 302,
          headers: {
            Location: payload.path,
            "Set-Cookie": createDraftModeCookie(true),
            "Cache-Control": "private, no-store"
          }
        });
      }
    }
  }
});
const $$splitComponentImporter$3 = () => import("./_-Cv1eSAd5.js");
const Route$4 = createFileRoute("/admin/$")({
  component: lazyRouteComponent($$splitComponentImporter$3, "component")
});
class UploadError extends Error {
  constructor(message2, status, response) {
    super(message2);
    this.status = status;
    this.response = response;
    this.name = "UploadError";
  }
}
class QuestpieClientError extends Error {
  status;
  statusText;
  url;
  // Type-safe error data from server
  code;
  fieldErrors;
  context;
  serverData;
  // Raw server response
  constructor(options) {
    super(options.message);
    this.name = "QuestpieClientError";
    this.status = options.status;
    this.statusText = options.statusText;
    this.url = options.url;
    this.serverData = options.data;
    if (this.isApiError(options.data)) {
      this.code = options.data.code;
      this.fieldErrors = options.data.fieldErrors;
      this.context = options.data.context;
    }
  }
  isApiError(data) {
    return typeof data === "object" && data !== null && "code" in data && "message" in data;
  }
  /**
   * Check if this is a specific error code
   * @example
   * if (error.isCode('FORBIDDEN')) { ... }
   */
  isCode(code) {
    return this.code === code;
  }
  /**
   * Get field error for specific path
   * @example
   * const emailError = error.getFieldError('email');
   */
  getFieldError(path) {
    return this.fieldErrors?.find((err2) => err2.path === path);
  }
  /**
   * Get all field errors as object
   * @example
   * const errors = error.getFieldErrorsMap();
   * // { email: ['Invalid format'], password: ['Too short'] }
   */
  getFieldErrorsMap() {
    if (!this.fieldErrors) return {};
    const map2 = {};
    for (const err2 of this.fieldErrors) {
      if (!map2[err2.path]) map2[err2.path] = [];
      map2[err2.path].push(err2.message);
    }
    return map2;
  }
}
function createClient(config2) {
  const fetcher = config2.fetch || globalThis.fetch;
  const basePath = config2.basePath ?? "/cms";
  const normalizedBasePath = basePath.startsWith("/") ? basePath : `/${basePath}`;
  const trimmedBasePath = normalizedBasePath.replace(/\/$/, "");
  const cmsBasePath = trimmedBasePath.endsWith("/cms") || trimmedBasePath === "/cms" ? trimmedBasePath : `${trimmedBasePath}/cms`;
  const defaultHeaders = config2.headers || {};
  let currentLocale = defaultHeaders["accept-language"] ?? defaultHeaders["Accept-Language"];
  async function request(path, options = {}) {
    const url = `${config2.baseURL}${path}`;
    const useSuperJSON = config2.useSuperJSON !== false;
    const contentType = useSuperJSON ? "application/superjson+json" : "application/json";
    const headers = {
      "Content-Type": contentType,
      ...defaultHeaders,
      ...options.headers
    };
    if (useSuperJSON) {
      headers["X-SuperJSON"] = "1";
    }
    let body = options.body;
    if (body && typeof body === "string" && useSuperJSON) {
      try {
        const parsed = JSON.parse(body);
        body = SuperJSON.stringify(parsed);
      } catch {
      }
    }
    const response = await fetcher(url, {
      ...options,
      headers,
      body,
      credentials: "include"
      // Ensure cookies are sent with requests
    });
    if (!response.ok) {
      let errorData;
      try {
        const responseContentType2 = response.headers.get("Content-Type");
        const text22 = await response.text();
        if (text22) {
          errorData = responseContentType2?.includes("superjson") ? SuperJSON.parse(text22) : JSON.parse(text22);
        }
      } catch {
        errorData = void 0;
      }
      const cmsError = errorData && typeof errorData === "object" && "error" in errorData && typeof errorData.error === "object" ? errorData.error : void 0;
      const message2 = cmsError?.message || (typeof errorData === "object" && errorData && "error" in errorData && typeof errorData.error === "string" ? errorData.error : `Request failed: ${response.statusText}`);
      throw new QuestpieClientError({
        message: message2,
        status: response.status,
        statusText: response.statusText,
        data: cmsError,
        // Pass the ApiErrorShape (not the wrapper)
        url
      });
    }
    const responseContentType = response.headers.get("Content-Type");
    const text2 = await response.text();
    if (!text2) return void 0;
    return responseContentType?.includes("superjson") ? SuperJSON.parse(text2) : JSON.parse(text2);
  }
  const collections = new Proxy({}, {
    get(_, collectionName) {
      const base = {
        find: async (options = {}) => {
          const queryString = qs.stringify(options, {
            skipNulls: true,
            arrayFormat: "brackets"
          });
          const path = `${cmsBasePath}/${collectionName}${queryString ? `?${queryString}` : ""}`;
          return request(path);
        },
        count: async (options = {}) => {
          const queryString = qs.stringify(options, {
            skipNulls: true,
            arrayFormat: "brackets"
          });
          const path = `${cmsBasePath}/${collectionName}/count${queryString ? `?${queryString}` : ""}`;
          const result2 = await request(path);
          return result2.count;
        },
        findOne: async (options = {}) => {
          const where = options?.where;
          if (where?.id && Object.keys(where).length === 1) {
            const queryString2 = qs.stringify(
              {
                with: options.with,
                columns: options.columns,
                includeDeleted: options.includeDeleted,
                locale: options.locale,
                localeFallback: options.localeFallback
              },
              {
                skipNulls: true,
                arrayFormat: "brackets"
              }
            );
            const path2 = `${cmsBasePath}/${collectionName}/${where.id}${queryString2 ? `?${queryString2}` : ""}`;
            return request(path2);
          }
          const queryString = qs.stringify(
            { ...options, limit: 1 },
            {
              skipNulls: true,
              arrayFormat: "brackets"
            }
          );
          const path = `${cmsBasePath}/${collectionName}${queryString ? `?${queryString}` : ""}`;
          const result2 = await request(path);
          return result2?.docs?.[0] ?? null;
        },
        create: async (data, options = {}) => {
          const queryString = qs.stringify(options, {
            skipNulls: true,
            arrayFormat: "brackets"
          });
          const path = `${cmsBasePath}/${collectionName}${queryString ? `?${queryString}` : ""}`;
          return request(path, {
            method: "POST",
            body: JSON.stringify(data)
          });
        },
        update: async ({ id, data }, options = {}) => {
          const queryString = qs.stringify(options, {
            skipNulls: true,
            arrayFormat: "brackets"
          });
          const path = `${cmsBasePath}/${collectionName}/${id}${queryString ? `?${queryString}` : ""}`;
          return request(path, {
            method: "PATCH",
            body: JSON.stringify(data)
          });
        },
        delete: async ({ id }, options = {}) => {
          const queryString = qs.stringify(options, {
            skipNulls: true,
            arrayFormat: "brackets"
          });
          const path = `${cmsBasePath}/${collectionName}/${id}${queryString ? `?${queryString}` : ""}`;
          return request(path, {
            method: "DELETE"
          });
        },
        restore: async ({ id }, options = {}) => {
          const queryString = qs.stringify(options, {
            skipNulls: true,
            arrayFormat: "brackets"
          });
          const path = `${cmsBasePath}/${collectionName}/${id}/restore${queryString ? `?${queryString}` : ""}`;
          return request(path, {
            method: "POST"
          });
        },
        updateMany: async ({ where, data }, options = {}) => {
          const queryString = qs.stringify(options, {
            skipNulls: true,
            arrayFormat: "brackets"
          });
          const path = `${cmsBasePath}/${collectionName}${queryString ? `?${queryString}` : ""}`;
          return request(path, {
            method: "PATCH",
            body: JSON.stringify({ where, data })
          });
        },
        deleteMany: async ({ where }, options = {}) => {
          const queryString = qs.stringify(options, {
            skipNulls: true,
            arrayFormat: "brackets"
          });
          const path = `${cmsBasePath}/${collectionName}/delete-many${queryString ? `?${queryString}` : ""}`;
          return request(path, {
            method: "POST",
            body: JSON.stringify({ where })
          });
        },
        meta: async () => {
          return request(`${cmsBasePath}/${collectionName}/meta`);
        },
        schema: async () => {
          return request(`${cmsBasePath}/${collectionName}/schema`);
        },
        upload: (file, options) => {
          return new Promise((resolve2, reject) => {
            const xhr = new XMLHttpRequest();
            const url = `${config2.baseURL}${cmsBasePath}/${collectionName}/upload`;
            const handleProgress = (event) => {
              if (event.lengthComputable && options?.onProgress) {
                const percent = Math.round(event.loaded / event.total * 100);
                options.onProgress(percent);
              }
            };
            const handleLoad = () => {
              cleanup();
              if (xhr.status >= 200 && xhr.status < 300) {
                try {
                  const response = JSON.parse(xhr.responseText);
                  resolve2(response);
                } catch {
                  reject(new UploadError("Invalid response from server"));
                }
              } else {
                let errorMessage = "Upload failed";
                try {
                  const errorResponse = JSON.parse(xhr.responseText);
                  errorMessage = errorResponse.error?.message || errorResponse.message || errorMessage;
                  reject(
                    new UploadError(errorMessage, xhr.status, errorResponse)
                  );
                } catch {
                  reject(new UploadError(errorMessage, xhr.status));
                }
              }
            };
            const handleError2 = () => {
              cleanup();
              reject(new UploadError("Network error during upload"));
            };
            const handleAbort = () => {
              cleanup();
              reject(new UploadError("Upload cancelled"));
            };
            const handleSignalAbort = () => {
              xhr.abort();
            };
            const cleanup = () => {
              xhr.upload.removeEventListener("progress", handleProgress);
              xhr.removeEventListener("load", handleLoad);
              xhr.removeEventListener("error", handleError2);
              xhr.removeEventListener("abort", handleAbort);
              if (options?.signal) {
                options.signal.removeEventListener("abort", handleSignalAbort);
              }
            };
            xhr.upload.addEventListener("progress", handleProgress);
            xhr.addEventListener("load", handleLoad);
            xhr.addEventListener("error", handleError2);
            xhr.addEventListener("abort", handleAbort);
            if (options?.signal) {
              options.signal.addEventListener("abort", handleSignalAbort);
            }
            const formData = new FormData();
            formData.append("file", file);
            xhr.open("POST", url);
            xhr.withCredentials = true;
            xhr.send(formData);
          });
        },
        uploadMany: async (files, options) => {
          if (files.length === 0) {
            return [];
          }
          const results = [];
          const totalFiles = files.length;
          for (let i = 0; i < totalFiles; i++) {
            const file = files[i];
            if (options?.signal?.aborted) {
              throw new UploadError("Upload cancelled");
            }
            const result2 = await base.upload(file, {
              signal: options?.signal,
              onProgress: (fileProgress) => {
                const baseProgress = i / totalFiles * 100;
                const currentFileContribution = fileProgress / totalFiles;
                const overallProgress = Math.round(
                  baseProgress + currentFileContribution
                );
                options?.onProgress?.(overallProgress, i);
              }
            });
            results.push(result2);
          }
          options?.onProgress?.(100);
          return results;
        }
      };
      return new Proxy(base, {
        get(target, prop) {
          if (Object.hasOwn(target, prop)) {
            return target[prop];
          }
          if (typeof prop !== "string") return void 0;
          return async (input) => {
            return request(
              `${cmsBasePath}/collections/${collectionName}/rpc/${prop}`,
              {
                method: "POST",
                body: JSON.stringify(input)
              }
            );
          };
        }
      });
    }
  });
  const globals = new Proxy({}, {
    get(_, globalName) {
      const base = {
        get: async (options = {}) => {
          const queryString = qs.stringify(
            {
              with: options.with,
              columns: options.columns,
              locale: options.locale,
              localeFallback: options.localeFallback
            },
            { skipNulls: true, arrayFormat: "brackets" }
          );
          const path = `${cmsBasePath}/globals/${globalName}${queryString ? `?${queryString}` : ""}`;
          return request(path);
        },
        update: async (data, options = {}) => {
          const queryString = qs.stringify(
            {
              with: options.with,
              locale: options.locale,
              localeFallback: options.localeFallback
            },
            { skipNulls: true, arrayFormat: "brackets" }
          );
          return request(
            `${cmsBasePath}/globals/${globalName}${queryString ? `?${queryString}` : ""}`,
            {
              method: "PATCH",
              body: JSON.stringify(data)
            }
          );
        },
        schema: async () => {
          return request(`${cmsBasePath}/globals/${globalName}/schema`);
        }
      };
      return new Proxy(base, {
        get(target, prop) {
          if (prop in target) return target[prop];
          if (typeof prop !== "string") return void 0;
          return async (input) => {
            return request(`${cmsBasePath}/globals/${globalName}/rpc/${prop}`, {
              method: "POST",
              body: JSON.stringify(input)
            });
          };
        }
      });
    }
  });
  const createRpcProcedureProxy = (segments) => {
    const callable = async (input) => {
      return request(`${cmsBasePath}/rpc/${segments.join("/")}`, {
        method: "POST",
        body: JSON.stringify(input)
      });
    };
    return new Proxy(callable, {
      get(_, prop) {
        if (prop === "then") return void 0;
        if (typeof prop !== "string") return void 0;
        return createRpcProcedureProxy([...segments, prop]);
      },
      apply(_, __, args) {
        const input = args[0];
        return request(`${cmsBasePath}/rpc/${segments.join("/")}`, {
          method: "POST",
          body: JSON.stringify(input)
        });
      }
    });
  };
  const rpc2 = new Proxy({}, {
    get(_, prop) {
      if (typeof prop !== "string") return void 0;
      return createRpcProcedureProxy([prop]);
    }
  });
  const search = {
    search: async (options) => {
      return request(`${cmsBasePath}/search`, {
        method: "POST",
        body: JSON.stringify(options)
      });
    },
    reindex: async (collection) => {
      return request(`${cmsBasePath}/search/reindex/${collection}`, {
        method: "POST"
      });
    }
  };
  return {
    collections,
    globals,
    rpc: rpc2,
    search,
    setLocale: (locale) => {
      currentLocale = locale;
      if (locale) {
        defaultHeaders["accept-language"] = locale;
        delete defaultHeaders["Accept-Language"];
      } else {
        delete defaultHeaders["accept-language"];
        delete defaultHeaders["Accept-Language"];
      }
    },
    getLocale: () => currentLocale,
    getBasePath: () => cmsBasePath
  };
}
const baseURL = typeof window !== "undefined" ? "/api" : "http://localhost:3001/api";
const cmsClient = createClient({
  baseURL
});
async function getCityBySlug({ slug: slug2 }) {
  const result2 = await cmsClient.api.collections.cities.find({
    where: { slug: slug2 },
    limit: 1
  });
  return { city: result2.docs[0] || null };
}
async function getSiteSettings({ citySlug }) {
  const { city } = await getCityBySlug({ slug: citySlug });
  if (!city) return null;
  const settings = await cmsClient.api.globals.siteSettings.get({
    scope: city.id
  });
  return settings;
}
async function getPageBySlug({
  citySlug,
  pageSlug
}) {
  const { city } = await getCityBySlug({ slug: citySlug });
  if (!city) return { page: null };
  const result2 = await cmsClient.api.collections.pages.find({
    where: {
      slug: pageSlug,
      city: city.id,
      isPublished: true
    },
    limit: 1
  });
  return { page: result2.docs[0] || null };
}
async function getHomepage({ citySlug }) {
  let result2 = await getPageBySlug({ citySlug, pageSlug: "home" });
  if (!result2.page) {
    result2 = await getPageBySlug({ citySlug, pageSlug: "index" });
  }
  return result2;
}
const stylesCss = "/assets/styles-D8AoNwuc.css";
const $$splitComponentImporter$2 = () => import("./_citySlug-DANCvJr6.js");
const Route$3 = createFileRoute("/_app/$citySlug")({
  loader: async ({
    params
  }) => {
    const {
      citySlug
    } = params;
    const [cityResult, settings] = await Promise.all([getCityBySlug({
      slug: citySlug
    }), getSiteSettings({
      citySlug
    })]);
    if (!cityResult.city) {
      throw new Error("City not found");
    }
    return {
      city: cityResult.city,
      settings
    };
  },
  head: ({
    loaderData
  }) => {
    const settings = loaderData?.settings;
    return {
      title: settings?.metaTitle || `${loaderData?.city.name} - City Council`,
      meta: settings?.metaDescription ? [{
        name: "description",
        content: settings.metaDescription
      }] : [],
      links: [{
        rel: "stylesheet",
        href: stylesCss
      }]
    };
  },
  component: lazyRouteComponent($$splitComponentImporter$2, "component")
});
const $$splitComponentImporter$1 = () => import("./_citySlug.index-Bg8mHfmz.js");
const Route$2 = createFileRoute("/_app/$citySlug/")({
  loader: async ({
    params
  }) => {
    const {
      citySlug
    } = params;
    return getHomepage({
      citySlug
    });
  },
  component: lazyRouteComponent($$splitComponentImporter$1, "component")
});
function ref(name2) {
  return { $ref: `#/components/schemas/${name2}` };
}
function errorResponseSchema() {
  return {
    type: "object",
    properties: { error: {
      type: "object",
      properties: {
        code: { type: "string" },
        message: { type: "string" },
        details: {}
      },
      required: ["code", "message"]
    } },
    required: ["error"]
  };
}
function paginatedResponseSchema(itemRef) {
  return {
    type: "object",
    properties: {
      docs: {
        type: "array",
        items: itemRef
      },
      totalDocs: { type: "integer" },
      limit: { type: "integer" },
      page: { type: "integer" },
      totalPages: { type: "integer" },
      hasNextPage: { type: "boolean" },
      hasPrevPage: { type: "boolean" },
      nextPage: { type: ["integer", "null"] },
      prevPage: { type: ["integer", "null"] }
    },
    required: [
      "docs",
      "totalDocs",
      "limit",
      "page",
      "totalPages"
    ]
  };
}
function listQueryParameters() {
  return [
    {
      name: "limit",
      in: "query",
      schema: {
        type: "integer",
        default: 10
      },
      description: "Number of records to return"
    },
    {
      name: "page",
      in: "query",
      schema: {
        type: "integer",
        default: 1
      },
      description: "Page number"
    },
    {
      name: "offset",
      in: "query",
      schema: { type: "integer" },
      description: "Number of records to skip"
    },
    {
      name: "where",
      in: "query",
      schema: { type: "string" },
      description: "Filter conditions (JSON encoded)"
    },
    {
      name: "orderBy",
      in: "query",
      schema: { type: "string" },
      description: "Sort configuration (JSON encoded)"
    },
    {
      name: "locale",
      in: "query",
      schema: { type: "string" },
      description: "Content locale"
    }
  ];
}
function singleQueryParameters() {
  return [{
    name: "locale",
    in: "query",
    schema: { type: "string" },
    description: "Content locale"
  }];
}
function jsonResponse(schema2, description = "Successful response") {
  return {
    "200": {
      description,
      content: { "application/json": { schema: schema2 } }
    },
    "400": {
      description: "Bad request",
      content: { "application/json": { schema: ref("ErrorResponse") } }
    },
    "401": {
      description: "Unauthorized",
      content: { "application/json": { schema: ref("ErrorResponse") } }
    },
    "404": {
      description: "Not found",
      content: { "application/json": { schema: ref("ErrorResponse") } }
    }
  };
}
function jsonRequestBody(schema2, description) {
  return {
    description,
    required: true,
    content: { "application/json": { schema: schema2 } }
  };
}
function zodToJsonSchema(schema2) {
  try {
    if (schema2 && typeof schema2 === "object" && "_def" in schema2) return z$1.toJSONSchema(schema2);
  } catch {
  }
  return {
    type: "object",
    description: "Schema could not be generated"
  };
}
function baseComponentSchemas() {
  return {
    ErrorResponse: errorResponseSchema(),
    SuccessResponse: {
      type: "object",
      properties: { success: { type: "boolean" } },
      required: ["success"]
    },
    CountResponse: {
      type: "object",
      properties: { count: { type: "integer" } },
      required: ["count"]
    },
    DeleteManyResponse: {
      type: "object",
      properties: {
        success: { type: "boolean" },
        count: { type: "integer" }
      },
      required: ["success"]
    }
  };
}
function generateAuthPaths(config2) {
  if (config2.auth === false) return {
    paths: {},
    tags: []
  };
  const basePath = config2.basePath ?? "/cms";
  const tag2 = "Auth";
  const paths2 = {};
  paths2[`${basePath}/auth/sign-in/email`] = { post: {
    operationId: "auth_signInEmail",
    summary: "Sign in with email and password",
    tags: [tag2],
    requestBody: jsonRequestBody({
      type: "object",
      properties: {
        email: {
          type: "string",
          format: "email"
        },
        password: { type: "string" }
      },
      required: ["email", "password"]
    }),
    responses: jsonResponse({
      type: "object",
      properties: {
        user: { type: "object" },
        session: { type: "object" }
      }
    }, "Authentication successful")
  } };
  paths2[`${basePath}/auth/sign-up/email`] = { post: {
    operationId: "auth_signUpEmail",
    summary: "Sign up with email and password",
    tags: [tag2],
    requestBody: jsonRequestBody({
      type: "object",
      properties: {
        email: {
          type: "string",
          format: "email"
        },
        password: { type: "string" },
        name: { type: "string" }
      },
      required: [
        "email",
        "password",
        "name"
      ]
    }),
    responses: jsonResponse({
      type: "object",
      properties: {
        user: { type: "object" },
        session: { type: "object" }
      }
    }, "Registration successful")
  } };
  paths2[`${basePath}/auth/get-session`] = { get: {
    operationId: "auth_getSession",
    summary: "Get current session",
    tags: [tag2],
    responses: jsonResponse({
      type: "object",
      properties: {
        user: { type: "object" },
        session: { type: "object" }
      }
    }, "Current session")
  } };
  paths2[`${basePath}/auth/sign-out`] = { post: {
    operationId: "auth_signOut",
    summary: "Sign out",
    tags: [tag2],
    responses: jsonResponse({
      type: "object",
      properties: { success: { type: "boolean" } }
    }, "Signed out")
  } };
  return {
    paths: paths2,
    tags: [{
      name: tag2,
      description: "Authentication endpoints (Better Auth)"
    }]
  };
}
function generateCollectionPaths(cms2, config2) {
  const collections = cms2.getCollections();
  const basePath = config2.basePath ?? "/cms";
  const excluded = new Set(config2.exclude?.collections ?? []);
  const paths2 = {};
  const schemas = {};
  const tags = [];
  for (const [name2, collection] of Object.entries(collections)) {
    if (excluded.has(name2)) continue;
    const state = collection.state;
    if (!state) continue;
    const tag2 = `Collections: ${name2}`;
    tags.push({
      name: tag2,
      description: `CRUD operations for ${name2}`
    });
    const pascalName = toPascalCase$1(name2);
    const documentSchemaName = `${pascalName}Document`;
    const insertSchemaName = `${pascalName}Insert`;
    const updateSchemaName = `${pascalName}Update`;
    const fieldDefinitionSchema = buildSchemaFromFieldDefinitions(state.fieldDefinitions);
    if (state.validation?.insertSchema) try {
      schemas[insertSchemaName] = z$1.toJSONSchema(state.validation.insertSchema, { unrepresentable: "any" });
    } catch {
      schemas[insertSchemaName] = {
        type: "object",
        description: `Insert schema for ${name2}`
      };
    }
    else if (fieldDefinitionSchema != null) schemas[insertSchemaName] = fieldDefinitionSchema.insert;
    else schemas[insertSchemaName] = {
      type: "object",
      description: `Insert schema for ${name2}`
    };
    if (state.validation?.updateSchema) try {
      schemas[updateSchemaName] = z$1.toJSONSchema(state.validation.updateSchema, { unrepresentable: "any" });
    } catch {
      schemas[updateSchemaName] = {
        type: "object",
        description: `Update schema for ${name2}`
      };
    }
    else if (fieldDefinitionSchema != null) schemas[updateSchemaName] = fieldDefinitionSchema.update;
    else schemas[updateSchemaName] = {
      type: "object",
      description: `Update schema for ${name2}`
    };
    schemas[documentSchemaName] = buildDocumentSchema(name2, state, insertSchemaName);
    const prefix = `${basePath}/${name2}`;
    paths2[prefix] = {
      get: {
        operationId: `${name2}_find`,
        summary: `List ${name2}`,
        tags: [tag2],
        parameters: listQueryParameters(),
        responses: jsonResponse(paginatedResponseSchema(ref(documentSchemaName)), `Paginated list of ${name2}`)
      },
      post: {
        operationId: `${name2}_create`,
        summary: `Create ${name2}`,
        tags: [tag2],
        requestBody: jsonRequestBody(ref(insertSchemaName)),
        responses: jsonResponse(ref(documentSchemaName), `Created ${name2} record`)
      }
    };
    paths2[`${prefix}/count`] = { get: {
      operationId: `${name2}_count`,
      summary: `Count ${name2}`,
      tags: [tag2],
      parameters: [{
        name: "where",
        in: "query",
        schema: { type: "string" },
        description: "Filter conditions (JSON encoded)"
      }],
      responses: jsonResponse(ref("CountResponse"), `Count of ${name2}`)
    } };
    paths2[`${prefix}/delete-many`] = { post: {
      operationId: `${name2}_deleteMany`,
      summary: `Delete many ${name2}`,
      tags: [tag2],
      requestBody: jsonRequestBody({
        type: "object",
        properties: { where: {
          type: "object",
          description: "Filter conditions for records to delete"
        } }
      }),
      responses: jsonResponse(ref("DeleteManyResponse"), `Delete multiple ${name2} records`)
    } };
    if (state.upload) paths2[`${prefix}/upload`] = { post: {
      operationId: `${name2}_upload`,
      summary: `Upload file to ${name2}`,
      tags: [tag2],
      requestBody: {
        required: true,
        content: { "multipart/form-data": { schema: {
          type: "object",
          properties: { file: {
            type: "string",
            format: "binary"
          } },
          required: ["file"]
        } } }
      },
      responses: jsonResponse(ref(documentSchemaName), `Uploaded file record`)
    } };
    paths2[`${prefix}/schema`] = { get: {
      operationId: `${name2}_schema`,
      summary: `Get ${name2} introspection schema`,
      tags: [tag2],
      responses: jsonResponse({
        type: "object",
        description: "Introspected collection schema"
      }, `Introspection schema for ${name2}`)
    } };
    paths2[`${prefix}/meta`] = { get: {
      operationId: `${name2}_meta`,
      summary: `Get ${name2} metadata`,
      tags: [tag2],
      responses: jsonResponse({
        type: "object",
        description: "Collection metadata"
      }, `Metadata for ${name2}`)
    } };
    const idParam = {
      name: "id",
      in: "path",
      required: true,
      schema: { type: "string" },
      description: "Record ID"
    };
    paths2[`${prefix}/{id}`] = {
      get: {
        operationId: `${name2}_findOne`,
        summary: `Get ${name2} by ID`,
        tags: [tag2],
        parameters: [idParam, ...singleQueryParameters()],
        responses: jsonResponse(ref(documentSchemaName), `Single ${name2} record`)
      },
      patch: {
        operationId: `${name2}_update`,
        summary: `Update ${name2}`,
        tags: [tag2],
        parameters: [idParam],
        requestBody: jsonRequestBody(ref(updateSchemaName)),
        responses: jsonResponse(ref(documentSchemaName), `Updated ${name2} record`)
      },
      delete: {
        operationId: `${name2}_delete`,
        summary: `Delete ${name2}`,
        tags: [tag2],
        parameters: [idParam],
        responses: jsonResponse(ref("SuccessResponse"), `Deleted ${name2} record`)
      }
    };
    if (state.options?.softDelete) paths2[`${prefix}/{id}/restore`] = { post: {
      operationId: `${name2}_restore`,
      summary: `Restore deleted ${name2}`,
      tags: [tag2],
      parameters: [idParam],
      responses: jsonResponse(ref(documentSchemaName), `Restored ${name2} record`)
    } };
  }
  return {
    paths: paths2,
    schemas,
    tags
  };
}
function buildDocumentSchema(name2, state, insertSchemaName) {
  const properties = { id: { type: "string" } };
  if (state.options?.timestamps !== false) {
    properties.createdAt = {
      type: "string",
      format: "date-time"
    };
    properties.updatedAt = {
      type: "string",
      format: "date-time"
    };
  }
  if (state.options?.softDelete) properties.deletedAt = {
    type: ["string", "null"],
    format: "date-time"
  };
  return {
    allOf: [{
      type: "object",
      properties,
      required: ["id"]
    }, ref(insertSchemaName)],
    description: `${name2} document`
  };
}
function toPascalCase$1(str) {
  return str.replace(/[-_](.)/g, (_, c2) => c2.toUpperCase()).replace(/^(.)/, (_, c2) => c2.toUpperCase());
}
function buildSchemaFromFieldDefinitions(fieldDefinitions) {
  if (!fieldDefinitions || typeof fieldDefinitions !== "object") return null;
  const shape = {};
  for (const [fieldName, fieldDefinition] of Object.entries(fieldDefinitions)) {
    const toZodSchema2 = fieldDefinition.toZodSchema;
    if (typeof toZodSchema2 !== "function") continue;
    try {
      const schema2 = toZodSchema2();
      if (schema2 && typeof schema2 === "object" && "_def" in schema2) shape[fieldName] = schema2;
    } catch {
    }
  }
  if (Object.keys(shape).length === 0) return null;
  const insertSchema = z$1.object(shape);
  const updateSchema = insertSchema.partial();
  return {
    insert: z$1.toJSONSchema(insertSchema, { unrepresentable: "any" }),
    update: z$1.toJSONSchema(updateSchema, { unrepresentable: "any" })
  };
}
function generateGlobalPaths(cms2, config2) {
  const globals = cms2.getGlobals();
  const basePath = config2.basePath ?? "/cms";
  const excluded = new Set(config2.exclude?.globals ?? []);
  const paths2 = {};
  const schemas = {};
  const tags = [];
  for (const [name2, global2] of Object.entries(globals)) {
    if (excluded.has(name2)) continue;
    const state = global2.state;
    if (!state) continue;
    const tag2 = `Globals: ${name2}`;
    tags.push({
      name: tag2,
      description: `Operations for ${name2} global`
    });
    const pascalName = toPascalCase(name2);
    const valueSchemaName = `${pascalName}Global`;
    const updateSchemaName = `${pascalName}GlobalUpdate`;
    const fieldDefinitionSchema = buildGlobalSchemaFromFieldDefinitions(state.fieldDefinitions);
    if (state.validation?.updateSchema) try {
      schemas[updateSchemaName] = z$1.toJSONSchema(state.validation.updateSchema, { unrepresentable: "any" });
    } catch {
      schemas[updateSchemaName] = {
        type: "object",
        description: `Update schema for ${name2} global`
      };
    }
    else if (fieldDefinitionSchema != null) schemas[updateSchemaName] = fieldDefinitionSchema;
    else schemas[updateSchemaName] = {
      type: "object",
      description: `Update schema for ${name2} global`
    };
    const properties = { id: { type: "string" } };
    if (state.options?.timestamps !== false) {
      properties.createdAt = {
        type: "string",
        format: "date-time"
      };
      properties.updatedAt = {
        type: "string",
        format: "date-time"
      };
    }
    schemas[valueSchemaName] = {
      allOf: [{
        type: "object",
        properties,
        required: ["id"]
      }, ref(updateSchemaName)],
      description: `${name2} global value`
    };
    const prefix = `${basePath}/globals/${name2}`;
    paths2[prefix] = {
      get: {
        operationId: `global_${name2}_get`,
        summary: `Get ${name2} global`,
        tags: [tag2],
        parameters: [{
          name: "locale",
          in: "query",
          schema: { type: "string" },
          description: "Content locale"
        }],
        responses: jsonResponse(ref(valueSchemaName), `Current value of ${name2} global`)
      },
      patch: {
        operationId: `global_${name2}_update`,
        summary: `Update ${name2} global`,
        tags: [tag2],
        requestBody: jsonRequestBody(ref(updateSchemaName)),
        responses: jsonResponse(ref(valueSchemaName), `Updated ${name2} global`)
      }
    };
    paths2[`${prefix}/schema`] = { get: {
      operationId: `global_${name2}_schema`,
      summary: `Get ${name2} global introspection schema`,
      tags: [tag2],
      responses: jsonResponse({
        type: "object",
        description: "Introspected global schema"
      }, `Introspection schema for ${name2} global`)
    } };
  }
  return {
    paths: paths2,
    schemas,
    tags
  };
}
function toPascalCase(str) {
  return str.replace(/[-_](.)/g, (_, c2) => c2.toUpperCase()).replace(/^(.)/, (_, c2) => c2.toUpperCase());
}
function buildGlobalSchemaFromFieldDefinitions(fieldDefinitions) {
  if (!fieldDefinitions || typeof fieldDefinitions !== "object") return null;
  const shape = {};
  for (const [fieldName, fieldDefinition] of Object.entries(fieldDefinitions)) {
    const toZodSchema2 = fieldDefinition.toZodSchema;
    if (typeof toZodSchema2 !== "function") continue;
    try {
      const schema2 = toZodSchema2();
      if (schema2 && typeof schema2 === "object" && "_def" in schema2) shape[fieldName] = schema2;
    } catch {
    }
  }
  if (Object.keys(shape).length === 0) return null;
  return z$1.toJSONSchema(z$1.object(shape).partial(), { unrepresentable: "any" });
}
function flattenRpcTree(tree, prefix = []) {
  const entries = [];
  for (const [key, value] of Object.entries(tree)) {
    const segments = [...prefix, key];
    if (value && typeof value === "object" && "handler" in value && typeof value.handler === "function") entries.push({
      path: segments.join("/"),
      segments,
      definition: value
    });
    else if (value && typeof value === "object") entries.push(...flattenRpcTree(value, segments));
  }
  return entries;
}
function generateRpcPaths(rpc2, config2) {
  const paths2 = {};
  const schemas = {};
  const tags = [];
  if (!rpc2) return {
    paths: paths2,
    schemas,
    tags
  };
  const basePath = config2.basePath ?? "/cms";
  const entries = flattenRpcTree(rpc2);
  const tagSet = /* @__PURE__ */ new Set();
  for (const entry of entries) {
    const def = entry.definition;
    const isRaw = def.mode === "raw";
    const topLevel = entry.segments[0] ?? "rpc";
    if (!tagSet.has(topLevel)) {
      tagSet.add(topLevel);
      tags.push({
        name: `RPC: ${topLevel}`,
        description: `RPC functions under ${topLevel}`
      });
    }
    const operationId = `rpc_${entry.segments.join("_")}`;
    const routePath = `${basePath}/rpc/${entry.path}`;
    const operation = {
      operationId,
      summary: entry.path,
      tags: [`RPC: ${topLevel}`],
      responses: {}
    };
    if (isRaw) {
      operation.description = "Raw RPC function  accepts any request body and returns a raw response.";
      operation.requestBody = { content: {
        "application/json": { schema: {} },
        "application/octet-stream": { schema: {
          type: "string",
          format: "binary"
        } }
      } };
      operation.responses = {
        "200": { description: "Raw response" },
        "401": {
          description: "Unauthorized",
          content: { "application/json": { schema: { $ref: "#/components/schemas/ErrorResponse" } } }
        }
      };
    } else {
      let inputSchema = {};
      let outputSchema = { type: "object" };
      if (def.schema) {
        const schemaName = `${operationId}_Input`;
        schemas[schemaName] = zodToJsonSchema(def.schema);
        inputSchema = { $ref: `#/components/schemas/${schemaName}` };
      }
      if (def.outputSchema) {
        const schemaName = `${operationId}_Output`;
        schemas[schemaName] = zodToJsonSchema(def.outputSchema);
        outputSchema = { $ref: `#/components/schemas/${schemaName}` };
      }
      operation.requestBody = jsonRequestBody(inputSchema, "RPC function input");
      operation.responses = jsonResponse(outputSchema, "RPC function output");
    }
    paths2[routePath] = { post: operation };
  }
  return {
    paths: paths2,
    schemas,
    tags
  };
}
function generateSearchPaths(config2) {
  if (config2.search === false) return {
    paths: {},
    tags: []
  };
  const basePath = config2.basePath ?? "/cms";
  const tag2 = "Search";
  const paths2 = {};
  paths2[`${basePath}/search`] = { post: {
    operationId: "search",
    summary: "Search across collections",
    tags: [tag2],
    requestBody: jsonRequestBody({
      type: "object",
      properties: {
        query: {
          type: "string",
          description: "Search query"
        },
        collections: {
          type: "array",
          items: { type: "string" },
          description: "Collections to search (omit for all)"
        },
        limit: {
          type: "integer",
          default: 10
        },
        offset: {
          type: "integer",
          default: 0
        }
      },
      required: ["query"]
    }),
    responses: jsonResponse({
      type: "object",
      properties: {
        results: {
          type: "array",
          items: {
            type: "object",
            properties: {
              collection: { type: "string" },
              doc: { type: "object" },
              _search: {
                type: "object",
                properties: {
                  score: { type: "number" },
                  highlights: { type: "object" },
                  indexedTitle: { type: "string" }
                }
              }
            }
          }
        },
        totalResults: { type: "integer" }
      }
    }, "Search results")
  } };
  paths2[`${basePath}/search/reindex/{collection}`] = { post: {
    operationId: "search_reindex",
    summary: "Reindex a collection",
    description: "Requires admin authentication.",
    tags: [tag2],
    parameters: [{
      name: "collection",
      in: "path",
      required: true,
      schema: { type: "string" },
      description: "Collection name to reindex"
    }],
    responses: jsonResponse({
      type: "object",
      properties: {
        success: { type: "boolean" },
        collection: { type: "string" }
      }
    }, "Reindex started")
  } };
  return {
    paths: paths2,
    tags: [{
      name: tag2,
      description: "Full-text search endpoints"
    }]
  };
}
function generateOpenApiSpec$1(cms2, rpc2, config2 = {}) {
  const allPaths = {};
  const allSchemas = { ...baseComponentSchemas() };
  const allTags = [];
  const collections = generateCollectionPaths(cms2, config2);
  Object.assign(allPaths, collections.paths);
  Object.assign(allSchemas, collections.schemas);
  allTags.push(...collections.tags);
  const globals = generateGlobalPaths(cms2, config2);
  Object.assign(allPaths, globals.paths);
  Object.assign(allSchemas, globals.schemas);
  allTags.push(...globals.tags);
  const rpcResult = generateRpcPaths(rpc2, config2);
  Object.assign(allPaths, rpcResult.paths);
  Object.assign(allSchemas, rpcResult.schemas);
  allTags.push(...rpcResult.tags);
  const auth2 = generateAuthPaths(config2);
  Object.assign(allPaths, auth2.paths);
  allTags.push(...auth2.tags);
  const search = generateSearchPaths(config2);
  Object.assign(allPaths, search.paths);
  allTags.push(...search.tags);
  return {
    openapi: "3.1.0",
    info: {
      title: config2.info?.title ?? "QuestPie CMS API",
      version: config2.info?.version ?? "1.0.0",
      description: config2.info?.description
    },
    servers: config2.servers,
    paths: allPaths,
    components: {
      schemas: allSchemas,
      securitySchemes: {
        bearerAuth: {
          type: "http",
          scheme: "bearer"
        },
        cookieAuth: {
          type: "apiKey",
          in: "cookie",
          name: "better-auth.session_token"
        }
      }
    },
    tags: allTags,
    security: [{ bearerAuth: [] }, { cookieAuth: [] }]
  };
}
function serveScalarUI(spec, config2) {
  const title = config2?.title ?? spec.info.title ?? "API Reference";
  const scalarConfig = JSON.stringify({
    theme: config2?.theme ?? "purple",
    hideDownloadButton: config2?.hideDownloadButton,
    defaultHttpClient: config2?.defaultHttpClient,
    customCss: config2?.customCss,
    content: spec
  });
  const html2 = `<!DOCTYPE html>
<html>
<head>
  <title>${escapeHtml(title)}</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
</head>
<body>
  <script id="api-reference" data-configuration='${escapeAttr(scalarConfig)}'><\/script>
  <script src="https://cdn.jsdelivr.net/npm/@scalar/api-reference"><\/script>
</body>
</html>`;
  return new Response(html2, { headers: { "Content-Type": "text/html; charset=utf-8" } });
}
function escapeHtml(str) {
  return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function escapeAttr(str) {
  return str.replace(/&/g, "&amp;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function createOpenApiHandlers(spec, options) {
  return {
    specHandler: () => new Response(JSON.stringify(spec), { headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "*"
    } }),
    scalarHandler: () => serveScalarUI(spec, options?.scalar)
  };
}
function withOpenApi(handler2, config2) {
  const { cms: cms2, rpc: rpc2, scalar, specPath = "openapi.json", docsPath = "docs", ...openApiConfig } = config2;
  const { specHandler, scalarHandler } = createOpenApiHandlers(generateOpenApiSpec$1(cms2, rpc2, openApiConfig), { scalar });
  const basePath = normalizeBasePath(openApiConfig.basePath ?? "/cms");
  const specRoute = `${basePath}/${specPath}`;
  const docsRoute = `${basePath}/${docsPath}`;
  return (request, context) => {
    const pathname = new URL(request.url).pathname;
    if (request.method === "GET") {
      if (pathname === specRoute) return specHandler();
      if (pathname === docsRoute) return scalarHandler();
    }
    return handler2(request, context);
  };
}
function normalizeBasePath(path) {
  return path.endsWith("/") ? path.slice(0, -1) : path;
}
const qb = q.use(adminModule).context(async ({ request }) => {
  const cityId = request.headers.get("x-selected-city");
  return {
    cityId: cityId || null
  };
});
const announcements = qb.collection("announcements").fields((f) => ({
  city: f.relation({
    label: "City",
    to: "cities",
    required: true
  }),
  title: f.text({
    label: "Title",
    required: true,
    maxLength: 255
  }),
  content: f.richText({
    label: "Content"
  }),
  category: f.select({
    label: "Category",
    options: [
      { value: "notice", label: "Public Notice" },
      { value: "planning", label: "Planning Application" },
      { value: "consultation", label: "Public Consultation" },
      { value: "tender", label: "Tender" },
      { value: "job", label: "Job Vacancy" },
      { value: "event", label: "Event" },
      { value: "emergency", label: "Emergency Notice" }
    ],
    required: true,
    default: "notice"
  }),
  validFrom: f.date({
    label: "Valid From",
    required: true
  }),
  validTo: f.date({
    label: "Valid Until",
    required: true,
    description: "Announcement will be hidden after this date"
  }),
  isPinned: f.boolean({
    label: "Pinned",
    default: false,
    description: "Show at the top of the list"
  }),
  attachments: f.upload({
    label: "Attachments",
    accept: ["application/pdf", "image/*"],
    multiple: true
  }),
  referenceNumber: f.text({
    label: "Reference Number",
    maxLength: 100,
    description: "Official reference number"
  })
})).title(({ f }) => f.title).admin(({ c: c2 }) => ({
  label: "Announcements",
  icon: c2.icon("ph:megaphone"),
  description: "Official notices and public announcements"
})).list(
  ({ v }) => v.table({
    columns: ["title", "category", "validFrom", "validTo", "isPinned"]
  })
).form(
  ({ v, f }) => v.form({
    sidebar: {
      position: "right",
      fields: [
        f.city,
        f.category,
        f.validFrom,
        f.validTo,
        f.isPinned,
        f.referenceNumber
      ]
    },
    fields: [
      {
        type: "section",
        label: "Announcement",
        fields: [f.title, f.content, f.attachments]
      }
    ]
  })
);
const cities = qb.collection("cities").fields((f) => ({
  name: f.text({
    label: "City Name",
    required: true,
    maxLength: 255
  }),
  slug: f.text({
    label: "Slug",
    required: true,
    maxLength: 100,
    description: "URL-friendly identifier (e.g., 'london', 'manchester')"
  }),
  logo: f.upload({
    label: "City Logo/Crest",
    accept: ["image/*"]
  }),
  email: f.text({
    label: "Contact Email",
    maxLength: 255
  }),
  phone: f.text({
    label: "Contact Phone",
    maxLength: 50
  }),
  address: f.textarea({
    label: "Address",
    description: "Full postal address of the city council"
  }),
  website: f.text({
    label: "External Website",
    maxLength: 255,
    description: "Link to the official city website (if different)"
  }),
  population: f.number({
    label: "Population",
    description: "Approximate population"
  }),
  isActive: f.boolean({
    label: "Active",
    default: true,
    description: "Whether this city portal is publicly accessible"
  })
})).indexes(({ table }) => [
  uniqueIndex("cities_slug_unique").on(table.slug)
]).title(({ f }) => f.name).admin(({ c: c2 }) => ({
  label: "Cities",
  icon: c2.icon("ph:buildings"),
  description: "Manage city portals"
})).list(
  ({ v }) => v.table({
    columns: ["name", "slug", "email", "isActive"]
  })
).form(
  ({ v, f }) => v.form({
    sidebar: {
      position: "right",
      fields: [f.slug, f.isActive]
    },
    fields: [
      {
        type: "section",
        label: "Basic Information",
        layout: "grid",
        columns: 2,
        fields: [f.name, f.logo]
      },
      {
        type: "section",
        label: "Contact Details",
        layout: "grid",
        columns: 2,
        fields: [f.email, f.phone, f.address, f.website]
      },
      {
        type: "section",
        label: "Additional Info",
        fields: [f.population]
      }
    ]
  })
);
const cityMembers = qb.collection("cityMembers").fields((f) => ({
  user: f.relation({
    label: "User",
    to: "user",
    required: true
  }),
  city: f.relation({
    label: "City",
    to: "cities",
    required: true
  }),
  role: f.select({
    label: "Role",
    options: [
      { value: "admin", label: "Admin" },
      { value: "editor", label: "Editor" },
      { value: "viewer", label: "Viewer" }
    ],
    default: "editor",
    required: true,
    description: "Admin: full access, Editor: can edit content, Viewer: read only"
  })
})).indexes(({ table }) => [
  uniqueIndex("city_members_unique").on(table.user, table.city)
]).admin(({ c: c2 }) => ({
  label: "City Members",
  icon: c2.icon("ph:users-three"),
  description: "Manage who can access each city portal"
})).list(
  ({ v }) => v.table({
    columns: ["user", "city", "role"]
  })
).form(
  ({ v, f }) => v.form({
    fields: [
      {
        type: "section",
        label: "Membership",
        layout: "grid",
        columns: 3,
        fields: [f.user, f.city, f.role]
      }
    ]
  })
);
const contacts = qb.collection("contacts").fields((f) => ({
  city: f.relation({
    label: "City",
    to: "cities",
    required: true
  }),
  department: f.text({
    label: "Department",
    required: true,
    maxLength: 255
  }),
  description: f.textarea({
    label: "Description",
    description: "What this department handles"
  }),
  contactPerson: f.text({
    label: "Contact Person",
    maxLength: 255
  }),
  position: f.text({
    label: "Position",
    maxLength: 255
  }),
  email: f.text({
    label: "Email",
    maxLength: 255
  }),
  phone: f.text({
    label: "Phone",
    maxLength: 50
  }),
  address: f.textarea({
    label: "Address",
    description: "If different from main city address"
  }),
  officeHours: f.text({
    label: "Office Hours",
    maxLength: 255,
    description: "e.g., Mon-Fri 9:00-17:00"
  }),
  order: f.number({
    label: "Display Order",
    default: 0
  })
})).title(({ f }) => f.department).admin(({ c: c2 }) => ({
  label: "Contacts",
  icon: c2.icon("ph:address-book"),
  description: "Department contacts and information"
})).list(
  ({ v }) => v.table({
    columns: ["department", "contactPerson", "email", "phone"]
  })
).form(
  ({ v, f }) => v.form({
    sidebar: {
      position: "right",
      fields: [f.city, f.order]
    },
    fields: [
      {
        type: "section",
        label: "Department Info",
        layout: "grid",
        columns: 2,
        fields: [f.department, f.description]
      },
      {
        type: "section",
        label: "Contact Person",
        layout: "grid",
        columns: 2,
        fields: [f.contactPerson, f.position]
      },
      {
        type: "section",
        label: "Contact Details",
        layout: "grid",
        columns: 2,
        fields: [f.email, f.phone, f.officeHours, f.address]
      }
    ]
  })
);
const documents = qb.collection("documents").fields((f) => ({
  city: f.relation({
    label: "City",
    to: "cities",
    required: true
  }),
  title: f.text({
    label: "Title",
    required: true,
    maxLength: 255
  }),
  description: f.textarea({
    label: "Description"
  }),
  category: f.select({
    label: "Category",
    options: [
      { value: "policy", label: "Policy" },
      { value: "minutes", label: "Meeting Minutes" },
      { value: "budget", label: "Budget & Finance" },
      { value: "planning", label: "Planning" },
      { value: "strategy", label: "Strategy" },
      { value: "report", label: "Report" },
      { value: "form", label: "Form" },
      { value: "guide", label: "Guide" },
      { value: "other", label: "Other" }
    ],
    required: true,
    default: "other"
  }),
  file: f.upload({
    label: "File",
    accept: [
      "application/pdf",
      "application/msword",
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    ],
    required: true
  }),
  publishedDate: f.date({
    label: "Published Date"
  }),
  version: f.text({
    label: "Version",
    maxLength: 50,
    description: "Document version (e.g., v1.0, 2024 Edition)"
  }),
  isPublished: f.boolean({
    label: "Published",
    default: true
  })
})).title(({ f }) => f.title).admin(({ c: c2 }) => ({
  label: "Documents",
  icon: c2.icon("ph:file-pdf"),
  description: "Official documents and publications"
})).list(
  ({ v }) => v.table({
    columns: ["title", "category", "publishedDate", "isPublished"]
  })
).form(
  ({ v, f }) => v.form({
    sidebar: {
      position: "right",
      fields: [f.city, f.category, f.publishedDate, f.version, f.isPublished]
    },
    fields: [
      {
        type: "section",
        label: "Document",
        fields: [f.title, f.description, f.file]
      }
    ]
  })
);
function slugify(text2) {
  return text2.toString().toLowerCase().trim().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, "");
}
const news = qb.collection("news").fields((f) => ({
  city: f.relation({
    label: "City",
    to: "cities",
    required: true
  }),
  title: f.text({
    label: "Title",
    required: true,
    maxLength: 255
  }),
  slug: f.text({
    label: "Slug",
    required: true,
    maxLength: 255,
    input: "optional",
    meta: {
      admin: {
        compute: {
          handler: ({
            data,
            prev
          }) => {
            const title = data.title;
            const currentSlug = data.slug;
            const prevTitle = prev.data.title;
            if (currentSlug && prevTitle === title) {
              return void 0;
            }
            if (title && typeof title === "string") {
              return slugify(title);
            }
            return void 0;
          },
          deps: ({ data }) => [
            data.title,
            data.slug
          ],
          debounce: 300
        }
      }
    }
  }),
  excerpt: f.textarea({
    label: "Excerpt",
    description: "Short summary for listings"
  }),
  content: f.richText({
    label: "Content"
  }),
  image: f.upload({
    label: "Featured Image",
    accept: ["image/*"]
  }),
  category: f.select({
    label: "Category",
    options: [
      { value: "general", label: "General" },
      { value: "council", label: "Council News" },
      { value: "events", label: "Events" },
      { value: "planning", label: "Planning" },
      { value: "community", label: "Community" },
      { value: "transport", label: "Transport" }
    ],
    default: "general"
  }),
  publishedAt: f.datetime({
    label: "Published Date"
  }),
  author: f.text({
    label: "Author",
    maxLength: 255
  }),
  isPublished: f.boolean({
    label: "Published",
    default: false
  }),
  isFeatured: f.boolean({
    label: "Featured",
    default: false,
    description: "Show on homepage"
  })
})).indexes(({ table }) => [
  uniqueIndex("news_city_slug_unique").on(
    table.city,
    table.slug
  )
]).title(({ f }) => f.title).admin(({ c: c2 }) => ({
  label: "News",
  icon: c2.icon("ph:newspaper"),
  description: "News articles and updates"
})).list(
  ({ v }) => v.table({
    columns: [
      "title",
      "category",
      "publishedAt",
      "isPublished",
      "isFeatured"
    ]
  })
).form(
  ({ v, f }) => v.form({
    sidebar: {
      position: "right",
      fields: [
        f.slug,
        f.city,
        f.category,
        f.publishedAt,
        f.author,
        f.isPublished,
        f.isFeatured
      ]
    },
    fields: [
      {
        type: "section",
        label: "Article",
        fields: [f.title, f.excerpt, f.image, f.content]
      }
    ]
  })
);
const pages = qb.collection("pages").fields((f) => ({
  city: f.relation({
    label: "City",
    to: "cities",
    required: true
  }),
  title: f.text({
    label: "Title",
    required: true,
    maxLength: 255
  }),
  slug: f.text({
    label: "Slug",
    required: true,
    maxLength: 255,
    input: "optional",
    meta: {
      admin: {
        compute: {
          handler: ({
            data,
            prev
          }) => {
            const title = data.title;
            const currentSlug = data.slug;
            const prevTitle = prev.data.title;
            if (currentSlug && prevTitle === title) {
              return void 0;
            }
            if (title && typeof title === "string") {
              return slugify(title);
            }
            return void 0;
          },
          deps: ({ data }) => [
            data.title,
            data.slug
          ],
          debounce: 300
        }
      }
    }
  }),
  content: f.blocks({
    label: "Content"
  }),
  excerpt: f.textarea({
    label: "Excerpt",
    description: "Short description for listings and SEO"
  }),
  parent: f.relation({
    label: "Parent Page",
    to: "pages",
    description: "For creating page hierarchy"
  }),
  order: f.number({
    label: "Order",
    default: 0,
    description: "Display order in navigation"
  }),
  showInNav: f.boolean({
    label: "Show in Navigation",
    default: true
  }),
  featuredImage: f.upload({
    label: "Featured Image",
    accept: ["image/*"]
  }),
  isPublished: f.boolean({
    label: "Published",
    default: false
  }),
  metaTitle: f.text({
    label: "Meta Title",
    maxLength: 70,
    meta: {
      admin: {
        hidden: ({ data }) => !data.isPublished
      }
    }
  }),
  metaDescription: f.textarea({
    label: "Meta Description",
    meta: {
      admin: {
        hidden: ({ data }) => !data.isPublished
      }
    }
  })
})).indexes(({ table }) => [
  uniqueIndex("pages_city_slug_unique").on(
    table.city,
    table.slug
  )
]).title(({ f }) => f.title).admin(({ c: c2 }) => ({
  label: "Pages",
  icon: c2.icon("ph:article"),
  description: "Website pages with block-based content"
})).list(
  ({ v }) => v.table({
    columns: ["title", "slug", "parent", "isPublished"]
  })
).form(
  ({ v, f }) => v.form({
    sidebar: {
      position: "right",
      fields: [f.slug, f.city, f.parent, f.order, f.showInNav, f.isPublished]
    },
    fields: [
      {
        type: "section",
        label: "Page Content",
        fields: [f.title, f.excerpt, f.featuredImage, f.content]
      },
      {
        type: "section",
        label: "SEO",
        layout: "grid",
        columns: 2,
        fields: [f.metaTitle, f.metaDescription]
      }
    ]
  })
).preview({
  enabled: true,
  position: "right",
  defaultWidth: 50,
  url: ({ record }) => {
    const slug2 = record.slug || "home";
    return `/pages/${slug2}?preview=true`;
  }
});
const submissions = qb.collection("submissions").fields((f) => ({
  city: f.relation({
    label: "City",
    to: "cities",
    required: true
  }),
  name: f.text({
    label: "Name",
    required: true,
    maxLength: 255
  }),
  email: f.text({
    label: "Email",
    required: true,
    maxLength: 255
  }),
  phone: f.text({
    label: "Phone",
    maxLength: 50
  }),
  subject: f.text({
    label: "Subject",
    required: true,
    maxLength: 255
  }),
  message: f.textarea({
    label: "Message",
    required: true
  }),
  department: f.select({
    label: "Department",
    options: [
      { value: "general", label: "General Enquiry" },
      { value: "planning", label: "Planning" },
      { value: "housing", label: "Housing" },
      { value: "environment", label: "Environment" },
      { value: "council-tax", label: "Council Tax" },
      { value: "benefits", label: "Benefits" },
      { value: "parking", label: "Parking" },
      { value: "waste", label: "Waste & Recycling" },
      { value: "other", label: "Other" }
    ],
    default: "general"
  }),
  status: f.select({
    label: "Status",
    options: [
      { value: "new", label: "New" },
      { value: "in-progress", label: "In Progress" },
      { value: "resolved", label: "Resolved" },
      { value: "closed", label: "Closed" }
    ],
    default: "new",
    required: true
  }),
  notes: f.textarea({
    label: "Internal Notes",
    description: "Notes for internal use only"
  })
})).title(({ f }) => f.subject).admin(({ c: c2 }) => ({
  label: "Submissions",
  icon: c2.icon("ph:envelope"),
  description: "Contact form submissions"
})).list(
  ({ v }) => v.table({
    columns: ["name", "subject", "department", "status", "createdAt"]
  })
).form(
  ({ v, f }) => v.form({
    sidebar: {
      position: "right",
      fields: [f.city, f.status, f.department]
    },
    fields: [
      {
        type: "section",
        label: "Contact Information",
        layout: "grid",
        columns: 3,
        fields: [f.name, f.email, f.phone]
      },
      {
        type: "section",
        label: "Message",
        fields: [f.subject, f.message]
      },
      {
        type: "section",
        label: "Internal",
        fields: [f.notes]
      }
    ]
  })
);
const sections = (c2) => ({
  label: "Sections",
  icon: c2.icon("ph:layout"),
  order: 1
});
const content = (c2) => ({
  label: "Content",
  icon: c2.icon("ph:text-t"),
  order: 2
});
const layout = (c2) => ({
  label: "Layout",
  icon: c2.icon("ph:columns"),
  order: 3
});
const dynamic = (c2) => ({
  label: "Dynamic",
  icon: c2.icon("ph:arrows-clockwise"),
  order: 4
});
const heroBlock = qb.block("hero").admin(({ c: c2 }) => ({
  label: "Hero Section",
  icon: c2.icon("ph:image"),
  category: sections(c2),
  order: 1
})).fields((f) => ({
  title: f.text({
    label: "Title",
    required: true
  }),
  subtitle: f.textarea({
    label: "Subtitle"
  }),
  backgroundImage: f.upload({
    label: "Background Image",
    accept: ["image/*"]
  }),
  overlayOpacity: f.number({
    label: "Overlay Opacity",
    default: 60
  }),
  alignment: f.select({
    label: "Alignment",
    options: [
      { value: "left", label: "Left" },
      { value: "center", label: "Center" },
      { value: "right", label: "Right" }
    ],
    default: "center"
  }),
  ctaText: f.text({
    label: "CTA Text"
  }),
  ctaLink: f.text({
    label: "CTA Link"
  }),
  showSearch: f.boolean({
    label: "Show Search Bar",
    default: false
  }),
  height: f.select({
    label: "Height",
    options: [
      { value: "small", label: "Small" },
      { value: "medium", label: "Medium" },
      { value: "large", label: "Large" },
      { value: "full", label: "Full" }
    ],
    default: "medium"
  })
}));
const ctaBlock = qb.block("cta").admin(({ c: c2 }) => ({
  label: "Call to Action",
  icon: c2.icon("ph:megaphone"),
  category: sections(c2),
  order: 2
})).fields((f) => ({
  title: f.text({
    label: "Title",
    required: true
  }),
  description: f.textarea({
    label: "Description"
  }),
  buttonText: f.text({
    label: "Button Text"
  }),
  buttonLink: f.text({
    label: "Button Link"
  }),
  variant: f.select({
    label: "Variant",
    options: [
      { value: "highlight", label: "Highlight" },
      { value: "dark", label: "Dark" },
      { value: "light", label: "Light" }
    ],
    default: "highlight"
  })
}));
const announcementBannerBlock = qb.block("announcement-banner").admin(({ c: c2 }) => ({
  label: "Announcement Banner",
  icon: c2.icon("ph:bell"),
  category: sections(c2),
  order: 3
})).fields((f) => ({
  count: f.number({
    label: "Number to Show",
    default: 3
  }),
  showExpired: f.boolean({
    label: "Show Expired",
    default: false
  })
})).prefetch(async ({ values, ctx }) => {
  const where = {};
  if (!values.showExpired) {
    where.validTo = { gte: /* @__PURE__ */ new Date() };
  }
  const res2 = await ctx.app.api.collections.announcements.find({
    limit: values.count || 3,
    where,
    orderBy: { isPinned: "desc", validFrom: "desc" }
  });
  return { announcements: res2.docs };
});
const textBlock = qb.block("text").admin(({ c: c2 }) => ({
  label: "Text Block",
  icon: c2.icon("ph:text-t"),
  category: content(c2),
  order: 1
})).fields((f) => ({
  content: f.richText({
    label: "Content",
    required: true
  }),
  maxWidth: f.select({
    label: "Max Width",
    options: [
      { value: "narrow", label: "Narrow" },
      { value: "medium", label: "Medium" },
      { value: "wide", label: "Wide" },
      { value: "full", label: "Full" }
    ],
    default: "medium"
  }),
  padding: f.select({
    label: "Padding",
    options: [
      { value: "none", label: "None" },
      { value: "small", label: "Small" },
      { value: "medium", label: "Medium" },
      { value: "large", label: "Large" }
    ],
    default: "medium"
  })
}));
const headingBlock = qb.block("heading").admin(({ c: c2 }) => ({
  label: "Heading",
  icon: c2.icon("ph:text-h-one"),
  category: content(c2),
  order: 2
})).fields((f) => ({
  text: f.text({
    label: "Text",
    required: true
  }),
  level: f.select({
    label: "Level",
    options: [
      { value: "h1", label: "H1" },
      { value: "h2", label: "H2" },
      { value: "h3", label: "H3" },
      { value: "h4", label: "H4" }
    ],
    default: "h2"
  }),
  align: f.select({
    label: "Alignment",
    options: [
      { value: "left", label: "Left" },
      { value: "center", label: "Center" },
      { value: "right", label: "Right" }
    ],
    default: "left"
  })
}));
const imageBlock = qb.block("image").admin(({ c: c2 }) => ({
  label: "Image",
  icon: c2.icon("ph:image"),
  category: content(c2),
  order: 3
})).fields((f) => ({
  image: f.upload({
    label: "Image",
    accept: ["image/*"],
    required: true
  }),
  caption: f.text({
    label: "Caption"
  }),
  alt: f.text({
    label: "Alt Text",
    description: "Description for accessibility"
  }),
  aspectRatio: f.select({
    label: "Aspect Ratio",
    options: [
      { value: "original", label: "Original" },
      { value: "square", label: "Square" },
      { value: "video", label: "16:9" },
      { value: "portrait", label: "3:4" }
    ],
    default: "original"
  }),
  width: f.select({
    label: "Width",
    options: [
      { value: "full", label: "Full Width" },
      { value: "medium", label: "Medium" },
      { value: "small", label: "Small" }
    ],
    default: "full"
  })
}));
const galleryBlock = qb.block("gallery").admin(({ c: c2 }) => ({
  label: "Gallery",
  icon: c2.icon("ph:images"),
  category: content(c2),
  order: 4
})).fields((f) => ({
  title: f.text({
    label: "Title"
  }),
  images: f.json({
    label: "Images",
    description: "Array of image data"
  }),
  columns: f.select({
    label: "Columns",
    options: [
      { value: "2", label: "2" },
      { value: "3", label: "3" },
      { value: "4", label: "4" }
    ],
    default: "3"
  }),
  showCaptions: f.boolean({
    label: "Show Captions",
    default: true
  }),
  gap: f.select({
    label: "Gap",
    options: [
      { value: "small", label: "Small" },
      { value: "medium", label: "Medium" },
      { value: "large", label: "Large" }
    ],
    default: "medium"
  })
}));
const imageTextBlock = qb.block("image-text").admin(({ c: c2 }) => ({
  label: "Image + Text",
  icon: c2.icon("ph:layout"),
  category: content(c2),
  order: 5
})).fields((f) => ({
  image: f.upload({
    label: "Image",
    accept: ["image/*"]
  }),
  imagePosition: f.select({
    label: "Image Position",
    options: [
      { value: "left", label: "Left" },
      { value: "right", label: "Right" }
    ],
    default: "left"
  }),
  title: f.text({
    label: "Title"
  }),
  content: f.richText({
    label: "Content"
  }),
  ctaText: f.text({
    label: "CTA Text"
  }),
  ctaLink: f.text({
    label: "CTA Link"
  })
}));
const videoBlock = qb.block("video").admin(({ c: c2 }) => ({
  label: "Video Embed",
  icon: c2.icon("ph:video"),
  category: content(c2),
  order: 6
})).fields((f) => ({
  title: f.text({
    label: "Title"
  }),
  url: f.text({
    label: "Video URL",
    description: "YouTube or Vimeo URL",
    required: true
  }),
  caption: f.text({
    label: "Caption"
  })
}));
const accordionBlock = qb.block("accordion").admin(({ c: c2 }) => ({
  label: "Accordion / FAQ",
  icon: c2.icon("ph:list-dashes"),
  category: content(c2),
  order: 7
})).fields((f) => ({
  title: f.text({
    label: "Title"
  }),
  items: f.json({
    label: "Items",
    description: "Array of {title, content} objects"
  }),
  allowMultipleOpen: f.boolean({
    label: "Allow Multiple Open",
    default: false
  })
}));
const latestNewsBlock = qb.block("latest-news").admin(({ c: c2 }) => ({
  label: "Latest News",
  icon: c2.icon("ph:newspaper"),
  category: dynamic(c2),
  order: 1
})).fields((f) => ({
  title: f.text({
    label: "Title",
    default: "Latest News"
  }),
  count: f.number({
    label: "Number of Articles",
    default: 3
  }),
  showFeatured: f.boolean({
    label: "Show Featured First",
    default: true
  }),
  category: f.select({
    label: "Filter by Category",
    options: [
      { value: "all", label: "All Categories" },
      { value: "general", label: "General" },
      { value: "council", label: "Council News" },
      { value: "events", label: "Events" },
      { value: "planning", label: "Planning" },
      { value: "community", label: "Community" },
      { value: "transport", label: "Transport" }
    ],
    default: "all"
  }),
  layout: f.select({
    label: "Layout",
    options: [
      { value: "grid", label: "Grid" },
      { value: "list", label: "List" }
    ],
    default: "grid"
  })
})).prefetch(async ({ values, ctx }) => {
  const where = {};
  if (values.category && values.category !== "all") {
    where.category = values.category;
  }
  const res2 = await ctx.app.api.collections.news.find({
    limit: values.count || 3,
    where,
    orderBy: values.showFeatured ? [{ isFeatured: "desc" }, { publishedAt: "desc" }] : { publishedAt: "desc" }
  });
  return { news: res2.docs };
});
const contactsListBlock = qb.block("contacts-list").admin(({ c: c2 }) => ({
  label: "Contacts List",
  icon: c2.icon("ph:address-book"),
  category: dynamic(c2),
  order: 2
})).fields((f) => ({
  title: f.text({
    label: "Title",
    default: "Contact Us"
  }),
  showAll: f.boolean({
    label: "Show All Contacts",
    default: true
  }),
  contactIds: f.json({
    label: "Specific Contacts",
    description: "Array of contact IDs (if not showing all)"
  })
})).prefetch(async ({ values, ctx }) => {
  const findOptions = {
    orderBy: { order: "asc" }
  };
  if (!values.showAll) {
    const ids = values.contactIds || [];
    if (ids.length === 0) return { contacts: [] };
    findOptions.where = { id: { in: ids } };
  }
  const res2 = await ctx.app.api.collections.contacts.find(
    findOptions
  );
  return { contacts: res2.docs };
});
const documentsListBlock = qb.block("documents-list").admin(({ c: c2 }) => ({
  label: "Documents List",
  icon: c2.icon("ph:file-text"),
  category: dynamic(c2),
  order: 3
})).fields((f) => ({
  title: f.text({
    label: "Title",
    default: "Documents"
  }),
  category: f.select({
    label: "Filter by Category",
    options: [
      { value: "all", label: "All Categories" },
      { value: "policy", label: "Policy" },
      { value: "minutes", label: "Meeting Minutes" },
      { value: "budget", label: "Budget & Finance" },
      { value: "planning", label: "Planning" },
      { value: "strategy", label: "Strategy" },
      { value: "report", label: "Report" },
      { value: "form", label: "Form" },
      { value: "guide", label: "Guide" }
    ],
    default: "all"
  }),
  limit: f.number({
    label: "Max Documents",
    default: 10
  })
})).prefetch(async ({ values, ctx }) => {
  const where = { isPublished: true };
  if (values.category && values.category !== "all") {
    where.category = values.category;
  }
  const res2 = await ctx.app.api.collections.documents.find({
    limit: values.limit || 10,
    where,
    orderBy: { publishedDate: "desc" }
  });
  return { documents: res2.docs };
});
const columnsBlock = qb.block("columns").admin(({ c: c2 }) => ({
  label: "Columns",
  icon: c2.icon("ph:columns"),
  category: layout(c2),
  order: 1
})).allowChildren().fields((f) => ({
  columns: f.select({
    label: "Columns",
    options: [
      { value: "2", label: "2" },
      { value: "3", label: "3" },
      { value: "4", label: "4" }
    ],
    default: "2"
  }),
  gap: f.select({
    label: "Gap",
    options: [
      { value: "small", label: "Small" },
      { value: "medium", label: "Medium" },
      { value: "large", label: "Large" }
    ],
    default: "medium"
  }),
  padding: f.select({
    label: "Padding",
    options: [
      { value: "none", label: "None" },
      { value: "small", label: "Small" },
      { value: "medium", label: "Medium" },
      { value: "large", label: "Large" }
    ],
    default: "medium"
  })
}));
const spacerBlock = qb.block("spacer").admin(({ c: c2 }) => ({
  label: "Spacer",
  icon: c2.icon("ph:arrows-out-vertical"),
  category: layout(c2),
  order: 2
})).fields((f) => ({
  size: f.select({
    label: "Size",
    options: [
      { value: "small", label: "S" },
      { value: "medium", label: "M" },
      { value: "large", label: "L" },
      { value: "xlarge", label: "XL" }
    ],
    default: "medium"
  })
}));
const dividerBlock = qb.block("divider").admin(({ c: c2 }) => ({
  label: "Divider",
  icon: c2.icon("ph:minus"),
  category: layout(c2),
  order: 3
})).fields((f) => ({
  style: f.select({
    label: "Style",
    options: [
      { value: "solid", label: "Solid" },
      { value: "dashed", label: "Dashed" },
      { value: "dotted", label: "Dotted" }
    ],
    default: "solid"
  }),
  width: f.select({
    label: "Width",
    options: [
      { value: "full", label: "Full" },
      { value: "medium", label: "Medium" },
      { value: "small", label: "Small" }
    ],
    default: "full"
  })
}));
const blocks = {
  hero: heroBlock,
  cta: ctaBlock,
  "announcement-banner": announcementBannerBlock,
  text: textBlock,
  heading: headingBlock,
  image: imageBlock,
  gallery: galleryBlock,
  "image-text": imageTextBlock,
  video: videoBlock,
  accordion: accordionBlock,
  "latest-news": latestNewsBlock,
  "contacts-list": contactsListBlock,
  "documents-list": documentsListBlock,
  columns: columnsBlock,
  spacer: spacerBlock,
  divider: dividerBlock
};
const siteSettings = qb.global("site_settings").fields((f) => ({
  // Branding
  siteName: f.text({
    label: "Site Name",
    required: true,
    default: "City Council",
    description: "Displayed in header and browser title"
  }),
  tagline: f.text({
    label: "Tagline",
    default: "Working for our community"
  }),
  logo: f.upload({
    label: "Site Logo",
    accept: ["image/*"]
  }),
  favicon: f.upload({
    label: "Favicon",
    accept: ["image/x-icon", "image/png"]
  }),
  // Colours
  primaryColour: f.text({
    label: "Primary Colour",
    default: "#1e40af",
    description: "Hex colour code for primary brand colour"
  }),
  secondaryColour: f.text({
    label: "Secondary Colour",
    default: "#64748b"
  }),
  // Navigation
  navigation: f.array({
    label: "Main Navigation",
    default: [
      { label: "Home", href: "/" },
      { label: "News", href: "/news" },
      { label: "Services", href: "/services" },
      { label: "Contact", href: "/contact" }
    ],
    of: f.object({
      fields: {
        label: f.text({
          label: "Label",
          required: true
        }),
        href: f.text({
          label: "URL",
          required: true
        }),
        isExternal: f.boolean({
          label: "External Link",
          default: false
        })
      }
    })
  }),
  // Footer
  footerText: f.textarea({
    label: "Footer Text",
    default: "Your local council, working for you."
  }),
  footerLinks: f.array({
    label: "Footer Links",
    default: [
      { label: "Privacy Policy", href: "/privacy" },
      { label: "Accessibility", href: "/accessibility" },
      { label: "Contact Us", href: "/contact" }
    ],
    of: f.object({
      fields: {
        label: f.text({
          label: "Label",
          required: true
        }),
        href: f.text({
          label: "URL",
          required: true
        }),
        isExternal: f.boolean({
          label: "External Link",
          default: false
        })
      }
    })
  }),
  copyrightText: f.text({
    label: "Copyright Text",
    default: "City Council. All rights reserved."
  }),
  // Social Links
  socialLinks: f.array({
    label: "Social Media Links",
    default: [],
    of: f.object({
      fields: {
        platform: f.select({
          label: "Platform",
          options: [
            { value: "facebook", label: "Facebook" },
            { value: "twitter", label: "Twitter/X" },
            { value: "instagram", label: "Instagram" },
            { value: "linkedin", label: "LinkedIn" },
            { value: "youtube", label: "YouTube" }
          ],
          required: true
        }),
        url: f.url({
          label: "URL",
          required: true
        })
      }
    })
  }),
  // Contact
  contactEmail: f.email({
    label: "Contact Email",
    default: "enquiries@council.gov.uk"
  }),
  contactPhone: f.text({
    label: "Contact Phone",
    default: "+44 20 7123 4567"
  }),
  address: f.textarea({
    label: "Address",
    default: "Council House\nCity Centre\nPostcode"
  }),
  emergencyPhone: f.text({
    label: "Emergency Phone",
    description: "Out of hours emergency contact"
  }),
  // Opening Hours
  openingHours: f.textarea({
    label: "Opening Hours",
    default: "Monday - Friday: 9:00 - 17:00\nSaturday - Sunday: Closed"
  }),
  // SEO
  metaTitle: f.text({
    label: "Meta Title",
    default: "City Council - Official Website"
  }),
  metaDescription: f.textarea({
    label: "Meta Description",
    default: "Official website of the City Council. Find information about local services, news, and how to contact us."
  }),
  ogImage: f.upload({
    label: "Social Share Image",
    accept: ["image/*"],
    description: "Image shown when sharing pages on social media"
  }),
  // Analytics
  googleAnalyticsId: f.text({
    label: "Google Analytics ID",
    description: "e.g., G-XXXXXXXXXX"
  }),
  // Alerts
  alertEnabled: f.boolean({
    label: "Show Alert Banner",
    default: false
  }),
  alertMessage: f.textarea({
    label: "Alert Message",
    description: "Shown at the top of every page when enabled"
  }),
  alertType: f.select({
    label: "Alert Type",
    options: [
      { value: "info", label: "Information" },
      { value: "warning", label: "Warning" },
      { value: "emergency", label: "Emergency" }
    ],
    default: "info"
  }),
  alertLink: f.text({
    label: "Alert Link",
    description: "Optional link for more information"
  })
})).admin(({ c: c2 }) => ({
  label: "Site Settings",
  icon: c2.icon("ph:gear"),
  description: "Configure site branding, navigation, and contact details"
})).form(
  ({ v, f }) => v.form({
    fields: [
      {
        type: "section",
        label: "Branding",
        layout: "grid",
        columns: 2,
        fields: [
          f.siteName,
          f.tagline,
          f.logo,
          f.favicon,
          f.primaryColour,
          f.secondaryColour
        ]
      },
      {
        type: "section",
        label: "Navigation",
        fields: [f.navigation]
      },
      {
        type: "section",
        label: "Footer",
        fields: [f.footerText, f.footerLinks, f.copyrightText]
      },
      {
        type: "section",
        label: "Social Media",
        fields: [f.socialLinks]
      },
      {
        type: "section",
        label: "Contact Information",
        layout: "grid",
        columns: 2,
        fields: [
          f.contactEmail,
          f.contactPhone,
          f.emergencyPhone,
          f.address,
          f.openingHours
        ]
      },
      {
        type: "section",
        label: "SEO",
        layout: "grid",
        columns: 2,
        fields: [f.metaTitle, f.metaDescription, f.ogImage]
      },
      {
        type: "section",
        label: "Analytics",
        fields: [f.googleAnalyticsId]
      },
      {
        type: "section",
        label: "Alert Banner",
        layout: "grid",
        columns: 2,
        fields: [f.alertEnabled, f.alertType, f.alertMessage, f.alertLink]
      }
    ]
  })
).options({
  timestamps: true,
  versioning: true,
  scoped: (ctx) => ctx.cityId
});
const sidebar = qb.sidebar(
  ({ s: s2, c: c2 }) => s2.sidebar({
    sections: [
      s2.section({
        id: "overview",
        title: "Overview",
        items: [
          {
            type: "link",
            label: "Dashboard",
            href: "/admin",
            icon: c2.icon("ph:house")
          },
          { type: "global", global: "siteSettings" }
        ]
      }),
      s2.section({
        id: "content",
        title: "Content",
        items: [
          { type: "collection", collection: "pages" },
          { type: "collection", collection: "news" },
          { type: "collection", collection: "announcements" }
        ]
      }),
      s2.section({
        id: "resources",
        title: "Resources",
        items: [
          { type: "collection", collection: "documents" },
          { type: "collection", collection: "contacts" }
        ]
      }),
      s2.section({
        id: "engagement",
        title: "Engagement",
        items: [{ type: "collection", collection: "submissions" }]
      }),
      s2.section({
        id: "administration",
        title: "Administration",
        items: [
          { type: "collection", collection: "cities" },
          { type: "collection", collection: "cityMembers" }
        ]
      }),
      s2.section({
        id: "external",
        title: "External",
        items: [
          {
            type: "link",
            label: "View Website",
            href: "/",
            external: true,
            icon: c2.icon("ph:arrow-square-out")
          }
        ]
      })
    ]
  })
);
const DATABASE_URL = process.env.DATABASE_URL || "postgres://localhost/cityportal";
const cms = qb.use(sidebar).blocks(blocks).collections({
  cities,
  cityMembers,
  pages,
  news,
  announcements,
  documents,
  contacts,
  submissions
}).globals({ siteSettings }).branding({
  name: "City Portal"
}).locale({
  locales: [
    {
      code: "en",
      label: "English",
      fallback: true,
      flagCountryCode: "gb"
    }
  ],
  defaultLocale: "en"
}).adminLocale({
  locales: ["en"],
  defaultLocale: "en"
}).auth({
  emailAndPassword: {
    enabled: true,
    requireEmailVerification: false
  },
  baseURL: process.env.APP_URL || "http://localhost:3001",
  basePath: "/api/cms/auth",
  secret: process.env.BETTER_AUTH_SECRET || "demo-secret-change-in-production"
}).build({
  app: {
    url: process.env.APP_URL || "http://localhost:3001"
  },
  db: {
    url: DATABASE_URL
  },
  storage: {
    basePath: "/api/cms"
  },
  secret: process.env.SECRET,
  email: {
    adapter: process.env.MAIL_ADAPTER === "console" ? new ConsoleAdapter({ logHtml: false }) : new SmtpAdapter({
      transport: {
        host: process.env.SMTP_HOST || "localhost",
        port: Number.parseInt(process.env.SMTP_PORT || "1025", 10),
        secure: false
      }
    })
  },
  queue: {
    adapter: pgBossAdapter({
      connectionString: DATABASE_URL
    })
  }
});
const appRpc = {
  ...adminRpc
};
const handler = withOpenApi(
  createFetchHandler(cms, {
    basePath: "/api/cms",
    rpc: appRpc
  }),
  {
    cms,
    rpc: appRpc,
    basePath: "/api/cms",
    info: {
      title: "City Portal API",
      version: "1.0.0",
      description: "QuestPie CMS API for the City Portal example"
    },
    scalar: { theme: "blue" }
  }
);
const handleCmsRequest = async (request) => {
  const response = await handler(request);
  return response ?? new Response(JSON.stringify({ error: "Not found" }), {
    status: 404,
    headers: { "Content-Type": "application/json" }
  });
};
const Route$1 = createFileRoute("/api/cms/$")({
  server: {
    handlers: {
      GET: ({ request }) => handleCmsRequest(request),
      POST: ({ request }) => handleCmsRequest(request),
      PUT: ({ request }) => handleCmsRequest(request),
      DELETE: ({ request }) => handleCmsRequest(request),
      PATCH: ({ request }) => handleCmsRequest(request)
    }
  }
});
const $$splitComponentImporter = () => import("./_citySlug.pages._slug-CBaFoaq2.js");
const Route = createFileRoute("/_app/$citySlug/pages/$slug")({
  loader: async ({
    params
  }) => {
    const {
      citySlug,
      slug: slug2
    } = params;
    return getPageBySlug({
      citySlug,
      pageSlug: slug2
    });
  },
  component: lazyRouteComponent($$splitComponentImporter, "component")
});
const AdminIndexRoute = Route$6.update({
  id: "/admin/",
  path: "/admin/",
  getParentRoute: () => Route$7
});
const ApiPreviewRoute = Route$5.update({
  id: "/api/preview",
  path: "/api/preview",
  getParentRoute: () => Route$7
});
const AdminSplatRoute = Route$4.update({
  id: "/admin/$",
  path: "/admin/$",
  getParentRoute: () => Route$7
});
const AppCitySlugRoute = Route$3.update({
  id: "/_app/$citySlug",
  path: "/$citySlug",
  getParentRoute: () => Route$7
});
const AppCitySlugIndexRoute = Route$2.update({
  id: "/",
  path: "/",
  getParentRoute: () => AppCitySlugRoute
});
const ApiCmsSplatRoute = Route$1.update({
  id: "/api/cms/$",
  path: "/api/cms/$",
  getParentRoute: () => Route$7
});
const AppCitySlugPagesSlugRoute = Route.update({
  id: "/pages/$slug",
  path: "/pages/$slug",
  getParentRoute: () => AppCitySlugRoute
});
const AppCitySlugRouteChildren = {
  AppCitySlugIndexRoute,
  AppCitySlugPagesSlugRoute
};
const AppCitySlugRouteWithChildren = AppCitySlugRoute._addFileChildren(
  AppCitySlugRouteChildren
);
const rootRouteChildren = {
  AppCitySlugRoute: AppCitySlugRouteWithChildren,
  AdminSplatRoute,
  ApiPreviewRoute,
  AdminIndexRoute,
  ApiCmsSplatRoute
};
const routeTree = Route$7._addFileChildren(rootRouteChildren)._addFileTypes();
function getRouter() {
  return createRouter$2({
    routeTree,
    scrollRestoration: true,
    defaultPreloadStaleTime: 0
  });
}
const router = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getRouter
}, Symbol.toStringTag, { value: "Module" }));
export {
  ApiError as A,
  CompiledQuery as C,
  DefaultQueryCompiler as D,
  QuestpieClientError as Q,
  Route$4 as R,
  Route$2 as a,
  Route as b,
  createAdapterFactory as c,
  createKyselyAdapter as d,
  getKyselyDatabaseType as e,
  DEFAULT_MIGRATION_TABLE as f,
  getHTTPStatusFromCode as g,
  DEFAULT_MIGRATION_LOCK_TABLE as h,
  Route$3 as i,
  commonjsGlobal as j,
  getDefaultExportFromCjs as k,
  logger as l,
  DEFAULT_LOCALE as m,
  DEFAULT_LOCALE_CONFIG as n,
  esm as o,
  parseDatabaseError as p,
  router as r,
  sql as s
};
