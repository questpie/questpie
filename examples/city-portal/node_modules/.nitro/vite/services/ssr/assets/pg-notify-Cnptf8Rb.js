class PgNotifyAdapter {
  client = null;
  clientConfig;
  connectionString;
  channel;
  listeners = /* @__PURE__ */ new Set();
  started = false;
  connected = false;
  ownsClient = true;
  notificationHandler;
  constructor(options = {}) {
    this.channel = options.channel ?? "questpie_realtime";
    if (!/^[a-zA-Z0-9_]+$/.test(this.channel)) {
      throw new Error(`Invalid pg notify channel name: "${this.channel}"`);
    }
    if (options.client) {
      this.client = options.client;
      this.ownsClient = false;
      return;
    }
    if (options.connection) {
      this.clientConfig = options.connection;
      return;
    }
    if (options.connectionString) {
      this.connectionString = options.connectionString;
      return;
    }
  }
  async start() {
    if (this.started) return;
    const client = await this.ensureClient();
    await this.ensureConnected(client);
    await client.query(`LISTEN ${this.channel}`);
    this.notificationHandler = (msg) => {
      if (!msg.payload) return;
      let notice = null;
      try {
        notice = JSON.parse(msg.payload);
      } catch {
        return;
      }
      for (const listener of this.listeners) {
        listener(notice);
      }
    };
    client.on("notification", this.notificationHandler);
    this.started = true;
  }
  async stop() {
    if (!this.started) return;
    this.started = false;
    const client = this.client;
    if (!client) return;
    if (this.notificationHandler) {
      client.off("notification", this.notificationHandler);
      this.notificationHandler = void 0;
    }
    try {
      await client.query(`UNLISTEN ${this.channel}`);
    } catch {
    }
    if (this.ownsClient) {
      try {
        await client.end();
      } finally {
        this.connected = false;
        this.client = null;
      }
    }
  }
  subscribe(handler) {
    this.listeners.add(handler);
    return () => {
      this.listeners.delete(handler);
    };
  }
  async notify(event) {
    const payload = JSON.stringify({
      seq: event.seq,
      resourceType: event.resourceType,
      resource: event.resource,
      operation: event.operation
    });
    const client = await this.ensureClient();
    await this.ensureConnected(client);
    await client.query("select pg_notify($1, $2)", [this.channel, payload]);
  }
  async ensureClient() {
    if (this.client) return this.client;
    const { Client: PgClient } = await import("./router-DfekICpe.js").then((n) => n.o);
    if (this.clientConfig) {
      this.client = new PgClient(this.clientConfig);
      return this.client;
    }
    if (this.connectionString) {
      this.client = new PgClient({ connectionString: this.connectionString });
      return this.client;
    }
    throw new Error(
      "PgNotifyAdapter requires a pg Client or connection config"
    );
  }
  async ensureConnected(client) {
    if (this.connected) return;
    try {
      await client.connect();
      this.connected = true;
      return;
    } catch (error) {
      const message = String(error?.message || "");
      if (message.includes("already been connected")) {
        this.connected = true;
        return;
      }
      throw error;
    }
  }
}
export {
  PgNotifyAdapter
};
